"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/hls.js";
exports.ids = ["vendor-chunks/hls.js"];
exports.modules = {

/***/ "(ssr)/./node_modules/hls.js/dist/hls.mjs":
/*!******************************************!*\
  !*** ./node_modules/hls.js/dist/hls.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbrController: () => (/* binding */ AbrController),\n/* harmony export */   AttrList: () => (/* binding */ AttrList),\n/* harmony export */   AudioStreamController: () => (/* binding */ AudioStreamController),\n/* harmony export */   AudioTrackController: () => (/* binding */ AudioTrackController),\n/* harmony export */   BasePlaylistController: () => (/* binding */ BasePlaylistController),\n/* harmony export */   BaseSegment: () => (/* binding */ BaseSegment),\n/* harmony export */   BaseStreamController: () => (/* binding */ BaseStreamController),\n/* harmony export */   BufferController: () => (/* binding */ BufferController),\n/* harmony export */   CMCDController: () => (/* binding */ CMCDController),\n/* harmony export */   CapLevelController: () => (/* binding */ CapLevelController),\n/* harmony export */   ChunkMetadata: () => (/* binding */ ChunkMetadata),\n/* harmony export */   ContentSteeringController: () => (/* binding */ ContentSteeringController),\n/* harmony export */   DateRange: () => (/* binding */ DateRange),\n/* harmony export */   EMEController: () => (/* binding */ EMEController),\n/* harmony export */   ErrorActionFlags: () => (/* binding */ ErrorActionFlags),\n/* harmony export */   ErrorController: () => (/* binding */ ErrorController),\n/* harmony export */   ErrorDetails: () => (/* binding */ ErrorDetails),\n/* harmony export */   ErrorTypes: () => (/* binding */ ErrorTypes),\n/* harmony export */   Events: () => (/* binding */ Events),\n/* harmony export */   FPSController: () => (/* binding */ FPSController),\n/* harmony export */   Fragment: () => (/* binding */ Fragment),\n/* harmony export */   Hls: () => (/* binding */ Hls),\n/* harmony export */   HlsSkip: () => (/* binding */ HlsSkip),\n/* harmony export */   HlsUrlParameters: () => (/* binding */ HlsUrlParameters),\n/* harmony export */   KeySystemFormats: () => (/* binding */ KeySystemFormats),\n/* harmony export */   KeySystems: () => (/* binding */ KeySystems),\n/* harmony export */   Level: () => (/* binding */ Level),\n/* harmony export */   LevelDetails: () => (/* binding */ LevelDetails),\n/* harmony export */   LevelKey: () => (/* binding */ LevelKey),\n/* harmony export */   LoadStats: () => (/* binding */ LoadStats),\n/* harmony export */   MetadataSchema: () => (/* binding */ MetadataSchema),\n/* harmony export */   NetworkErrorAction: () => (/* binding */ NetworkErrorAction),\n/* harmony export */   Part: () => (/* binding */ Part),\n/* harmony export */   PlaylistLevelType: () => (/* binding */ PlaylistLevelType),\n/* harmony export */   SubtitleStreamController: () => (/* binding */ SubtitleStreamController),\n/* harmony export */   SubtitleTrackController: () => (/* binding */ SubtitleTrackController),\n/* harmony export */   TimelineController: () => (/* binding */ TimelineController),\n/* harmony export */   \"default\": () => (/* binding */ Hls),\n/* harmony export */   getMediaSource: () => (/* binding */ getMediaSource),\n/* harmony export */   isMSESupported: () => (/* binding */ isMSESupported),\n/* harmony export */   isSupported: () => (/* binding */ isSupported)\n/* harmony export */ });\nfunction getDefaultExportFromCjs(x) {\n    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\nvar urlToolkit = {\n    exports: {}\n};\n(function(module, exports) {\n    // see https://tools.ietf.org/html/rfc1808\n    (function(root) {\n        var URL_REGEX = /^(?=((?:[a-zA-Z0-9+\\-.]+:)?))\\1(?=((?:\\/\\/[^\\/?#]*)?))\\2(?=((?:(?:[^?#\\/]*\\/)*[^;?#\\/]*)?))\\3((?:;[^?#]*)?)(\\?[^#]*)?(#[^]*)?$/;\n        var FIRST_SEGMENT_REGEX = /^(?=([^\\/?#]*))\\1([^]*)$/;\n        var SLASH_DOT_REGEX = /(?:\\/|^)\\.(?=\\/)/g;\n        var SLASH_DOT_DOT_REGEX = /(?:\\/|^)\\.\\.\\/(?!\\.\\.\\/)[^\\/]*(?=\\/)/g;\n        var URLToolkit = {\n            // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //\n            // E.g\n            // With opts.alwaysNormalize = false (default, spec compliant)\n            // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g\n            // With opts.alwaysNormalize = true (not spec compliant)\n            // http://a.com/b/cd + /e/f/../g => http://a.com/e/g\n            buildAbsoluteURL: function(baseURL, relativeURL, opts) {\n                opts = opts || {};\n                // remove any remaining space and CRLF\n                baseURL = baseURL.trim();\n                relativeURL = relativeURL.trim();\n                if (!relativeURL) {\n                    // 2a) If the embedded URL is entirely empty, it inherits the\n                    // entire base URL (i.e., is set equal to the base URL)\n                    // and we are done.\n                    if (!opts.alwaysNormalize) {\n                        return baseURL;\n                    }\n                    var basePartsForNormalise = URLToolkit.parseURL(baseURL);\n                    if (!basePartsForNormalise) {\n                        throw new Error(\"Error trying to parse base URL.\");\n                    }\n                    basePartsForNormalise.path = URLToolkit.normalizePath(basePartsForNormalise.path);\n                    return URLToolkit.buildURLFromParts(basePartsForNormalise);\n                }\n                var relativeParts = URLToolkit.parseURL(relativeURL);\n                if (!relativeParts) {\n                    throw new Error(\"Error trying to parse relative URL.\");\n                }\n                if (relativeParts.scheme) {\n                    // 2b) If the embedded URL starts with a scheme name, it is\n                    // interpreted as an absolute URL and we are done.\n                    if (!opts.alwaysNormalize) {\n                        return relativeURL;\n                    }\n                    relativeParts.path = URLToolkit.normalizePath(relativeParts.path);\n                    return URLToolkit.buildURLFromParts(relativeParts);\n                }\n                var baseParts = URLToolkit.parseURL(baseURL);\n                if (!baseParts) {\n                    throw new Error(\"Error trying to parse base URL.\");\n                }\n                if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== \"/\") {\n                    // If netLoc missing and path doesn't start with '/', assume everthing before the first '/' is the netLoc\n                    // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'\n                    var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);\n                    baseParts.netLoc = pathParts[1];\n                    baseParts.path = pathParts[2];\n                }\n                if (baseParts.netLoc && !baseParts.path) {\n                    baseParts.path = \"/\";\n                }\n                var builtParts = {\n                    // 2c) Otherwise, the embedded URL inherits the scheme of\n                    // the base URL.\n                    scheme: baseParts.scheme,\n                    netLoc: relativeParts.netLoc,\n                    path: null,\n                    params: relativeParts.params,\n                    query: relativeParts.query,\n                    fragment: relativeParts.fragment\n                };\n                if (!relativeParts.netLoc) {\n                    // 3) If the embedded URL's <net_loc> is non-empty, we skip to\n                    // Step 7.  Otherwise, the embedded URL inherits the <net_loc>\n                    // (if any) of the base URL.\n                    builtParts.netLoc = baseParts.netLoc;\n                    // 4) If the embedded URL path is preceded by a slash \"/\", the\n                    // path is not relative and we skip to Step 7.\n                    if (relativeParts.path[0] !== \"/\") {\n                        if (!relativeParts.path) {\n                            // 5) If the embedded URL path is empty (and not preceded by a\n                            // slash), then the embedded URL inherits the base URL path\n                            builtParts.path = baseParts.path;\n                            // 5a) if the embedded URL's <params> is non-empty, we skip to\n                            // step 7; otherwise, it inherits the <params> of the base\n                            // URL (if any) and\n                            if (!relativeParts.params) {\n                                builtParts.params = baseParts.params;\n                                // 5b) if the embedded URL's <query> is non-empty, we skip to\n                                // step 7; otherwise, it inherits the <query> of the base\n                                // URL (if any) and we skip to step 7.\n                                if (!relativeParts.query) {\n                                    builtParts.query = baseParts.query;\n                                }\n                            }\n                        } else {\n                            // 6) The last segment of the base URL's path (anything\n                            // following the rightmost slash \"/\", or the entire path if no\n                            // slash is present) is removed and the embedded URL's path is\n                            // appended in its place.\n                            var baseURLPath = baseParts.path;\n                            var newPath = baseURLPath.substring(0, baseURLPath.lastIndexOf(\"/\") + 1) + relativeParts.path;\n                            builtParts.path = URLToolkit.normalizePath(newPath);\n                        }\n                    }\n                }\n                if (builtParts.path === null) {\n                    builtParts.path = opts.alwaysNormalize ? URLToolkit.normalizePath(relativeParts.path) : relativeParts.path;\n                }\n                return URLToolkit.buildURLFromParts(builtParts);\n            },\n            parseURL: function(url) {\n                var parts = URL_REGEX.exec(url);\n                if (!parts) {\n                    return null;\n                }\n                return {\n                    scheme: parts[1] || \"\",\n                    netLoc: parts[2] || \"\",\n                    path: parts[3] || \"\",\n                    params: parts[4] || \"\",\n                    query: parts[5] || \"\",\n                    fragment: parts[6] || \"\"\n                };\n            },\n            normalizePath: function(path) {\n                // The following operations are\n                // then applied, in order, to the new path:\n                // 6a) All occurrences of \"./\", where \".\" is a complete path\n                // segment, are removed.\n                // 6b) If the path ends with \".\" as a complete path segment,\n                // that \".\" is removed.\n                path = path.split(\"\").reverse().join(\"\").replace(SLASH_DOT_REGEX, \"\");\n                // 6c) All occurrences of \"<segment>/../\", where <segment> is a\n                // complete path segment not equal to \"..\", are removed.\n                // Removal of these path segments is performed iteratively,\n                // removing the leftmost matching pattern on each iteration,\n                // until no matching pattern remains.\n                // 6d) If the path ends with \"<segment>/..\", where <segment> is a\n                // complete path segment not equal to \"..\", that\n                // \"<segment>/..\" is removed.\n                while(path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, \"\")).length){}\n                return path.split(\"\").reverse().join(\"\");\n            },\n            buildURLFromParts: function(parts) {\n                return parts.scheme + parts.netLoc + parts.path + parts.params + parts.query + parts.fragment;\n            }\n        };\n        module.exports = URLToolkit;\n    })();\n})(urlToolkit);\nvar urlToolkitExports = urlToolkit.exports;\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread2(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != typeof t || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != typeof i) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == typeof i ? i : String(i);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\n// https://caniuse.com/mdn-javascript_builtins_number_isfinite\nconst isFiniteNumber = Number.isFinite || function(value) {\n    return typeof value === \"number\" && isFinite(value);\n};\n// https://caniuse.com/mdn-javascript_builtins_number_issafeinteger\nconst isSafeInteger = Number.isSafeInteger || function(value) {\n    return typeof value === \"number\" && Math.abs(value) <= MAX_SAFE_INTEGER;\n};\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\nlet Events = /*#__PURE__*/ function(Events) {\n    Events[\"MEDIA_ATTACHING\"] = \"hlsMediaAttaching\";\n    Events[\"MEDIA_ATTACHED\"] = \"hlsMediaAttached\";\n    Events[\"MEDIA_DETACHING\"] = \"hlsMediaDetaching\";\n    Events[\"MEDIA_DETACHED\"] = \"hlsMediaDetached\";\n    Events[\"BUFFER_RESET\"] = \"hlsBufferReset\";\n    Events[\"BUFFER_CODECS\"] = \"hlsBufferCodecs\";\n    Events[\"BUFFER_CREATED\"] = \"hlsBufferCreated\";\n    Events[\"BUFFER_APPENDING\"] = \"hlsBufferAppending\";\n    Events[\"BUFFER_APPENDED\"] = \"hlsBufferAppended\";\n    Events[\"BUFFER_EOS\"] = \"hlsBufferEos\";\n    Events[\"BUFFER_FLUSHING\"] = \"hlsBufferFlushing\";\n    Events[\"BUFFER_FLUSHED\"] = \"hlsBufferFlushed\";\n    Events[\"MANIFEST_LOADING\"] = \"hlsManifestLoading\";\n    Events[\"MANIFEST_LOADED\"] = \"hlsManifestLoaded\";\n    Events[\"MANIFEST_PARSED\"] = \"hlsManifestParsed\";\n    Events[\"LEVEL_SWITCHING\"] = \"hlsLevelSwitching\";\n    Events[\"LEVEL_SWITCHED\"] = \"hlsLevelSwitched\";\n    Events[\"LEVEL_LOADING\"] = \"hlsLevelLoading\";\n    Events[\"LEVEL_LOADED\"] = \"hlsLevelLoaded\";\n    Events[\"LEVEL_UPDATED\"] = \"hlsLevelUpdated\";\n    Events[\"LEVEL_PTS_UPDATED\"] = \"hlsLevelPtsUpdated\";\n    Events[\"LEVELS_UPDATED\"] = \"hlsLevelsUpdated\";\n    Events[\"AUDIO_TRACKS_UPDATED\"] = \"hlsAudioTracksUpdated\";\n    Events[\"AUDIO_TRACK_SWITCHING\"] = \"hlsAudioTrackSwitching\";\n    Events[\"AUDIO_TRACK_SWITCHED\"] = \"hlsAudioTrackSwitched\";\n    Events[\"AUDIO_TRACK_LOADING\"] = \"hlsAudioTrackLoading\";\n    Events[\"AUDIO_TRACK_LOADED\"] = \"hlsAudioTrackLoaded\";\n    Events[\"SUBTITLE_TRACKS_UPDATED\"] = \"hlsSubtitleTracksUpdated\";\n    Events[\"SUBTITLE_TRACKS_CLEARED\"] = \"hlsSubtitleTracksCleared\";\n    Events[\"SUBTITLE_TRACK_SWITCH\"] = \"hlsSubtitleTrackSwitch\";\n    Events[\"SUBTITLE_TRACK_LOADING\"] = \"hlsSubtitleTrackLoading\";\n    Events[\"SUBTITLE_TRACK_LOADED\"] = \"hlsSubtitleTrackLoaded\";\n    Events[\"SUBTITLE_FRAG_PROCESSED\"] = \"hlsSubtitleFragProcessed\";\n    Events[\"CUES_PARSED\"] = \"hlsCuesParsed\";\n    Events[\"NON_NATIVE_TEXT_TRACKS_FOUND\"] = \"hlsNonNativeTextTracksFound\";\n    Events[\"INIT_PTS_FOUND\"] = \"hlsInitPtsFound\";\n    Events[\"FRAG_LOADING\"] = \"hlsFragLoading\";\n    Events[\"FRAG_LOAD_EMERGENCY_ABORTED\"] = \"hlsFragLoadEmergencyAborted\";\n    Events[\"FRAG_LOADED\"] = \"hlsFragLoaded\";\n    Events[\"FRAG_DECRYPTED\"] = \"hlsFragDecrypted\";\n    Events[\"FRAG_PARSING_INIT_SEGMENT\"] = \"hlsFragParsingInitSegment\";\n    Events[\"FRAG_PARSING_USERDATA\"] = \"hlsFragParsingUserdata\";\n    Events[\"FRAG_PARSING_METADATA\"] = \"hlsFragParsingMetadata\";\n    Events[\"FRAG_PARSED\"] = \"hlsFragParsed\";\n    Events[\"FRAG_BUFFERED\"] = \"hlsFragBuffered\";\n    Events[\"FRAG_CHANGED\"] = \"hlsFragChanged\";\n    Events[\"FPS_DROP\"] = \"hlsFpsDrop\";\n    Events[\"FPS_DROP_LEVEL_CAPPING\"] = \"hlsFpsDropLevelCapping\";\n    Events[\"MAX_AUTO_LEVEL_UPDATED\"] = \"hlsMaxAutoLevelUpdated\";\n    Events[\"ERROR\"] = \"hlsError\";\n    Events[\"DESTROYING\"] = \"hlsDestroying\";\n    Events[\"KEY_LOADING\"] = \"hlsKeyLoading\";\n    Events[\"KEY_LOADED\"] = \"hlsKeyLoaded\";\n    Events[\"LIVE_BACK_BUFFER_REACHED\"] = \"hlsLiveBackBufferReached\";\n    Events[\"BACK_BUFFER_REACHED\"] = \"hlsBackBufferReached\";\n    Events[\"STEERING_MANIFEST_LOADED\"] = \"hlsSteeringManifestLoaded\";\n    return Events;\n}({});\n/**\n * Defines each Event type and payload by Event name. Used in {@link hls.js#HlsEventEmitter} to strongly type the event listener API.\n */ let ErrorTypes = /*#__PURE__*/ function(ErrorTypes) {\n    ErrorTypes[\"NETWORK_ERROR\"] = \"networkError\";\n    ErrorTypes[\"MEDIA_ERROR\"] = \"mediaError\";\n    ErrorTypes[\"KEY_SYSTEM_ERROR\"] = \"keySystemError\";\n    ErrorTypes[\"MUX_ERROR\"] = \"muxError\";\n    ErrorTypes[\"OTHER_ERROR\"] = \"otherError\";\n    return ErrorTypes;\n}({});\nlet ErrorDetails = /*#__PURE__*/ function(ErrorDetails) {\n    ErrorDetails[\"KEY_SYSTEM_NO_KEYS\"] = \"keySystemNoKeys\";\n    ErrorDetails[\"KEY_SYSTEM_NO_ACCESS\"] = \"keySystemNoAccess\";\n    ErrorDetails[\"KEY_SYSTEM_NO_SESSION\"] = \"keySystemNoSession\";\n    ErrorDetails[\"KEY_SYSTEM_NO_CONFIGURED_LICENSE\"] = \"keySystemNoConfiguredLicense\";\n    ErrorDetails[\"KEY_SYSTEM_LICENSE_REQUEST_FAILED\"] = \"keySystemLicenseRequestFailed\";\n    ErrorDetails[\"KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED\"] = \"keySystemServerCertificateRequestFailed\";\n    ErrorDetails[\"KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED\"] = \"keySystemServerCertificateUpdateFailed\";\n    ErrorDetails[\"KEY_SYSTEM_SESSION_UPDATE_FAILED\"] = \"keySystemSessionUpdateFailed\";\n    ErrorDetails[\"KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED\"] = \"keySystemStatusOutputRestricted\";\n    ErrorDetails[\"KEY_SYSTEM_STATUS_INTERNAL_ERROR\"] = \"keySystemStatusInternalError\";\n    ErrorDetails[\"MANIFEST_LOAD_ERROR\"] = \"manifestLoadError\";\n    ErrorDetails[\"MANIFEST_LOAD_TIMEOUT\"] = \"manifestLoadTimeOut\";\n    ErrorDetails[\"MANIFEST_PARSING_ERROR\"] = \"manifestParsingError\";\n    ErrorDetails[\"MANIFEST_INCOMPATIBLE_CODECS_ERROR\"] = \"manifestIncompatibleCodecsError\";\n    ErrorDetails[\"LEVEL_EMPTY_ERROR\"] = \"levelEmptyError\";\n    ErrorDetails[\"LEVEL_LOAD_ERROR\"] = \"levelLoadError\";\n    ErrorDetails[\"LEVEL_LOAD_TIMEOUT\"] = \"levelLoadTimeOut\";\n    ErrorDetails[\"LEVEL_PARSING_ERROR\"] = \"levelParsingError\";\n    ErrorDetails[\"LEVEL_SWITCH_ERROR\"] = \"levelSwitchError\";\n    ErrorDetails[\"AUDIO_TRACK_LOAD_ERROR\"] = \"audioTrackLoadError\";\n    ErrorDetails[\"AUDIO_TRACK_LOAD_TIMEOUT\"] = \"audioTrackLoadTimeOut\";\n    ErrorDetails[\"SUBTITLE_LOAD_ERROR\"] = \"subtitleTrackLoadError\";\n    ErrorDetails[\"SUBTITLE_TRACK_LOAD_TIMEOUT\"] = \"subtitleTrackLoadTimeOut\";\n    ErrorDetails[\"FRAG_LOAD_ERROR\"] = \"fragLoadError\";\n    ErrorDetails[\"FRAG_LOAD_TIMEOUT\"] = \"fragLoadTimeOut\";\n    ErrorDetails[\"FRAG_DECRYPT_ERROR\"] = \"fragDecryptError\";\n    ErrorDetails[\"FRAG_PARSING_ERROR\"] = \"fragParsingError\";\n    ErrorDetails[\"FRAG_GAP\"] = \"fragGap\";\n    ErrorDetails[\"REMUX_ALLOC_ERROR\"] = \"remuxAllocError\";\n    ErrorDetails[\"KEY_LOAD_ERROR\"] = \"keyLoadError\";\n    ErrorDetails[\"KEY_LOAD_TIMEOUT\"] = \"keyLoadTimeOut\";\n    ErrorDetails[\"BUFFER_ADD_CODEC_ERROR\"] = \"bufferAddCodecError\";\n    ErrorDetails[\"BUFFER_INCOMPATIBLE_CODECS_ERROR\"] = \"bufferIncompatibleCodecsError\";\n    ErrorDetails[\"BUFFER_APPEND_ERROR\"] = \"bufferAppendError\";\n    ErrorDetails[\"BUFFER_APPENDING_ERROR\"] = \"bufferAppendingError\";\n    ErrorDetails[\"BUFFER_STALLED_ERROR\"] = \"bufferStalledError\";\n    ErrorDetails[\"BUFFER_FULL_ERROR\"] = \"bufferFullError\";\n    ErrorDetails[\"BUFFER_SEEK_OVER_HOLE\"] = \"bufferSeekOverHole\";\n    ErrorDetails[\"BUFFER_NUDGE_ON_STALL\"] = \"bufferNudgeOnStall\";\n    ErrorDetails[\"INTERNAL_EXCEPTION\"] = \"internalException\";\n    ErrorDetails[\"INTERNAL_ABORTED\"] = \"aborted\";\n    ErrorDetails[\"UNKNOWN\"] = \"unknown\";\n    return ErrorDetails;\n}({});\nconst noop = function noop() {};\nconst fakeLogger = {\n    trace: noop,\n    debug: noop,\n    log: noop,\n    warn: noop,\n    info: noop,\n    error: noop\n};\nlet exportedLogger = fakeLogger;\n// let lastCallTime;\n// function formatMsgWithTimeInfo(type, msg) {\n//   const now = Date.now();\n//   const diff = lastCallTime ? '+' + (now - lastCallTime) : '0';\n//   lastCallTime = now;\n//   msg = (new Date(now)).toISOString() + ' | [' +  type + '] > ' + msg + ' ( ' + diff + ' ms )';\n//   return msg;\n// }\nfunction consolePrintFn(type) {\n    const func = self.console[type];\n    if (func) {\n        return func.bind(self.console, `[${type}] >`);\n    }\n    return noop;\n}\nfunction exportLoggerFunctions(debugConfig, ...functions) {\n    functions.forEach(function(type) {\n        exportedLogger[type] = debugConfig[type] ? debugConfig[type].bind(debugConfig) : consolePrintFn(type);\n    });\n}\nfunction enableLogs(debugConfig, id) {\n    // check that console is available\n    if (typeof console === \"object\" && debugConfig === true || typeof debugConfig === \"object\") {\n        exportLoggerFunctions(debugConfig, // Remove out from list here to hard-disable a log-level\n        // 'trace',\n        \"debug\", \"log\", \"info\", \"warn\", \"error\");\n        // Some browsers don't allow to use bind on console object anyway\n        // fallback to default if needed\n        try {\n            exportedLogger.log(`Debug logs enabled for \"${id}\" in hls.js version ${\"1.5.2\"}`);\n        } catch (e) {\n            exportedLogger = fakeLogger;\n        }\n    } else {\n        exportedLogger = fakeLogger;\n    }\n}\nconst logger = exportedLogger;\nconst DECIMAL_RESOLUTION_REGEX = /^(\\d+)x(\\d+)$/;\nconst ATTR_LIST_REGEX = /(.+?)=(\".*?\"|.*?)(?:,|$)/g;\n// adapted from https://github.com/kanongil/node-m3u8parse/blob/master/attrlist.js\nclass AttrList {\n    constructor(attrs){\n        if (typeof attrs === \"string\") {\n            attrs = AttrList.parseAttrList(attrs);\n        }\n        _extends(this, attrs);\n    }\n    get clientAttrs() {\n        return Object.keys(this).filter((attr)=>attr.substring(0, 2) === \"X-\");\n    }\n    decimalInteger(attrName) {\n        const intValue = parseInt(this[attrName], 10);\n        if (intValue > Number.MAX_SAFE_INTEGER) {\n            return Infinity;\n        }\n        return intValue;\n    }\n    hexadecimalInteger(attrName) {\n        if (this[attrName]) {\n            let stringValue = (this[attrName] || \"0x\").slice(2);\n            stringValue = (stringValue.length & 1 ? \"0\" : \"\") + stringValue;\n            const value = new Uint8Array(stringValue.length / 2);\n            for(let i = 0; i < stringValue.length / 2; i++){\n                value[i] = parseInt(stringValue.slice(i * 2, i * 2 + 2), 16);\n            }\n            return value;\n        } else {\n            return null;\n        }\n    }\n    hexadecimalIntegerAsNumber(attrName) {\n        const intValue = parseInt(this[attrName], 16);\n        if (intValue > Number.MAX_SAFE_INTEGER) {\n            return Infinity;\n        }\n        return intValue;\n    }\n    decimalFloatingPoint(attrName) {\n        return parseFloat(this[attrName]);\n    }\n    optionalFloat(attrName, defaultValue) {\n        const value = this[attrName];\n        return value ? parseFloat(value) : defaultValue;\n    }\n    enumeratedString(attrName) {\n        return this[attrName];\n    }\n    bool(attrName) {\n        return this[attrName] === \"YES\";\n    }\n    decimalResolution(attrName) {\n        const res = DECIMAL_RESOLUTION_REGEX.exec(this[attrName]);\n        if (res === null) {\n            return undefined;\n        }\n        return {\n            width: parseInt(res[1], 10),\n            height: parseInt(res[2], 10)\n        };\n    }\n    static parseAttrList(input) {\n        let match;\n        const attrs = {};\n        const quote = '\"';\n        ATTR_LIST_REGEX.lastIndex = 0;\n        while((match = ATTR_LIST_REGEX.exec(input)) !== null){\n            let value = match[2];\n            if (value.indexOf(quote) === 0 && value.lastIndexOf(quote) === value.length - 1) {\n                value = value.slice(1, -1);\n            }\n            const name = match[1].trim();\n            attrs[name] = value;\n        }\n        return attrs;\n    }\n}\n// Avoid exporting const enum so that these values can be inlined\nfunction isDateRangeCueAttribute(attrName) {\n    return attrName !== \"ID\" && attrName !== \"CLASS\" && attrName !== \"START-DATE\" && attrName !== \"DURATION\" && attrName !== \"END-DATE\" && attrName !== \"END-ON-NEXT\";\n}\nfunction isSCTE35Attribute(attrName) {\n    return attrName === \"SCTE35-OUT\" || attrName === \"SCTE35-IN\";\n}\nclass DateRange {\n    constructor(dateRangeAttr, dateRangeWithSameId){\n        this.attr = void 0;\n        this._startDate = void 0;\n        this._endDate = void 0;\n        this._badValueForSameId = void 0;\n        if (dateRangeWithSameId) {\n            const previousAttr = dateRangeWithSameId.attr;\n            for(const key in previousAttr){\n                if (Object.prototype.hasOwnProperty.call(dateRangeAttr, key) && dateRangeAttr[key] !== previousAttr[key]) {\n                    logger.warn(`DATERANGE tag attribute: \"${key}\" does not match for tags with ID: \"${dateRangeAttr.ID}\"`);\n                    this._badValueForSameId = key;\n                    break;\n                }\n            }\n            // Merge DateRange tags with the same ID\n            dateRangeAttr = _extends(new AttrList({}), previousAttr, dateRangeAttr);\n        }\n        this.attr = dateRangeAttr;\n        this._startDate = new Date(dateRangeAttr[\"START-DATE\"]);\n        if (\"END-DATE\" in this.attr) {\n            const endDate = new Date(this.attr[\"END-DATE\"]);\n            if (isFiniteNumber(endDate.getTime())) {\n                this._endDate = endDate;\n            }\n        }\n    }\n    get id() {\n        return this.attr.ID;\n    }\n    get class() {\n        return this.attr.CLASS;\n    }\n    get startDate() {\n        return this._startDate;\n    }\n    get endDate() {\n        if (this._endDate) {\n            return this._endDate;\n        }\n        const duration = this.duration;\n        if (duration !== null) {\n            return new Date(this._startDate.getTime() + duration * 1000);\n        }\n        return null;\n    }\n    get duration() {\n        if (\"DURATION\" in this.attr) {\n            const duration = this.attr.decimalFloatingPoint(\"DURATION\");\n            if (isFiniteNumber(duration)) {\n                return duration;\n            }\n        } else if (this._endDate) {\n            return (this._endDate.getTime() - this._startDate.getTime()) / 1000;\n        }\n        return null;\n    }\n    get plannedDuration() {\n        if (\"PLANNED-DURATION\" in this.attr) {\n            return this.attr.decimalFloatingPoint(\"PLANNED-DURATION\");\n        }\n        return null;\n    }\n    get endOnNext() {\n        return this.attr.bool(\"END-ON-NEXT\");\n    }\n    get isValid() {\n        return !!this.id && !this._badValueForSameId && isFiniteNumber(this.startDate.getTime()) && (this.duration === null || this.duration >= 0) && (!this.endOnNext || !!this.class);\n    }\n}\nclass LoadStats {\n    constructor(){\n        this.aborted = false;\n        this.loaded = 0;\n        this.retry = 0;\n        this.total = 0;\n        this.chunkCount = 0;\n        this.bwEstimate = 0;\n        this.loading = {\n            start: 0,\n            first: 0,\n            end: 0\n        };\n        this.parsing = {\n            start: 0,\n            end: 0\n        };\n        this.buffering = {\n            start: 0,\n            first: 0,\n            end: 0\n        };\n    }\n}\nvar ElementaryStreamTypes = {\n    AUDIO: \"audio\",\n    VIDEO: \"video\",\n    AUDIOVIDEO: \"audiovideo\"\n};\nclass BaseSegment {\n    constructor(baseurl){\n        this._byteRange = null;\n        this._url = null;\n        // baseurl is the URL to the playlist\n        this.baseurl = void 0;\n        // relurl is the portion of the URL that comes from inside the playlist.\n        this.relurl = void 0;\n        // Holds the types of data this fragment supports\n        this.elementaryStreams = {\n            [ElementaryStreamTypes.AUDIO]: null,\n            [ElementaryStreamTypes.VIDEO]: null,\n            [ElementaryStreamTypes.AUDIOVIDEO]: null\n        };\n        this.baseurl = baseurl;\n    }\n    // setByteRange converts a EXT-X-BYTERANGE attribute into a two element array\n    setByteRange(value, previous) {\n        const params = value.split(\"@\", 2);\n        let start;\n        if (params.length === 1) {\n            start = (previous == null ? void 0 : previous.byteRangeEndOffset) || 0;\n        } else {\n            start = parseInt(params[1]);\n        }\n        this._byteRange = [\n            start,\n            parseInt(params[0]) + start\n        ];\n    }\n    get byteRange() {\n        if (!this._byteRange) {\n            return [];\n        }\n        return this._byteRange;\n    }\n    get byteRangeStartOffset() {\n        return this.byteRange[0];\n    }\n    get byteRangeEndOffset() {\n        return this.byteRange[1];\n    }\n    get url() {\n        if (!this._url && this.baseurl && this.relurl) {\n            this._url = urlToolkitExports.buildAbsoluteURL(this.baseurl, this.relurl, {\n                alwaysNormalize: true\n            });\n        }\n        return this._url || \"\";\n    }\n    set url(value) {\n        this._url = value;\n    }\n}\n/**\n * Object representing parsed data from an HLS Segment. Found in {@link hls.js#LevelDetails.fragments}.\n */ class Fragment extends BaseSegment {\n    constructor(type, baseurl){\n        super(baseurl);\n        this._decryptdata = null;\n        this.rawProgramDateTime = null;\n        this.programDateTime = null;\n        this.tagList = [];\n        // EXTINF has to be present for a m3u8 to be considered valid\n        this.duration = 0;\n        // sn notates the sequence number for a segment, and if set to a string can be 'initSegment'\n        this.sn = 0;\n        // levelkeys are the EXT-X-KEY tags that apply to this segment for decryption\n        // core difference from the private field _decryptdata is the lack of the initialized IV\n        // _decryptdata will set the IV for this segment based on the segment number in the fragment\n        this.levelkeys = void 0;\n        // A string representing the fragment type\n        this.type = void 0;\n        // A reference to the loader. Set while the fragment is loading, and removed afterwards. Used to abort fragment loading\n        this.loader = null;\n        // A reference to the key loader. Set while the key is loading, and removed afterwards. Used to abort key loading\n        this.keyLoader = null;\n        // The level/track index to which the fragment belongs\n        this.level = -1;\n        // The continuity counter of the fragment\n        this.cc = 0;\n        // The starting Presentation Time Stamp (PTS) of the fragment. Set after transmux complete.\n        this.startPTS = void 0;\n        // The ending Presentation Time Stamp (PTS) of the fragment. Set after transmux complete.\n        this.endPTS = void 0;\n        // The starting Decode Time Stamp (DTS) of the fragment. Set after transmux complete.\n        this.startDTS = void 0;\n        // The ending Decode Time Stamp (DTS) of the fragment. Set after transmux complete.\n        this.endDTS = void 0;\n        // The start time of the fragment, as listed in the manifest. Updated after transmux complete.\n        this.start = 0;\n        // Set by `updateFragPTSDTS` in level-helper\n        this.deltaPTS = void 0;\n        // The maximum starting Presentation Time Stamp (audio/video PTS) of the fragment. Set after transmux complete.\n        this.maxStartPTS = void 0;\n        // The minimum ending Presentation Time Stamp (audio/video PTS) of the fragment. Set after transmux complete.\n        this.minEndPTS = void 0;\n        // Load/parse timing information\n        this.stats = new LoadStats();\n        // Init Segment bytes (unset for media segments)\n        this.data = void 0;\n        // A flag indicating whether the segment was downloaded in order to test bitrate, and was not buffered\n        this.bitrateTest = false;\n        // #EXTINF  segment title\n        this.title = null;\n        // The Media Initialization Section for this segment\n        this.initSegment = null;\n        // Fragment is the last fragment in the media playlist\n        this.endList = void 0;\n        // Fragment is marked by an EXT-X-GAP tag indicating that it does not contain media data and should not be loaded\n        this.gap = void 0;\n        // Deprecated\n        this.urlId = 0;\n        this.type = type;\n    }\n    get decryptdata() {\n        const { levelkeys } = this;\n        if (!levelkeys && !this._decryptdata) {\n            return null;\n        }\n        if (!this._decryptdata && this.levelkeys && !this.levelkeys.NONE) {\n            const key = this.levelkeys.identity;\n            if (key) {\n                this._decryptdata = key.getDecryptData(this.sn);\n            } else {\n                const keyFormats = Object.keys(this.levelkeys);\n                if (keyFormats.length === 1) {\n                    return this._decryptdata = this.levelkeys[keyFormats[0]].getDecryptData(this.sn);\n                }\n            }\n        }\n        return this._decryptdata;\n    }\n    get end() {\n        return this.start + this.duration;\n    }\n    get endProgramDateTime() {\n        if (this.programDateTime === null) {\n            return null;\n        }\n        if (!isFiniteNumber(this.programDateTime)) {\n            return null;\n        }\n        const duration = !isFiniteNumber(this.duration) ? 0 : this.duration;\n        return this.programDateTime + duration * 1000;\n    }\n    get encrypted() {\n        var _this$_decryptdata;\n        // At the m3u8-parser level we need to add support for manifest signalled keyformats\n        // when we want the fragment to start reporting that it is encrypted.\n        // Currently, keyFormat will only be set for identity keys\n        if ((_this$_decryptdata = this._decryptdata) != null && _this$_decryptdata.encrypted) {\n            return true;\n        } else if (this.levelkeys) {\n            const keyFormats = Object.keys(this.levelkeys);\n            const len = keyFormats.length;\n            if (len > 1 || len === 1 && this.levelkeys[keyFormats[0]].encrypted) {\n                return true;\n            }\n        }\n        return false;\n    }\n    setKeyFormat(keyFormat) {\n        if (this.levelkeys) {\n            const key = this.levelkeys[keyFormat];\n            if (key && !this._decryptdata) {\n                this._decryptdata = key.getDecryptData(this.sn);\n            }\n        }\n    }\n    abortRequests() {\n        var _this$loader, _this$keyLoader;\n        (_this$loader = this.loader) == null ? void 0 : _this$loader.abort();\n        (_this$keyLoader = this.keyLoader) == null ? void 0 : _this$keyLoader.abort();\n    }\n    setElementaryStreamInfo(type, startPTS, endPTS, startDTS, endDTS, partial = false) {\n        const { elementaryStreams } = this;\n        const info = elementaryStreams[type];\n        if (!info) {\n            elementaryStreams[type] = {\n                startPTS,\n                endPTS,\n                startDTS,\n                endDTS,\n                partial\n            };\n            return;\n        }\n        info.startPTS = Math.min(info.startPTS, startPTS);\n        info.endPTS = Math.max(info.endPTS, endPTS);\n        info.startDTS = Math.min(info.startDTS, startDTS);\n        info.endDTS = Math.max(info.endDTS, endDTS);\n    }\n    clearElementaryStreamInfo() {\n        const { elementaryStreams } = this;\n        elementaryStreams[ElementaryStreamTypes.AUDIO] = null;\n        elementaryStreams[ElementaryStreamTypes.VIDEO] = null;\n        elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO] = null;\n    }\n}\n/**\n * Object representing parsed data from an HLS Partial Segment. Found in {@link hls.js#LevelDetails.partList}.\n */ class Part extends BaseSegment {\n    constructor(partAttrs, frag, baseurl, index, previous){\n        super(baseurl);\n        this.fragOffset = 0;\n        this.duration = 0;\n        this.gap = false;\n        this.independent = false;\n        this.relurl = void 0;\n        this.fragment = void 0;\n        this.index = void 0;\n        this.stats = new LoadStats();\n        this.duration = partAttrs.decimalFloatingPoint(\"DURATION\");\n        this.gap = partAttrs.bool(\"GAP\");\n        this.independent = partAttrs.bool(\"INDEPENDENT\");\n        this.relurl = partAttrs.enumeratedString(\"URI\");\n        this.fragment = frag;\n        this.index = index;\n        const byteRange = partAttrs.enumeratedString(\"BYTERANGE\");\n        if (byteRange) {\n            this.setByteRange(byteRange, previous);\n        }\n        if (previous) {\n            this.fragOffset = previous.fragOffset + previous.duration;\n        }\n    }\n    get start() {\n        return this.fragment.start + this.fragOffset;\n    }\n    get end() {\n        return this.start + this.duration;\n    }\n    get loaded() {\n        const { elementaryStreams } = this;\n        return !!(elementaryStreams.audio || elementaryStreams.video || elementaryStreams.audiovideo);\n    }\n}\nconst DEFAULT_TARGET_DURATION = 10;\n/**\n * Object representing parsed data from an HLS Media Playlist. Found in {@link hls.js#Level.details}.\n */ class LevelDetails {\n    constructor(baseUrl){\n        this.PTSKnown = false;\n        this.alignedSliding = false;\n        this.averagetargetduration = void 0;\n        this.endCC = 0;\n        this.endSN = 0;\n        this.fragments = void 0;\n        this.fragmentHint = void 0;\n        this.partList = null;\n        this.dateRanges = void 0;\n        this.live = true;\n        this.ageHeader = 0;\n        this.advancedDateTime = void 0;\n        this.updated = true;\n        this.advanced = true;\n        this.availabilityDelay = void 0;\n        // Manifest reload synchronization\n        this.misses = 0;\n        this.startCC = 0;\n        this.startSN = 0;\n        this.startTimeOffset = null;\n        this.targetduration = 0;\n        this.totalduration = 0;\n        this.type = null;\n        this.url = void 0;\n        this.m3u8 = \"\";\n        this.version = null;\n        this.canBlockReload = false;\n        this.canSkipUntil = 0;\n        this.canSkipDateRanges = false;\n        this.skippedSegments = 0;\n        this.recentlyRemovedDateranges = void 0;\n        this.partHoldBack = 0;\n        this.holdBack = 0;\n        this.partTarget = 0;\n        this.preloadHint = void 0;\n        this.renditionReports = void 0;\n        this.tuneInGoal = 0;\n        this.deltaUpdateFailed = void 0;\n        this.driftStartTime = 0;\n        this.driftEndTime = 0;\n        this.driftStart = 0;\n        this.driftEnd = 0;\n        this.encryptedFragments = void 0;\n        this.playlistParsingError = null;\n        this.variableList = null;\n        this.hasVariableRefs = false;\n        this.fragments = [];\n        this.encryptedFragments = [];\n        this.dateRanges = {};\n        this.url = baseUrl;\n    }\n    reloaded(previous) {\n        if (!previous) {\n            this.advanced = true;\n            this.updated = true;\n            return;\n        }\n        const partSnDiff = this.lastPartSn - previous.lastPartSn;\n        const partIndexDiff = this.lastPartIndex - previous.lastPartIndex;\n        this.updated = this.endSN !== previous.endSN || !!partIndexDiff || !!partSnDiff || !this.live;\n        this.advanced = this.endSN > previous.endSN || partSnDiff > 0 || partSnDiff === 0 && partIndexDiff > 0;\n        if (this.updated || this.advanced) {\n            this.misses = Math.floor(previous.misses * 0.6);\n        } else {\n            this.misses = previous.misses + 1;\n        }\n        this.availabilityDelay = previous.availabilityDelay;\n    }\n    get hasProgramDateTime() {\n        if (this.fragments.length) {\n            return isFiniteNumber(this.fragments[this.fragments.length - 1].programDateTime);\n        }\n        return false;\n    }\n    get levelTargetDuration() {\n        return this.averagetargetduration || this.targetduration || DEFAULT_TARGET_DURATION;\n    }\n    get drift() {\n        const runTime = this.driftEndTime - this.driftStartTime;\n        if (runTime > 0) {\n            const runDuration = this.driftEnd - this.driftStart;\n            return runDuration * 1000 / runTime;\n        }\n        return 1;\n    }\n    get edge() {\n        return this.partEnd || this.fragmentEnd;\n    }\n    get partEnd() {\n        var _this$partList;\n        if ((_this$partList = this.partList) != null && _this$partList.length) {\n            return this.partList[this.partList.length - 1].end;\n        }\n        return this.fragmentEnd;\n    }\n    get fragmentEnd() {\n        var _this$fragments;\n        if ((_this$fragments = this.fragments) != null && _this$fragments.length) {\n            return this.fragments[this.fragments.length - 1].end;\n        }\n        return 0;\n    }\n    get age() {\n        if (this.advancedDateTime) {\n            return Math.max(Date.now() - this.advancedDateTime, 0) / 1000;\n        }\n        return 0;\n    }\n    get lastPartIndex() {\n        var _this$partList2;\n        if ((_this$partList2 = this.partList) != null && _this$partList2.length) {\n            return this.partList[this.partList.length - 1].index;\n        }\n        return -1;\n    }\n    get lastPartSn() {\n        var _this$partList3;\n        if ((_this$partList3 = this.partList) != null && _this$partList3.length) {\n            return this.partList[this.partList.length - 1].fragment.sn;\n        }\n        return this.endSN;\n    }\n}\nfunction base64Decode(base64encodedStr) {\n    return Uint8Array.from(atob(base64encodedStr), (c)=>c.charCodeAt(0));\n}\nfunction getKeyIdBytes(str) {\n    const keyIdbytes = strToUtf8array(str).subarray(0, 16);\n    const paddedkeyIdbytes = new Uint8Array(16);\n    paddedkeyIdbytes.set(keyIdbytes, 16 - keyIdbytes.length);\n    return paddedkeyIdbytes;\n}\nfunction changeEndianness(keyId) {\n    const swap = function swap(array, from, to) {\n        const cur = array[from];\n        array[from] = array[to];\n        array[to] = cur;\n    };\n    swap(keyId, 0, 3);\n    swap(keyId, 1, 2);\n    swap(keyId, 4, 5);\n    swap(keyId, 6, 7);\n}\nfunction convertDataUriToArrayBytes(uri) {\n    // data:[<media type][;attribute=value][;base64],<data>\n    const colonsplit = uri.split(\":\");\n    let keydata = null;\n    if (colonsplit[0] === \"data\" && colonsplit.length === 2) {\n        const semicolonsplit = colonsplit[1].split(\";\");\n        const commasplit = semicolonsplit[semicolonsplit.length - 1].split(\",\");\n        if (commasplit.length === 2) {\n            const isbase64 = commasplit[0] === \"base64\";\n            const data = commasplit[1];\n            if (isbase64) {\n                semicolonsplit.splice(-1, 1); // remove from processing\n                keydata = base64Decode(data);\n            } else {\n                keydata = getKeyIdBytes(data);\n            }\n        }\n    }\n    return keydata;\n}\nfunction strToUtf8array(str) {\n    return Uint8Array.from(unescape(encodeURIComponent(str)), (c)=>c.charCodeAt(0));\n}\n/** returns `undefined` is `self` is missing, e.g. in node */ const optionalSelf = typeof self !== \"undefined\" ? self : undefined;\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess\n */ var KeySystems = {\n    CLEARKEY: \"org.w3.clearkey\",\n    FAIRPLAY: \"com.apple.fps\",\n    PLAYREADY: \"com.microsoft.playready\",\n    WIDEVINE: \"com.widevine.alpha\"\n};\n// Playlist #EXT-X-KEY KEYFORMAT values\nvar KeySystemFormats = {\n    CLEARKEY: \"org.w3.clearkey\",\n    FAIRPLAY: \"com.apple.streamingkeydelivery\",\n    PLAYREADY: \"com.microsoft.playready\",\n    WIDEVINE: \"urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed\"\n};\nfunction keySystemFormatToKeySystemDomain(format) {\n    switch(format){\n        case KeySystemFormats.FAIRPLAY:\n            return KeySystems.FAIRPLAY;\n        case KeySystemFormats.PLAYREADY:\n            return KeySystems.PLAYREADY;\n        case KeySystemFormats.WIDEVINE:\n            return KeySystems.WIDEVINE;\n        case KeySystemFormats.CLEARKEY:\n            return KeySystems.CLEARKEY;\n    }\n}\n// System IDs for which we can extract a key ID from \"encrypted\" event PSSH\nvar KeySystemIds = {\n    WIDEVINE: \"edef8ba979d64acea3c827dcd51d21ed\"\n};\nfunction keySystemIdToKeySystemDomain(systemId) {\n    if (systemId === KeySystemIds.WIDEVINE) {\n        return KeySystems.WIDEVINE;\n    // } else if (systemId === KeySystemIds.PLAYREADY) {\n    //   return KeySystems.PLAYREADY;\n    // } else if (systemId === KeySystemIds.CENC || systemId === KeySystemIds.CLEARKEY) {\n    //   return KeySystems.CLEARKEY;\n    }\n}\nfunction keySystemDomainToKeySystemFormat(keySystem) {\n    switch(keySystem){\n        case KeySystems.FAIRPLAY:\n            return KeySystemFormats.FAIRPLAY;\n        case KeySystems.PLAYREADY:\n            return KeySystemFormats.PLAYREADY;\n        case KeySystems.WIDEVINE:\n            return KeySystemFormats.WIDEVINE;\n        case KeySystems.CLEARKEY:\n            return KeySystemFormats.CLEARKEY;\n    }\n}\nfunction getKeySystemsForConfig(config) {\n    const { drmSystems, widevineLicenseUrl } = config;\n    const keySystemsToAttempt = drmSystems ? [\n        KeySystems.FAIRPLAY,\n        KeySystems.WIDEVINE,\n        KeySystems.PLAYREADY,\n        KeySystems.CLEARKEY\n    ].filter((keySystem)=>!!drmSystems[keySystem]) : [];\n    if (!keySystemsToAttempt[KeySystems.WIDEVINE] && widevineLicenseUrl) {\n        keySystemsToAttempt.push(KeySystems.WIDEVINE);\n    }\n    return keySystemsToAttempt;\n}\nconst requestMediaKeySystemAccess = function(_optionalSelf$navigat) {\n    if (optionalSelf != null && (_optionalSelf$navigat = optionalSelf.navigator) != null && _optionalSelf$navigat.requestMediaKeySystemAccess) {\n        return self.navigator.requestMediaKeySystemAccess.bind(self.navigator);\n    } else {\n        return null;\n    }\n}();\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/API/MediaKeySystemConfiguration\n */ function getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs, drmSystemOptions) {\n    let initDataTypes;\n    switch(keySystem){\n        case KeySystems.FAIRPLAY:\n            initDataTypes = [\n                \"cenc\",\n                \"sinf\"\n            ];\n            break;\n        case KeySystems.WIDEVINE:\n        case KeySystems.PLAYREADY:\n            initDataTypes = [\n                \"cenc\"\n            ];\n            break;\n        case KeySystems.CLEARKEY:\n            initDataTypes = [\n                \"cenc\",\n                \"keyids\"\n            ];\n            break;\n        default:\n            throw new Error(`Unknown key-system: ${keySystem}`);\n    }\n    return createMediaKeySystemConfigurations(initDataTypes, audioCodecs, videoCodecs, drmSystemOptions);\n}\nfunction createMediaKeySystemConfigurations(initDataTypes, audioCodecs, videoCodecs, drmSystemOptions) {\n    const baseConfig = {\n        initDataTypes: initDataTypes,\n        persistentState: drmSystemOptions.persistentState || \"optional\",\n        distinctiveIdentifier: drmSystemOptions.distinctiveIdentifier || \"optional\",\n        sessionTypes: drmSystemOptions.sessionTypes || [\n            drmSystemOptions.sessionType || \"temporary\"\n        ],\n        audioCapabilities: audioCodecs.map((codec)=>({\n                contentType: `audio/mp4; codecs=\"${codec}\"`,\n                robustness: drmSystemOptions.audioRobustness || \"\",\n                encryptionScheme: drmSystemOptions.audioEncryptionScheme || null\n            })),\n        videoCapabilities: videoCodecs.map((codec)=>({\n                contentType: `video/mp4; codecs=\"${codec}\"`,\n                robustness: drmSystemOptions.videoRobustness || \"\",\n                encryptionScheme: drmSystemOptions.videoEncryptionScheme || null\n            }))\n    };\n    return [\n        baseConfig\n    ];\n}\nfunction sliceUint8(array, start, end) {\n    // @ts-expect-error This polyfills IE11 usage of Uint8Array slice.\n    // It always exists in the TypeScript definition so fails, but it fails at runtime on IE11.\n    return Uint8Array.prototype.slice ? array.slice(start, end) : new Uint8Array(Array.prototype.slice.call(array, start, end));\n}\n// breaking up those two types in order to clarify what is happening in the decoding path.\n/**\n * Returns true if an ID3 header can be found at offset in data\n * @param data - The data to search\n * @param offset - The offset at which to start searching\n */ const isHeader$2 = (data, offset)=>{\n    /*\n   * http://id3.org/id3v2.3.0\n   * [0]     = 'I'\n   * [1]     = 'D'\n   * [2]     = '3'\n   * [3,4]   = {Version}\n   * [5]     = {Flags}\n   * [6-9]   = {ID3 Size}\n   *\n   * An ID3v2 tag can be detected with the following pattern:\n   *  $49 44 33 yy yy xx zz zz zz zz\n   * Where yy is less than $FF, xx is the 'flags' byte and zz is less than $80\n   */ if (offset + 10 <= data.length) {\n        // look for 'ID3' identifier\n        if (data[offset] === 0x49 && data[offset + 1] === 0x44 && data[offset + 2] === 0x33) {\n            // check version is within range\n            if (data[offset + 3] < 0xff && data[offset + 4] < 0xff) {\n                // check size is within range\n                if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n};\n/**\n * Returns true if an ID3 footer can be found at offset in data\n * @param data - The data to search\n * @param offset - The offset at which to start searching\n */ const isFooter = (data, offset)=>{\n    /*\n   * The footer is a copy of the header, but with a different identifier\n   */ if (offset + 10 <= data.length) {\n        // look for '3DI' identifier\n        if (data[offset] === 0x33 && data[offset + 1] === 0x44 && data[offset + 2] === 0x49) {\n            // check version is within range\n            if (data[offset + 3] < 0xff && data[offset + 4] < 0xff) {\n                // check size is within range\n                if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n};\n/**\n * Returns any adjacent ID3 tags found in data starting at offset, as one block of data\n * @param data - The data to search in\n * @param offset - The offset at which to start searching\n * @returns the block of data containing any ID3 tags found\n * or *undefined* if no header is found at the starting offset\n */ const getID3Data = (data, offset)=>{\n    const front = offset;\n    let length = 0;\n    while(isHeader$2(data, offset)){\n        // ID3 header is 10 bytes\n        length += 10;\n        const size = readSize(data, offset + 6);\n        length += size;\n        if (isFooter(data, offset + 10)) {\n            // ID3 footer is 10 bytes\n            length += 10;\n        }\n        offset += length;\n    }\n    if (length > 0) {\n        return data.subarray(front, front + length);\n    }\n    return undefined;\n};\nconst readSize = (data, offset)=>{\n    let size = 0;\n    size = (data[offset] & 0x7f) << 21;\n    size |= (data[offset + 1] & 0x7f) << 14;\n    size |= (data[offset + 2] & 0x7f) << 7;\n    size |= data[offset + 3] & 0x7f;\n    return size;\n};\nconst canParse$2 = (data, offset)=>{\n    return isHeader$2(data, offset) && readSize(data, offset + 6) + 10 <= data.length - offset;\n};\n/**\n * Searches for the Elementary Stream timestamp found in the ID3 data chunk\n * @param data - Block of data containing one or more ID3 tags\n */ const getTimeStamp = (data)=>{\n    const frames = getID3Frames(data);\n    for(let i = 0; i < frames.length; i++){\n        const frame = frames[i];\n        if (isTimeStampFrame(frame)) {\n            return readTimeStamp(frame);\n        }\n    }\n    return undefined;\n};\n/**\n * Returns true if the ID3 frame is an Elementary Stream timestamp frame\n */ const isTimeStampFrame = (frame)=>{\n    return frame && frame.key === \"PRIV\" && frame.info === \"com.apple.streaming.transportStreamTimestamp\";\n};\nconst getFrameData = (data)=>{\n    /*\n  Frame ID       $xx xx xx xx (four characters)\n  Size           $xx xx xx xx\n  Flags          $xx xx\n  */ const type = String.fromCharCode(data[0], data[1], data[2], data[3]);\n    const size = readSize(data, 4);\n    // skip frame id, size, and flags\n    const offset = 10;\n    return {\n        type,\n        size,\n        data: data.subarray(offset, offset + size)\n    };\n};\n/**\n * Returns an array of ID3 frames found in all the ID3 tags in the id3Data\n * @param id3Data - The ID3 data containing one or more ID3 tags\n */ const getID3Frames = (id3Data)=>{\n    let offset = 0;\n    const frames = [];\n    while(isHeader$2(id3Data, offset)){\n        const size = readSize(id3Data, offset + 6);\n        // skip past ID3 header\n        offset += 10;\n        const end = offset + size;\n        // loop through frames in the ID3 tag\n        while(offset + 8 < end){\n            const frameData = getFrameData(id3Data.subarray(offset));\n            const frame = decodeFrame(frameData);\n            if (frame) {\n                frames.push(frame);\n            }\n            // skip frame header and frame data\n            offset += frameData.size + 10;\n        }\n        if (isFooter(id3Data, offset)) {\n            offset += 10;\n        }\n    }\n    return frames;\n};\nconst decodeFrame = (frame)=>{\n    if (frame.type === \"PRIV\") {\n        return decodePrivFrame(frame);\n    } else if (frame.type[0] === \"W\") {\n        return decodeURLFrame(frame);\n    }\n    return decodeTextFrame(frame);\n};\nconst decodePrivFrame = (frame)=>{\n    /*\n  Format: <text string>\\0<binary data>\n  */ if (frame.size < 2) {\n        return undefined;\n    }\n    const owner = utf8ArrayToStr(frame.data, true);\n    const privateData = new Uint8Array(frame.data.subarray(owner.length + 1));\n    return {\n        key: frame.type,\n        info: owner,\n        data: privateData.buffer\n    };\n};\nconst decodeTextFrame = (frame)=>{\n    if (frame.size < 2) {\n        return undefined;\n    }\n    if (frame.type === \"TXXX\") {\n        /*\n    Format:\n    [0]   = {Text Encoding}\n    [1-?] = {Description}\\0{Value}\n    */ let index = 1;\n        const description = utf8ArrayToStr(frame.data.subarray(index), true);\n        index += description.length + 1;\n        const value = utf8ArrayToStr(frame.data.subarray(index));\n        return {\n            key: frame.type,\n            info: description,\n            data: value\n        };\n    }\n    /*\n  Format:\n  [0]   = {Text Encoding}\n  [1-?] = {Value}\n  */ const text = utf8ArrayToStr(frame.data.subarray(1));\n    return {\n        key: frame.type,\n        data: text\n    };\n};\nconst decodeURLFrame = (frame)=>{\n    if (frame.type === \"WXXX\") {\n        /*\n    Format:\n    [0]   = {Text Encoding}\n    [1-?] = {Description}\\0{URL}\n    */ if (frame.size < 2) {\n            return undefined;\n        }\n        let index = 1;\n        const description = utf8ArrayToStr(frame.data.subarray(index), true);\n        index += description.length + 1;\n        const value = utf8ArrayToStr(frame.data.subarray(index));\n        return {\n            key: frame.type,\n            info: description,\n            data: value\n        };\n    }\n    /*\n  Format:\n  [0-?] = {URL}\n  */ const url = utf8ArrayToStr(frame.data);\n    return {\n        key: frame.type,\n        data: url\n    };\n};\nconst readTimeStamp = (timeStampFrame)=>{\n    if (timeStampFrame.data.byteLength === 8) {\n        const data = new Uint8Array(timeStampFrame.data);\n        // timestamp is 33 bit expressed as a big-endian eight-octet number,\n        // with the upper 31 bits set to zero.\n        const pts33Bit = data[3] & 0x1;\n        let timestamp = (data[4] << 23) + (data[5] << 15) + (data[6] << 7) + data[7];\n        timestamp /= 45;\n        if (pts33Bit) {\n            timestamp += 47721858.84;\n        } // 2^32 / 90\n        return Math.round(timestamp);\n    }\n    return undefined;\n};\n// http://stackoverflow.com/questions/8936984/uint8array-to-string-in-javascript/22373197\n// http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt\n/* utf.js - UTF-8 <=> UTF-16 convertion\n *\n * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>\n * Version: 1.0\n * LastModified: Dec 25 1999\n * This library is free.  You can redistribute it and/or modify it.\n */ const utf8ArrayToStr = (array, exitOnNull = false)=>{\n    const decoder = getTextDecoder();\n    if (decoder) {\n        const decoded = decoder.decode(array);\n        if (exitOnNull) {\n            // grab up to the first null\n            const idx = decoded.indexOf(\"\\x00\");\n            return idx !== -1 ? decoded.substring(0, idx) : decoded;\n        }\n        // remove any null characters\n        return decoded.replace(/\\0/g, \"\");\n    }\n    const len = array.length;\n    let c;\n    let char2;\n    let char3;\n    let out = \"\";\n    let i = 0;\n    while(i < len){\n        c = array[i++];\n        if (c === 0x00 && exitOnNull) {\n            return out;\n        } else if (c === 0x00 || c === 0x03) {\n            continue;\n        }\n        switch(c >> 4){\n            case 0:\n            case 1:\n            case 2:\n            case 3:\n            case 4:\n            case 5:\n            case 6:\n            case 7:\n                // 0xxxxxxx\n                out += String.fromCharCode(c);\n                break;\n            case 12:\n            case 13:\n                // 110x xxxx   10xx xxxx\n                char2 = array[i++];\n                out += String.fromCharCode((c & 0x1f) << 6 | char2 & 0x3f);\n                break;\n            case 14:\n                // 1110 xxxx  10xx xxxx  10xx xxxx\n                char2 = array[i++];\n                char3 = array[i++];\n                out += String.fromCharCode((c & 0x0f) << 12 | (char2 & 0x3f) << 6 | (char3 & 0x3f) << 0);\n                break;\n        }\n    }\n    return out;\n};\nlet decoder;\nfunction getTextDecoder() {\n    // On Play Station 4, TextDecoder is defined but partially implemented.\n    // Manual decoding option is preferable\n    if (navigator.userAgent.includes(\"PlayStation 4\")) {\n        return;\n    }\n    if (!decoder && typeof self.TextDecoder !== \"undefined\") {\n        decoder = new self.TextDecoder(\"utf-8\");\n    }\n    return decoder;\n}\n/**\n *  hex dump helper class\n */ const Hex = {\n    hexDump: function(array) {\n        let str = \"\";\n        for(let i = 0; i < array.length; i++){\n            let h = array[i].toString(16);\n            if (h.length < 2) {\n                h = \"0\" + h;\n            }\n            str += h;\n        }\n        return str;\n    }\n};\nconst UINT32_MAX$1 = Math.pow(2, 32) - 1;\nconst push = [].push;\n// We are using fixed track IDs for driving the MP4 remuxer\n// instead of following the TS PIDs.\n// There is no reason not to do this and some browsers/SourceBuffer-demuxers\n// may not like if there are TrackID \"switches\"\n// See https://github.com/video-dev/hls.js/issues/1331\n// Here we are mapping our internal track types to constant MP4 track IDs\n// With MSE currently one can only have one track of each, and we are muxing\n// whatever video/audio rendition in them.\nconst RemuxerTrackIdConfig = {\n    video: 1,\n    audio: 2,\n    id3: 3,\n    text: 4\n};\nfunction bin2str(data) {\n    return String.fromCharCode.apply(null, data);\n}\nfunction readUint16(buffer, offset) {\n    const val = buffer[offset] << 8 | buffer[offset + 1];\n    return val < 0 ? 65536 + val : val;\n}\nfunction readUint32(buffer, offset) {\n    const val = readSint32(buffer, offset);\n    return val < 0 ? 4294967296 + val : val;\n}\nfunction readSint32(buffer, offset) {\n    return buffer[offset] << 24 | buffer[offset + 1] << 16 | buffer[offset + 2] << 8 | buffer[offset + 3];\n}\nfunction writeUint32(buffer, offset, value) {\n    buffer[offset] = value >> 24;\n    buffer[offset + 1] = value >> 16 & 0xff;\n    buffer[offset + 2] = value >> 8 & 0xff;\n    buffer[offset + 3] = value & 0xff;\n}\n// Find \"moof\" box\nfunction hasMoofData(data) {\n    const end = data.byteLength;\n    for(let i = 0; i < end;){\n        const size = readUint32(data, i);\n        if (size > 8 && data[i + 4] === 0x6d && data[i + 5] === 0x6f && data[i + 6] === 0x6f && data[i + 7] === 0x66) {\n            return true;\n        }\n        i = size > 1 ? i + size : end;\n    }\n    return false;\n}\n// Find the data for a box specified by its path\nfunction findBox(data, path) {\n    const results = [];\n    if (!path.length) {\n        // short-circuit the search for empty paths\n        return results;\n    }\n    const end = data.byteLength;\n    for(let i = 0; i < end;){\n        const size = readUint32(data, i);\n        const type = bin2str(data.subarray(i + 4, i + 8));\n        const endbox = size > 1 ? i + size : end;\n        if (type === path[0]) {\n            if (path.length === 1) {\n                // this is the end of the path and we've found the box we were\n                // looking for\n                results.push(data.subarray(i + 8, endbox));\n            } else {\n                // recursively search for the next box along the path\n                const subresults = findBox(data.subarray(i + 8, endbox), path.slice(1));\n                if (subresults.length) {\n                    push.apply(results, subresults);\n                }\n            }\n        }\n        i = endbox;\n    }\n    // we've finished searching all of data\n    return results;\n}\nfunction parseSegmentIndex(sidx) {\n    const references = [];\n    const version = sidx[0];\n    // set initial offset, we skip the reference ID (not needed)\n    let index = 8;\n    const timescale = readUint32(sidx, index);\n    index += 4;\n    // TODO: parse earliestPresentationTime and firstOffset\n    // usually zero in our case\n    const earliestPresentationTime = 0;\n    const firstOffset = 0;\n    if (version === 0) {\n        index += 8;\n    } else {\n        index += 16;\n    }\n    // skip reserved\n    index += 2;\n    let startByte = sidx.length + firstOffset;\n    const referencesCount = readUint16(sidx, index);\n    index += 2;\n    for(let i = 0; i < referencesCount; i++){\n        let referenceIndex = index;\n        const referenceInfo = readUint32(sidx, referenceIndex);\n        referenceIndex += 4;\n        const referenceSize = referenceInfo & 0x7fffffff;\n        const referenceType = (referenceInfo & 0x80000000) >>> 31;\n        if (referenceType === 1) {\n            logger.warn(\"SIDX has hierarchical references (not supported)\");\n            return null;\n        }\n        const subsegmentDuration = readUint32(sidx, referenceIndex);\n        referenceIndex += 4;\n        references.push({\n            referenceSize,\n            subsegmentDuration,\n            // unscaled\n            info: {\n                duration: subsegmentDuration / timescale,\n                start: startByte,\n                end: startByte + referenceSize - 1\n            }\n        });\n        startByte += referenceSize;\n        // Skipping 1 bit for |startsWithSap|, 3 bits for |sapType|, and 28 bits\n        // for |sapDelta|.\n        referenceIndex += 4;\n        // skip to next ref\n        index = referenceIndex;\n    }\n    return {\n        earliestPresentationTime,\n        timescale,\n        version,\n        referencesCount,\n        references\n    };\n}\n/**\n * Parses an MP4 initialization segment and extracts stream type and\n * timescale values for any declared tracks. Timescale values indicate the\n * number of clock ticks per second to assume for time-based values\n * elsewhere in the MP4.\n *\n * To determine the start time of an MP4, you need two pieces of\n * information: the timescale unit and the earliest base media decode\n * time. Multiple timescales can be specified within an MP4 but the\n * base media decode time is always expressed in the timescale from\n * the media header box for the track:\n * ```\n * moov > trak > mdia > mdhd.timescale\n * moov > trak > mdia > hdlr\n * ```\n * @param initSegment the bytes of the init segment\n * @returns a hash of track type to timescale values or null if\n * the init segment is malformed.\n */ function parseInitSegment(initSegment) {\n    const result = [];\n    const traks = findBox(initSegment, [\n        \"moov\",\n        \"trak\"\n    ]);\n    for(let i = 0; i < traks.length; i++){\n        const trak = traks[i];\n        const tkhd = findBox(trak, [\n            \"tkhd\"\n        ])[0];\n        if (tkhd) {\n            let version = tkhd[0];\n            const trackId = readUint32(tkhd, version === 0 ? 12 : 20);\n            const mdhd = findBox(trak, [\n                \"mdia\",\n                \"mdhd\"\n            ])[0];\n            if (mdhd) {\n                version = mdhd[0];\n                const timescale = readUint32(mdhd, version === 0 ? 12 : 20);\n                const hdlr = findBox(trak, [\n                    \"mdia\",\n                    \"hdlr\"\n                ])[0];\n                if (hdlr) {\n                    const hdlrType = bin2str(hdlr.subarray(8, 12));\n                    const type = {\n                        soun: ElementaryStreamTypes.AUDIO,\n                        vide: ElementaryStreamTypes.VIDEO\n                    }[hdlrType];\n                    if (type) {\n                        // Parse codec details\n                        const stsd = findBox(trak, [\n                            \"mdia\",\n                            \"minf\",\n                            \"stbl\",\n                            \"stsd\"\n                        ])[0];\n                        const stsdData = parseStsd(stsd);\n                        result[trackId] = {\n                            timescale,\n                            type\n                        };\n                        result[type] = _objectSpread2({\n                            timescale,\n                            id: trackId\n                        }, stsdData);\n                    }\n                }\n            }\n        }\n    }\n    const trex = findBox(initSegment, [\n        \"moov\",\n        \"mvex\",\n        \"trex\"\n    ]);\n    trex.forEach((trex)=>{\n        const trackId = readUint32(trex, 4);\n        const track = result[trackId];\n        if (track) {\n            track.default = {\n                duration: readUint32(trex, 12),\n                flags: readUint32(trex, 20)\n            };\n        }\n    });\n    return result;\n}\nfunction parseStsd(stsd) {\n    const sampleEntries = stsd.subarray(8);\n    const sampleEntriesEnd = sampleEntries.subarray(8 + 78);\n    const fourCC = bin2str(sampleEntries.subarray(4, 8));\n    let codec = fourCC;\n    const encrypted = fourCC === \"enca\" || fourCC === \"encv\";\n    if (encrypted) {\n        const encBox = findBox(sampleEntries, [\n            fourCC\n        ])[0];\n        const encBoxChildren = encBox.subarray(fourCC === \"enca\" ? 28 : 78);\n        const sinfs = findBox(encBoxChildren, [\n            \"sinf\"\n        ]);\n        sinfs.forEach((sinf)=>{\n            const schm = findBox(sinf, [\n                \"schm\"\n            ])[0];\n            if (schm) {\n                const scheme = bin2str(schm.subarray(4, 8));\n                if (scheme === \"cbcs\" || scheme === \"cenc\") {\n                    const frma = findBox(sinf, [\n                        \"frma\"\n                    ])[0];\n                    if (frma) {\n                        // for encrypted content codec fourCC will be in frma\n                        codec = bin2str(frma);\n                    }\n                }\n            }\n        });\n    }\n    switch(codec){\n        case \"avc1\":\n        case \"avc2\":\n        case \"avc3\":\n        case \"avc4\":\n            {\n                // extract profile + compatibility + level out of avcC box\n                const avcCBox = findBox(sampleEntriesEnd, [\n                    \"avcC\"\n                ])[0];\n                codec += \".\" + toHex(avcCBox[1]) + toHex(avcCBox[2]) + toHex(avcCBox[3]);\n                break;\n            }\n        case \"mp4a\":\n            {\n                const codecBox = findBox(sampleEntries, [\n                    fourCC\n                ])[0];\n                const esdsBox = findBox(codecBox.subarray(28), [\n                    \"esds\"\n                ])[0];\n                if (esdsBox && esdsBox.length > 12) {\n                    let i = 4;\n                    // ES Descriptor tag\n                    if (esdsBox[i++] !== 0x03) {\n                        break;\n                    }\n                    i = skipBERInteger(esdsBox, i);\n                    i += 2; // skip es_id;\n                    const flags = esdsBox[i++];\n                    if (flags & 0x80) {\n                        i += 2; // skip dependency es_id\n                    }\n                    if (flags & 0x40) {\n                        i += esdsBox[i++]; // skip URL\n                    }\n                    // Decoder config descriptor\n                    if (esdsBox[i++] !== 0x04) {\n                        break;\n                    }\n                    i = skipBERInteger(esdsBox, i);\n                    const objectType = esdsBox[i++];\n                    if (objectType === 0x40) {\n                        codec += \".\" + toHex(objectType);\n                    } else {\n                        break;\n                    }\n                    i += 12;\n                    // Decoder specific info\n                    if (esdsBox[i++] !== 0x05) {\n                        break;\n                    }\n                    i = skipBERInteger(esdsBox, i);\n                    const firstByte = esdsBox[i++];\n                    let audioObjectType = (firstByte & 0xf8) >> 3;\n                    if (audioObjectType === 31) {\n                        audioObjectType += 1 + ((firstByte & 0x7) << 3) + ((esdsBox[i] & 0xe0) >> 5);\n                    }\n                    codec += \".\" + audioObjectType;\n                }\n                break;\n            }\n        case \"hvc1\":\n        case \"hev1\":\n            {\n                const hvcCBox = findBox(sampleEntriesEnd, [\n                    \"hvcC\"\n                ])[0];\n                const profileByte = hvcCBox[1];\n                const profileSpace = [\n                    \"\",\n                    \"A\",\n                    \"B\",\n                    \"C\"\n                ][profileByte >> 6];\n                const generalProfileIdc = profileByte & 0x1f;\n                const profileCompat = readUint32(hvcCBox, 2);\n                const tierFlag = (profileByte & 0x20) >> 5 ? \"H\" : \"L\";\n                const levelIDC = hvcCBox[12];\n                const constraintIndicator = hvcCBox.subarray(6, 12);\n                codec += \".\" + profileSpace + generalProfileIdc;\n                codec += \".\" + profileCompat.toString(16).toUpperCase();\n                codec += \".\" + tierFlag + levelIDC;\n                let constraintString = \"\";\n                for(let i = constraintIndicator.length; i--;){\n                    const byte = constraintIndicator[i];\n                    if (byte || constraintString) {\n                        const encodedByte = byte.toString(16).toUpperCase();\n                        constraintString = \".\" + encodedByte + constraintString;\n                    }\n                }\n                codec += constraintString;\n                break;\n            }\n        case \"dvh1\":\n        case \"dvhe\":\n            {\n                const dvcCBox = findBox(sampleEntriesEnd, [\n                    \"dvcC\"\n                ])[0];\n                const profile = dvcCBox[2] >> 1 & 0x7f;\n                const level = dvcCBox[2] << 5 & 0x20 | dvcCBox[3] >> 3 & 0x1f;\n                codec += \".\" + addLeadingZero(profile) + \".\" + addLeadingZero(level);\n                break;\n            }\n        case \"vp09\":\n            {\n                const vpcCBox = findBox(sampleEntriesEnd, [\n                    \"vpcC\"\n                ])[0];\n                const profile = vpcCBox[4];\n                const level = vpcCBox[5];\n                const bitDepth = vpcCBox[6] >> 4 & 0x0f;\n                codec += \".\" + addLeadingZero(profile) + \".\" + addLeadingZero(level) + \".\" + addLeadingZero(bitDepth);\n                break;\n            }\n        case \"av01\":\n            {\n                const av1CBox = findBox(sampleEntriesEnd, [\n                    \"av1C\"\n                ])[0];\n                const profile = av1CBox[1] >>> 5;\n                const level = av1CBox[1] & 0x1f;\n                const tierFlag = av1CBox[2] >>> 7 ? \"H\" : \"M\";\n                const highBitDepth = (av1CBox[2] & 0x40) >> 6;\n                const twelveBit = (av1CBox[2] & 0x20) >> 5;\n                const bitDepth = profile === 2 && highBitDepth ? twelveBit ? 12 : 10 : highBitDepth ? 10 : 8;\n                const monochrome = (av1CBox[2] & 0x10) >> 4;\n                const chromaSubsamplingX = (av1CBox[2] & 0x08) >> 3;\n                const chromaSubsamplingY = (av1CBox[2] & 0x04) >> 2;\n                const chromaSamplePosition = av1CBox[2] & 0x03;\n                // TODO: parse color_description_present_flag\n                // default it to BT.709/limited range for now\n                // more info https://aomediacodec.github.io/av1-isobmff/#av1codecconfigurationbox-syntax\n                const colorPrimaries = 1;\n                const transferCharacteristics = 1;\n                const matrixCoefficients = 1;\n                const videoFullRangeFlag = 0;\n                codec += \".\" + profile + \".\" + addLeadingZero(level) + tierFlag + \".\" + addLeadingZero(bitDepth) + \".\" + monochrome + \".\" + chromaSubsamplingX + chromaSubsamplingY + chromaSamplePosition + \".\" + addLeadingZero(colorPrimaries) + \".\" + addLeadingZero(transferCharacteristics) + \".\" + addLeadingZero(matrixCoefficients) + \".\" + videoFullRangeFlag;\n                break;\n            }\n    }\n    return {\n        codec,\n        encrypted\n    };\n}\nfunction skipBERInteger(bytes, i) {\n    const limit = i + 5;\n    while(bytes[i++] & 0x80 && i < limit){}\n    return i;\n}\nfunction toHex(x) {\n    return (\"0\" + x.toString(16).toUpperCase()).slice(-2);\n}\nfunction addLeadingZero(num) {\n    return (num < 10 ? \"0\" : \"\") + num;\n}\nfunction patchEncyptionData(initSegment, decryptdata) {\n    if (!initSegment || !decryptdata) {\n        return initSegment;\n    }\n    const keyId = decryptdata.keyId;\n    if (keyId && decryptdata.isCommonEncryption) {\n        const traks = findBox(initSegment, [\n            \"moov\",\n            \"trak\"\n        ]);\n        traks.forEach((trak)=>{\n            const stsd = findBox(trak, [\n                \"mdia\",\n                \"minf\",\n                \"stbl\",\n                \"stsd\"\n            ])[0];\n            // skip the sample entry count\n            const sampleEntries = stsd.subarray(8);\n            let encBoxes = findBox(sampleEntries, [\n                \"enca\"\n            ]);\n            const isAudio = encBoxes.length > 0;\n            if (!isAudio) {\n                encBoxes = findBox(sampleEntries, [\n                    \"encv\"\n                ]);\n            }\n            encBoxes.forEach((enc)=>{\n                const encBoxChildren = isAudio ? enc.subarray(28) : enc.subarray(78);\n                const sinfBoxes = findBox(encBoxChildren, [\n                    \"sinf\"\n                ]);\n                sinfBoxes.forEach((sinf)=>{\n                    const tenc = parseSinf(sinf);\n                    if (tenc) {\n                        // Look for default key id (keyID offset is always 8 within the tenc box):\n                        const tencKeyId = tenc.subarray(8, 24);\n                        if (!tencKeyId.some((b)=>b !== 0)) {\n                            logger.log(`[eme] Patching keyId in 'enc${isAudio ? \"a\" : \"v\"}>sinf>>tenc' box: ${Hex.hexDump(tencKeyId)} -> ${Hex.hexDump(keyId)}`);\n                            tenc.set(keyId, 8);\n                        }\n                    }\n                });\n            });\n        });\n    }\n    return initSegment;\n}\nfunction parseSinf(sinf) {\n    const schm = findBox(sinf, [\n        \"schm\"\n    ])[0];\n    if (schm) {\n        const scheme = bin2str(schm.subarray(4, 8));\n        if (scheme === \"cbcs\" || scheme === \"cenc\") {\n            return findBox(sinf, [\n                \"schi\",\n                \"tenc\"\n            ])[0];\n        }\n    }\n    logger.error(`[eme] missing 'schm' box`);\n    return null;\n}\n/**\n * Determine the base media decode start time, in seconds, for an MP4\n * fragment. If multiple fragments are specified, the earliest time is\n * returned.\n *\n * The base media decode time can be parsed from track fragment\n * metadata:\n * ```\n * moof > traf > tfdt.baseMediaDecodeTime\n * ```\n * It requires the timescale value from the mdhd to interpret.\n *\n * @param initData - a hash of track type to timescale values\n * @param fmp4 - the bytes of the mp4 fragment\n * @returns the earliest base media decode start time for the\n * fragment, in seconds\n */ function getStartDTS(initData, fmp4) {\n    // we need info from two children of each track fragment box\n    return findBox(fmp4, [\n        \"moof\",\n        \"traf\"\n    ]).reduce((result, traf)=>{\n        const tfdt = findBox(traf, [\n            \"tfdt\"\n        ])[0];\n        const version = tfdt[0];\n        const start = findBox(traf, [\n            \"tfhd\"\n        ]).reduce((result, tfhd)=>{\n            // get the track id from the tfhd\n            const id = readUint32(tfhd, 4);\n            const track = initData[id];\n            if (track) {\n                let baseTime = readUint32(tfdt, 4);\n                if (version === 1) {\n                    // If value is too large, assume signed 64-bit. Negative track fragment decode times are invalid, but they exist in the wild.\n                    // This prevents large values from being used for initPTS, which can cause playlist sync issues.\n                    // https://github.com/video-dev/hls.js/issues/5303\n                    if (baseTime === UINT32_MAX$1) {\n                        logger.warn(`[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time`);\n                        return result;\n                    }\n                    baseTime *= UINT32_MAX$1 + 1;\n                    baseTime += readUint32(tfdt, 8);\n                }\n                // assume a 90kHz clock if no timescale was specified\n                const scale = track.timescale || 90e3;\n                // convert base time to seconds\n                const startTime = baseTime / scale;\n                if (isFiniteNumber(startTime) && (result === null || startTime < result)) {\n                    return startTime;\n                }\n            }\n            return result;\n        }, null);\n        if (start !== null && isFiniteNumber(start) && (result === null || start < result)) {\n            return start;\n        }\n        return result;\n    }, null);\n}\n/*\n  For Reference:\n  aligned(8) class TrackFragmentHeaderBox\n           extends FullBox(tfhd, 0, tf_flags){\n     unsigned int(32)  track_ID;\n     // all the following are optional fields\n     unsigned int(64)  base_data_offset;\n     unsigned int(32)  sample_description_index;\n     unsigned int(32)  default_sample_duration;\n     unsigned int(32)  default_sample_size;\n     unsigned int(32)  default_sample_flags\n  }\n */ function getDuration(data, initData) {\n    let rawDuration = 0;\n    let videoDuration = 0;\n    let audioDuration = 0;\n    const trafs = findBox(data, [\n        \"moof\",\n        \"traf\"\n    ]);\n    for(let i = 0; i < trafs.length; i++){\n        const traf = trafs[i];\n        // There is only one tfhd & trun per traf\n        // This is true for CMAF style content, and we should perhaps check the ftyp\n        // and only look for a single trun then, but for ISOBMFF we should check\n        // for multiple track runs.\n        const tfhd = findBox(traf, [\n            \"tfhd\"\n        ])[0];\n        // get the track id from the tfhd\n        const id = readUint32(tfhd, 4);\n        const track = initData[id];\n        if (!track) {\n            continue;\n        }\n        const trackDefault = track.default;\n        const tfhdFlags = readUint32(tfhd, 0) | (trackDefault == null ? void 0 : trackDefault.flags);\n        let sampleDuration = trackDefault == null ? void 0 : trackDefault.duration;\n        if (tfhdFlags & 0x000008) {\n            // 0x000008 indicates the presence of the default_sample_duration field\n            if (tfhdFlags & 0x000002) {\n                // 0x000002 indicates the presence of the sample_description_index field, which precedes default_sample_duration\n                // If present, the default_sample_duration exists at byte offset 12\n                sampleDuration = readUint32(tfhd, 12);\n            } else {\n                // Otherwise, the duration is at byte offset 8\n                sampleDuration = readUint32(tfhd, 8);\n            }\n        }\n        // assume a 90kHz clock if no timescale was specified\n        const timescale = track.timescale || 90e3;\n        const truns = findBox(traf, [\n            \"trun\"\n        ]);\n        for(let j = 0; j < truns.length; j++){\n            rawDuration = computeRawDurationFromSamples(truns[j]);\n            if (!rawDuration && sampleDuration) {\n                const sampleCount = readUint32(truns[j], 4);\n                rawDuration = sampleDuration * sampleCount;\n            }\n            if (track.type === ElementaryStreamTypes.VIDEO) {\n                videoDuration += rawDuration / timescale;\n            } else if (track.type === ElementaryStreamTypes.AUDIO) {\n                audioDuration += rawDuration / timescale;\n            }\n        }\n    }\n    if (videoDuration === 0 && audioDuration === 0) {\n        // If duration samples are not available in the traf use sidx subsegment_duration\n        let sidxDuration = 0;\n        const sidxs = findBox(data, [\n            \"sidx\"\n        ]);\n        for(let i = 0; i < sidxs.length; i++){\n            const sidx = parseSegmentIndex(sidxs[i]);\n            if (sidx != null && sidx.references) {\n                sidxDuration += sidx.references.reduce((dur, ref)=>dur + ref.info.duration || 0, 0);\n            }\n        }\n        return sidxDuration;\n    }\n    if (videoDuration) {\n        return videoDuration;\n    }\n    return audioDuration;\n}\n/*\n  For Reference:\n  aligned(8) class TrackRunBox\n           extends FullBox(trun, version, tr_flags) {\n     unsigned int(32)  sample_count;\n     // the following are optional fields\n     signed int(32) data_offset;\n     unsigned int(32)  first_sample_flags;\n     // all fields in the following array are optional\n     {\n        unsigned int(32)  sample_duration;\n        unsigned int(32)  sample_size;\n        unsigned int(32)  sample_flags\n        if (version == 0)\n           { unsigned int(32)\n        else\n           { signed int(32)\n     }[ sample_count ]\n  }\n */ function computeRawDurationFromSamples(trun) {\n    const flags = readUint32(trun, 0);\n    // Flags are at offset 0, non-optional sample_count is at offset 4. Therefore we start 8 bytes in.\n    // Each field is an int32, which is 4 bytes\n    let offset = 8;\n    // data-offset-present flag\n    if (flags & 0x000001) {\n        offset += 4;\n    }\n    // first-sample-flags-present flag\n    if (flags & 0x000004) {\n        offset += 4;\n    }\n    let duration = 0;\n    const sampleCount = readUint32(trun, 4);\n    for(let i = 0; i < sampleCount; i++){\n        // sample-duration-present flag\n        if (flags & 0x000100) {\n            const sampleDuration = readUint32(trun, offset);\n            duration += sampleDuration;\n            offset += 4;\n        }\n        // sample-size-present flag\n        if (flags & 0x000200) {\n            offset += 4;\n        }\n        // sample-flags-present flag\n        if (flags & 0x000400) {\n            offset += 4;\n        }\n        // sample-composition-time-offsets-present flag\n        if (flags & 0x000800) {\n            offset += 4;\n        }\n    }\n    return duration;\n}\nfunction offsetStartDTS(initData, fmp4, timeOffset) {\n    findBox(fmp4, [\n        \"moof\",\n        \"traf\"\n    ]).forEach((traf)=>{\n        findBox(traf, [\n            \"tfhd\"\n        ]).forEach((tfhd)=>{\n            // get the track id from the tfhd\n            const id = readUint32(tfhd, 4);\n            const track = initData[id];\n            if (!track) {\n                return;\n            }\n            // assume a 90kHz clock if no timescale was specified\n            const timescale = track.timescale || 90e3;\n            // get the base media decode time from the tfdt\n            findBox(traf, [\n                \"tfdt\"\n            ]).forEach((tfdt)=>{\n                const version = tfdt[0];\n                const offset = timeOffset * timescale;\n                if (offset) {\n                    let baseMediaDecodeTime = readUint32(tfdt, 4);\n                    if (version === 0) {\n                        baseMediaDecodeTime -= offset;\n                        baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);\n                        writeUint32(tfdt, 4, baseMediaDecodeTime);\n                    } else {\n                        baseMediaDecodeTime *= Math.pow(2, 32);\n                        baseMediaDecodeTime += readUint32(tfdt, 8);\n                        baseMediaDecodeTime -= offset;\n                        baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);\n                        const upper = Math.floor(baseMediaDecodeTime / (UINT32_MAX$1 + 1));\n                        const lower = Math.floor(baseMediaDecodeTime % (UINT32_MAX$1 + 1));\n                        writeUint32(tfdt, 4, upper);\n                        writeUint32(tfdt, 8, lower);\n                    }\n                }\n            });\n        });\n    });\n}\n// TODO: Check if the last moof+mdat pair is part of the valid range\nfunction segmentValidRange(data) {\n    const segmentedRange = {\n        valid: null,\n        remainder: null\n    };\n    const moofs = findBox(data, [\n        \"moof\"\n    ]);\n    if (moofs.length < 2) {\n        segmentedRange.remainder = data;\n        return segmentedRange;\n    }\n    const last = moofs[moofs.length - 1];\n    // Offset by 8 bytes; findBox offsets the start by as much\n    segmentedRange.valid = sliceUint8(data, 0, last.byteOffset - 8);\n    segmentedRange.remainder = sliceUint8(data, last.byteOffset - 8);\n    return segmentedRange;\n}\nfunction appendUint8Array(data1, data2) {\n    const temp = new Uint8Array(data1.length + data2.length);\n    temp.set(data1);\n    temp.set(data2, data1.length);\n    return temp;\n}\nfunction parseSamples(timeOffset, track) {\n    const seiSamples = [];\n    const videoData = track.samples;\n    const timescale = track.timescale;\n    const trackId = track.id;\n    let isHEVCFlavor = false;\n    const moofs = findBox(videoData, [\n        \"moof\"\n    ]);\n    moofs.map((moof)=>{\n        const moofOffset = moof.byteOffset - 8;\n        const trafs = findBox(moof, [\n            \"traf\"\n        ]);\n        trafs.map((traf)=>{\n            // get the base media decode time from the tfdt\n            const baseTime = findBox(traf, [\n                \"tfdt\"\n            ]).map((tfdt)=>{\n                const version = tfdt[0];\n                let result = readUint32(tfdt, 4);\n                if (version === 1) {\n                    result *= Math.pow(2, 32);\n                    result += readUint32(tfdt, 8);\n                }\n                return result / timescale;\n            })[0];\n            if (baseTime !== undefined) {\n                timeOffset = baseTime;\n            }\n            return findBox(traf, [\n                \"tfhd\"\n            ]).map((tfhd)=>{\n                const id = readUint32(tfhd, 4);\n                const tfhdFlags = readUint32(tfhd, 0) & 0xffffff;\n                const baseDataOffsetPresent = (tfhdFlags & 0x000001) !== 0;\n                const sampleDescriptionIndexPresent = (tfhdFlags & 0x000002) !== 0;\n                const defaultSampleDurationPresent = (tfhdFlags & 0x000008) !== 0;\n                let defaultSampleDuration = 0;\n                const defaultSampleSizePresent = (tfhdFlags & 0x000010) !== 0;\n                let defaultSampleSize = 0;\n                const defaultSampleFlagsPresent = (tfhdFlags & 0x000020) !== 0;\n                let tfhdOffset = 8;\n                if (id === trackId) {\n                    if (baseDataOffsetPresent) {\n                        tfhdOffset += 8;\n                    }\n                    if (sampleDescriptionIndexPresent) {\n                        tfhdOffset += 4;\n                    }\n                    if (defaultSampleDurationPresent) {\n                        defaultSampleDuration = readUint32(tfhd, tfhdOffset);\n                        tfhdOffset += 4;\n                    }\n                    if (defaultSampleSizePresent) {\n                        defaultSampleSize = readUint32(tfhd, tfhdOffset);\n                        tfhdOffset += 4;\n                    }\n                    if (defaultSampleFlagsPresent) {\n                        tfhdOffset += 4;\n                    }\n                    if (track.type === \"video\") {\n                        isHEVCFlavor = isHEVC(track.codec);\n                    }\n                    findBox(traf, [\n                        \"trun\"\n                    ]).map((trun)=>{\n                        const version = trun[0];\n                        const flags = readUint32(trun, 0) & 0xffffff;\n                        const dataOffsetPresent = (flags & 0x000001) !== 0;\n                        let dataOffset = 0;\n                        const firstSampleFlagsPresent = (flags & 0x000004) !== 0;\n                        const sampleDurationPresent = (flags & 0x000100) !== 0;\n                        let sampleDuration = 0;\n                        const sampleSizePresent = (flags & 0x000200) !== 0;\n                        let sampleSize = 0;\n                        const sampleFlagsPresent = (flags & 0x000400) !== 0;\n                        const sampleCompositionOffsetsPresent = (flags & 0x000800) !== 0;\n                        let compositionOffset = 0;\n                        const sampleCount = readUint32(trun, 4);\n                        let trunOffset = 8; // past version, flags, and sample count\n                        if (dataOffsetPresent) {\n                            dataOffset = readUint32(trun, trunOffset);\n                            trunOffset += 4;\n                        }\n                        if (firstSampleFlagsPresent) {\n                            trunOffset += 4;\n                        }\n                        let sampleOffset = dataOffset + moofOffset;\n                        for(let ix = 0; ix < sampleCount; ix++){\n                            if (sampleDurationPresent) {\n                                sampleDuration = readUint32(trun, trunOffset);\n                                trunOffset += 4;\n                            } else {\n                                sampleDuration = defaultSampleDuration;\n                            }\n                            if (sampleSizePresent) {\n                                sampleSize = readUint32(trun, trunOffset);\n                                trunOffset += 4;\n                            } else {\n                                sampleSize = defaultSampleSize;\n                            }\n                            if (sampleFlagsPresent) {\n                                trunOffset += 4;\n                            }\n                            if (sampleCompositionOffsetsPresent) {\n                                if (version === 0) {\n                                    compositionOffset = readUint32(trun, trunOffset);\n                                } else {\n                                    compositionOffset = readSint32(trun, trunOffset);\n                                }\n                                trunOffset += 4;\n                            }\n                            if (track.type === ElementaryStreamTypes.VIDEO) {\n                                let naluTotalSize = 0;\n                                while(naluTotalSize < sampleSize){\n                                    const naluSize = readUint32(videoData, sampleOffset);\n                                    sampleOffset += 4;\n                                    if (isSEIMessage(isHEVCFlavor, videoData[sampleOffset])) {\n                                        const data = videoData.subarray(sampleOffset, sampleOffset + naluSize);\n                                        parseSEIMessageFromNALu(data, isHEVCFlavor ? 2 : 1, timeOffset + compositionOffset / timescale, seiSamples);\n                                    }\n                                    sampleOffset += naluSize;\n                                    naluTotalSize += naluSize + 4;\n                                }\n                            }\n                            timeOffset += sampleDuration / timescale;\n                        }\n                    });\n                }\n            });\n        });\n    });\n    return seiSamples;\n}\nfunction isHEVC(codec) {\n    if (!codec) {\n        return false;\n    }\n    const delimit = codec.indexOf(\".\");\n    const baseCodec = delimit < 0 ? codec : codec.substring(0, delimit);\n    return baseCodec === \"hvc1\" || baseCodec === \"hev1\" || // Dolby Vision\n    baseCodec === \"dvh1\" || baseCodec === \"dvhe\";\n}\nfunction isSEIMessage(isHEVCFlavor, naluHeader) {\n    if (isHEVCFlavor) {\n        const naluType = naluHeader >> 1 & 0x3f;\n        return naluType === 39 || naluType === 40;\n    } else {\n        const naluType = naluHeader & 0x1f;\n        return naluType === 6;\n    }\n}\nfunction parseSEIMessageFromNALu(unescapedData, headerSize, pts, samples) {\n    const data = discardEPB(unescapedData);\n    let seiPtr = 0;\n    // skip nal header\n    seiPtr += headerSize;\n    let payloadType = 0;\n    let payloadSize = 0;\n    let b = 0;\n    while(seiPtr < data.length){\n        payloadType = 0;\n        do {\n            if (seiPtr >= data.length) {\n                break;\n            }\n            b = data[seiPtr++];\n            payloadType += b;\n        }while (b === 0xff);\n        // Parse payload size.\n        payloadSize = 0;\n        do {\n            if (seiPtr >= data.length) {\n                break;\n            }\n            b = data[seiPtr++];\n            payloadSize += b;\n        }while (b === 0xff);\n        const leftOver = data.length - seiPtr;\n        // Create a variable to process the payload\n        let payPtr = seiPtr;\n        // Increment the seiPtr to the end of the payload\n        if (payloadSize < leftOver) {\n            seiPtr += payloadSize;\n        } else if (payloadSize > leftOver) {\n            // Some type of corruption has happened?\n            logger.error(`Malformed SEI payload. ${payloadSize} is too small, only ${leftOver} bytes left to parse.`);\n            break;\n        }\n        if (payloadType === 4) {\n            const countryCode = data[payPtr++];\n            if (countryCode === 181) {\n                const providerCode = readUint16(data, payPtr);\n                payPtr += 2;\n                if (providerCode === 49) {\n                    const userStructure = readUint32(data, payPtr);\n                    payPtr += 4;\n                    if (userStructure === 0x47413934) {\n                        const userDataType = data[payPtr++];\n                        // Raw CEA-608 bytes wrapped in CEA-708 packet\n                        if (userDataType === 3) {\n                            const firstByte = data[payPtr++];\n                            const totalCCs = 0x1f & firstByte;\n                            const enabled = 0x40 & firstByte;\n                            const totalBytes = enabled ? 2 + totalCCs * 3 : 0;\n                            const byteArray = new Uint8Array(totalBytes);\n                            if (enabled) {\n                                byteArray[0] = firstByte;\n                                for(let i = 1; i < totalBytes; i++){\n                                    byteArray[i] = data[payPtr++];\n                                }\n                            }\n                            samples.push({\n                                type: userDataType,\n                                payloadType,\n                                pts,\n                                bytes: byteArray\n                            });\n                        }\n                    }\n                }\n            }\n        } else if (payloadType === 5) {\n            if (payloadSize > 16) {\n                const uuidStrArray = [];\n                for(let i = 0; i < 16; i++){\n                    const _b = data[payPtr++].toString(16);\n                    uuidStrArray.push(_b.length == 1 ? \"0\" + _b : _b);\n                    if (i === 3 || i === 5 || i === 7 || i === 9) {\n                        uuidStrArray.push(\"-\");\n                    }\n                }\n                const length = payloadSize - 16;\n                const userDataBytes = new Uint8Array(length);\n                for(let i = 0; i < length; i++){\n                    userDataBytes[i] = data[payPtr++];\n                }\n                samples.push({\n                    payloadType,\n                    pts,\n                    uuid: uuidStrArray.join(\"\"),\n                    userData: utf8ArrayToStr(userDataBytes),\n                    userDataBytes\n                });\n            }\n        }\n    }\n}\n/**\n * remove Emulation Prevention bytes from a RBSP\n */ function discardEPB(data) {\n    const length = data.byteLength;\n    const EPBPositions = [];\n    let i = 1;\n    // Find all `Emulation Prevention Bytes`\n    while(i < length - 2){\n        if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\n            EPBPositions.push(i + 2);\n            i += 2;\n        } else {\n            i++;\n        }\n    }\n    // If no Emulation Prevention Bytes were found just return the original\n    // array\n    if (EPBPositions.length === 0) {\n        return data;\n    }\n    // Create a new array to hold the NAL unit data\n    const newLength = length - EPBPositions.length;\n    const newData = new Uint8Array(newLength);\n    let sourceIndex = 0;\n    for(i = 0; i < newLength; sourceIndex++, i++){\n        if (sourceIndex === EPBPositions[0]) {\n            // Skip this byte\n            sourceIndex++;\n            // Remove this position index\n            EPBPositions.shift();\n        }\n        newData[i] = data[sourceIndex];\n    }\n    return newData;\n}\nfunction parseEmsg(data) {\n    const version = data[0];\n    let schemeIdUri = \"\";\n    let value = \"\";\n    let timeScale = 0;\n    let presentationTimeDelta = 0;\n    let presentationTime = 0;\n    let eventDuration = 0;\n    let id = 0;\n    let offset = 0;\n    if (version === 0) {\n        while(bin2str(data.subarray(offset, offset + 1)) !== \"\\x00\"){\n            schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n            offset += 1;\n        }\n        schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n        offset += 1;\n        while(bin2str(data.subarray(offset, offset + 1)) !== \"\\x00\"){\n            value += bin2str(data.subarray(offset, offset + 1));\n            offset += 1;\n        }\n        value += bin2str(data.subarray(offset, offset + 1));\n        offset += 1;\n        timeScale = readUint32(data, 12);\n        presentationTimeDelta = readUint32(data, 16);\n        eventDuration = readUint32(data, 20);\n        id = readUint32(data, 24);\n        offset = 28;\n    } else if (version === 1) {\n        offset += 4;\n        timeScale = readUint32(data, offset);\n        offset += 4;\n        const leftPresentationTime = readUint32(data, offset);\n        offset += 4;\n        const rightPresentationTime = readUint32(data, offset);\n        offset += 4;\n        presentationTime = 2 ** 32 * leftPresentationTime + rightPresentationTime;\n        if (!isSafeInteger(presentationTime)) {\n            presentationTime = Number.MAX_SAFE_INTEGER;\n            logger.warn(\"Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box\");\n        }\n        eventDuration = readUint32(data, offset);\n        offset += 4;\n        id = readUint32(data, offset);\n        offset += 4;\n        while(bin2str(data.subarray(offset, offset + 1)) !== \"\\x00\"){\n            schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n            offset += 1;\n        }\n        schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n        offset += 1;\n        while(bin2str(data.subarray(offset, offset + 1)) !== \"\\x00\"){\n            value += bin2str(data.subarray(offset, offset + 1));\n            offset += 1;\n        }\n        value += bin2str(data.subarray(offset, offset + 1));\n        offset += 1;\n    }\n    const payload = data.subarray(offset, data.byteLength);\n    return {\n        schemeIdUri,\n        value,\n        timeScale,\n        presentationTime,\n        presentationTimeDelta,\n        eventDuration,\n        id,\n        payload\n    };\n}\nfunction mp4Box(type, ...payload) {\n    const len = payload.length;\n    let size = 8;\n    let i = len;\n    while(i--){\n        size += payload[i].byteLength;\n    }\n    const result = new Uint8Array(size);\n    result[0] = size >> 24 & 0xff;\n    result[1] = size >> 16 & 0xff;\n    result[2] = size >> 8 & 0xff;\n    result[3] = size & 0xff;\n    result.set(type, 4);\n    for(i = 0, size = 8; i < len; i++){\n        result.set(payload[i], size);\n        size += payload[i].byteLength;\n    }\n    return result;\n}\nfunction mp4pssh(systemId, keyids, data) {\n    if (systemId.byteLength !== 16) {\n        throw new RangeError(\"Invalid system id\");\n    }\n    let version;\n    let kids;\n    if (keyids) {\n        version = 1;\n        kids = new Uint8Array(keyids.length * 16);\n        for(let ix = 0; ix < keyids.length; ix++){\n            const k = keyids[ix]; // uint8array\n            if (k.byteLength !== 16) {\n                throw new RangeError(\"Invalid key\");\n            }\n            kids.set(k, ix * 16);\n        }\n    } else {\n        version = 0;\n        kids = new Uint8Array();\n    }\n    let kidCount;\n    if (version > 0) {\n        kidCount = new Uint8Array(4);\n        if (keyids.length > 0) {\n            new DataView(kidCount.buffer).setUint32(0, keyids.length, false);\n        }\n    } else {\n        kidCount = new Uint8Array();\n    }\n    const dataSize = new Uint8Array(4);\n    if (data && data.byteLength > 0) {\n        new DataView(dataSize.buffer).setUint32(0, data.byteLength, false);\n    }\n    return mp4Box([\n        112,\n        115,\n        115,\n        104\n    ], new Uint8Array([\n        version,\n        0x00,\n        0x00,\n        0x00 // Flags\n    ]), systemId, // 16 bytes\n    kidCount, kids, dataSize, data || new Uint8Array());\n}\nfunction parsePssh(initData) {\n    if (!(initData instanceof ArrayBuffer) || initData.byteLength < 32) {\n        return null;\n    }\n    const result = {\n        version: 0,\n        systemId: \"\",\n        kids: null,\n        data: null\n    };\n    const view = new DataView(initData);\n    const boxSize = view.getUint32(0);\n    if (initData.byteLength !== boxSize && boxSize > 44) {\n        return null;\n    }\n    const type = view.getUint32(4);\n    if (type !== 0x70737368) {\n        return null;\n    }\n    result.version = view.getUint32(8) >>> 24;\n    if (result.version > 1) {\n        return null;\n    }\n    result.systemId = Hex.hexDump(new Uint8Array(initData, 12, 16));\n    const dataSizeOrKidCount = view.getUint32(28);\n    if (result.version === 0) {\n        if (boxSize - 32 < dataSizeOrKidCount) {\n            return null;\n        }\n        result.data = new Uint8Array(initData, 32, dataSizeOrKidCount);\n    } else if (result.version === 1) {\n        result.kids = [];\n        for(let i = 0; i < dataSizeOrKidCount; i++){\n            result.kids.push(new Uint8Array(initData, 32 + i * 16, 16));\n        }\n    }\n    return result;\n}\nlet keyUriToKeyIdMap = {};\nclass LevelKey {\n    static clearKeyUriToKeyIdMap() {\n        keyUriToKeyIdMap = {};\n    }\n    constructor(method, uri, format, formatversions = [\n        1\n    ], iv = null){\n        this.uri = void 0;\n        this.method = void 0;\n        this.keyFormat = void 0;\n        this.keyFormatVersions = void 0;\n        this.encrypted = void 0;\n        this.isCommonEncryption = void 0;\n        this.iv = null;\n        this.key = null;\n        this.keyId = null;\n        this.pssh = null;\n        this.method = method;\n        this.uri = uri;\n        this.keyFormat = format;\n        this.keyFormatVersions = formatversions;\n        this.iv = iv;\n        this.encrypted = method ? method !== \"NONE\" : false;\n        this.isCommonEncryption = this.encrypted && method !== \"AES-128\";\n    }\n    isSupported() {\n        // If it's Segment encryption or No encryption, just select that key system\n        if (this.method) {\n            if (this.method === \"AES-128\" || this.method === \"NONE\") {\n                return true;\n            }\n            if (this.keyFormat === \"identity\") {\n                // Maintain support for clear SAMPLE-AES with MPEG-3 TS\n                return this.method === \"SAMPLE-AES\";\n            } else {\n                switch(this.keyFormat){\n                    case KeySystemFormats.FAIRPLAY:\n                    case KeySystemFormats.WIDEVINE:\n                    case KeySystemFormats.PLAYREADY:\n                    case KeySystemFormats.CLEARKEY:\n                        return [\n                            \"ISO-23001-7\",\n                            \"SAMPLE-AES\",\n                            \"SAMPLE-AES-CENC\",\n                            \"SAMPLE-AES-CTR\"\n                        ].indexOf(this.method) !== -1;\n                }\n            }\n        }\n        return false;\n    }\n    getDecryptData(sn) {\n        if (!this.encrypted || !this.uri) {\n            return null;\n        }\n        if (this.method === \"AES-128\" && this.uri && !this.iv) {\n            if (typeof sn !== \"number\") {\n                // We are fetching decryption data for a initialization segment\n                // If the segment was encrypted with AES-128\n                // It must have an IV defined. We cannot substitute the Segment Number in.\n                if (this.method === \"AES-128\" && !this.iv) {\n                    logger.warn(`missing IV for initialization segment with method=\"${this.method}\" - compliance issue`);\n                }\n                // Explicitly set sn to resulting value from implicit conversions 'initSegment' values for IV generation.\n                sn = 0;\n            }\n            const iv = createInitializationVector(sn);\n            const decryptdata = new LevelKey(this.method, this.uri, \"identity\", this.keyFormatVersions, iv);\n            return decryptdata;\n        }\n        // Initialize keyId if possible\n        const keyBytes = convertDataUriToArrayBytes(this.uri);\n        if (keyBytes) {\n            switch(this.keyFormat){\n                case KeySystemFormats.WIDEVINE:\n                    this.pssh = keyBytes;\n                    // In case of widevine keyID is embedded in PSSH box. Read Key ID.\n                    if (keyBytes.length >= 22) {\n                        this.keyId = keyBytes.subarray(keyBytes.length - 22, keyBytes.length - 6);\n                    }\n                    break;\n                case KeySystemFormats.PLAYREADY:\n                    {\n                        const PlayReadyKeySystemUUID = new Uint8Array([\n                            0x9a,\n                            0x04,\n                            0xf0,\n                            0x79,\n                            0x98,\n                            0x40,\n                            0x42,\n                            0x86,\n                            0xab,\n                            0x92,\n                            0xe6,\n                            0x5b,\n                            0xe0,\n                            0x88,\n                            0x5f,\n                            0x95\n                        ]);\n                        this.pssh = mp4pssh(PlayReadyKeySystemUUID, null, keyBytes);\n                        const keyBytesUtf16 = new Uint16Array(keyBytes.buffer, keyBytes.byteOffset, keyBytes.byteLength / 2);\n                        const keyByteStr = String.fromCharCode.apply(null, Array.from(keyBytesUtf16));\n                        // Parse Playready WRMHeader XML\n                        const xmlKeyBytes = keyByteStr.substring(keyByteStr.indexOf(\"<\"), keyByteStr.length);\n                        const parser = new DOMParser();\n                        const xmlDoc = parser.parseFromString(xmlKeyBytes, \"text/xml\");\n                        const keyData = xmlDoc.getElementsByTagName(\"KID\")[0];\n                        if (keyData) {\n                            const keyId = keyData.childNodes[0] ? keyData.childNodes[0].nodeValue : keyData.getAttribute(\"VALUE\");\n                            if (keyId) {\n                                const keyIdArray = base64Decode(keyId).subarray(0, 16);\n                                // KID value in PRO is a base64-encoded little endian GUID interpretation of UUID\n                                // KID value in tenc is a big endian UUID GUID interpretation of UUID\n                                changeEndianness(keyIdArray);\n                                this.keyId = keyIdArray;\n                            }\n                        }\n                        break;\n                    }\n                default:\n                    {\n                        let keydata = keyBytes.subarray(0, 16);\n                        if (keydata.length !== 16) {\n                            const padded = new Uint8Array(16);\n                            padded.set(keydata, 16 - keydata.length);\n                            keydata = padded;\n                        }\n                        this.keyId = keydata;\n                        break;\n                    }\n            }\n        }\n        // Default behavior: assign a new keyId for each uri\n        if (!this.keyId || this.keyId.byteLength !== 16) {\n            let keyId = keyUriToKeyIdMap[this.uri];\n            if (!keyId) {\n                const val = Object.keys(keyUriToKeyIdMap).length % Number.MAX_SAFE_INTEGER;\n                keyId = new Uint8Array(16);\n                const dv = new DataView(keyId.buffer, 12, 4); // Just set the last 4 bytes\n                dv.setUint32(0, val);\n                keyUriToKeyIdMap[this.uri] = keyId;\n            }\n            this.keyId = keyId;\n        }\n        return this;\n    }\n}\nfunction createInitializationVector(segmentNumber) {\n    const uint8View = new Uint8Array(16);\n    for(let i = 12; i < 16; i++){\n        uint8View[i] = segmentNumber >> 8 * (15 - i) & 0xff;\n    }\n    return uint8View;\n}\nconst VARIABLE_REPLACEMENT_REGEX = /\\{\\$([a-zA-Z0-9-_]+)\\}/g;\nfunction hasVariableReferences(str) {\n    return VARIABLE_REPLACEMENT_REGEX.test(str);\n}\nfunction substituteVariablesInAttributes(parsed, attr, attributeNames) {\n    if (parsed.variableList !== null || parsed.hasVariableRefs) {\n        for(let i = attributeNames.length; i--;){\n            const name = attributeNames[i];\n            const value = attr[name];\n            if (value) {\n                attr[name] = substituteVariables(parsed, value);\n            }\n        }\n    }\n}\nfunction substituteVariables(parsed, value) {\n    if (parsed.variableList !== null || parsed.hasVariableRefs) {\n        const variableList = parsed.variableList;\n        return value.replace(VARIABLE_REPLACEMENT_REGEX, (variableReference)=>{\n            const variableName = variableReference.substring(2, variableReference.length - 1);\n            const variableValue = variableList == null ? void 0 : variableList[variableName];\n            if (variableValue === undefined) {\n                parsed.playlistParsingError || (parsed.playlistParsingError = new Error(`Missing preceding EXT-X-DEFINE tag for Variable Reference: \"${variableName}\"`));\n                return variableReference;\n            }\n            return variableValue;\n        });\n    }\n    return value;\n}\nfunction addVariableDefinition(parsed, attr, parentUrl) {\n    let variableList = parsed.variableList;\n    if (!variableList) {\n        parsed.variableList = variableList = {};\n    }\n    let NAME;\n    let VALUE;\n    if (\"QUERYPARAM\" in attr) {\n        NAME = attr.QUERYPARAM;\n        try {\n            const searchParams = new self.URL(parentUrl).searchParams;\n            if (searchParams.has(NAME)) {\n                VALUE = searchParams.get(NAME);\n            } else {\n                throw new Error(`\"${NAME}\" does not match any query parameter in URI: \"${parentUrl}\"`);\n            }\n        } catch (error) {\n            parsed.playlistParsingError || (parsed.playlistParsingError = new Error(`EXT-X-DEFINE QUERYPARAM: ${error.message}`));\n        }\n    } else {\n        NAME = attr.NAME;\n        VALUE = attr.VALUE;\n    }\n    if (NAME in variableList) {\n        parsed.playlistParsingError || (parsed.playlistParsingError = new Error(`EXT-X-DEFINE duplicate Variable Name declarations: \"${NAME}\"`));\n    } else {\n        variableList[NAME] = VALUE || \"\";\n    }\n}\nfunction importVariableDefinition(parsed, attr, sourceVariableList) {\n    const IMPORT = attr.IMPORT;\n    if (sourceVariableList && IMPORT in sourceVariableList) {\n        let variableList = parsed.variableList;\n        if (!variableList) {\n            parsed.variableList = variableList = {};\n        }\n        variableList[IMPORT] = sourceVariableList[IMPORT];\n    } else {\n        parsed.playlistParsingError || (parsed.playlistParsingError = new Error(`EXT-X-DEFINE IMPORT attribute not found in Multivariant Playlist: \"${IMPORT}\"`));\n    }\n}\n/**\n * MediaSource helper\n */ function getMediaSource(preferManagedMediaSource = true) {\n    if (typeof self === \"undefined\") return undefined;\n    const mms = (preferManagedMediaSource || !self.MediaSource) && self.ManagedMediaSource;\n    return mms || self.MediaSource || self.WebKitMediaSource;\n}\n// from http://mp4ra.org/codecs.html\n// values indicate codec selection preference (lower is higher priority)\nconst sampleEntryCodesISO = {\n    audio: {\n        a3ds: 1,\n        \"ac-3\": 0.95,\n        \"ac-4\": 1,\n        alac: 0.9,\n        alaw: 1,\n        dra1: 1,\n        \"dts+\": 1,\n        \"dts-\": 1,\n        dtsc: 1,\n        dtse: 1,\n        dtsh: 1,\n        \"ec-3\": 0.9,\n        enca: 1,\n        fLaC: 0.9,\n        // MP4-RA listed codec entry for FLAC\n        flac: 0.9,\n        // legacy browser codec name for FLAC\n        FLAC: 0.9,\n        // some manifests may list \"FLAC\" with Apple's tools\n        g719: 1,\n        g726: 1,\n        m4ae: 1,\n        mha1: 1,\n        mha2: 1,\n        mhm1: 1,\n        mhm2: 1,\n        mlpa: 1,\n        mp4a: 1,\n        \"raw \": 1,\n        Opus: 1,\n        opus: 1,\n        // browsers expect this to be lowercase despite MP4RA says 'Opus'\n        samr: 1,\n        sawb: 1,\n        sawp: 1,\n        sevc: 1,\n        sqcp: 1,\n        ssmv: 1,\n        twos: 1,\n        ulaw: 1\n    },\n    video: {\n        avc1: 1,\n        avc2: 1,\n        avc3: 1,\n        avc4: 1,\n        avcp: 1,\n        av01: 0.8,\n        drac: 1,\n        dva1: 1,\n        dvav: 1,\n        dvh1: 0.7,\n        dvhe: 0.7,\n        encv: 1,\n        hev1: 0.75,\n        hvc1: 0.75,\n        mjp2: 1,\n        mp4v: 1,\n        mvc1: 1,\n        mvc2: 1,\n        mvc3: 1,\n        mvc4: 1,\n        resv: 1,\n        rv60: 1,\n        s263: 1,\n        svc1: 1,\n        svc2: 1,\n        \"vc-1\": 1,\n        vp08: 1,\n        vp09: 0.9\n    },\n    text: {\n        stpp: 1,\n        wvtt: 1\n    }\n};\nfunction isCodecType(codec, type) {\n    const typeCodes = sampleEntryCodesISO[type];\n    return !!typeCodes && !!typeCodes[codec.slice(0, 4)];\n}\nfunction areCodecsMediaSourceSupported(codecs, type, preferManagedMediaSource = true) {\n    return !codecs.split(\",\").some((codec)=>!isCodecMediaSourceSupported(codec, type, preferManagedMediaSource));\n}\nfunction isCodecMediaSourceSupported(codec, type, preferManagedMediaSource = true) {\n    var _MediaSource$isTypeSu;\n    const MediaSource = getMediaSource(preferManagedMediaSource);\n    return (_MediaSource$isTypeSu = MediaSource == null ? void 0 : MediaSource.isTypeSupported(mimeTypeForCodec(codec, type))) != null ? _MediaSource$isTypeSu : false;\n}\nfunction mimeTypeForCodec(codec, type) {\n    return `${type}/mp4;codecs=\"${codec}\"`;\n}\nfunction videoCodecPreferenceValue(videoCodec) {\n    if (videoCodec) {\n        const fourCC = videoCodec.substring(0, 4);\n        return sampleEntryCodesISO.video[fourCC];\n    }\n    return 2;\n}\nfunction codecsSetSelectionPreferenceValue(codecSet) {\n    return codecSet.split(\",\").reduce((num, fourCC)=>{\n        const preferenceValue = sampleEntryCodesISO.video[fourCC];\n        if (preferenceValue) {\n            return (preferenceValue * 2 + num) / (num ? 3 : 2);\n        }\n        return (sampleEntryCodesISO.audio[fourCC] + num) / (num ? 2 : 1);\n    }, 0);\n}\nconst CODEC_COMPATIBLE_NAMES = {};\nfunction getCodecCompatibleNameLower(lowerCaseCodec, preferManagedMediaSource = true) {\n    if (CODEC_COMPATIBLE_NAMES[lowerCaseCodec]) {\n        return CODEC_COMPATIBLE_NAMES[lowerCaseCodec];\n    }\n    // Idealy fLaC and Opus would be first (spec-compliant) but\n    // some browsers will report that fLaC is supported then fail.\n    // see: https://bugs.chromium.org/p/chromium/issues/detail?id=1422728\n    const codecsToCheck = {\n        flac: [\n            \"flac\",\n            \"fLaC\",\n            \"FLAC\"\n        ],\n        opus: [\n            \"opus\",\n            \"Opus\"\n        ]\n    }[lowerCaseCodec];\n    for(let i = 0; i < codecsToCheck.length; i++){\n        if (isCodecMediaSourceSupported(codecsToCheck[i], \"audio\", preferManagedMediaSource)) {\n            CODEC_COMPATIBLE_NAMES[lowerCaseCodec] = codecsToCheck[i];\n            return codecsToCheck[i];\n        }\n    }\n    return lowerCaseCodec;\n}\nconst AUDIO_CODEC_REGEXP = /flac|opus/i;\nfunction getCodecCompatibleName(codec, preferManagedMediaSource = true) {\n    return codec.replace(AUDIO_CODEC_REGEXP, (m)=>getCodecCompatibleNameLower(m.toLowerCase(), preferManagedMediaSource));\n}\nfunction pickMostCompleteCodecName(parsedCodec, levelCodec) {\n    // Parsing of mp4a codecs strings in mp4-tools from media is incomplete as of d8c6c7a\n    // so use level codec is parsed codec is unavailable or incomplete\n    if (parsedCodec && parsedCodec !== \"mp4a\") {\n        return parsedCodec;\n    }\n    return levelCodec;\n}\nfunction convertAVC1ToAVCOTI(codec) {\n    // Convert avc1 codec string from RFC-4281 to RFC-6381 for MediaSource.isTypeSupported\n    const avcdata = codec.split(\".\");\n    if (avcdata.length > 2) {\n        let result = avcdata.shift() + \".\";\n        result += parseInt(avcdata.shift()).toString(16);\n        result += (\"000\" + parseInt(avcdata.shift()).toString(16)).slice(-4);\n        return result;\n    }\n    return codec;\n}\nconst MASTER_PLAYLIST_REGEX = /#EXT-X-STREAM-INF:([^\\r\\n]*)(?:[\\r\\n](?:#[^\\r\\n]*)?)*([^\\r\\n]+)|#EXT-X-(SESSION-DATA|SESSION-KEY|DEFINE|CONTENT-STEERING|START):([^\\r\\n]*)[\\r\\n]+/g;\nconst MASTER_PLAYLIST_MEDIA_REGEX = /#EXT-X-MEDIA:(.*)/g;\nconst IS_MEDIA_PLAYLIST = /^#EXT(?:INF|-X-TARGETDURATION):/m; // Handle empty Media Playlist (first EXTINF not signaled, but TARGETDURATION present)\nconst LEVEL_PLAYLIST_REGEX_FAST = new RegExp([\n    /#EXTINF:\\s*(\\d*(?:\\.\\d+)?)(?:,(.*)\\s+)?/.source,\n    // duration (#EXTINF:<duration>,<title>), group 1 => duration, group 2 => title\n    /(?!#) *(\\S[\\S ]*)/.source,\n    // segment URI, group 3 => the URI (note newline is not eaten)\n    /#EXT-X-BYTERANGE:*(.+)/.source,\n    // next segment's byterange, group 4 => range spec (x@y)\n    /#EXT-X-PROGRAM-DATE-TIME:(.+)/.source,\n    // next segment's program date/time group 5 => the datetime spec\n    /#.*/.source // All other non-segment oriented tags will match with all groups empty\n].join(\"|\"), \"g\");\nconst LEVEL_PLAYLIST_REGEX_SLOW = new RegExp([\n    /#(EXTM3U)/.source,\n    /#EXT-X-(DATERANGE|DEFINE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source,\n    /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\\d+)/.source,\n    /#EXT-X-(DISCONTINUITY|ENDLIST|GAP|INDEPENDENT-SEGMENTS)/.source,\n    /(#)([^:]*):(.*)/.source,\n    /(#)(.*)(?:.*)\\r?\\n?/.source\n].join(\"|\"));\nclass M3U8Parser {\n    static findGroup(groups, mediaGroupId) {\n        for(let i = 0; i < groups.length; i++){\n            const group = groups[i];\n            if (group.id === mediaGroupId) {\n                return group;\n            }\n        }\n    }\n    static resolve(url, baseUrl) {\n        return urlToolkitExports.buildAbsoluteURL(baseUrl, url, {\n            alwaysNormalize: true\n        });\n    }\n    static isMediaPlaylist(str) {\n        return IS_MEDIA_PLAYLIST.test(str);\n    }\n    static parseMasterPlaylist(string, baseurl) {\n        const hasVariableRefs = hasVariableReferences(string);\n        const parsed = {\n            contentSteering: null,\n            levels: [],\n            playlistParsingError: null,\n            sessionData: null,\n            sessionKeys: null,\n            startTimeOffset: null,\n            variableList: null,\n            hasVariableRefs\n        };\n        const levelsWithKnownCodecs = [];\n        MASTER_PLAYLIST_REGEX.lastIndex = 0;\n        let result;\n        while((result = MASTER_PLAYLIST_REGEX.exec(string)) != null){\n            if (result[1]) {\n                var _level$unknownCodecs;\n                // '#EXT-X-STREAM-INF' is found, parse level tag  in group 1\n                const attrs = new AttrList(result[1]);\n                {\n                    substituteVariablesInAttributes(parsed, attrs, [\n                        \"CODECS\",\n                        \"SUPPLEMENTAL-CODECS\",\n                        \"ALLOWED-CPC\",\n                        \"PATHWAY-ID\",\n                        \"STABLE-VARIANT-ID\",\n                        \"AUDIO\",\n                        \"VIDEO\",\n                        \"SUBTITLES\",\n                        \"CLOSED-CAPTIONS\",\n                        \"NAME\"\n                    ]);\n                }\n                const uri = substituteVariables(parsed, result[2]);\n                const level = {\n                    attrs,\n                    bitrate: attrs.decimalInteger(\"BANDWIDTH\") || attrs.decimalInteger(\"AVERAGE-BANDWIDTH\"),\n                    name: attrs.NAME,\n                    url: M3U8Parser.resolve(uri, baseurl)\n                };\n                const resolution = attrs.decimalResolution(\"RESOLUTION\");\n                if (resolution) {\n                    level.width = resolution.width;\n                    level.height = resolution.height;\n                }\n                setCodecs(attrs.CODECS, level);\n                if (!((_level$unknownCodecs = level.unknownCodecs) != null && _level$unknownCodecs.length)) {\n                    levelsWithKnownCodecs.push(level);\n                }\n                parsed.levels.push(level);\n            } else if (result[3]) {\n                const tag = result[3];\n                const attributes = result[4];\n                switch(tag){\n                    case \"SESSION-DATA\":\n                        {\n                            // #EXT-X-SESSION-DATA\n                            const sessionAttrs = new AttrList(attributes);\n                            {\n                                substituteVariablesInAttributes(parsed, sessionAttrs, [\n                                    \"DATA-ID\",\n                                    \"LANGUAGE\",\n                                    \"VALUE\",\n                                    \"URI\"\n                                ]);\n                            }\n                            const dataId = sessionAttrs[\"DATA-ID\"];\n                            if (dataId) {\n                                if (parsed.sessionData === null) {\n                                    parsed.sessionData = {};\n                                }\n                                parsed.sessionData[dataId] = sessionAttrs;\n                            }\n                            break;\n                        }\n                    case \"SESSION-KEY\":\n                        {\n                            // #EXT-X-SESSION-KEY\n                            const sessionKey = parseKey(attributes, baseurl, parsed);\n                            if (sessionKey.encrypted && sessionKey.isSupported()) {\n                                if (parsed.sessionKeys === null) {\n                                    parsed.sessionKeys = [];\n                                }\n                                parsed.sessionKeys.push(sessionKey);\n                            } else {\n                                logger.warn(`[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: \"${attributes}\"`);\n                            }\n                            break;\n                        }\n                    case \"DEFINE\":\n                        {\n                            // #EXT-X-DEFINE\n                            {\n                                const variableAttributes = new AttrList(attributes);\n                                substituteVariablesInAttributes(parsed, variableAttributes, [\n                                    \"NAME\",\n                                    \"VALUE\",\n                                    \"QUERYPARAM\"\n                                ]);\n                                addVariableDefinition(parsed, variableAttributes, baseurl);\n                            }\n                            break;\n                        }\n                    case \"CONTENT-STEERING\":\n                        {\n                            // #EXT-X-CONTENT-STEERING\n                            const contentSteeringAttributes = new AttrList(attributes);\n                            {\n                                substituteVariablesInAttributes(parsed, contentSteeringAttributes, [\n                                    \"SERVER-URI\",\n                                    \"PATHWAY-ID\"\n                                ]);\n                            }\n                            parsed.contentSteering = {\n                                uri: M3U8Parser.resolve(contentSteeringAttributes[\"SERVER-URI\"], baseurl),\n                                pathwayId: contentSteeringAttributes[\"PATHWAY-ID\"] || \".\"\n                            };\n                            break;\n                        }\n                    case \"START\":\n                        {\n                            // #EXT-X-START\n                            parsed.startTimeOffset = parseStartTimeOffset(attributes);\n                            break;\n                        }\n                }\n            }\n        }\n        // Filter out levels with unknown codecs if it does not remove all levels\n        const stripUnknownCodecLevels = levelsWithKnownCodecs.length > 0 && levelsWithKnownCodecs.length < parsed.levels.length;\n        parsed.levels = stripUnknownCodecLevels ? levelsWithKnownCodecs : parsed.levels;\n        if (parsed.levels.length === 0) {\n            parsed.playlistParsingError = new Error(\"no levels found in manifest\");\n        }\n        return parsed;\n    }\n    static parseMasterPlaylistMedia(string, baseurl, parsed) {\n        let result;\n        const results = {};\n        const levels = parsed.levels;\n        const groupsByType = {\n            AUDIO: levels.map((level)=>({\n                    id: level.attrs.AUDIO,\n                    audioCodec: level.audioCodec\n                })),\n            SUBTITLES: levels.map((level)=>({\n                    id: level.attrs.SUBTITLES,\n                    textCodec: level.textCodec\n                })),\n            \"CLOSED-CAPTIONS\": []\n        };\n        let id = 0;\n        MASTER_PLAYLIST_MEDIA_REGEX.lastIndex = 0;\n        while((result = MASTER_PLAYLIST_MEDIA_REGEX.exec(string)) !== null){\n            const attrs = new AttrList(result[1]);\n            const type = attrs.TYPE;\n            if (type) {\n                const groups = groupsByType[type];\n                const medias = results[type] || [];\n                results[type] = medias;\n                {\n                    substituteVariablesInAttributes(parsed, attrs, [\n                        \"URI\",\n                        \"GROUP-ID\",\n                        \"LANGUAGE\",\n                        \"ASSOC-LANGUAGE\",\n                        \"STABLE-RENDITION-ID\",\n                        \"NAME\",\n                        \"INSTREAM-ID\",\n                        \"CHARACTERISTICS\",\n                        \"CHANNELS\"\n                    ]);\n                }\n                const lang = attrs.LANGUAGE;\n                const assocLang = attrs[\"ASSOC-LANGUAGE\"];\n                const channels = attrs.CHANNELS;\n                const characteristics = attrs.CHARACTERISTICS;\n                const instreamId = attrs[\"INSTREAM-ID\"];\n                const media = {\n                    attrs,\n                    bitrate: 0,\n                    id: id++,\n                    groupId: attrs[\"GROUP-ID\"] || \"\",\n                    name: attrs.NAME || lang || \"\",\n                    type,\n                    default: attrs.bool(\"DEFAULT\"),\n                    autoselect: attrs.bool(\"AUTOSELECT\"),\n                    forced: attrs.bool(\"FORCED\"),\n                    lang,\n                    url: attrs.URI ? M3U8Parser.resolve(attrs.URI, baseurl) : \"\"\n                };\n                if (assocLang) {\n                    media.assocLang = assocLang;\n                }\n                if (channels) {\n                    media.channels = channels;\n                }\n                if (characteristics) {\n                    media.characteristics = characteristics;\n                }\n                if (instreamId) {\n                    media.instreamId = instreamId;\n                }\n                if (groups != null && groups.length) {\n                    // If there are audio or text groups signalled in the manifest, let's look for a matching codec string for this track\n                    // If we don't find the track signalled, lets use the first audio groups codec we have\n                    // Acting as a best guess\n                    const groupCodec = M3U8Parser.findGroup(groups, media.groupId) || groups[0];\n                    assignCodec(media, groupCodec, \"audioCodec\");\n                    assignCodec(media, groupCodec, \"textCodec\");\n                }\n                medias.push(media);\n            }\n        }\n        return results;\n    }\n    static parseLevelPlaylist(string, baseurl, id, type, levelUrlId, multivariantVariableList) {\n        const level = new LevelDetails(baseurl);\n        const fragments = level.fragments;\n        // The most recent init segment seen (applies to all subsequent segments)\n        let currentInitSegment = null;\n        let currentSN = 0;\n        let currentPart = 0;\n        let totalduration = 0;\n        let discontinuityCounter = 0;\n        let prevFrag = null;\n        let frag = new Fragment(type, baseurl);\n        let result;\n        let i;\n        let levelkeys;\n        let firstPdtIndex = -1;\n        let createNextFrag = false;\n        let nextByteRange = null;\n        LEVEL_PLAYLIST_REGEX_FAST.lastIndex = 0;\n        level.m3u8 = string;\n        level.hasVariableRefs = hasVariableReferences(string);\n        while((result = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) !== null){\n            if (createNextFrag) {\n                createNextFrag = false;\n                frag = new Fragment(type, baseurl);\n                // setup the next fragment for part loading\n                frag.start = totalduration;\n                frag.sn = currentSN;\n                frag.cc = discontinuityCounter;\n                frag.level = id;\n                if (currentInitSegment) {\n                    frag.initSegment = currentInitSegment;\n                    frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;\n                    currentInitSegment.rawProgramDateTime = null;\n                    if (nextByteRange) {\n                        frag.setByteRange(nextByteRange);\n                        nextByteRange = null;\n                    }\n                }\n            }\n            const duration = result[1];\n            if (duration) {\n                // INF\n                frag.duration = parseFloat(duration);\n                // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n                const title = (\" \" + result[2]).slice(1);\n                frag.title = title || null;\n                frag.tagList.push(title ? [\n                    \"INF\",\n                    duration,\n                    title\n                ] : [\n                    \"INF\",\n                    duration\n                ]);\n            } else if (result[3]) {\n                // url\n                if (isFiniteNumber(frag.duration)) {\n                    frag.start = totalduration;\n                    if (levelkeys) {\n                        setFragLevelKeys(frag, levelkeys, level);\n                    }\n                    frag.sn = currentSN;\n                    frag.level = id;\n                    frag.cc = discontinuityCounter;\n                    fragments.push(frag);\n                    // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n                    const uri = (\" \" + result[3]).slice(1);\n                    frag.relurl = substituteVariables(level, uri);\n                    assignProgramDateTime(frag, prevFrag);\n                    prevFrag = frag;\n                    totalduration += frag.duration;\n                    currentSN++;\n                    currentPart = 0;\n                    createNextFrag = true;\n                }\n            } else if (result[4]) {\n                // X-BYTERANGE\n                const data = (\" \" + result[4]).slice(1);\n                if (prevFrag) {\n                    frag.setByteRange(data, prevFrag);\n                } else {\n                    frag.setByteRange(data);\n                }\n            } else if (result[5]) {\n                // PROGRAM-DATE-TIME\n                // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n                frag.rawProgramDateTime = (\" \" + result[5]).slice(1);\n                frag.tagList.push([\n                    \"PROGRAM-DATE-TIME\",\n                    frag.rawProgramDateTime\n                ]);\n                if (firstPdtIndex === -1) {\n                    firstPdtIndex = fragments.length;\n                }\n            } else {\n                result = result[0].match(LEVEL_PLAYLIST_REGEX_SLOW);\n                if (!result) {\n                    logger.warn(\"No matches on slow regex match for level playlist!\");\n                    continue;\n                }\n                for(i = 1; i < result.length; i++){\n                    if (typeof result[i] !== \"undefined\") {\n                        break;\n                    }\n                }\n                // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n                const tag = (\" \" + result[i]).slice(1);\n                const value1 = (\" \" + result[i + 1]).slice(1);\n                const value2 = result[i + 2] ? (\" \" + result[i + 2]).slice(1) : \"\";\n                switch(tag){\n                    case \"PLAYLIST-TYPE\":\n                        level.type = value1.toUpperCase();\n                        break;\n                    case \"MEDIA-SEQUENCE\":\n                        currentSN = level.startSN = parseInt(value1);\n                        break;\n                    case \"SKIP\":\n                        {\n                            const skipAttrs = new AttrList(value1);\n                            {\n                                substituteVariablesInAttributes(level, skipAttrs, [\n                                    \"RECENTLY-REMOVED-DATERANGES\"\n                                ]);\n                            }\n                            const skippedSegments = skipAttrs.decimalInteger(\"SKIPPED-SEGMENTS\");\n                            if (isFiniteNumber(skippedSegments)) {\n                                level.skippedSegments = skippedSegments;\n                                // This will result in fragments[] containing undefined values, which we will fill in with `mergeDetails`\n                                for(let _i = skippedSegments; _i--;){\n                                    fragments.unshift(null);\n                                }\n                                currentSN += skippedSegments;\n                            }\n                            const recentlyRemovedDateranges = skipAttrs.enumeratedString(\"RECENTLY-REMOVED-DATERANGES\");\n                            if (recentlyRemovedDateranges) {\n                                level.recentlyRemovedDateranges = recentlyRemovedDateranges.split(\"\t\");\n                            }\n                            break;\n                        }\n                    case \"TARGETDURATION\":\n                        level.targetduration = Math.max(parseInt(value1), 1);\n                        break;\n                    case \"VERSION\":\n                        level.version = parseInt(value1);\n                        break;\n                    case \"INDEPENDENT-SEGMENTS\":\n                    case \"EXTM3U\":\n                        break;\n                    case \"ENDLIST\":\n                        level.live = false;\n                        break;\n                    case \"#\":\n                        if (value1 || value2) {\n                            frag.tagList.push(value2 ? [\n                                value1,\n                                value2\n                            ] : [\n                                value1\n                            ]);\n                        }\n                        break;\n                    case \"DISCONTINUITY\":\n                        discontinuityCounter++;\n                        frag.tagList.push([\n                            \"DIS\"\n                        ]);\n                        break;\n                    case \"GAP\":\n                        frag.gap = true;\n                        frag.tagList.push([\n                            tag\n                        ]);\n                        break;\n                    case \"BITRATE\":\n                        frag.tagList.push([\n                            tag,\n                            value1\n                        ]);\n                        break;\n                    case \"DATERANGE\":\n                        {\n                            const dateRangeAttr = new AttrList(value1);\n                            {\n                                substituteVariablesInAttributes(level, dateRangeAttr, [\n                                    \"ID\",\n                                    \"CLASS\",\n                                    \"START-DATE\",\n                                    \"END-DATE\",\n                                    \"SCTE35-CMD\",\n                                    \"SCTE35-OUT\",\n                                    \"SCTE35-IN\"\n                                ]);\n                                substituteVariablesInAttributes(level, dateRangeAttr, dateRangeAttr.clientAttrs);\n                            }\n                            const dateRange = new DateRange(dateRangeAttr, level.dateRanges[dateRangeAttr.ID]);\n                            if (dateRange.isValid || level.skippedSegments) {\n                                level.dateRanges[dateRange.id] = dateRange;\n                            } else {\n                                logger.warn(`Ignoring invalid DATERANGE tag: \"${value1}\"`);\n                            }\n                            // Add to fragment tag list for backwards compatibility (< v1.2.0)\n                            frag.tagList.push([\n                                \"EXT-X-DATERANGE\",\n                                value1\n                            ]);\n                            break;\n                        }\n                    case \"DEFINE\":\n                        {\n                            {\n                                const variableAttributes = new AttrList(value1);\n                                substituteVariablesInAttributes(level, variableAttributes, [\n                                    \"NAME\",\n                                    \"VALUE\",\n                                    \"IMPORT\",\n                                    \"QUERYPARAM\"\n                                ]);\n                                if (\"IMPORT\" in variableAttributes) {\n                                    importVariableDefinition(level, variableAttributes, multivariantVariableList);\n                                } else {\n                                    addVariableDefinition(level, variableAttributes, baseurl);\n                                }\n                            }\n                            break;\n                        }\n                    case \"DISCONTINUITY-SEQUENCE\":\n                        discontinuityCounter = parseInt(value1);\n                        break;\n                    case \"KEY\":\n                        {\n                            const levelKey = parseKey(value1, baseurl, level);\n                            if (levelKey.isSupported()) {\n                                if (levelKey.method === \"NONE\") {\n                                    levelkeys = undefined;\n                                    break;\n                                }\n                                if (!levelkeys) {\n                                    levelkeys = {};\n                                }\n                                if (levelkeys[levelKey.keyFormat]) {\n                                    levelkeys = _extends({}, levelkeys);\n                                }\n                                levelkeys[levelKey.keyFormat] = levelKey;\n                            } else {\n                                logger.warn(`[Keys] Ignoring invalid EXT-X-KEY tag: \"${value1}\"`);\n                            }\n                            break;\n                        }\n                    case \"START\":\n                        level.startTimeOffset = parseStartTimeOffset(value1);\n                        break;\n                    case \"MAP\":\n                        {\n                            const mapAttrs = new AttrList(value1);\n                            {\n                                substituteVariablesInAttributes(level, mapAttrs, [\n                                    \"BYTERANGE\",\n                                    \"URI\"\n                                ]);\n                            }\n                            if (frag.duration) {\n                                // Initial segment tag is after segment duration tag.\n                                //   #EXTINF: 6.0\n                                //   #EXT-X-MAP:URI=\"init.mp4\n                                const init = new Fragment(type, baseurl);\n                                setInitSegment(init, mapAttrs, id, levelkeys);\n                                currentInitSegment = init;\n                                frag.initSegment = currentInitSegment;\n                                if (currentInitSegment.rawProgramDateTime && !frag.rawProgramDateTime) {\n                                    frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;\n                                }\n                            } else {\n                                // Initial segment tag is before segment duration tag\n                                // Handle case where EXT-X-MAP is declared after EXT-X-BYTERANGE\n                                const end = frag.byteRangeEndOffset;\n                                if (end) {\n                                    const start = frag.byteRangeStartOffset;\n                                    nextByteRange = `${end - start}@${start}`;\n                                } else {\n                                    nextByteRange = null;\n                                }\n                                setInitSegment(frag, mapAttrs, id, levelkeys);\n                                currentInitSegment = frag;\n                                createNextFrag = true;\n                            }\n                            break;\n                        }\n                    case \"SERVER-CONTROL\":\n                        {\n                            const serverControlAttrs = new AttrList(value1);\n                            level.canBlockReload = serverControlAttrs.bool(\"CAN-BLOCK-RELOAD\");\n                            level.canSkipUntil = serverControlAttrs.optionalFloat(\"CAN-SKIP-UNTIL\", 0);\n                            level.canSkipDateRanges = level.canSkipUntil > 0 && serverControlAttrs.bool(\"CAN-SKIP-DATERANGES\");\n                            level.partHoldBack = serverControlAttrs.optionalFloat(\"PART-HOLD-BACK\", 0);\n                            level.holdBack = serverControlAttrs.optionalFloat(\"HOLD-BACK\", 0);\n                            break;\n                        }\n                    case \"PART-INF\":\n                        {\n                            const partInfAttrs = new AttrList(value1);\n                            level.partTarget = partInfAttrs.decimalFloatingPoint(\"PART-TARGET\");\n                            break;\n                        }\n                    case \"PART\":\n                        {\n                            let partList = level.partList;\n                            if (!partList) {\n                                partList = level.partList = [];\n                            }\n                            const previousFragmentPart = currentPart > 0 ? partList[partList.length - 1] : undefined;\n                            const index = currentPart++;\n                            const partAttrs = new AttrList(value1);\n                            {\n                                substituteVariablesInAttributes(level, partAttrs, [\n                                    \"BYTERANGE\",\n                                    \"URI\"\n                                ]);\n                            }\n                            const part = new Part(partAttrs, frag, baseurl, index, previousFragmentPart);\n                            partList.push(part);\n                            frag.duration += part.duration;\n                            break;\n                        }\n                    case \"PRELOAD-HINT\":\n                        {\n                            const preloadHintAttrs = new AttrList(value1);\n                            {\n                                substituteVariablesInAttributes(level, preloadHintAttrs, [\n                                    \"URI\"\n                                ]);\n                            }\n                            level.preloadHint = preloadHintAttrs;\n                            break;\n                        }\n                    case \"RENDITION-REPORT\":\n                        {\n                            const renditionReportAttrs = new AttrList(value1);\n                            {\n                                substituteVariablesInAttributes(level, renditionReportAttrs, [\n                                    \"URI\"\n                                ]);\n                            }\n                            level.renditionReports = level.renditionReports || [];\n                            level.renditionReports.push(renditionReportAttrs);\n                            break;\n                        }\n                    default:\n                        logger.warn(`line parsed but not handled: ${result}`);\n                        break;\n                }\n            }\n        }\n        if (prevFrag && !prevFrag.relurl) {\n            fragments.pop();\n            totalduration -= prevFrag.duration;\n            if (level.partList) {\n                level.fragmentHint = prevFrag;\n            }\n        } else if (level.partList) {\n            assignProgramDateTime(frag, prevFrag);\n            frag.cc = discontinuityCounter;\n            level.fragmentHint = frag;\n            if (levelkeys) {\n                setFragLevelKeys(frag, levelkeys, level);\n            }\n        }\n        const fragmentLength = fragments.length;\n        const firstFragment = fragments[0];\n        const lastFragment = fragments[fragmentLength - 1];\n        totalduration += level.skippedSegments * level.targetduration;\n        if (totalduration > 0 && fragmentLength && lastFragment) {\n            level.averagetargetduration = totalduration / fragmentLength;\n            const lastSn = lastFragment.sn;\n            level.endSN = lastSn !== \"initSegment\" ? lastSn : 0;\n            if (!level.live) {\n                lastFragment.endList = true;\n            }\n            if (firstFragment) {\n                level.startCC = firstFragment.cc;\n            }\n        } else {\n            level.endSN = 0;\n            level.startCC = 0;\n        }\n        if (level.fragmentHint) {\n            totalduration += level.fragmentHint.duration;\n        }\n        level.totalduration = totalduration;\n        level.endCC = discontinuityCounter;\n        /**\n     * Backfill any missing PDT values\n     * \"If the first EXT-X-PROGRAM-DATE-TIME tag in a Playlist appears after\n     * one or more Media Segment URIs, the client SHOULD extrapolate\n     * backward from that tag (using EXTINF durations and/or media\n     * timestamps) to associate dates with those segments.\"\n     * We have already extrapolated forward, but all fragments up to the first instance of PDT do not have their PDTs\n     * computed.\n     */ if (firstPdtIndex > 0) {\n            backfillProgramDateTimes(fragments, firstPdtIndex);\n        }\n        return level;\n    }\n}\nfunction parseKey(keyTagAttributes, baseurl, parsed) {\n    var _keyAttrs$METHOD, _keyAttrs$KEYFORMAT;\n    // https://tools.ietf.org/html/rfc8216#section-4.3.2.4\n    const keyAttrs = new AttrList(keyTagAttributes);\n    {\n        substituteVariablesInAttributes(parsed, keyAttrs, [\n            \"KEYFORMAT\",\n            \"KEYFORMATVERSIONS\",\n            \"URI\",\n            \"IV\",\n            \"URI\"\n        ]);\n    }\n    const decryptmethod = (_keyAttrs$METHOD = keyAttrs.METHOD) != null ? _keyAttrs$METHOD : \"\";\n    const decrypturi = keyAttrs.URI;\n    const decryptiv = keyAttrs.hexadecimalInteger(\"IV\");\n    const decryptkeyformatversions = keyAttrs.KEYFORMATVERSIONS;\n    // From RFC: This attribute is OPTIONAL; its absence indicates an implicit value of \"identity\".\n    const decryptkeyformat = (_keyAttrs$KEYFORMAT = keyAttrs.KEYFORMAT) != null ? _keyAttrs$KEYFORMAT : \"identity\";\n    if (decrypturi && keyAttrs.IV && !decryptiv) {\n        logger.error(`Invalid IV: ${keyAttrs.IV}`);\n    }\n    // If decrypturi is a URI with a scheme, then baseurl will be ignored\n    // No uri is allowed when METHOD is NONE\n    const resolvedUri = decrypturi ? M3U8Parser.resolve(decrypturi, baseurl) : \"\";\n    const keyFormatVersions = (decryptkeyformatversions ? decryptkeyformatversions : \"1\").split(\"/\").map(Number).filter(Number.isFinite);\n    return new LevelKey(decryptmethod, resolvedUri, decryptkeyformat, keyFormatVersions, decryptiv);\n}\nfunction parseStartTimeOffset(startAttributes) {\n    const startAttrs = new AttrList(startAttributes);\n    const startTimeOffset = startAttrs.decimalFloatingPoint(\"TIME-OFFSET\");\n    if (isFiniteNumber(startTimeOffset)) {\n        return startTimeOffset;\n    }\n    return null;\n}\nfunction setCodecs(codecsAttributeValue, level) {\n    let codecs = (codecsAttributeValue || \"\").split(/[ ,]+/).filter((c)=>c);\n    [\n        \"video\",\n        \"audio\",\n        \"text\"\n    ].forEach((type)=>{\n        const filtered = codecs.filter((codec)=>isCodecType(codec, type));\n        if (filtered.length) {\n            // Comma separated list of all codecs for type\n            level[`${type}Codec`] = filtered.join(\",\");\n            // Remove known codecs so that only unknownCodecs are left after iterating through each type\n            codecs = codecs.filter((codec)=>filtered.indexOf(codec) === -1);\n        }\n    });\n    level.unknownCodecs = codecs;\n}\nfunction assignCodec(media, groupItem, codecProperty) {\n    const codecValue = groupItem[codecProperty];\n    if (codecValue) {\n        media[codecProperty] = codecValue;\n    }\n}\nfunction backfillProgramDateTimes(fragments, firstPdtIndex) {\n    let fragPrev = fragments[firstPdtIndex];\n    for(let i = firstPdtIndex; i--;){\n        const frag = fragments[i];\n        // Exit on delta-playlist skipped segments\n        if (!frag) {\n            return;\n        }\n        frag.programDateTime = fragPrev.programDateTime - frag.duration * 1000;\n        fragPrev = frag;\n    }\n}\nfunction assignProgramDateTime(frag, prevFrag) {\n    if (frag.rawProgramDateTime) {\n        frag.programDateTime = Date.parse(frag.rawProgramDateTime);\n    } else if (prevFrag != null && prevFrag.programDateTime) {\n        frag.programDateTime = prevFrag.endProgramDateTime;\n    }\n    if (!isFiniteNumber(frag.programDateTime)) {\n        frag.programDateTime = null;\n        frag.rawProgramDateTime = null;\n    }\n}\nfunction setInitSegment(frag, mapAttrs, id, levelkeys) {\n    frag.relurl = mapAttrs.URI;\n    if (mapAttrs.BYTERANGE) {\n        frag.setByteRange(mapAttrs.BYTERANGE);\n    }\n    frag.level = id;\n    frag.sn = \"initSegment\";\n    if (levelkeys) {\n        frag.levelkeys = levelkeys;\n    }\n    frag.initSegment = null;\n}\nfunction setFragLevelKeys(frag, levelkeys, level) {\n    frag.levelkeys = levelkeys;\n    const { encryptedFragments } = level;\n    if ((!encryptedFragments.length || encryptedFragments[encryptedFragments.length - 1].levelkeys !== levelkeys) && Object.keys(levelkeys).some((format)=>levelkeys[format].isCommonEncryption)) {\n        encryptedFragments.push(frag);\n    }\n}\nvar PlaylistContextType = {\n    MANIFEST: \"manifest\",\n    LEVEL: \"level\",\n    AUDIO_TRACK: \"audioTrack\",\n    SUBTITLE_TRACK: \"subtitleTrack\"\n};\nvar PlaylistLevelType = {\n    MAIN: \"main\",\n    AUDIO: \"audio\",\n    SUBTITLE: \"subtitle\"\n};\nfunction mapContextToLevelType(context) {\n    const { type } = context;\n    switch(type){\n        case PlaylistContextType.AUDIO_TRACK:\n            return PlaylistLevelType.AUDIO;\n        case PlaylistContextType.SUBTITLE_TRACK:\n            return PlaylistLevelType.SUBTITLE;\n        default:\n            return PlaylistLevelType.MAIN;\n    }\n}\nfunction getResponseUrl(response, context) {\n    let url = response.url;\n    // responseURL not supported on some browsers (it is used to detect URL redirection)\n    // data-uri mode also not supported (but no need to detect redirection)\n    if (url === undefined || url.indexOf(\"data:\") === 0) {\n        // fallback to initial URL\n        url = context.url;\n    }\n    return url;\n}\nclass PlaylistLoader {\n    constructor(hls){\n        this.hls = void 0;\n        this.loaders = Object.create(null);\n        this.variableList = null;\n        this.hls = hls;\n        this.registerListeners();\n    }\n    startLoad(startPosition) {}\n    stopLoad() {\n        this.destroyInternalLoaders();\n    }\n    registerListeners() {\n        const { hls } = this;\n        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);\n        hls.on(Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);\n        hls.on(Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);\n    }\n    unregisterListeners() {\n        const { hls } = this;\n        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);\n        hls.off(Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);\n        hls.off(Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);\n    }\n    /**\n   * Returns defaults or configured loader-type overloads (pLoader and loader config params)\n   */ createInternalLoader(context) {\n        const config = this.hls.config;\n        const PLoader = config.pLoader;\n        const Loader = config.loader;\n        const InternalLoader = PLoader || Loader;\n        const loader = new InternalLoader(config);\n        this.loaders[context.type] = loader;\n        return loader;\n    }\n    getInternalLoader(context) {\n        return this.loaders[context.type];\n    }\n    resetInternalLoader(contextType) {\n        if (this.loaders[contextType]) {\n            delete this.loaders[contextType];\n        }\n    }\n    /**\n   * Call `destroy` on all internal loader instances mapped (one per context type)\n   */ destroyInternalLoaders() {\n        for(const contextType in this.loaders){\n            const loader = this.loaders[contextType];\n            if (loader) {\n                loader.destroy();\n            }\n            this.resetInternalLoader(contextType);\n        }\n    }\n    destroy() {\n        this.variableList = null;\n        this.unregisterListeners();\n        this.destroyInternalLoaders();\n    }\n    onManifestLoading(event, data) {\n        const { url } = data;\n        this.variableList = null;\n        this.load({\n            id: null,\n            level: 0,\n            responseType: \"text\",\n            type: PlaylistContextType.MANIFEST,\n            url,\n            deliveryDirectives: null\n        });\n    }\n    onLevelLoading(event, data) {\n        const { id, level, pathwayId, url, deliveryDirectives } = data;\n        this.load({\n            id,\n            level,\n            pathwayId,\n            responseType: \"text\",\n            type: PlaylistContextType.LEVEL,\n            url,\n            deliveryDirectives\n        });\n    }\n    onAudioTrackLoading(event, data) {\n        const { id, groupId, url, deliveryDirectives } = data;\n        this.load({\n            id,\n            groupId,\n            level: null,\n            responseType: \"text\",\n            type: PlaylistContextType.AUDIO_TRACK,\n            url,\n            deliveryDirectives\n        });\n    }\n    onSubtitleTrackLoading(event, data) {\n        const { id, groupId, url, deliveryDirectives } = data;\n        this.load({\n            id,\n            groupId,\n            level: null,\n            responseType: \"text\",\n            type: PlaylistContextType.SUBTITLE_TRACK,\n            url,\n            deliveryDirectives\n        });\n    }\n    load(context) {\n        var _context$deliveryDire;\n        const config = this.hls.config;\n        // logger.debug(`[playlist-loader]: Loading playlist of type ${context.type}, level: ${context.level}, id: ${context.id}`);\n        // Check if a loader for this context already exists\n        let loader = this.getInternalLoader(context);\n        if (loader) {\n            const loaderContext = loader.context;\n            if (loaderContext && loaderContext.url === context.url && loaderContext.level === context.level) {\n                // same URL can't overlap\n                logger.trace(\"[playlist-loader]: playlist request ongoing\");\n                return;\n            }\n            logger.log(`[playlist-loader]: aborting previous loader for type: ${context.type}`);\n            loader.abort();\n        }\n        // apply different configs for retries depending on\n        // context (manifest, level, audio/subs playlist)\n        let loadPolicy;\n        if (context.type === PlaylistContextType.MANIFEST) {\n            loadPolicy = config.manifestLoadPolicy.default;\n        } else {\n            loadPolicy = _extends({}, config.playlistLoadPolicy.default, {\n                timeoutRetry: null,\n                errorRetry: null\n            });\n        }\n        loader = this.createInternalLoader(context);\n        // Override level/track timeout for LL-HLS requests\n        // (the default of 10000ms is counter productive to blocking playlist reload requests)\n        if (isFiniteNumber((_context$deliveryDire = context.deliveryDirectives) == null ? void 0 : _context$deliveryDire.part)) {\n            let levelDetails;\n            if (context.type === PlaylistContextType.LEVEL && context.level !== null) {\n                levelDetails = this.hls.levels[context.level].details;\n            } else if (context.type === PlaylistContextType.AUDIO_TRACK && context.id !== null) {\n                levelDetails = this.hls.audioTracks[context.id].details;\n            } else if (context.type === PlaylistContextType.SUBTITLE_TRACK && context.id !== null) {\n                levelDetails = this.hls.subtitleTracks[context.id].details;\n            }\n            if (levelDetails) {\n                const partTarget = levelDetails.partTarget;\n                const targetDuration = levelDetails.targetduration;\n                if (partTarget && targetDuration) {\n                    const maxLowLatencyPlaylistRefresh = Math.max(partTarget * 3, targetDuration * 0.8) * 1000;\n                    loadPolicy = _extends({}, loadPolicy, {\n                        maxTimeToFirstByteMs: Math.min(maxLowLatencyPlaylistRefresh, loadPolicy.maxTimeToFirstByteMs),\n                        maxLoadTimeMs: Math.min(maxLowLatencyPlaylistRefresh, loadPolicy.maxTimeToFirstByteMs)\n                    });\n                }\n            }\n        }\n        const legacyRetryCompatibility = loadPolicy.errorRetry || loadPolicy.timeoutRetry || {};\n        const loaderConfig = {\n            loadPolicy,\n            timeout: loadPolicy.maxLoadTimeMs,\n            maxRetry: legacyRetryCompatibility.maxNumRetry || 0,\n            retryDelay: legacyRetryCompatibility.retryDelayMs || 0,\n            maxRetryDelay: legacyRetryCompatibility.maxRetryDelayMs || 0\n        };\n        const loaderCallbacks = {\n            onSuccess: (response, stats, context, networkDetails)=>{\n                const loader = this.getInternalLoader(context);\n                this.resetInternalLoader(context.type);\n                const string = response.data;\n                // Validate if it is an M3U8 at all\n                if (string.indexOf(\"#EXTM3U\") !== 0) {\n                    this.handleManifestParsingError(response, context, new Error(\"no EXTM3U delimiter\"), networkDetails || null, stats);\n                    return;\n                }\n                stats.parsing.start = performance.now();\n                if (M3U8Parser.isMediaPlaylist(string)) {\n                    this.handleTrackOrLevelPlaylist(response, stats, context, networkDetails || null, loader);\n                } else {\n                    this.handleMasterPlaylist(response, stats, context, networkDetails);\n                }\n            },\n            onError: (response, context, networkDetails, stats)=>{\n                this.handleNetworkError(context, networkDetails, false, response, stats);\n            },\n            onTimeout: (stats, context, networkDetails)=>{\n                this.handleNetworkError(context, networkDetails, true, undefined, stats);\n            }\n        };\n        // logger.debug(`[playlist-loader]: Calling internal loader delegate for URL: ${context.url}`);\n        loader.load(context, loaderConfig, loaderCallbacks);\n    }\n    handleMasterPlaylist(response, stats, context, networkDetails) {\n        const hls = this.hls;\n        const string = response.data;\n        const url = getResponseUrl(response, context);\n        const parsedResult = M3U8Parser.parseMasterPlaylist(string, url);\n        if (parsedResult.playlistParsingError) {\n            this.handleManifestParsingError(response, context, parsedResult.playlistParsingError, networkDetails, stats);\n            return;\n        }\n        const { contentSteering, levels, sessionData, sessionKeys, startTimeOffset, variableList } = parsedResult;\n        this.variableList = variableList;\n        const { AUDIO: audioTracks = [], SUBTITLES: subtitles, \"CLOSED-CAPTIONS\": captions } = M3U8Parser.parseMasterPlaylistMedia(string, url, parsedResult);\n        if (audioTracks.length) {\n            // check if we have found an audio track embedded in main playlist (audio track without URI attribute)\n            const embeddedAudioFound = audioTracks.some((audioTrack)=>!audioTrack.url);\n            // if no embedded audio track defined, but audio codec signaled in quality level,\n            // we need to signal this main audio track this could happen with playlists with\n            // alt audio rendition in which quality levels (main)\n            // contains both audio+video. but with mixed audio track not signaled\n            if (!embeddedAudioFound && levels[0].audioCodec && !levels[0].attrs.AUDIO) {\n                logger.log(\"[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one\");\n                audioTracks.unshift({\n                    type: \"main\",\n                    name: \"main\",\n                    groupId: \"main\",\n                    default: false,\n                    autoselect: false,\n                    forced: false,\n                    id: -1,\n                    attrs: new AttrList({}),\n                    bitrate: 0,\n                    url: \"\"\n                });\n            }\n        }\n        hls.trigger(Events.MANIFEST_LOADED, {\n            levels,\n            audioTracks,\n            subtitles,\n            captions,\n            contentSteering,\n            url,\n            stats,\n            networkDetails,\n            sessionData,\n            sessionKeys,\n            startTimeOffset,\n            variableList\n        });\n    }\n    handleTrackOrLevelPlaylist(response, stats, context, networkDetails, loader) {\n        const hls = this.hls;\n        const { id, level, type } = context;\n        const url = getResponseUrl(response, context);\n        const levelUrlId = 0;\n        const levelId = isFiniteNumber(level) ? level : isFiniteNumber(id) ? id : 0;\n        const levelType = mapContextToLevelType(context);\n        const levelDetails = M3U8Parser.parseLevelPlaylist(response.data, url, levelId, levelType, levelUrlId, this.variableList);\n        // We have done our first request (Manifest-type) and receive\n        // not a master playlist but a chunk-list (track/level)\n        // We fire the manifest-loaded event anyway with the parsed level-details\n        // by creating a single-level structure for it.\n        if (type === PlaylistContextType.MANIFEST) {\n            const singleLevel = {\n                attrs: new AttrList({}),\n                bitrate: 0,\n                details: levelDetails,\n                name: \"\",\n                url\n            };\n            hls.trigger(Events.MANIFEST_LOADED, {\n                levels: [\n                    singleLevel\n                ],\n                audioTracks: [],\n                url,\n                stats,\n                networkDetails,\n                sessionData: null,\n                sessionKeys: null,\n                contentSteering: null,\n                startTimeOffset: null,\n                variableList: null\n            });\n        }\n        // save parsing time\n        stats.parsing.end = performance.now();\n        // extend the context with the new levelDetails property\n        context.levelDetails = levelDetails;\n        this.handlePlaylistLoaded(levelDetails, response, stats, context, networkDetails, loader);\n    }\n    handleManifestParsingError(response, context, error, networkDetails, stats) {\n        this.hls.trigger(Events.ERROR, {\n            type: ErrorTypes.NETWORK_ERROR,\n            details: ErrorDetails.MANIFEST_PARSING_ERROR,\n            fatal: context.type === PlaylistContextType.MANIFEST,\n            url: response.url,\n            err: error,\n            error,\n            reason: error.message,\n            response,\n            context,\n            networkDetails,\n            stats\n        });\n    }\n    handleNetworkError(context, networkDetails, timeout = false, response, stats) {\n        let message = `A network ${timeout ? \"timeout\" : \"error\" + (response ? \" (status \" + response.code + \")\" : \"\")} occurred while loading ${context.type}`;\n        if (context.type === PlaylistContextType.LEVEL) {\n            message += `: ${context.level} id: ${context.id}`;\n        } else if (context.type === PlaylistContextType.AUDIO_TRACK || context.type === PlaylistContextType.SUBTITLE_TRACK) {\n            message += ` id: ${context.id} group-id: \"${context.groupId}\"`;\n        }\n        const error = new Error(message);\n        logger.warn(`[playlist-loader]: ${message}`);\n        let details = ErrorDetails.UNKNOWN;\n        let fatal = false;\n        const loader = this.getInternalLoader(context);\n        switch(context.type){\n            case PlaylistContextType.MANIFEST:\n                details = timeout ? ErrorDetails.MANIFEST_LOAD_TIMEOUT : ErrorDetails.MANIFEST_LOAD_ERROR;\n                fatal = true;\n                break;\n            case PlaylistContextType.LEVEL:\n                details = timeout ? ErrorDetails.LEVEL_LOAD_TIMEOUT : ErrorDetails.LEVEL_LOAD_ERROR;\n                fatal = false;\n                break;\n            case PlaylistContextType.AUDIO_TRACK:\n                details = timeout ? ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT : ErrorDetails.AUDIO_TRACK_LOAD_ERROR;\n                fatal = false;\n                break;\n            case PlaylistContextType.SUBTITLE_TRACK:\n                details = timeout ? ErrorDetails.SUBTITLE_TRACK_LOAD_TIMEOUT : ErrorDetails.SUBTITLE_LOAD_ERROR;\n                fatal = false;\n                break;\n        }\n        if (loader) {\n            this.resetInternalLoader(context.type);\n        }\n        const errorData = {\n            type: ErrorTypes.NETWORK_ERROR,\n            details,\n            fatal,\n            url: context.url,\n            loader,\n            context,\n            error,\n            networkDetails,\n            stats\n        };\n        if (response) {\n            const url = (networkDetails == null ? void 0 : networkDetails.url) || context.url;\n            errorData.response = _objectSpread2({\n                url,\n                data: undefined\n            }, response);\n        }\n        this.hls.trigger(Events.ERROR, errorData);\n    }\n    handlePlaylistLoaded(levelDetails, response, stats, context, networkDetails, loader) {\n        const hls = this.hls;\n        const { type, level, id, groupId, deliveryDirectives } = context;\n        const url = getResponseUrl(response, context);\n        const parent = mapContextToLevelType(context);\n        const levelIndex = typeof context.level === \"number\" && parent === PlaylistLevelType.MAIN ? level : undefined;\n        if (!levelDetails.fragments.length) {\n            const _error = new Error(\"No Segments found in Playlist\");\n            hls.trigger(Events.ERROR, {\n                type: ErrorTypes.NETWORK_ERROR,\n                details: ErrorDetails.LEVEL_EMPTY_ERROR,\n                fatal: false,\n                url,\n                error: _error,\n                reason: _error.message,\n                response,\n                context,\n                level: levelIndex,\n                parent,\n                networkDetails,\n                stats\n            });\n            return;\n        }\n        if (!levelDetails.targetduration) {\n            levelDetails.playlistParsingError = new Error(\"Missing Target Duration\");\n        }\n        const error = levelDetails.playlistParsingError;\n        if (error) {\n            hls.trigger(Events.ERROR, {\n                type: ErrorTypes.NETWORK_ERROR,\n                details: ErrorDetails.LEVEL_PARSING_ERROR,\n                fatal: false,\n                url,\n                error,\n                reason: error.message,\n                response,\n                context,\n                level: levelIndex,\n                parent,\n                networkDetails,\n                stats\n            });\n            return;\n        }\n        if (levelDetails.live && loader) {\n            if (loader.getCacheAge) {\n                levelDetails.ageHeader = loader.getCacheAge() || 0;\n            }\n            if (!loader.getCacheAge || isNaN(levelDetails.ageHeader)) {\n                levelDetails.ageHeader = 0;\n            }\n        }\n        switch(type){\n            case PlaylistContextType.MANIFEST:\n            case PlaylistContextType.LEVEL:\n                hls.trigger(Events.LEVEL_LOADED, {\n                    details: levelDetails,\n                    level: levelIndex || 0,\n                    id: id || 0,\n                    stats,\n                    networkDetails,\n                    deliveryDirectives\n                });\n                break;\n            case PlaylistContextType.AUDIO_TRACK:\n                hls.trigger(Events.AUDIO_TRACK_LOADED, {\n                    details: levelDetails,\n                    id: id || 0,\n                    groupId: groupId || \"\",\n                    stats,\n                    networkDetails,\n                    deliveryDirectives\n                });\n                break;\n            case PlaylistContextType.SUBTITLE_TRACK:\n                hls.trigger(Events.SUBTITLE_TRACK_LOADED, {\n                    details: levelDetails,\n                    id: id || 0,\n                    groupId: groupId || \"\",\n                    stats,\n                    networkDetails,\n                    deliveryDirectives\n                });\n                break;\n        }\n    }\n}\nfunction sendAddTrackEvent(track, videoEl) {\n    let event;\n    try {\n        event = new Event(\"addtrack\");\n    } catch (err) {\n        // for IE11\n        event = document.createEvent(\"Event\");\n        event.initEvent(\"addtrack\", false, false);\n    }\n    event.track = track;\n    videoEl.dispatchEvent(event);\n}\nfunction addCueToTrack(track, cue) {\n    // Sometimes there are cue overlaps on segmented vtts so the same\n    // cue can appear more than once in different vtt files.\n    // This avoid showing duplicated cues with same timecode and text.\n    const mode = track.mode;\n    if (mode === \"disabled\") {\n        track.mode = \"hidden\";\n    }\n    if (track.cues && !track.cues.getCueById(cue.id)) {\n        try {\n            track.addCue(cue);\n            if (!track.cues.getCueById(cue.id)) {\n                throw new Error(`addCue is failed for: ${cue}`);\n            }\n        } catch (err) {\n            logger.debug(`[texttrack-utils]: ${err}`);\n            try {\n                const textTrackCue = new self.TextTrackCue(cue.startTime, cue.endTime, cue.text);\n                textTrackCue.id = cue.id;\n                track.addCue(textTrackCue);\n            } catch (err2) {\n                logger.debug(`[texttrack-utils]: Legacy TextTrackCue fallback failed: ${err2}`);\n            }\n        }\n    }\n    if (mode === \"disabled\") {\n        track.mode = mode;\n    }\n}\nfunction clearCurrentCues(track) {\n    // When track.mode is disabled, track.cues will be null.\n    // To guarantee the removal of cues, we need to temporarily\n    // change the mode to hidden\n    const mode = track.mode;\n    if (mode === \"disabled\") {\n        track.mode = \"hidden\";\n    }\n    if (track.cues) {\n        for(let i = track.cues.length; i--;){\n            track.removeCue(track.cues[i]);\n        }\n    }\n    if (mode === \"disabled\") {\n        track.mode = mode;\n    }\n}\nfunction removeCuesInRange(track, start, end, predicate) {\n    const mode = track.mode;\n    if (mode === \"disabled\") {\n        track.mode = \"hidden\";\n    }\n    if (track.cues && track.cues.length > 0) {\n        const cues = getCuesInRange(track.cues, start, end);\n        for(let i = 0; i < cues.length; i++){\n            if (!predicate || predicate(cues[i])) {\n                track.removeCue(cues[i]);\n            }\n        }\n    }\n    if (mode === \"disabled\") {\n        track.mode = mode;\n    }\n}\n// Find first cue starting after given time.\n// Modified version of binary search O(log(n)).\nfunction getFirstCueIndexAfterTime(cues, time) {\n    // If first cue starts after time, start there\n    if (time < cues[0].startTime) {\n        return 0;\n    }\n    // If the last cue ends before time there is no overlap\n    const len = cues.length - 1;\n    if (time > cues[len].endTime) {\n        return -1;\n    }\n    let left = 0;\n    let right = len;\n    while(left <= right){\n        const mid = Math.floor((right + left) / 2);\n        if (time < cues[mid].startTime) {\n            right = mid - 1;\n        } else if (time > cues[mid].startTime && left < len) {\n            left = mid + 1;\n        } else {\n            // If it's not lower or higher, it must be equal.\n            return mid;\n        }\n    }\n    // At this point, left and right have swapped.\n    // No direct match was found, left or right element must be the closest. Check which one has the smallest diff.\n    return cues[left].startTime - time < time - cues[right].startTime ? left : right;\n}\nfunction getCuesInRange(cues, start, end) {\n    const cuesFound = [];\n    const firstCueInRange = getFirstCueIndexAfterTime(cues, start);\n    if (firstCueInRange > -1) {\n        for(let i = firstCueInRange, len = cues.length; i < len; i++){\n            const cue = cues[i];\n            if (cue.startTime >= start && cue.endTime <= end) {\n                cuesFound.push(cue);\n            } else if (cue.startTime > end) {\n                return cuesFound;\n            }\n        }\n    }\n    return cuesFound;\n}\nfunction filterSubtitleTracks(textTrackList) {\n    const tracks = [];\n    for(let i = 0; i < textTrackList.length; i++){\n        const track = textTrackList[i];\n        // Edge adds a track without a label; we don't want to use it\n        if ((track.kind === \"subtitles\" || track.kind === \"captions\") && track.label) {\n            tracks.push(textTrackList[i]);\n        }\n    }\n    return tracks;\n}\nvar MetadataSchema = {\n    audioId3: \"org.id3\",\n    dateRange: \"com.apple.quicktime.HLS\",\n    emsg: \"https://aomedia.org/emsg/ID3\"\n};\nconst MIN_CUE_DURATION = 0.25;\nfunction getCueClass() {\n    if (typeof self === \"undefined\") return undefined;\n    return self.VTTCue || self.TextTrackCue;\n}\nfunction createCueWithDataFields(Cue, startTime, endTime, data, type) {\n    let cue = new Cue(startTime, endTime, \"\");\n    try {\n        cue.value = data;\n        if (type) {\n            cue.type = type;\n        }\n    } catch (e) {\n        cue = new Cue(startTime, endTime, JSON.stringify(type ? _objectSpread2({\n            type\n        }, data) : data));\n    }\n    return cue;\n}\n// VTTCue latest draft allows an infinite duration, fallback\n// to MAX_VALUE if necessary\nconst MAX_CUE_ENDTIME = (()=>{\n    const Cue = getCueClass();\n    try {\n        Cue && new Cue(0, Number.POSITIVE_INFINITY, \"\");\n    } catch (e) {\n        return Number.MAX_VALUE;\n    }\n    return Number.POSITIVE_INFINITY;\n})();\nfunction dateRangeDateToTimelineSeconds(date, offset) {\n    return date.getTime() / 1000 - offset;\n}\nfunction hexToArrayBuffer(str) {\n    return Uint8Array.from(str.replace(/^0x/, \"\").replace(/([\\da-fA-F]{2}) ?/g, \"0x$1 \").replace(/ +$/, \"\").split(\" \")).buffer;\n}\nclass ID3TrackController {\n    constructor(hls){\n        this.hls = void 0;\n        this.id3Track = null;\n        this.media = null;\n        this.dateRangeCuesAppended = {};\n        this.hls = hls;\n        this._registerListeners();\n    }\n    destroy() {\n        this._unregisterListeners();\n        this.id3Track = null;\n        this.media = null;\n        this.dateRangeCuesAppended = {};\n        // @ts-ignore\n        this.hls = null;\n    }\n    _registerListeners() {\n        const { hls } = this;\n        hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.on(Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);\n        hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n        hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n    }\n    _unregisterListeners() {\n        const { hls } = this;\n        hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.off(Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);\n        hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n        hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n    }\n    // Add ID3 metatadata text track.\n    onMediaAttached(event, data) {\n        this.media = data.media;\n    }\n    onMediaDetaching() {\n        if (!this.id3Track) {\n            return;\n        }\n        clearCurrentCues(this.id3Track);\n        this.id3Track = null;\n        this.media = null;\n        this.dateRangeCuesAppended = {};\n    }\n    onManifestLoading() {\n        this.dateRangeCuesAppended = {};\n    }\n    createTrack(media) {\n        const track = this.getID3Track(media.textTracks);\n        track.mode = \"hidden\";\n        return track;\n    }\n    getID3Track(textTracks) {\n        if (!this.media) {\n            return;\n        }\n        for(let i = 0; i < textTracks.length; i++){\n            const textTrack = textTracks[i];\n            if (textTrack.kind === \"metadata\" && textTrack.label === \"id3\") {\n                // send 'addtrack' when reusing the textTrack for metadata,\n                // same as what we do for captions\n                sendAddTrackEvent(textTrack, this.media);\n                return textTrack;\n            }\n        }\n        return this.media.addTextTrack(\"metadata\", \"id3\");\n    }\n    onFragParsingMetadata(event, data) {\n        if (!this.media) {\n            return;\n        }\n        const { hls: { config: { enableEmsgMetadataCues, enableID3MetadataCues } } } = this;\n        if (!enableEmsgMetadataCues && !enableID3MetadataCues) {\n            return;\n        }\n        const { samples } = data;\n        // create track dynamically\n        if (!this.id3Track) {\n            this.id3Track = this.createTrack(this.media);\n        }\n        const Cue = getCueClass();\n        if (!Cue) {\n            return;\n        }\n        for(let i = 0; i < samples.length; i++){\n            const type = samples[i].type;\n            if (type === MetadataSchema.emsg && !enableEmsgMetadataCues || !enableID3MetadataCues) {\n                continue;\n            }\n            const frames = getID3Frames(samples[i].data);\n            if (frames) {\n                const startTime = samples[i].pts;\n                let endTime = startTime + samples[i].duration;\n                if (endTime > MAX_CUE_ENDTIME) {\n                    endTime = MAX_CUE_ENDTIME;\n                }\n                const timeDiff = endTime - startTime;\n                if (timeDiff <= 0) {\n                    endTime = startTime + MIN_CUE_DURATION;\n                }\n                for(let j = 0; j < frames.length; j++){\n                    const frame = frames[j];\n                    // Safari doesn't put the timestamp frame in the TextTrack\n                    if (!isTimeStampFrame(frame)) {\n                        // add a bounds to any unbounded cues\n                        this.updateId3CueEnds(startTime, type);\n                        const cue = createCueWithDataFields(Cue, startTime, endTime, frame, type);\n                        if (cue) {\n                            this.id3Track.addCue(cue);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    updateId3CueEnds(startTime, type) {\n        var _this$id3Track;\n        const cues = (_this$id3Track = this.id3Track) == null ? void 0 : _this$id3Track.cues;\n        if (cues) {\n            for(let i = cues.length; i--;){\n                const cue = cues[i];\n                if (cue.type === type && cue.startTime < startTime && cue.endTime === MAX_CUE_ENDTIME) {\n                    cue.endTime = startTime;\n                }\n            }\n        }\n    }\n    onBufferFlushing(event, { startOffset, endOffset, type }) {\n        const { id3Track, hls } = this;\n        if (!hls) {\n            return;\n        }\n        const { config: { enableEmsgMetadataCues, enableID3MetadataCues } } = hls;\n        if (id3Track && (enableEmsgMetadataCues || enableID3MetadataCues)) {\n            let predicate;\n            if (type === \"audio\") {\n                predicate = (cue)=>cue.type === MetadataSchema.audioId3 && enableID3MetadataCues;\n            } else if (type === \"video\") {\n                predicate = (cue)=>cue.type === MetadataSchema.emsg && enableEmsgMetadataCues;\n            } else {\n                predicate = (cue)=>cue.type === MetadataSchema.audioId3 && enableID3MetadataCues || cue.type === MetadataSchema.emsg && enableEmsgMetadataCues;\n            }\n            removeCuesInRange(id3Track, startOffset, endOffset, predicate);\n        }\n    }\n    onLevelUpdated(event, { details }) {\n        if (!this.media || !details.hasProgramDateTime || !this.hls.config.enableDateRangeMetadataCues) {\n            return;\n        }\n        const { dateRangeCuesAppended, id3Track } = this;\n        const { dateRanges } = details;\n        const ids = Object.keys(dateRanges);\n        // Remove cues from track not found in details.dateRanges\n        if (id3Track) {\n            const idsToRemove = Object.keys(dateRangeCuesAppended).filter((id)=>!ids.includes(id));\n            for(let i = idsToRemove.length; i--;){\n                const id = idsToRemove[i];\n                Object.keys(dateRangeCuesAppended[id].cues).forEach((key)=>{\n                    id3Track.removeCue(dateRangeCuesAppended[id].cues[key]);\n                });\n                delete dateRangeCuesAppended[id];\n            }\n        }\n        // Exit if the playlist does not have Date Ranges or does not have Program Date Time\n        const lastFragment = details.fragments[details.fragments.length - 1];\n        if (ids.length === 0 || !isFiniteNumber(lastFragment == null ? void 0 : lastFragment.programDateTime)) {\n            return;\n        }\n        if (!this.id3Track) {\n            this.id3Track = this.createTrack(this.media);\n        }\n        const dateTimeOffset = lastFragment.programDateTime / 1000 - lastFragment.start;\n        const Cue = getCueClass();\n        for(let i = 0; i < ids.length; i++){\n            const id = ids[i];\n            const dateRange = dateRanges[id];\n            const startTime = dateRangeDateToTimelineSeconds(dateRange.startDate, dateTimeOffset);\n            // Process DateRanges to determine end-time (known DURATION, END-DATE, or END-ON-NEXT)\n            const appendedDateRangeCues = dateRangeCuesAppended[id];\n            const cues = (appendedDateRangeCues == null ? void 0 : appendedDateRangeCues.cues) || {};\n            let durationKnown = (appendedDateRangeCues == null ? void 0 : appendedDateRangeCues.durationKnown) || false;\n            let endTime = MAX_CUE_ENDTIME;\n            const endDate = dateRange.endDate;\n            if (endDate) {\n                endTime = dateRangeDateToTimelineSeconds(endDate, dateTimeOffset);\n                durationKnown = true;\n            } else if (dateRange.endOnNext && !durationKnown) {\n                const nextDateRangeWithSameClass = ids.reduce((candidateDateRange, id)=>{\n                    if (id !== dateRange.id) {\n                        const otherDateRange = dateRanges[id];\n                        if (otherDateRange.class === dateRange.class && otherDateRange.startDate > dateRange.startDate && (!candidateDateRange || dateRange.startDate < candidateDateRange.startDate)) {\n                            return otherDateRange;\n                        }\n                    }\n                    return candidateDateRange;\n                }, null);\n                if (nextDateRangeWithSameClass) {\n                    endTime = dateRangeDateToTimelineSeconds(nextDateRangeWithSameClass.startDate, dateTimeOffset);\n                    durationKnown = true;\n                }\n            }\n            // Create TextTrack Cues for each MetadataGroup Item (select DateRange attribute)\n            // This is to emulate Safari HLS playback handling of DateRange tags\n            const attributes = Object.keys(dateRange.attr);\n            for(let j = 0; j < attributes.length; j++){\n                const key = attributes[j];\n                if (!isDateRangeCueAttribute(key)) {\n                    continue;\n                }\n                const cue = cues[key];\n                if (cue) {\n                    if (durationKnown && !appendedDateRangeCues.durationKnown) {\n                        cue.endTime = endTime;\n                    }\n                } else if (Cue) {\n                    let data = dateRange.attr[key];\n                    if (isSCTE35Attribute(key)) {\n                        data = hexToArrayBuffer(data);\n                    }\n                    const _cue = createCueWithDataFields(Cue, startTime, endTime, {\n                        key,\n                        data\n                    }, MetadataSchema.dateRange);\n                    if (_cue) {\n                        _cue.id = id;\n                        this.id3Track.addCue(_cue);\n                        cues[key] = _cue;\n                    }\n                }\n            }\n            // Keep track of processed DateRanges by ID for updating cues with new DateRange tag attributes\n            dateRangeCuesAppended[id] = {\n                cues,\n                dateRange,\n                durationKnown\n            };\n        }\n    }\n}\nclass LatencyController {\n    constructor(hls){\n        this.hls = void 0;\n        this.config = void 0;\n        this.media = null;\n        this.levelDetails = null;\n        this.currentTime = 0;\n        this.stallCount = 0;\n        this._latency = null;\n        this.timeupdateHandler = ()=>this.timeupdate();\n        this.hls = hls;\n        this.config = hls.config;\n        this.registerListeners();\n    }\n    get latency() {\n        return this._latency || 0;\n    }\n    get maxLatency() {\n        const { config, levelDetails } = this;\n        if (config.liveMaxLatencyDuration !== undefined) {\n            return config.liveMaxLatencyDuration;\n        }\n        return levelDetails ? config.liveMaxLatencyDurationCount * levelDetails.targetduration : 0;\n    }\n    get targetLatency() {\n        const { levelDetails } = this;\n        if (levelDetails === null) {\n            return null;\n        }\n        const { holdBack, partHoldBack, targetduration } = levelDetails;\n        const { liveSyncDuration, liveSyncDurationCount, lowLatencyMode } = this.config;\n        const userConfig = this.hls.userConfig;\n        let targetLatency = lowLatencyMode ? partHoldBack || holdBack : holdBack;\n        if (userConfig.liveSyncDuration || userConfig.liveSyncDurationCount || targetLatency === 0) {\n            targetLatency = liveSyncDuration !== undefined ? liveSyncDuration : liveSyncDurationCount * targetduration;\n        }\n        const maxLiveSyncOnStallIncrease = targetduration;\n        const liveSyncOnStallIncrease = 1.0;\n        return targetLatency + Math.min(this.stallCount * liveSyncOnStallIncrease, maxLiveSyncOnStallIncrease);\n    }\n    get liveSyncPosition() {\n        const liveEdge = this.estimateLiveEdge();\n        const targetLatency = this.targetLatency;\n        const levelDetails = this.levelDetails;\n        if (liveEdge === null || targetLatency === null || levelDetails === null) {\n            return null;\n        }\n        const edge = levelDetails.edge;\n        const syncPosition = liveEdge - targetLatency - this.edgeStalled;\n        const min = edge - levelDetails.totalduration;\n        const max = edge - (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration);\n        return Math.min(Math.max(min, syncPosition), max);\n    }\n    get drift() {\n        const { levelDetails } = this;\n        if (levelDetails === null) {\n            return 1;\n        }\n        return levelDetails.drift;\n    }\n    get edgeStalled() {\n        const { levelDetails } = this;\n        if (levelDetails === null) {\n            return 0;\n        }\n        const maxLevelUpdateAge = (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration) * 3;\n        return Math.max(levelDetails.age - maxLevelUpdateAge, 0);\n    }\n    get forwardBufferLength() {\n        const { media, levelDetails } = this;\n        if (!media || !levelDetails) {\n            return 0;\n        }\n        const bufferedRanges = media.buffered.length;\n        return (bufferedRanges ? media.buffered.end(bufferedRanges - 1) : levelDetails.edge) - this.currentTime;\n    }\n    destroy() {\n        this.unregisterListeners();\n        this.onMediaDetaching();\n        this.levelDetails = null;\n        // @ts-ignore\n        this.hls = this.timeupdateHandler = null;\n    }\n    registerListeners() {\n        this.hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        this.hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        this.hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        this.hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n        this.hls.on(Events.ERROR, this.onError, this);\n    }\n    unregisterListeners() {\n        this.hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        this.hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        this.hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        this.hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n        this.hls.off(Events.ERROR, this.onError, this);\n    }\n    onMediaAttached(event, data) {\n        this.media = data.media;\n        this.media.addEventListener(\"timeupdate\", this.timeupdateHandler);\n    }\n    onMediaDetaching() {\n        if (this.media) {\n            this.media.removeEventListener(\"timeupdate\", this.timeupdateHandler);\n            this.media = null;\n        }\n    }\n    onManifestLoading() {\n        this.levelDetails = null;\n        this._latency = null;\n        this.stallCount = 0;\n    }\n    onLevelUpdated(event, { details }) {\n        this.levelDetails = details;\n        if (details.advanced) {\n            this.timeupdate();\n        }\n        if (!details.live && this.media) {\n            this.media.removeEventListener(\"timeupdate\", this.timeupdateHandler);\n        }\n    }\n    onError(event, data) {\n        var _this$levelDetails;\n        if (data.details !== ErrorDetails.BUFFER_STALLED_ERROR) {\n            return;\n        }\n        this.stallCount++;\n        if ((_this$levelDetails = this.levelDetails) != null && _this$levelDetails.live) {\n            logger.warn(\"[playback-rate-controller]: Stall detected, adjusting target latency\");\n        }\n    }\n    timeupdate() {\n        const { media, levelDetails } = this;\n        if (!media || !levelDetails) {\n            return;\n        }\n        this.currentTime = media.currentTime;\n        const latency = this.computeLatency();\n        if (latency === null) {\n            return;\n        }\n        this._latency = latency;\n        // Adapt playbackRate to meet target latency in low-latency mode\n        const { lowLatencyMode, maxLiveSyncPlaybackRate } = this.config;\n        if (!lowLatencyMode || maxLiveSyncPlaybackRate === 1 || !levelDetails.live) {\n            return;\n        }\n        const targetLatency = this.targetLatency;\n        if (targetLatency === null) {\n            return;\n        }\n        const distanceFromTarget = latency - targetLatency;\n        // Only adjust playbackRate when within one target duration of targetLatency\n        // and more than one second from under-buffering.\n        // Playback further than one target duration from target can be considered DVR playback.\n        const liveMinLatencyDuration = Math.min(this.maxLatency, targetLatency + levelDetails.targetduration);\n        const inLiveRange = distanceFromTarget < liveMinLatencyDuration;\n        if (inLiveRange && distanceFromTarget > 0.05 && this.forwardBufferLength > 1) {\n            const max = Math.min(2, Math.max(1.0, maxLiveSyncPlaybackRate));\n            const rate = Math.round(2 / (1 + Math.exp(-0.75 * distanceFromTarget - this.edgeStalled)) * 20) / 20;\n            media.playbackRate = Math.min(max, Math.max(1, rate));\n        } else if (media.playbackRate !== 1 && media.playbackRate !== 0) {\n            media.playbackRate = 1;\n        }\n    }\n    estimateLiveEdge() {\n        const { levelDetails } = this;\n        if (levelDetails === null) {\n            return null;\n        }\n        return levelDetails.edge + levelDetails.age;\n    }\n    computeLatency() {\n        const liveEdge = this.estimateLiveEdge();\n        if (liveEdge === null) {\n            return null;\n        }\n        return liveEdge - this.currentTime;\n    }\n}\nconst HdcpLevels = [\n    \"NONE\",\n    \"TYPE-0\",\n    \"TYPE-1\",\n    null\n];\nfunction isHdcpLevel(value) {\n    return HdcpLevels.indexOf(value) > -1;\n}\nconst VideoRangeValues = [\n    \"SDR\",\n    \"PQ\",\n    \"HLG\"\n];\nfunction isVideoRange(value) {\n    return !!value && VideoRangeValues.indexOf(value) > -1;\n}\nvar HlsSkip = {\n    No: \"\",\n    Yes: \"YES\",\n    v2: \"v2\"\n};\nfunction getSkipValue(details, msn) {\n    const { canSkipUntil, canSkipDateRanges, endSN } = details;\n    const snChangeGoal = msn !== undefined ? msn - endSN : 0;\n    if (canSkipUntil && snChangeGoal < canSkipUntil) {\n        if (canSkipDateRanges) {\n            return HlsSkip.v2;\n        }\n        return HlsSkip.Yes;\n    }\n    return HlsSkip.No;\n}\nclass HlsUrlParameters {\n    constructor(msn, part, skip){\n        this.msn = void 0;\n        this.part = void 0;\n        this.skip = void 0;\n        this.msn = msn;\n        this.part = part;\n        this.skip = skip;\n    }\n    addDirectives(uri) {\n        const url = new self.URL(uri);\n        if (this.msn !== undefined) {\n            url.searchParams.set(\"_HLS_msn\", this.msn.toString());\n        }\n        if (this.part !== undefined) {\n            url.searchParams.set(\"_HLS_part\", this.part.toString());\n        }\n        if (this.skip) {\n            url.searchParams.set(\"_HLS_skip\", this.skip);\n        }\n        return url.href;\n    }\n}\nclass Level {\n    constructor(data){\n        this._attrs = void 0;\n        this.audioCodec = void 0;\n        this.bitrate = void 0;\n        this.codecSet = void 0;\n        this.url = void 0;\n        this.frameRate = void 0;\n        this.height = void 0;\n        this.id = void 0;\n        this.name = void 0;\n        this.videoCodec = void 0;\n        this.width = void 0;\n        this.details = void 0;\n        this.fragmentError = 0;\n        this.loadError = 0;\n        this.loaded = void 0;\n        this.realBitrate = 0;\n        this.supportedPromise = void 0;\n        this.supportedResult = void 0;\n        this._avgBitrate = 0;\n        this._audioGroups = void 0;\n        this._subtitleGroups = void 0;\n        // Deprecated (retained for backwards compatibility)\n        this._urlId = 0;\n        this.url = [\n            data.url\n        ];\n        this._attrs = [\n            data.attrs\n        ];\n        this.bitrate = data.bitrate;\n        if (data.details) {\n            this.details = data.details;\n        }\n        this.id = data.id || 0;\n        this.name = data.name;\n        this.width = data.width || 0;\n        this.height = data.height || 0;\n        this.frameRate = data.attrs.optionalFloat(\"FRAME-RATE\", 0);\n        this._avgBitrate = data.attrs.decimalInteger(\"AVERAGE-BANDWIDTH\");\n        this.audioCodec = data.audioCodec;\n        this.videoCodec = data.videoCodec;\n        this.codecSet = [\n            data.videoCodec,\n            data.audioCodec\n        ].filter((c)=>!!c).map((s)=>s.substring(0, 4)).join(\",\");\n        this.addGroupId(\"audio\", data.attrs.AUDIO);\n        this.addGroupId(\"text\", data.attrs.SUBTITLES);\n    }\n    get maxBitrate() {\n        return Math.max(this.realBitrate, this.bitrate);\n    }\n    get averageBitrate() {\n        return this._avgBitrate || this.realBitrate || this.bitrate;\n    }\n    get attrs() {\n        return this._attrs[0];\n    }\n    get codecs() {\n        return this.attrs.CODECS || \"\";\n    }\n    get pathwayId() {\n        return this.attrs[\"PATHWAY-ID\"] || \".\";\n    }\n    get videoRange() {\n        return this.attrs[\"VIDEO-RANGE\"] || \"SDR\";\n    }\n    get score() {\n        return this.attrs.optionalFloat(\"SCORE\", 0);\n    }\n    get uri() {\n        return this.url[0] || \"\";\n    }\n    hasAudioGroup(groupId) {\n        return hasGroup(this._audioGroups, groupId);\n    }\n    hasSubtitleGroup(groupId) {\n        return hasGroup(this._subtitleGroups, groupId);\n    }\n    get audioGroups() {\n        return this._audioGroups;\n    }\n    get subtitleGroups() {\n        return this._subtitleGroups;\n    }\n    addGroupId(type, groupId) {\n        if (!groupId) {\n            return;\n        }\n        if (type === \"audio\") {\n            let audioGroups = this._audioGroups;\n            if (!audioGroups) {\n                audioGroups = this._audioGroups = [];\n            }\n            if (audioGroups.indexOf(groupId) === -1) {\n                audioGroups.push(groupId);\n            }\n        } else if (type === \"text\") {\n            let subtitleGroups = this._subtitleGroups;\n            if (!subtitleGroups) {\n                subtitleGroups = this._subtitleGroups = [];\n            }\n            if (subtitleGroups.indexOf(groupId) === -1) {\n                subtitleGroups.push(groupId);\n            }\n        }\n    }\n    // Deprecated methods (retained for backwards compatibility)\n    get urlId() {\n        return 0;\n    }\n    set urlId(value) {}\n    get audioGroupIds() {\n        return this.audioGroups ? [\n            this.audioGroupId\n        ] : undefined;\n    }\n    get textGroupIds() {\n        return this.subtitleGroups ? [\n            this.textGroupId\n        ] : undefined;\n    }\n    get audioGroupId() {\n        var _this$audioGroups;\n        return (_this$audioGroups = this.audioGroups) == null ? void 0 : _this$audioGroups[0];\n    }\n    get textGroupId() {\n        var _this$subtitleGroups;\n        return (_this$subtitleGroups = this.subtitleGroups) == null ? void 0 : _this$subtitleGroups[0];\n    }\n    addFallback() {}\n}\nfunction hasGroup(groups, groupId) {\n    if (!groupId || !groups) {\n        return false;\n    }\n    return groups.indexOf(groupId) !== -1;\n}\nfunction updateFromToPTS(fragFrom, fragTo) {\n    const fragToPTS = fragTo.startPTS;\n    // if we know startPTS[toIdx]\n    if (isFiniteNumber(fragToPTS)) {\n        // update fragment duration.\n        // it helps to fix drifts between playlist reported duration and fragment real duration\n        let duration = 0;\n        let frag;\n        if (fragTo.sn > fragFrom.sn) {\n            duration = fragToPTS - fragFrom.start;\n            frag = fragFrom;\n        } else {\n            duration = fragFrom.start - fragToPTS;\n            frag = fragTo;\n        }\n        if (frag.duration !== duration) {\n            frag.duration = duration;\n        }\n    // we dont know startPTS[toIdx]\n    } else if (fragTo.sn > fragFrom.sn) {\n        const contiguous = fragFrom.cc === fragTo.cc;\n        // TODO: With part-loading end/durations we need to confirm the whole fragment is loaded before using (or setting) minEndPTS\n        if (contiguous && fragFrom.minEndPTS) {\n            fragTo.start = fragFrom.start + (fragFrom.minEndPTS - fragFrom.start);\n        } else {\n            fragTo.start = fragFrom.start + fragFrom.duration;\n        }\n    } else {\n        fragTo.start = Math.max(fragFrom.start - fragTo.duration, 0);\n    }\n}\nfunction updateFragPTSDTS(details, frag, startPTS, endPTS, startDTS, endDTS) {\n    const parsedMediaDuration = endPTS - startPTS;\n    if (parsedMediaDuration <= 0) {\n        logger.warn(\"Fragment should have a positive duration\", frag);\n        endPTS = startPTS + frag.duration;\n        endDTS = startDTS + frag.duration;\n    }\n    let maxStartPTS = startPTS;\n    let minEndPTS = endPTS;\n    const fragStartPts = frag.startPTS;\n    const fragEndPts = frag.endPTS;\n    if (isFiniteNumber(fragStartPts)) {\n        // delta PTS between audio and video\n        const deltaPTS = Math.abs(fragStartPts - startPTS);\n        if (!isFiniteNumber(frag.deltaPTS)) {\n            frag.deltaPTS = deltaPTS;\n        } else {\n            frag.deltaPTS = Math.max(deltaPTS, frag.deltaPTS);\n        }\n        maxStartPTS = Math.max(startPTS, fragStartPts);\n        startPTS = Math.min(startPTS, fragStartPts);\n        startDTS = Math.min(startDTS, frag.startDTS);\n        minEndPTS = Math.min(endPTS, fragEndPts);\n        endPTS = Math.max(endPTS, fragEndPts);\n        endDTS = Math.max(endDTS, frag.endDTS);\n    }\n    const drift = startPTS - frag.start;\n    if (frag.start !== 0) {\n        frag.start = startPTS;\n    }\n    frag.duration = endPTS - frag.start;\n    frag.startPTS = startPTS;\n    frag.maxStartPTS = maxStartPTS;\n    frag.startDTS = startDTS;\n    frag.endPTS = endPTS;\n    frag.minEndPTS = minEndPTS;\n    frag.endDTS = endDTS;\n    const sn = frag.sn; // 'initSegment'\n    // exit if sn out of range\n    if (!details || sn < details.startSN || sn > details.endSN) {\n        return 0;\n    }\n    let i;\n    const fragIdx = sn - details.startSN;\n    const fragments = details.fragments;\n    // update frag reference in fragments array\n    // rationale is that fragments array might not contain this frag object.\n    // this will happen if playlist has been refreshed between frag loading and call to updateFragPTSDTS()\n    // if we don't update frag, we won't be able to propagate PTS info on the playlist\n    // resulting in invalid sliding computation\n    fragments[fragIdx] = frag;\n    // adjust fragment PTS/duration from seqnum-1 to frag 0\n    for(i = fragIdx; i > 0; i--){\n        updateFromToPTS(fragments[i], fragments[i - 1]);\n    }\n    // adjust fragment PTS/duration from seqnum to last frag\n    for(i = fragIdx; i < fragments.length - 1; i++){\n        updateFromToPTS(fragments[i], fragments[i + 1]);\n    }\n    if (details.fragmentHint) {\n        updateFromToPTS(fragments[fragments.length - 1], details.fragmentHint);\n    }\n    details.PTSKnown = details.alignedSliding = true;\n    return drift;\n}\nfunction mergeDetails(oldDetails, newDetails) {\n    // Track the last initSegment processed. Initialize it to the last one on the timeline.\n    let currentInitSegment = null;\n    const oldFragments = oldDetails.fragments;\n    for(let i = oldFragments.length - 1; i >= 0; i--){\n        const oldInit = oldFragments[i].initSegment;\n        if (oldInit) {\n            currentInitSegment = oldInit;\n            break;\n        }\n    }\n    if (oldDetails.fragmentHint) {\n        // prevent PTS and duration from being adjusted on the next hint\n        delete oldDetails.fragmentHint.endPTS;\n    }\n    // check if old/new playlists have fragments in common\n    // loop through overlapping SN and update startPTS , cc, and duration if any found\n    let ccOffset = 0;\n    let PTSFrag;\n    mapFragmentIntersection(oldDetails, newDetails, (oldFrag, newFrag)=>{\n        if (oldFrag.relurl) {\n            // Do not compare CC if the old fragment has no url. This is a level.fragmentHint used by LL-HLS parts.\n            // It maybe be off by 1 if it was created before any parts or discontinuity tags were appended to the end\n            // of the playlist.\n            ccOffset = oldFrag.cc - newFrag.cc;\n        }\n        if (isFiniteNumber(oldFrag.startPTS) && isFiniteNumber(oldFrag.endPTS)) {\n            newFrag.start = newFrag.startPTS = oldFrag.startPTS;\n            newFrag.startDTS = oldFrag.startDTS;\n            newFrag.maxStartPTS = oldFrag.maxStartPTS;\n            newFrag.endPTS = oldFrag.endPTS;\n            newFrag.endDTS = oldFrag.endDTS;\n            newFrag.minEndPTS = oldFrag.minEndPTS;\n            newFrag.duration = oldFrag.endPTS - oldFrag.startPTS;\n            if (newFrag.duration) {\n                PTSFrag = newFrag;\n            }\n            // PTS is known when any segment has startPTS and endPTS\n            newDetails.PTSKnown = newDetails.alignedSliding = true;\n        }\n        newFrag.elementaryStreams = oldFrag.elementaryStreams;\n        newFrag.loader = oldFrag.loader;\n        newFrag.stats = oldFrag.stats;\n        if (oldFrag.initSegment) {\n            newFrag.initSegment = oldFrag.initSegment;\n            currentInitSegment = oldFrag.initSegment;\n        }\n    });\n    if (currentInitSegment) {\n        const fragmentsToCheck = newDetails.fragmentHint ? newDetails.fragments.concat(newDetails.fragmentHint) : newDetails.fragments;\n        fragmentsToCheck.forEach((frag)=>{\n            var _currentInitSegment;\n            if (frag && (!frag.initSegment || frag.initSegment.relurl === ((_currentInitSegment = currentInitSegment) == null ? void 0 : _currentInitSegment.relurl))) {\n                frag.initSegment = currentInitSegment;\n            }\n        });\n    }\n    if (newDetails.skippedSegments) {\n        newDetails.deltaUpdateFailed = newDetails.fragments.some((frag)=>!frag);\n        if (newDetails.deltaUpdateFailed) {\n            logger.warn(\"[level-helper] Previous playlist missing segments skipped in delta playlist\");\n            for(let i = newDetails.skippedSegments; i--;){\n                newDetails.fragments.shift();\n            }\n            newDetails.startSN = newDetails.fragments[0].sn;\n            newDetails.startCC = newDetails.fragments[0].cc;\n        } else if (newDetails.canSkipDateRanges) {\n            newDetails.dateRanges = mergeDateRanges(oldDetails.dateRanges, newDetails.dateRanges, newDetails.recentlyRemovedDateranges);\n        }\n    }\n    const newFragments = newDetails.fragments;\n    if (ccOffset) {\n        logger.warn(\"discontinuity sliding from playlist, take drift into account\");\n        for(let i = 0; i < newFragments.length; i++){\n            newFragments[i].cc += ccOffset;\n        }\n    }\n    if (newDetails.skippedSegments) {\n        newDetails.startCC = newDetails.fragments[0].cc;\n    }\n    // Merge parts\n    mapPartIntersection(oldDetails.partList, newDetails.partList, (oldPart, newPart)=>{\n        newPart.elementaryStreams = oldPart.elementaryStreams;\n        newPart.stats = oldPart.stats;\n    });\n    // if at least one fragment contains PTS info, recompute PTS information for all fragments\n    if (PTSFrag) {\n        updateFragPTSDTS(newDetails, PTSFrag, PTSFrag.startPTS, PTSFrag.endPTS, PTSFrag.startDTS, PTSFrag.endDTS);\n    } else {\n        // ensure that delta is within oldFragments range\n        // also adjust sliding in case delta is 0 (we could have old=[50-60] and new=old=[50-61])\n        // in that case we also need to adjust start offset of all fragments\n        adjustSliding(oldDetails, newDetails);\n    }\n    if (newFragments.length) {\n        newDetails.totalduration = newDetails.edge - newFragments[0].start;\n    }\n    newDetails.driftStartTime = oldDetails.driftStartTime;\n    newDetails.driftStart = oldDetails.driftStart;\n    const advancedDateTime = newDetails.advancedDateTime;\n    if (newDetails.advanced && advancedDateTime) {\n        const edge = newDetails.edge;\n        if (!newDetails.driftStart) {\n            newDetails.driftStartTime = advancedDateTime;\n            newDetails.driftStart = edge;\n        }\n        newDetails.driftEndTime = advancedDateTime;\n        newDetails.driftEnd = edge;\n    } else {\n        newDetails.driftEndTime = oldDetails.driftEndTime;\n        newDetails.driftEnd = oldDetails.driftEnd;\n        newDetails.advancedDateTime = oldDetails.advancedDateTime;\n    }\n}\nfunction mergeDateRanges(oldDateRanges, deltaDateRanges, recentlyRemovedDateranges) {\n    const dateRanges = _extends({}, oldDateRanges);\n    if (recentlyRemovedDateranges) {\n        recentlyRemovedDateranges.forEach((id)=>{\n            delete dateRanges[id];\n        });\n    }\n    Object.keys(deltaDateRanges).forEach((id)=>{\n        const dateRange = new DateRange(deltaDateRanges[id].attr, dateRanges[id]);\n        if (dateRange.isValid) {\n            dateRanges[id] = dateRange;\n        } else {\n            logger.warn(`Ignoring invalid Playlist Delta Update DATERANGE tag: \"${JSON.stringify(deltaDateRanges[id].attr)}\"`);\n        }\n    });\n    return dateRanges;\n}\nfunction mapPartIntersection(oldParts, newParts, intersectionFn) {\n    if (oldParts && newParts) {\n        let delta = 0;\n        for(let i = 0, len = oldParts.length; i <= len; i++){\n            const oldPart = oldParts[i];\n            const newPart = newParts[i + delta];\n            if (oldPart && newPart && oldPart.index === newPart.index && oldPart.fragment.sn === newPart.fragment.sn) {\n                intersectionFn(oldPart, newPart);\n            } else {\n                delta--;\n            }\n        }\n    }\n}\nfunction mapFragmentIntersection(oldDetails, newDetails, intersectionFn) {\n    const skippedSegments = newDetails.skippedSegments;\n    const start = Math.max(oldDetails.startSN, newDetails.startSN) - newDetails.startSN;\n    const end = (oldDetails.fragmentHint ? 1 : 0) + (skippedSegments ? newDetails.endSN : Math.min(oldDetails.endSN, newDetails.endSN)) - newDetails.startSN;\n    const delta = newDetails.startSN - oldDetails.startSN;\n    const newFrags = newDetails.fragmentHint ? newDetails.fragments.concat(newDetails.fragmentHint) : newDetails.fragments;\n    const oldFrags = oldDetails.fragmentHint ? oldDetails.fragments.concat(oldDetails.fragmentHint) : oldDetails.fragments;\n    for(let i = start; i <= end; i++){\n        const oldFrag = oldFrags[delta + i];\n        let newFrag = newFrags[i];\n        if (skippedSegments && !newFrag && i < skippedSegments) {\n            // Fill in skipped segments in delta playlist\n            newFrag = newDetails.fragments[i] = oldFrag;\n        }\n        if (oldFrag && newFrag) {\n            intersectionFn(oldFrag, newFrag);\n        }\n    }\n}\nfunction adjustSliding(oldDetails, newDetails) {\n    const delta = newDetails.startSN + newDetails.skippedSegments - oldDetails.startSN;\n    const oldFragments = oldDetails.fragments;\n    if (delta < 0 || delta >= oldFragments.length) {\n        return;\n    }\n    addSliding(newDetails, oldFragments[delta].start);\n}\nfunction addSliding(details, start) {\n    if (start) {\n        const fragments = details.fragments;\n        for(let i = details.skippedSegments; i < fragments.length; i++){\n            fragments[i].start += start;\n        }\n        if (details.fragmentHint) {\n            details.fragmentHint.start += start;\n        }\n    }\n}\nfunction computeReloadInterval(newDetails, distanceToLiveEdgeMs = Infinity) {\n    let reloadInterval = 1000 * newDetails.targetduration;\n    if (newDetails.updated) {\n        // Use last segment duration when shorter than target duration and near live edge\n        const fragments = newDetails.fragments;\n        const liveEdgeMaxTargetDurations = 4;\n        if (fragments.length && reloadInterval * liveEdgeMaxTargetDurations > distanceToLiveEdgeMs) {\n            const lastSegmentDuration = fragments[fragments.length - 1].duration * 1000;\n            if (lastSegmentDuration < reloadInterval) {\n                reloadInterval = lastSegmentDuration;\n            }\n        }\n    } else {\n        // estimate = 'miss half average';\n        // follow HLS Spec, If the client reloads a Playlist file and finds that it has not\n        // changed then it MUST wait for a period of one-half the target\n        // duration before retrying.\n        reloadInterval /= 2;\n    }\n    return Math.round(reloadInterval);\n}\nfunction getFragmentWithSN(level, sn, fragCurrent) {\n    if (!(level != null && level.details)) {\n        return null;\n    }\n    const levelDetails = level.details;\n    let fragment = levelDetails.fragments[sn - levelDetails.startSN];\n    if (fragment) {\n        return fragment;\n    }\n    fragment = levelDetails.fragmentHint;\n    if (fragment && fragment.sn === sn) {\n        return fragment;\n    }\n    if (sn < levelDetails.startSN && fragCurrent && fragCurrent.sn === sn) {\n        return fragCurrent;\n    }\n    return null;\n}\nfunction getPartWith(level, sn, partIndex) {\n    var _level$details;\n    if (!(level != null && level.details)) {\n        return null;\n    }\n    return findPart((_level$details = level.details) == null ? void 0 : _level$details.partList, sn, partIndex);\n}\nfunction findPart(partList, sn, partIndex) {\n    if (partList) {\n        for(let i = partList.length; i--;){\n            const part = partList[i];\n            if (part.index === partIndex && part.fragment.sn === sn) {\n                return part;\n            }\n        }\n    }\n    return null;\n}\nfunction reassignFragmentLevelIndexes(levels) {\n    levels.forEach((level, index)=>{\n        const { details } = level;\n        if (details != null && details.fragments) {\n            details.fragments.forEach((fragment)=>{\n                fragment.level = index;\n            });\n        }\n    });\n}\nfunction isTimeoutError(error) {\n    switch(error.details){\n        case ErrorDetails.FRAG_LOAD_TIMEOUT:\n        case ErrorDetails.KEY_LOAD_TIMEOUT:\n        case ErrorDetails.LEVEL_LOAD_TIMEOUT:\n        case ErrorDetails.MANIFEST_LOAD_TIMEOUT:\n            return true;\n    }\n    return false;\n}\nfunction getRetryConfig(loadPolicy, error) {\n    const isTimeout = isTimeoutError(error);\n    return loadPolicy.default[`${isTimeout ? \"timeout\" : \"error\"}Retry`];\n}\nfunction getRetryDelay(retryConfig, retryCount) {\n    // exponential backoff capped to max retry delay\n    const backoffFactor = retryConfig.backoff === \"linear\" ? 1 : Math.pow(2, retryCount);\n    return Math.min(backoffFactor * retryConfig.retryDelayMs, retryConfig.maxRetryDelayMs);\n}\nfunction getLoaderConfigWithoutReties(loderConfig) {\n    return _objectSpread2(_objectSpread2({}, loderConfig), {\n        errorRetry: null,\n        timeoutRetry: null\n    });\n}\nfunction shouldRetry(retryConfig, retryCount, isTimeout, loaderResponse) {\n    if (!retryConfig) {\n        return false;\n    }\n    const httpStatus = loaderResponse == null ? void 0 : loaderResponse.code;\n    const retry = retryCount < retryConfig.maxNumRetry && (retryForHttpStatus(httpStatus) || !!isTimeout);\n    return retryConfig.shouldRetry ? retryConfig.shouldRetry(retryConfig, retryCount, isTimeout, loaderResponse, retry) : retry;\n}\nfunction retryForHttpStatus(httpStatus) {\n    // Do not retry on status 4xx, status 0 (CORS error), or undefined (decrypt/gap/parse error)\n    return httpStatus === 0 && navigator.onLine === false || !!httpStatus && (httpStatus < 400 || httpStatus > 499);\n}\nconst BinarySearch = {\n    /**\n   * Searches for an item in an array which matches a certain condition.\n   * This requires the condition to only match one item in the array,\n   * and for the array to be ordered.\n   *\n   * @param list The array to search.\n   * @param comparisonFn\n   *      Called and provided a candidate item as the first argument.\n   *      Should return:\n   *          > -1 if the item should be located at a lower index than the provided item.\n   *          > 1 if the item should be located at a higher index than the provided item.\n   *          > 0 if the item is the item you're looking for.\n   *\n   * @returns the object if found, otherwise returns null\n   */ search: function(list, comparisonFn) {\n        let minIndex = 0;\n        let maxIndex = list.length - 1;\n        let currentIndex = null;\n        let currentElement = null;\n        while(minIndex <= maxIndex){\n            currentIndex = (minIndex + maxIndex) / 2 | 0;\n            currentElement = list[currentIndex];\n            const comparisonResult = comparisonFn(currentElement);\n            if (comparisonResult > 0) {\n                minIndex = currentIndex + 1;\n            } else if (comparisonResult < 0) {\n                maxIndex = currentIndex - 1;\n            } else {\n                return currentElement;\n            }\n        }\n        return null;\n    }\n};\n/**\n * Returns first fragment whose endPdt value exceeds the given PDT, or null.\n * @param fragments - The array of candidate fragments\n * @param PDTValue - The PDT value which must be exceeded\n * @param maxFragLookUpTolerance - The amount of time that a fragment's start/end can be within in order to be considered contiguous\n */ function findFragmentByPDT(fragments, PDTValue, maxFragLookUpTolerance) {\n    if (PDTValue === null || !Array.isArray(fragments) || !fragments.length || !isFiniteNumber(PDTValue)) {\n        return null;\n    }\n    // if less than start\n    const startPDT = fragments[0].programDateTime;\n    if (PDTValue < (startPDT || 0)) {\n        return null;\n    }\n    const endPDT = fragments[fragments.length - 1].endProgramDateTime;\n    if (PDTValue >= (endPDT || 0)) {\n        return null;\n    }\n    maxFragLookUpTolerance = maxFragLookUpTolerance || 0;\n    for(let seg = 0; seg < fragments.length; ++seg){\n        const frag = fragments[seg];\n        if (pdtWithinToleranceTest(PDTValue, maxFragLookUpTolerance, frag)) {\n            return frag;\n        }\n    }\n    return null;\n}\n/**\n * Finds a fragment based on the SN of the previous fragment; or based on the needs of the current buffer.\n * This method compensates for small buffer gaps by applying a tolerance to the start of any candidate fragment, thus\n * breaking any traps which would cause the same fragment to be continuously selected within a small range.\n * @param fragPrevious - The last frag successfully appended\n * @param fragments - The array of candidate fragments\n * @param bufferEnd - The end of the contiguous buffered range the playhead is currently within\n * @param maxFragLookUpTolerance - The amount of time that a fragment's start/end can be within in order to be considered contiguous\n * @returns a matching fragment or null\n */ function findFragmentByPTS(fragPrevious, fragments, bufferEnd = 0, maxFragLookUpTolerance = 0) {\n    let fragNext = null;\n    if (fragPrevious) {\n        fragNext = fragments[fragPrevious.sn - fragments[0].sn + 1] || null;\n        // check for buffer-end rounding error\n        const bufferEdgeError = fragPrevious.endDTS - bufferEnd;\n        if (bufferEdgeError > 0 && bufferEdgeError < 0.0000015) {\n            bufferEnd += 0.0000015;\n        }\n    } else if (bufferEnd === 0 && fragments[0].start === 0) {\n        fragNext = fragments[0];\n    }\n    // Prefer the next fragment if it's within tolerance\n    if (fragNext && (!fragPrevious || fragPrevious.level === fragNext.level) && fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, fragNext) === 0) {\n        return fragNext;\n    }\n    // We might be seeking past the tolerance so find the best match\n    const foundFragment = BinarySearch.search(fragments, fragmentWithinToleranceTest.bind(null, bufferEnd, maxFragLookUpTolerance));\n    if (foundFragment && (foundFragment !== fragPrevious || !fragNext)) {\n        return foundFragment;\n    }\n    // If no match was found return the next fragment after fragPrevious, or null\n    return fragNext;\n}\n/**\n * The test function used by the findFragmentBySn's BinarySearch to look for the best match to the current buffer conditions.\n * @param candidate - The fragment to test\n * @param bufferEnd - The end of the current buffered range the playhead is currently within\n * @param maxFragLookUpTolerance - The amount of time that a fragment's start can be within in order to be considered contiguous\n * @returns 0 if it matches, 1 if too low, -1 if too high\n */ function fragmentWithinToleranceTest(bufferEnd = 0, maxFragLookUpTolerance = 0, candidate) {\n    // eagerly accept an accurate match (no tolerance)\n    if (candidate.start <= bufferEnd && candidate.start + candidate.duration > bufferEnd) {\n        return 0;\n    }\n    // offset should be within fragment boundary - config.maxFragLookUpTolerance\n    // this is to cope with situations like\n    // bufferEnd = 9.991\n    // frag[] : [0,10]\n    // frag[1] : [10,20]\n    // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here\n    //              frag start               frag start+duration\n    //                  |-----------------------------|\n    //              <--->                         <--->\n    //  ...--------><-----------------------------><---------....\n    // previous frag         matching fragment         next frag\n    //  return -1             return 0                 return 1\n    // logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);\n    // Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments\n    const candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0));\n    if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {\n        return 1;\n    } else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {\n        // if maxFragLookUpTolerance will have negative value then don't return -1 for first element\n        return -1;\n    }\n    return 0;\n}\n/**\n * The test function used by the findFragmentByPdt's BinarySearch to look for the best match to the current buffer conditions.\n * This function tests the candidate's program date time values, as represented in Unix time\n * @param candidate - The fragment to test\n * @param pdtBufferEnd - The Unix time representing the end of the current buffered range\n * @param maxFragLookUpTolerance - The amount of time that a fragment's start can be within in order to be considered contiguous\n * @returns true if contiguous, false otherwise\n */ function pdtWithinToleranceTest(pdtBufferEnd, maxFragLookUpTolerance, candidate) {\n    const candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0)) * 1000;\n    // endProgramDateTime can be null, default to zero\n    const endProgramDateTime = candidate.endProgramDateTime || 0;\n    return endProgramDateTime - candidateLookupTolerance > pdtBufferEnd;\n}\nfunction findFragWithCC(fragments, cc) {\n    return BinarySearch.search(fragments, (candidate)=>{\n        if (candidate.cc < cc) {\n            return 1;\n        } else if (candidate.cc > cc) {\n            return -1;\n        } else {\n            return 0;\n        }\n    });\n}\nvar NetworkErrorAction = {\n    DoNothing: 0,\n    SendEndCallback: 1,\n    SendAlternateToPenaltyBox: 2,\n    RemoveAlternatePermanently: 3,\n    InsertDiscontinuity: 4,\n    RetryRequest: 5\n};\nvar ErrorActionFlags = {\n    None: 0,\n    MoveAllAlternatesMatchingHost: 1,\n    MoveAllAlternatesMatchingHDCP: 2,\n    SwitchToSDR: 4\n}; // Reserved for future use\nclass ErrorController {\n    constructor(hls){\n        this.hls = void 0;\n        this.playlistError = 0;\n        this.penalizedRenditions = {};\n        this.log = void 0;\n        this.warn = void 0;\n        this.error = void 0;\n        this.hls = hls;\n        this.log = logger.log.bind(logger, `[info]:`);\n        this.warn = logger.warn.bind(logger, `[warning]:`);\n        this.error = logger.error.bind(logger, `[error]:`);\n        this.registerListeners();\n    }\n    registerListeners() {\n        const hls = this.hls;\n        hls.on(Events.ERROR, this.onError, this);\n        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n    }\n    unregisterListeners() {\n        const hls = this.hls;\n        if (!hls) {\n            return;\n        }\n        hls.off(Events.ERROR, this.onError, this);\n        hls.off(Events.ERROR, this.onErrorOut, this);\n        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n    }\n    destroy() {\n        this.unregisterListeners();\n        // @ts-ignore\n        this.hls = null;\n        this.penalizedRenditions = {};\n    }\n    startLoad(startPosition) {}\n    stopLoad() {\n        this.playlistError = 0;\n    }\n    getVariantLevelIndex(frag) {\n        return (frag == null ? void 0 : frag.type) === PlaylistLevelType.MAIN ? frag.level : this.hls.loadLevel;\n    }\n    onManifestLoading() {\n        this.playlistError = 0;\n        this.penalizedRenditions = {};\n    }\n    onLevelUpdated() {\n        this.playlistError = 0;\n    }\n    onError(event, data) {\n        var _data$frag, _data$level;\n        if (data.fatal) {\n            return;\n        }\n        const hls = this.hls;\n        const context = data.context;\n        switch(data.details){\n            case ErrorDetails.FRAG_LOAD_ERROR:\n            case ErrorDetails.FRAG_LOAD_TIMEOUT:\n            case ErrorDetails.KEY_LOAD_ERROR:\n            case ErrorDetails.KEY_LOAD_TIMEOUT:\n                data.errorAction = this.getFragRetryOrSwitchAction(data);\n                return;\n            case ErrorDetails.FRAG_PARSING_ERROR:\n                // ignore empty segment errors marked as gap\n                if ((_data$frag = data.frag) != null && _data$frag.gap) {\n                    data.errorAction = {\n                        action: NetworkErrorAction.DoNothing,\n                        flags: ErrorActionFlags.None\n                    };\n                    return;\n                }\n            // falls through\n            case ErrorDetails.FRAG_GAP:\n            case ErrorDetails.FRAG_DECRYPT_ERROR:\n                {\n                    // Switch level if possible, otherwise allow retry count to reach max error retries\n                    data.errorAction = this.getFragRetryOrSwitchAction(data);\n                    data.errorAction.action = NetworkErrorAction.SendAlternateToPenaltyBox;\n                    return;\n                }\n            case ErrorDetails.LEVEL_EMPTY_ERROR:\n            case ErrorDetails.LEVEL_PARSING_ERROR:\n                {\n                    var _data$context, _data$context$levelDe;\n                    // Only retry when empty and live\n                    const levelIndex = data.parent === PlaylistLevelType.MAIN ? data.level : hls.loadLevel;\n                    if (data.details === ErrorDetails.LEVEL_EMPTY_ERROR && !!((_data$context = data.context) != null && (_data$context$levelDe = _data$context.levelDetails) != null && _data$context$levelDe.live)) {\n                        data.errorAction = this.getPlaylistRetryOrSwitchAction(data, levelIndex);\n                    } else {\n                        // Escalate to fatal if not retrying or switching\n                        data.levelRetry = false;\n                        data.errorAction = this.getLevelSwitchAction(data, levelIndex);\n                    }\n                }\n                return;\n            case ErrorDetails.LEVEL_LOAD_ERROR:\n            case ErrorDetails.LEVEL_LOAD_TIMEOUT:\n                if (typeof (context == null ? void 0 : context.level) === \"number\") {\n                    data.errorAction = this.getPlaylistRetryOrSwitchAction(data, context.level);\n                }\n                return;\n            case ErrorDetails.AUDIO_TRACK_LOAD_ERROR:\n            case ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:\n            case ErrorDetails.SUBTITLE_LOAD_ERROR:\n            case ErrorDetails.SUBTITLE_TRACK_LOAD_TIMEOUT:\n                if (context) {\n                    const level = hls.levels[hls.loadLevel];\n                    if (level && (context.type === PlaylistContextType.AUDIO_TRACK && level.hasAudioGroup(context.groupId) || context.type === PlaylistContextType.SUBTITLE_TRACK && level.hasSubtitleGroup(context.groupId))) {\n                        // Perform Pathway switch or Redundant failover if possible for fastest recovery\n                        // otherwise allow playlist retry count to reach max error retries\n                        data.errorAction = this.getPlaylistRetryOrSwitchAction(data, hls.loadLevel);\n                        data.errorAction.action = NetworkErrorAction.SendAlternateToPenaltyBox;\n                        data.errorAction.flags = ErrorActionFlags.MoveAllAlternatesMatchingHost;\n                        return;\n                    }\n                }\n                return;\n            case ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED:\n                {\n                    const level = hls.levels[hls.loadLevel];\n                    const restrictedHdcpLevel = level == null ? void 0 : level.attrs[\"HDCP-LEVEL\"];\n                    if (restrictedHdcpLevel) {\n                        data.errorAction = {\n                            action: NetworkErrorAction.SendAlternateToPenaltyBox,\n                            flags: ErrorActionFlags.MoveAllAlternatesMatchingHDCP,\n                            hdcpLevel: restrictedHdcpLevel\n                        };\n                    } else {\n                        this.keySystemError(data);\n                    }\n                }\n                return;\n            case ErrorDetails.BUFFER_ADD_CODEC_ERROR:\n            case ErrorDetails.REMUX_ALLOC_ERROR:\n            case ErrorDetails.BUFFER_APPEND_ERROR:\n                data.errorAction = this.getLevelSwitchAction(data, (_data$level = data.level) != null ? _data$level : hls.loadLevel);\n                return;\n            case ErrorDetails.INTERNAL_EXCEPTION:\n            case ErrorDetails.BUFFER_APPENDING_ERROR:\n            case ErrorDetails.BUFFER_FULL_ERROR:\n            case ErrorDetails.LEVEL_SWITCH_ERROR:\n            case ErrorDetails.BUFFER_STALLED_ERROR:\n            case ErrorDetails.BUFFER_SEEK_OVER_HOLE:\n            case ErrorDetails.BUFFER_NUDGE_ON_STALL:\n                data.errorAction = {\n                    action: NetworkErrorAction.DoNothing,\n                    flags: ErrorActionFlags.None\n                };\n                return;\n        }\n        if (data.type === ErrorTypes.KEY_SYSTEM_ERROR) {\n            this.keySystemError(data);\n        }\n    }\n    keySystemError(data) {\n        const levelIndex = this.getVariantLevelIndex(data.frag);\n        // Do not retry level. Escalate to fatal if switching levels fails.\n        data.levelRetry = false;\n        data.errorAction = this.getLevelSwitchAction(data, levelIndex);\n    }\n    getPlaylistRetryOrSwitchAction(data, levelIndex) {\n        const hls = this.hls;\n        const retryConfig = getRetryConfig(hls.config.playlistLoadPolicy, data);\n        const retryCount = this.playlistError++;\n        const retry = shouldRetry(retryConfig, retryCount, isTimeoutError(data), data.response);\n        if (retry) {\n            return {\n                action: NetworkErrorAction.RetryRequest,\n                flags: ErrorActionFlags.None,\n                retryConfig,\n                retryCount\n            };\n        }\n        const errorAction = this.getLevelSwitchAction(data, levelIndex);\n        if (retryConfig) {\n            errorAction.retryConfig = retryConfig;\n            errorAction.retryCount = retryCount;\n        }\n        return errorAction;\n    }\n    getFragRetryOrSwitchAction(data) {\n        const hls = this.hls;\n        // Share fragment error count accross media options (main, audio, subs)\n        // This allows for level based rendition switching when media option assets fail\n        const variantLevelIndex = this.getVariantLevelIndex(data.frag);\n        const level = hls.levels[variantLevelIndex];\n        const { fragLoadPolicy, keyLoadPolicy } = hls.config;\n        const retryConfig = getRetryConfig(data.details.startsWith(\"key\") ? keyLoadPolicy : fragLoadPolicy, data);\n        const fragmentErrors = hls.levels.reduce((acc, level)=>acc + level.fragmentError, 0);\n        // Switch levels when out of retried or level index out of bounds\n        if (level) {\n            if (data.details !== ErrorDetails.FRAG_GAP) {\n                level.fragmentError++;\n            }\n            const retry = shouldRetry(retryConfig, fragmentErrors, isTimeoutError(data), data.response);\n            if (retry) {\n                return {\n                    action: NetworkErrorAction.RetryRequest,\n                    flags: ErrorActionFlags.None,\n                    retryConfig,\n                    retryCount: fragmentErrors\n                };\n            }\n        }\n        // Reach max retry count, or Missing level reference\n        // Switch to valid index\n        const errorAction = this.getLevelSwitchAction(data, variantLevelIndex);\n        // Add retry details to allow skipping of FRAG_PARSING_ERROR\n        if (retryConfig) {\n            errorAction.retryConfig = retryConfig;\n            errorAction.retryCount = fragmentErrors;\n        }\n        return errorAction;\n    }\n    getLevelSwitchAction(data, levelIndex) {\n        const hls = this.hls;\n        if (levelIndex === null || levelIndex === undefined) {\n            levelIndex = hls.loadLevel;\n        }\n        const level = this.hls.levels[levelIndex];\n        if (level) {\n            var _data$frag2, _data$context2;\n            const errorDetails = data.details;\n            level.loadError++;\n            if (errorDetails === ErrorDetails.BUFFER_APPEND_ERROR) {\n                level.fragmentError++;\n            }\n            // Search for next level to retry\n            let nextLevel = -1;\n            const { levels, loadLevel, minAutoLevel, maxAutoLevel } = hls;\n            if (!hls.autoLevelEnabled) {\n                hls.loadLevel = -1;\n            }\n            const fragErrorType = (_data$frag2 = data.frag) == null ? void 0 : _data$frag2.type;\n            // Find alternate audio codec if available on audio codec error\n            const isAudioCodecError = fragErrorType === PlaylistLevelType.AUDIO && errorDetails === ErrorDetails.FRAG_PARSING_ERROR || data.sourceBufferName === \"audio\" && (errorDetails === ErrorDetails.BUFFER_ADD_CODEC_ERROR || errorDetails === ErrorDetails.BUFFER_APPEND_ERROR);\n            const findAudioCodecAlternate = isAudioCodecError && levels.some(({ audioCodec })=>level.audioCodec !== audioCodec);\n            // Find alternate video codec if available on video codec error\n            const isVideoCodecError = data.sourceBufferName === \"video\" && (errorDetails === ErrorDetails.BUFFER_ADD_CODEC_ERROR || errorDetails === ErrorDetails.BUFFER_APPEND_ERROR);\n            const findVideoCodecAlternate = isVideoCodecError && levels.some(({ codecSet, audioCodec })=>level.codecSet !== codecSet && level.audioCodec === audioCodec);\n            const { type: playlistErrorType, groupId: playlistErrorGroupId } = (_data$context2 = data.context) != null ? _data$context2 : {};\n            for(let i = levels.length; i--;){\n                const candidate = (i + loadLevel) % levels.length;\n                if (candidate !== loadLevel && candidate >= minAutoLevel && candidate <= maxAutoLevel && levels[candidate].loadError === 0) {\n                    var _level$audioGroups, _level$subtitleGroups;\n                    const levelCandidate = levels[candidate];\n                    // Skip level switch if GAP tag is found in next level at same position\n                    if (errorDetails === ErrorDetails.FRAG_GAP && data.frag) {\n                        const levelDetails = levels[candidate].details;\n                        if (levelDetails) {\n                            const fragCandidate = findFragmentByPTS(data.frag, levelDetails.fragments, data.frag.start);\n                            if (fragCandidate != null && fragCandidate.gap) {\n                                continue;\n                            }\n                        }\n                    } else if (playlistErrorType === PlaylistContextType.AUDIO_TRACK && levelCandidate.hasAudioGroup(playlistErrorGroupId) || playlistErrorType === PlaylistContextType.SUBTITLE_TRACK && levelCandidate.hasSubtitleGroup(playlistErrorGroupId)) {\n                        continue;\n                    } else if (fragErrorType === PlaylistLevelType.AUDIO && (_level$audioGroups = level.audioGroups) != null && _level$audioGroups.some((groupId)=>levelCandidate.hasAudioGroup(groupId)) || fragErrorType === PlaylistLevelType.SUBTITLE && (_level$subtitleGroups = level.subtitleGroups) != null && _level$subtitleGroups.some((groupId)=>levelCandidate.hasSubtitleGroup(groupId)) || findAudioCodecAlternate && level.audioCodec === levelCandidate.audioCodec || !findAudioCodecAlternate && level.audioCodec !== levelCandidate.audioCodec || findVideoCodecAlternate && level.codecSet === levelCandidate.codecSet) {\n                        continue;\n                    }\n                    nextLevel = candidate;\n                    break;\n                }\n            }\n            if (nextLevel > -1 && hls.loadLevel !== nextLevel) {\n                data.levelRetry = true;\n                this.playlistError = 0;\n                return {\n                    action: NetworkErrorAction.SendAlternateToPenaltyBox,\n                    flags: ErrorActionFlags.None,\n                    nextAutoLevel: nextLevel\n                };\n            }\n        }\n        // No levels to switch / Manual level selection / Level not found\n        // Resolve with Pathway switch, Redundant fail-over, or stay on lowest Level\n        return {\n            action: NetworkErrorAction.SendAlternateToPenaltyBox,\n            flags: ErrorActionFlags.MoveAllAlternatesMatchingHost\n        };\n    }\n    onErrorOut(event, data) {\n        var _data$errorAction;\n        switch((_data$errorAction = data.errorAction) == null ? void 0 : _data$errorAction.action){\n            case NetworkErrorAction.DoNothing:\n                break;\n            case NetworkErrorAction.SendAlternateToPenaltyBox:\n                this.sendAlternateToPenaltyBox(data);\n                if (!data.errorAction.resolved && data.details !== ErrorDetails.FRAG_GAP) {\n                    data.fatal = true;\n                } else if (/MediaSource readyState: ended/.test(data.error.message)) {\n                    this.warn(`MediaSource ended after \"${data.sourceBufferName}\" sourceBuffer append error. Attempting to recover from media error.`);\n                    this.hls.recoverMediaError();\n                }\n                break;\n            case NetworkErrorAction.RetryRequest:\n                break;\n        }\n        if (data.fatal) {\n            this.hls.stopLoad();\n            return;\n        }\n    }\n    sendAlternateToPenaltyBox(data) {\n        const hls = this.hls;\n        const errorAction = data.errorAction;\n        if (!errorAction) {\n            return;\n        }\n        const { flags, hdcpLevel, nextAutoLevel } = errorAction;\n        switch(flags){\n            case ErrorActionFlags.None:\n                this.switchLevel(data, nextAutoLevel);\n                break;\n            case ErrorActionFlags.MoveAllAlternatesMatchingHDCP:\n                if (hdcpLevel) {\n                    hls.maxHdcpLevel = HdcpLevels[HdcpLevels.indexOf(hdcpLevel) - 1];\n                    errorAction.resolved = true;\n                }\n                this.warn(`Restricting playback to HDCP-LEVEL of \"${hls.maxHdcpLevel}\" or lower`);\n                break;\n        }\n        // If not resolved by previous actions try to switch to next level\n        if (!errorAction.resolved) {\n            this.switchLevel(data, nextAutoLevel);\n        }\n    }\n    switchLevel(data, levelIndex) {\n        if (levelIndex !== undefined && data.errorAction) {\n            this.warn(`switching to level ${levelIndex} after ${data.details}`);\n            this.hls.nextAutoLevel = levelIndex;\n            data.errorAction.resolved = true;\n            // Stream controller is responsible for this but won't switch on false start\n            this.hls.nextLoadLevel = this.hls.nextAutoLevel;\n        }\n    }\n}\nclass BasePlaylistController {\n    constructor(hls, logPrefix){\n        this.hls = void 0;\n        this.timer = -1;\n        this.requestScheduled = -1;\n        this.canLoad = false;\n        this.log = void 0;\n        this.warn = void 0;\n        this.log = logger.log.bind(logger, `${logPrefix}:`);\n        this.warn = logger.warn.bind(logger, `${logPrefix}:`);\n        this.hls = hls;\n    }\n    destroy() {\n        this.clearTimer();\n        // @ts-ignore\n        this.hls = this.log = this.warn = null;\n    }\n    clearTimer() {\n        if (this.timer !== -1) {\n            self.clearTimeout(this.timer);\n            this.timer = -1;\n        }\n    }\n    startLoad() {\n        this.canLoad = true;\n        this.requestScheduled = -1;\n        this.loadPlaylist();\n    }\n    stopLoad() {\n        this.canLoad = false;\n        this.clearTimer();\n    }\n    switchParams(playlistUri, previous) {\n        const renditionReports = previous == null ? void 0 : previous.renditionReports;\n        if (renditionReports) {\n            let foundIndex = -1;\n            for(let i = 0; i < renditionReports.length; i++){\n                const attr = renditionReports[i];\n                let uri;\n                try {\n                    uri = new self.URL(attr.URI, previous.url).href;\n                } catch (error) {\n                    logger.warn(`Could not construct new URL for Rendition Report: ${error}`);\n                    uri = attr.URI || \"\";\n                }\n                // Use exact match. Otherwise, the last partial match, if any, will be used\n                // (Playlist URI includes a query string that the Rendition Report does not)\n                if (uri === playlistUri) {\n                    foundIndex = i;\n                    break;\n                } else if (uri === playlistUri.substring(0, uri.length)) {\n                    foundIndex = i;\n                }\n            }\n            if (foundIndex !== -1) {\n                const attr = renditionReports[foundIndex];\n                const msn = parseInt(attr[\"LAST-MSN\"]) || (previous == null ? void 0 : previous.lastPartSn);\n                let part = parseInt(attr[\"LAST-PART\"]) || (previous == null ? void 0 : previous.lastPartIndex);\n                if (this.hls.config.lowLatencyMode) {\n                    const currentGoal = Math.min(previous.age - previous.partTarget, previous.targetduration);\n                    if (part >= 0 && currentGoal > previous.partTarget) {\n                        part += 1;\n                    }\n                }\n                return new HlsUrlParameters(msn, part >= 0 ? part : undefined, HlsSkip.No);\n            }\n        }\n    }\n    loadPlaylist(hlsUrlParameters) {\n        if (this.requestScheduled === -1) {\n            this.requestScheduled = self.performance.now();\n        }\n    // Loading is handled by the subclasses\n    }\n    shouldLoadPlaylist(playlist) {\n        return this.canLoad && !!playlist && !!playlist.url && (!playlist.details || playlist.details.live);\n    }\n    shouldReloadPlaylist(playlist) {\n        return this.timer === -1 && this.requestScheduled === -1 && this.shouldLoadPlaylist(playlist);\n    }\n    playlistLoaded(index, data, previousDetails) {\n        const { details, stats } = data;\n        // Set last updated date-time\n        const now = self.performance.now();\n        const elapsed = stats.loading.first ? Math.max(0, now - stats.loading.first) : 0;\n        details.advancedDateTime = Date.now() - elapsed;\n        // if current playlist is a live playlist, arm a timer to reload it\n        if (details.live || previousDetails != null && previousDetails.live) {\n            details.reloaded(previousDetails);\n            if (previousDetails) {\n                this.log(`live playlist ${index} ${details.advanced ? \"REFRESHED \" + details.lastPartSn + \"-\" + details.lastPartIndex : details.updated ? \"UPDATED\" : \"MISSED\"}`);\n            }\n            // Merge live playlists to adjust fragment starts and fill in delta playlist skipped segments\n            if (previousDetails && details.fragments.length > 0) {\n                mergeDetails(previousDetails, details);\n            }\n            if (!this.canLoad || !details.live) {\n                return;\n            }\n            let deliveryDirectives;\n            let msn = undefined;\n            let part = undefined;\n            if (details.canBlockReload && details.endSN && details.advanced) {\n                // Load level with LL-HLS delivery directives\n                const lowLatencyMode = this.hls.config.lowLatencyMode;\n                const lastPartSn = details.lastPartSn;\n                const endSn = details.endSN;\n                const lastPartIndex = details.lastPartIndex;\n                const hasParts = lastPartIndex !== -1;\n                const lastPart = lastPartSn === endSn;\n                // When low latency mode is disabled, we'll skip part requests once the last part index is found\n                const nextSnStartIndex = lowLatencyMode ? 0 : lastPartIndex;\n                if (hasParts) {\n                    msn = lastPart ? endSn + 1 : lastPartSn;\n                    part = lastPart ? nextSnStartIndex : lastPartIndex + 1;\n                } else {\n                    msn = endSn + 1;\n                }\n                // Low-Latency CDN Tune-in: \"age\" header and time since load indicates we're behind by more than one part\n                // Update directives to obtain the Playlist that has the estimated additional duration of media\n                const lastAdvanced = details.age;\n                const cdnAge = lastAdvanced + details.ageHeader;\n                let currentGoal = Math.min(cdnAge - details.partTarget, details.targetduration * 1.5);\n                if (currentGoal > 0) {\n                    if (previousDetails && currentGoal > previousDetails.tuneInGoal) {\n                        // If we attempted to get the next or latest playlist update, but currentGoal increased,\n                        // then we either can't catchup, or the \"age\" header cannot be trusted.\n                        this.warn(`CDN Tune-in goal increased from: ${previousDetails.tuneInGoal} to: ${currentGoal} with playlist age: ${details.age}`);\n                        currentGoal = 0;\n                    } else {\n                        const segments = Math.floor(currentGoal / details.targetduration);\n                        msn += segments;\n                        if (part !== undefined) {\n                            const parts = Math.round(currentGoal % details.targetduration / details.partTarget);\n                            part += parts;\n                        }\n                        this.log(`CDN Tune-in age: ${details.ageHeader}s last advanced ${lastAdvanced.toFixed(2)}s goal: ${currentGoal} skip sn ${segments} to part ${part}`);\n                    }\n                    details.tuneInGoal = currentGoal;\n                }\n                deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);\n                if (lowLatencyMode || !lastPart) {\n                    this.loadPlaylist(deliveryDirectives);\n                    return;\n                }\n            } else if (details.canBlockReload || details.canSkipUntil) {\n                deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);\n            }\n            const bufferInfo = this.hls.mainForwardBufferInfo;\n            const position = bufferInfo ? bufferInfo.end - bufferInfo.len : 0;\n            const distanceToLiveEdgeMs = (details.edge - position) * 1000;\n            const reloadInterval = computeReloadInterval(details, distanceToLiveEdgeMs);\n            if (details.updated && now > this.requestScheduled + reloadInterval) {\n                this.requestScheduled = stats.loading.start;\n            }\n            if (msn !== undefined && details.canBlockReload) {\n                this.requestScheduled = stats.loading.first + reloadInterval - (details.partTarget * 1000 || 1000);\n            } else if (this.requestScheduled === -1 || this.requestScheduled + reloadInterval < now) {\n                this.requestScheduled = now;\n            } else if (this.requestScheduled - now <= 0) {\n                this.requestScheduled += reloadInterval;\n            }\n            let estimatedTimeUntilUpdate = this.requestScheduled - now;\n            estimatedTimeUntilUpdate = Math.max(0, estimatedTimeUntilUpdate);\n            this.log(`reload live playlist ${index} in ${Math.round(estimatedTimeUntilUpdate)} ms`);\n            // this.log(\n            //   `live reload ${details.updated ? 'REFRESHED' : 'MISSED'}\n            // reload in ${estimatedTimeUntilUpdate / 1000}\n            // round trip ${(stats.loading.end - stats.loading.start) / 1000}\n            // diff ${\n            //   (reloadInterval -\n            //     (estimatedTimeUntilUpdate +\n            //       stats.loading.end -\n            //       stats.loading.start)) /\n            //   1000\n            // }\n            // reload interval ${reloadInterval / 1000}\n            // target duration ${details.targetduration}\n            // distance to edge ${distanceToLiveEdgeMs / 1000}`\n            // );\n            this.timer = self.setTimeout(()=>this.loadPlaylist(deliveryDirectives), estimatedTimeUntilUpdate);\n        } else {\n            this.clearTimer();\n        }\n    }\n    getDeliveryDirectives(details, previousDeliveryDirectives, msn, part) {\n        let skip = getSkipValue(details, msn);\n        if (previousDeliveryDirectives != null && previousDeliveryDirectives.skip && details.deltaUpdateFailed) {\n            msn = previousDeliveryDirectives.msn;\n            part = previousDeliveryDirectives.part;\n            skip = HlsSkip.No;\n        }\n        return new HlsUrlParameters(msn, part, skip);\n    }\n    checkRetry(errorEvent) {\n        const errorDetails = errorEvent.details;\n        const isTimeout = isTimeoutError(errorEvent);\n        const errorAction = errorEvent.errorAction;\n        const { action, retryCount = 0, retryConfig } = errorAction || {};\n        const retry = !!errorAction && !!retryConfig && (action === NetworkErrorAction.RetryRequest || !errorAction.resolved && action === NetworkErrorAction.SendAlternateToPenaltyBox);\n        if (retry) {\n            var _errorEvent$context;\n            this.requestScheduled = -1;\n            if (retryCount >= retryConfig.maxNumRetry) {\n                return false;\n            }\n            if (isTimeout && (_errorEvent$context = errorEvent.context) != null && _errorEvent$context.deliveryDirectives) {\n                // The LL-HLS request already timed out so retry immediately\n                this.warn(`Retrying playlist loading ${retryCount + 1}/${retryConfig.maxNumRetry} after \"${errorDetails}\" without delivery-directives`);\n                this.loadPlaylist();\n            } else {\n                const delay = getRetryDelay(retryConfig, retryCount);\n                // Schedule level/track reload\n                this.timer = self.setTimeout(()=>this.loadPlaylist(), delay);\n                this.warn(`Retrying playlist loading ${retryCount + 1}/${retryConfig.maxNumRetry} after \"${errorDetails}\" in ${delay}ms`);\n            }\n            // `levelRetry = true` used to inform other controllers that a retry is happening\n            errorEvent.levelRetry = true;\n            errorAction.resolved = true;\n        }\n        return retry;\n    }\n}\n/*\n * compute an Exponential Weighted moving average\n * - https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average\n *  - heavily inspired from shaka-player\n */ class EWMA {\n    //  About half of the estimated value will be from the last |halfLife| samples by weight.\n    constructor(halfLife, estimate = 0, weight = 0){\n        this.halfLife = void 0;\n        this.alpha_ = void 0;\n        this.estimate_ = void 0;\n        this.totalWeight_ = void 0;\n        this.halfLife = halfLife;\n        // Larger values of alpha expire historical data more slowly.\n        this.alpha_ = halfLife ? Math.exp(Math.log(0.5) / halfLife) : 0;\n        this.estimate_ = estimate;\n        this.totalWeight_ = weight;\n    }\n    sample(weight, value) {\n        const adjAlpha = Math.pow(this.alpha_, weight);\n        this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;\n        this.totalWeight_ += weight;\n    }\n    getTotalWeight() {\n        return this.totalWeight_;\n    }\n    getEstimate() {\n        if (this.alpha_) {\n            const zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);\n            if (zeroFactor) {\n                return this.estimate_ / zeroFactor;\n            }\n        }\n        return this.estimate_;\n    }\n}\n/*\n * EWMA Bandwidth Estimator\n *  - heavily inspired from shaka-player\n * Tracks bandwidth samples and estimates available bandwidth.\n * Based on the minimum of two exponentially-weighted moving averages with\n * different half-lives.\n */ class EwmaBandWidthEstimator {\n    constructor(slow, fast, defaultEstimate, defaultTTFB = 100){\n        this.defaultEstimate_ = void 0;\n        this.minWeight_ = void 0;\n        this.minDelayMs_ = void 0;\n        this.slow_ = void 0;\n        this.fast_ = void 0;\n        this.defaultTTFB_ = void 0;\n        this.ttfb_ = void 0;\n        this.defaultEstimate_ = defaultEstimate;\n        this.minWeight_ = 0.001;\n        this.minDelayMs_ = 50;\n        this.slow_ = new EWMA(slow);\n        this.fast_ = new EWMA(fast);\n        this.defaultTTFB_ = defaultTTFB;\n        this.ttfb_ = new EWMA(slow);\n    }\n    update(slow, fast) {\n        const { slow_, fast_, ttfb_ } = this;\n        if (slow_.halfLife !== slow) {\n            this.slow_ = new EWMA(slow, slow_.getEstimate(), slow_.getTotalWeight());\n        }\n        if (fast_.halfLife !== fast) {\n            this.fast_ = new EWMA(fast, fast_.getEstimate(), fast_.getTotalWeight());\n        }\n        if (ttfb_.halfLife !== slow) {\n            this.ttfb_ = new EWMA(slow, ttfb_.getEstimate(), ttfb_.getTotalWeight());\n        }\n    }\n    sample(durationMs, numBytes) {\n        durationMs = Math.max(durationMs, this.minDelayMs_);\n        const numBits = 8 * numBytes;\n        // weight is duration in seconds\n        const durationS = durationMs / 1000;\n        // value is bandwidth in bits/s\n        const bandwidthInBps = numBits / durationS;\n        this.fast_.sample(durationS, bandwidthInBps);\n        this.slow_.sample(durationS, bandwidthInBps);\n    }\n    sampleTTFB(ttfb) {\n        // weight is frequency curve applied to TTFB in seconds\n        // (longer times have less weight with expected input under 1 second)\n        const seconds = ttfb / 1000;\n        const weight = Math.sqrt(2) * Math.exp(-Math.pow(seconds, 2) / 2);\n        this.ttfb_.sample(weight, Math.max(ttfb, 5));\n    }\n    canEstimate() {\n        return this.fast_.getTotalWeight() >= this.minWeight_;\n    }\n    getEstimate() {\n        if (this.canEstimate()) {\n            // console.log('slow estimate:'+ Math.round(this.slow_.getEstimate()));\n            // console.log('fast estimate:'+ Math.round(this.fast_.getEstimate()));\n            // Take the minimum of these two estimates.  This should have the effect of\n            // adapting down quickly, but up more slowly.\n            return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());\n        } else {\n            return this.defaultEstimate_;\n        }\n    }\n    getEstimateTTFB() {\n        if (this.ttfb_.getTotalWeight() >= this.minWeight_) {\n            return this.ttfb_.getEstimate();\n        } else {\n            return this.defaultTTFB_;\n        }\n    }\n    destroy() {}\n}\nconst SUPPORTED_INFO_DEFAULT = {\n    supported: true,\n    configurations: [],\n    decodingInfoResults: [\n        {\n            supported: true,\n            powerEfficient: true,\n            smooth: true\n        }\n    ]\n};\nconst SUPPORTED_INFO_CACHE = {};\nfunction requiresMediaCapabilitiesDecodingInfo(level, audioTracksByGroup, currentVideoRange, currentFrameRate, currentBw, audioPreference) {\n    // Only test support when configuration is exceeds minimum options\n    const audioGroups = level.audioCodec ? level.audioGroups : null;\n    const audioCodecPreference = audioPreference == null ? void 0 : audioPreference.audioCodec;\n    const channelsPreference = audioPreference == null ? void 0 : audioPreference.channels;\n    const maxChannels = channelsPreference ? parseInt(channelsPreference) : audioCodecPreference ? Infinity : 2;\n    let audioChannels = null;\n    if (audioGroups != null && audioGroups.length) {\n        try {\n            if (audioGroups.length === 1 && audioGroups[0]) {\n                audioChannels = audioTracksByGroup.groups[audioGroups[0]].channels;\n            } else {\n                audioChannels = audioGroups.reduce((acc, groupId)=>{\n                    if (groupId) {\n                        const audioTrackGroup = audioTracksByGroup.groups[groupId];\n                        if (!audioTrackGroup) {\n                            throw new Error(`Audio track group ${groupId} not found`);\n                        }\n                        // Sum all channel key values\n                        Object.keys(audioTrackGroup.channels).forEach((key)=>{\n                            acc[key] = (acc[key] || 0) + audioTrackGroup.channels[key];\n                        });\n                    }\n                    return acc;\n                }, {\n                    2: 0\n                });\n            }\n        } catch (error) {\n            return true;\n        }\n    }\n    return level.videoCodec !== undefined && (level.width > 1920 && level.height > 1088 || level.height > 1920 && level.width > 1088 || level.frameRate > Math.max(currentFrameRate, 30) || level.videoRange !== \"SDR\" && level.videoRange !== currentVideoRange || level.bitrate > Math.max(currentBw, 8e6)) || !!audioChannels && isFiniteNumber(maxChannels) && Object.keys(audioChannels).some((channels)=>parseInt(channels) > maxChannels);\n}\nfunction getMediaDecodingInfoPromise(level, audioTracksByGroup, mediaCapabilities) {\n    const videoCodecs = level.videoCodec;\n    const audioCodecs = level.audioCodec;\n    if (!videoCodecs || !audioCodecs || !mediaCapabilities) {\n        return Promise.resolve(SUPPORTED_INFO_DEFAULT);\n    }\n    const baseVideoConfiguration = {\n        width: level.width,\n        height: level.height,\n        bitrate: Math.ceil(Math.max(level.bitrate * 0.9, level.averageBitrate)),\n        // Assume a framerate of 30fps since MediaCapabilities will not accept Level default of 0.\n        framerate: level.frameRate || 30\n    };\n    const videoRange = level.videoRange;\n    if (videoRange !== \"SDR\") {\n        baseVideoConfiguration.transferFunction = videoRange.toLowerCase();\n    }\n    const configurations = videoCodecs.split(\",\").map((videoCodec)=>({\n            type: \"media-source\",\n            video: _objectSpread2(_objectSpread2({}, baseVideoConfiguration), {}, {\n                contentType: mimeTypeForCodec(videoCodec, \"video\")\n            })\n        }));\n    if (audioCodecs && level.audioGroups) {\n        level.audioGroups.forEach((audioGroupId)=>{\n            var _audioTracksByGroup$g;\n            if (!audioGroupId) {\n                return;\n            }\n            (_audioTracksByGroup$g = audioTracksByGroup.groups[audioGroupId]) == null ? void 0 : _audioTracksByGroup$g.tracks.forEach((audioTrack)=>{\n                if (audioTrack.groupId === audioGroupId) {\n                    const channels = audioTrack.channels || \"\";\n                    const channelsNumber = parseFloat(channels);\n                    if (isFiniteNumber(channelsNumber) && channelsNumber > 2) {\n                        configurations.push.apply(configurations, audioCodecs.split(\",\").map((audioCodec)=>({\n                                type: \"media-source\",\n                                audio: {\n                                    contentType: mimeTypeForCodec(audioCodec, \"audio\"),\n                                    channels: \"\" + channelsNumber\n                                }\n                            })));\n                    }\n                }\n            });\n        });\n    }\n    return Promise.all(configurations.map((configuration)=>{\n        // Cache MediaCapabilities promises\n        const decodingInfoKey = getMediaDecodingInfoKey(configuration);\n        return SUPPORTED_INFO_CACHE[decodingInfoKey] || (SUPPORTED_INFO_CACHE[decodingInfoKey] = mediaCapabilities.decodingInfo(configuration));\n    })).then((decodingInfoResults)=>({\n            supported: !decodingInfoResults.some((info)=>!info.supported),\n            configurations,\n            decodingInfoResults\n        })).catch((error)=>({\n            supported: false,\n            configurations,\n            decodingInfoResults: [],\n            error\n        }));\n}\nfunction getMediaDecodingInfoKey(config) {\n    const { audio, video } = config;\n    const mediaConfig = video || audio;\n    if (mediaConfig) {\n        const codec = mediaConfig.contentType.split('\"')[1];\n        if (video) {\n            return `r${video.height}x${video.width}f${Math.ceil(video.framerate)}${video.transferFunction || \"sd\"}_${codec}_${Math.ceil(video.bitrate / 1e5)}`;\n        }\n        if (audio) {\n            return `c${audio.channels}${audio.spatialRendering ? \"s\" : \"n\"}_${codec}`;\n        }\n    }\n    return \"\";\n}\n/**\n * @returns Whether we can detect and validate HDR capability within the window context\n */ function isHdrSupported() {\n    if (typeof matchMedia === \"function\") {\n        const mediaQueryList = matchMedia(\"(dynamic-range: high)\");\n        const badQuery = matchMedia(\"bad query\");\n        if (mediaQueryList.media !== badQuery.media) {\n            return mediaQueryList.matches === true;\n        }\n    }\n    return false;\n}\n/**\n * Sanitizes inputs to return the active video selection options for HDR/SDR.\n * When both inputs are null:\n *\n *    `{ preferHDR: false, allowedVideoRanges: [] }`\n *\n * When `currentVideoRange` non-null, maintain the active range:\n *\n *    `{ preferHDR: currentVideoRange !== 'SDR', allowedVideoRanges: [currentVideoRange] }`\n *\n * When VideoSelectionOption non-null:\n *\n *  - Allow all video ranges if `allowedVideoRanges` unspecified.\n *  - If `preferHDR` is non-null use the value to filter `allowedVideoRanges`.\n *  - Else check window for HDR support and set `preferHDR` to the result.\n *\n * @param currentVideoRange\n * @param videoPreference\n */ function getVideoSelectionOptions(currentVideoRange, videoPreference) {\n    let preferHDR = false;\n    let allowedVideoRanges = [];\n    if (currentVideoRange) {\n        preferHDR = currentVideoRange !== \"SDR\";\n        allowedVideoRanges = [\n            currentVideoRange\n        ];\n    }\n    if (videoPreference) {\n        allowedVideoRanges = videoPreference.allowedVideoRanges || VideoRangeValues.slice(0);\n        preferHDR = videoPreference.preferHDR !== undefined ? videoPreference.preferHDR : isHdrSupported();\n        if (preferHDR) {\n            allowedVideoRanges = allowedVideoRanges.filter((range)=>range !== \"SDR\");\n        } else {\n            allowedVideoRanges = [\n                \"SDR\"\n            ];\n        }\n    }\n    return {\n        preferHDR,\n        allowedVideoRanges\n    };\n}\nfunction getStartCodecTier(codecTiers, currentVideoRange, currentBw, audioPreference, videoPreference) {\n    const codecSets = Object.keys(codecTiers);\n    const channelsPreference = audioPreference == null ? void 0 : audioPreference.channels;\n    const audioCodecPreference = audioPreference == null ? void 0 : audioPreference.audioCodec;\n    const preferStereo = channelsPreference && parseInt(channelsPreference) === 2;\n    // Use first level set to determine stereo, and minimum resolution and framerate\n    let hasStereo = true;\n    let hasCurrentVideoRange = false;\n    let minHeight = Infinity;\n    let minFramerate = Infinity;\n    let minBitrate = Infinity;\n    let selectedScore = 0;\n    let videoRanges = [];\n    const { preferHDR, allowedVideoRanges } = getVideoSelectionOptions(currentVideoRange, videoPreference);\n    for(let i = codecSets.length; i--;){\n        const tier = codecTiers[codecSets[i]];\n        hasStereo = tier.channels[2] > 0;\n        minHeight = Math.min(minHeight, tier.minHeight);\n        minFramerate = Math.min(minFramerate, tier.minFramerate);\n        minBitrate = Math.min(minBitrate, tier.minBitrate);\n        const matchingVideoRanges = allowedVideoRanges.filter((range)=>tier.videoRanges[range] > 0);\n        if (matchingVideoRanges.length > 0) {\n            hasCurrentVideoRange = true;\n            videoRanges = matchingVideoRanges;\n        }\n    }\n    minHeight = isFiniteNumber(minHeight) ? minHeight : 0;\n    minFramerate = isFiniteNumber(minFramerate) ? minFramerate : 0;\n    const maxHeight = Math.max(1080, minHeight);\n    const maxFramerate = Math.max(30, minFramerate);\n    minBitrate = isFiniteNumber(minBitrate) ? minBitrate : currentBw;\n    currentBw = Math.max(minBitrate, currentBw);\n    // If there are no variants with matching preference, set currentVideoRange to undefined\n    if (!hasCurrentVideoRange) {\n        currentVideoRange = undefined;\n        videoRanges = [];\n    }\n    const codecSet = codecSets.reduce((selected, candidate)=>{\n        // Remove candiates which do not meet bitrate, default audio, stereo or channels preference, 1080p or lower, 30fps or lower, or SDR/HDR selection if present\n        const candidateTier = codecTiers[candidate];\n        if (candidate === selected) {\n            return selected;\n        }\n        if (candidateTier.minBitrate > currentBw) {\n            logStartCodecCandidateIgnored(candidate, `min bitrate of ${candidateTier.minBitrate} > current estimate of ${currentBw}`);\n            return selected;\n        }\n        if (!candidateTier.hasDefaultAudio) {\n            logStartCodecCandidateIgnored(candidate, `no renditions with default or auto-select sound found`);\n            return selected;\n        }\n        if (audioCodecPreference && candidate.indexOf(audioCodecPreference.substring(0, 4)) % 5 !== 0) {\n            logStartCodecCandidateIgnored(candidate, `audio codec preference \"${audioCodecPreference}\" not found`);\n            return selected;\n        }\n        if (channelsPreference && !preferStereo) {\n            if (!candidateTier.channels[channelsPreference]) {\n                logStartCodecCandidateIgnored(candidate, `no renditions with ${channelsPreference} channel sound found (channels options: ${Object.keys(candidateTier.channels)})`);\n                return selected;\n            }\n        } else if ((!audioCodecPreference || preferStereo) && hasStereo && candidateTier.channels[\"2\"] === 0) {\n            logStartCodecCandidateIgnored(candidate, `no renditions with stereo sound found`);\n            return selected;\n        }\n        if (candidateTier.minHeight > maxHeight) {\n            logStartCodecCandidateIgnored(candidate, `min resolution of ${candidateTier.minHeight} > maximum of ${maxHeight}`);\n            return selected;\n        }\n        if (candidateTier.minFramerate > maxFramerate) {\n            logStartCodecCandidateIgnored(candidate, `min framerate of ${candidateTier.minFramerate} > maximum of ${maxFramerate}`);\n            return selected;\n        }\n        if (!videoRanges.some((range)=>candidateTier.videoRanges[range] > 0)) {\n            logStartCodecCandidateIgnored(candidate, `no variants with VIDEO-RANGE of ${JSON.stringify(videoRanges)} found`);\n            return selected;\n        }\n        if (candidateTier.maxScore < selectedScore) {\n            logStartCodecCandidateIgnored(candidate, `max score of ${candidateTier.maxScore} < selected max of ${selectedScore}`);\n            return selected;\n        }\n        // Remove candiates with less preferred codecs or more errors\n        if (selected && (codecsSetSelectionPreferenceValue(candidate) >= codecsSetSelectionPreferenceValue(selected) || candidateTier.fragmentError > codecTiers[selected].fragmentError)) {\n            return selected;\n        }\n        selectedScore = candidateTier.maxScore;\n        return candidate;\n    }, undefined);\n    return {\n        codecSet,\n        videoRanges,\n        preferHDR,\n        minFramerate,\n        minBitrate\n    };\n}\nfunction logStartCodecCandidateIgnored(codeSet, reason) {\n    logger.log(`[abr] start candidates with \"${codeSet}\" ignored because ${reason}`);\n}\nfunction getAudioTracksByGroup(allAudioTracks) {\n    return allAudioTracks.reduce((audioTracksByGroup, track)=>{\n        let trackGroup = audioTracksByGroup.groups[track.groupId];\n        if (!trackGroup) {\n            trackGroup = audioTracksByGroup.groups[track.groupId] = {\n                tracks: [],\n                channels: {\n                    2: 0\n                },\n                hasDefault: false,\n                hasAutoSelect: false\n            };\n        }\n        trackGroup.tracks.push(track);\n        const channelsKey = track.channels || \"2\";\n        trackGroup.channels[channelsKey] = (trackGroup.channels[channelsKey] || 0) + 1;\n        trackGroup.hasDefault = trackGroup.hasDefault || track.default;\n        trackGroup.hasAutoSelect = trackGroup.hasAutoSelect || track.autoselect;\n        if (trackGroup.hasDefault) {\n            audioTracksByGroup.hasDefaultAudio = true;\n        }\n        if (trackGroup.hasAutoSelect) {\n            audioTracksByGroup.hasAutoSelectAudio = true;\n        }\n        return audioTracksByGroup;\n    }, {\n        hasDefaultAudio: false,\n        hasAutoSelectAudio: false,\n        groups: {}\n    });\n}\nfunction getCodecTiers(levels, audioTracksByGroup, minAutoLevel, maxAutoLevel) {\n    return levels.slice(minAutoLevel, maxAutoLevel + 1).reduce((tiers, level)=>{\n        if (!level.codecSet) {\n            return tiers;\n        }\n        const audioGroups = level.audioGroups;\n        let tier = tiers[level.codecSet];\n        if (!tier) {\n            tiers[level.codecSet] = tier = {\n                minBitrate: Infinity,\n                minHeight: Infinity,\n                minFramerate: Infinity,\n                maxScore: 0,\n                videoRanges: {\n                    SDR: 0\n                },\n                channels: {\n                    \"2\": 0\n                },\n                hasDefaultAudio: !audioGroups,\n                fragmentError: 0\n            };\n        }\n        tier.minBitrate = Math.min(tier.minBitrate, level.bitrate);\n        const lesserWidthOrHeight = Math.min(level.height, level.width);\n        tier.minHeight = Math.min(tier.minHeight, lesserWidthOrHeight);\n        tier.minFramerate = Math.min(tier.minFramerate, level.frameRate);\n        tier.maxScore = Math.max(tier.maxScore, level.score);\n        tier.fragmentError += level.fragmentError;\n        tier.videoRanges[level.videoRange] = (tier.videoRanges[level.videoRange] || 0) + 1;\n        if (audioGroups) {\n            audioGroups.forEach((audioGroupId)=>{\n                if (!audioGroupId) {\n                    return;\n                }\n                const audioGroup = audioTracksByGroup.groups[audioGroupId];\n                // Default audio is any group with DEFAULT=YES, or if missing then any group with AUTOSELECT=YES, or all variants\n                tier.hasDefaultAudio = tier.hasDefaultAudio || audioTracksByGroup.hasDefaultAudio ? audioGroup.hasDefault : audioGroup.hasAutoSelect || !audioTracksByGroup.hasDefaultAudio && !audioTracksByGroup.hasAutoSelectAudio;\n                Object.keys(audioGroup.channels).forEach((channels)=>{\n                    tier.channels[channels] = (tier.channels[channels] || 0) + audioGroup.channels[channels];\n                });\n            });\n        }\n        return tiers;\n    }, {});\n}\nfunction findMatchingOption(option, tracks, matchPredicate) {\n    if (\"attrs\" in option) {\n        const index = tracks.indexOf(option);\n        if (index !== -1) {\n            return index;\n        }\n    }\n    for(let i = 0; i < tracks.length; i++){\n        const track = tracks[i];\n        if (matchesOption(option, track, matchPredicate)) {\n            return i;\n        }\n    }\n    return -1;\n}\nfunction matchesOption(option, track, matchPredicate) {\n    const { groupId, name, lang, assocLang, characteristics, default: isDefault } = option;\n    const forced = option.forced;\n    return (groupId === undefined || track.groupId === groupId) && (name === undefined || track.name === name) && (lang === undefined || track.lang === lang) && (lang === undefined || track.assocLang === assocLang) && (isDefault === undefined || track.default === isDefault) && (forced === undefined || track.forced === forced) && (characteristics === undefined || characteristicsMatch(characteristics, track.characteristics)) && (matchPredicate === undefined || matchPredicate(option, track));\n}\nfunction characteristicsMatch(characteristicsA, characteristicsB = \"\") {\n    const arrA = characteristicsA.split(\",\");\n    const arrB = characteristicsB.split(\",\");\n    // Expects each item to be unique:\n    return arrA.length === arrB.length && !arrA.some((el)=>arrB.indexOf(el) === -1);\n}\nfunction audioMatchPredicate(option, track) {\n    const { audioCodec, channels } = option;\n    return (audioCodec === undefined || (track.audioCodec || \"\").substring(0, 4) === audioCodec.substring(0, 4)) && (channels === undefined || channels === (track.channels || \"2\"));\n}\nfunction findClosestLevelWithAudioGroup(option, levels, allAudioTracks, searchIndex, matchPredicate) {\n    const currentLevel = levels[searchIndex];\n    // Are there variants with same URI as current level?\n    // If so, find a match that does not require any level URI change\n    const variants = levels.reduce((variantMap, level, index)=>{\n        const uri = level.uri;\n        const renditions = variantMap[uri] || (variantMap[uri] = []);\n        renditions.push(index);\n        return variantMap;\n    }, {});\n    const renditions = variants[currentLevel.uri];\n    if (renditions.length > 1) {\n        searchIndex = Math.max.apply(Math, renditions);\n    }\n    // Find best match\n    const currentVideoRange = currentLevel.videoRange;\n    const currentFrameRate = currentLevel.frameRate;\n    const currentVideoCodec = currentLevel.codecSet.substring(0, 4);\n    const matchingVideo = searchDownAndUpList(levels, searchIndex, (level)=>{\n        if (level.videoRange !== currentVideoRange || level.frameRate !== currentFrameRate || level.codecSet.substring(0, 4) !== currentVideoCodec) {\n            return false;\n        }\n        const audioGroups = level.audioGroups;\n        const tracks = allAudioTracks.filter((track)=>!audioGroups || audioGroups.indexOf(track.groupId) !== -1);\n        return findMatchingOption(option, tracks, matchPredicate) > -1;\n    });\n    if (matchingVideo > -1) {\n        return matchingVideo;\n    }\n    return searchDownAndUpList(levels, searchIndex, (level)=>{\n        const audioGroups = level.audioGroups;\n        const tracks = allAudioTracks.filter((track)=>!audioGroups || audioGroups.indexOf(track.groupId) !== -1);\n        return findMatchingOption(option, tracks, matchPredicate) > -1;\n    });\n}\nfunction searchDownAndUpList(arr, searchIndex, predicate) {\n    for(let i = searchIndex; i; i--){\n        if (predicate(arr[i])) {\n            return i;\n        }\n    }\n    for(let i = searchIndex + 1; i < arr.length; i++){\n        if (predicate(arr[i])) {\n            return i;\n        }\n    }\n    return -1;\n}\nclass AbrController {\n    constructor(_hls){\n        this.hls = void 0;\n        this.lastLevelLoadSec = 0;\n        this.lastLoadedFragLevel = -1;\n        this.firstSelection = -1;\n        this._nextAutoLevel = -1;\n        this.nextAutoLevelKey = \"\";\n        this.audioTracksByGroup = null;\n        this.codecTiers = null;\n        this.timer = -1;\n        this.fragCurrent = null;\n        this.partCurrent = null;\n        this.bitrateTestDelay = 0;\n        this.bwEstimator = void 0;\n        /*\n        This method monitors the download rate of the current fragment, and will downswitch if that fragment will not load\n        quickly enough to prevent underbuffering\n      */ this._abandonRulesCheck = ()=>{\n            const { fragCurrent: frag, partCurrent: part, hls } = this;\n            const { autoLevelEnabled, media } = hls;\n            if (!frag || !media) {\n                return;\n            }\n            const now = performance.now();\n            const stats = part ? part.stats : frag.stats;\n            const duration = part ? part.duration : frag.duration;\n            const timeLoading = now - stats.loading.start;\n            const minAutoLevel = hls.minAutoLevel;\n            // If frag loading is aborted, complete, or from lowest level, stop timer and return\n            if (stats.aborted || stats.loaded && stats.loaded === stats.total || frag.level <= minAutoLevel) {\n                this.clearTimer();\n                // reset forced auto level value so that next level will be selected\n                this._nextAutoLevel = -1;\n                return;\n            }\n            // This check only runs if we're in ABR mode and actually playing\n            if (!autoLevelEnabled || media.paused || !media.playbackRate || !media.readyState) {\n                return;\n            }\n            const bufferInfo = hls.mainForwardBufferInfo;\n            if (bufferInfo === null) {\n                return;\n            }\n            const ttfbEstimate = this.bwEstimator.getEstimateTTFB();\n            const playbackRate = Math.abs(media.playbackRate);\n            // To maintain stable adaptive playback, only begin monitoring frag loading after half or more of its playback duration has passed\n            if (timeLoading <= Math.max(ttfbEstimate, 1000 * (duration / (playbackRate * 2)))) {\n                return;\n            }\n            // bufferStarvationDelay is an estimate of the amount time (in seconds) it will take to exhaust the buffer\n            const bufferStarvationDelay = bufferInfo.len / playbackRate;\n            const ttfb = stats.loading.first ? stats.loading.first - stats.loading.start : -1;\n            const loadedFirstByte = stats.loaded && ttfb > -1;\n            const bwEstimate = this.getBwEstimate();\n            const levels = hls.levels;\n            const level = levels[frag.level];\n            const expectedLen = stats.total || Math.max(stats.loaded, Math.round(duration * level.averageBitrate / 8));\n            let timeStreaming = loadedFirstByte ? timeLoading - ttfb : timeLoading;\n            if (timeStreaming < 1 && loadedFirstByte) {\n                timeStreaming = Math.min(timeLoading, stats.loaded * 8 / bwEstimate);\n            }\n            const loadRate = loadedFirstByte ? stats.loaded * 1000 / timeStreaming : 0;\n            // fragLoadDelay is an estimate of the time (in seconds) it will take to buffer the remainder of the fragment\n            const fragLoadedDelay = loadRate ? (expectedLen - stats.loaded) / loadRate : expectedLen * 8 / bwEstimate + ttfbEstimate / 1000;\n            // Only downswitch if the time to finish loading the current fragment is greater than the amount of buffer left\n            if (fragLoadedDelay <= bufferStarvationDelay) {\n                return;\n            }\n            const bwe = loadRate ? loadRate * 8 : bwEstimate;\n            let fragLevelNextLoadedDelay = Number.POSITIVE_INFINITY;\n            let nextLoadLevel;\n            // Iterate through lower level and try to find the largest one that avoids rebuffering\n            for(nextLoadLevel = frag.level - 1; nextLoadLevel > minAutoLevel; nextLoadLevel--){\n                // compute time to load next fragment at lower level\n                // 8 = bits per byte (bps/Bps)\n                const levelNextBitrate = levels[nextLoadLevel].maxBitrate;\n                fragLevelNextLoadedDelay = this.getTimeToLoadFrag(ttfbEstimate / 1000, bwe, duration * levelNextBitrate, !levels[nextLoadLevel].details);\n                if (fragLevelNextLoadedDelay < bufferStarvationDelay) {\n                    break;\n                }\n            }\n            // Only emergency switch down if it takes less time to load a new fragment at lowest level instead of continuing\n            // to load the current one\n            if (fragLevelNextLoadedDelay >= fragLoadedDelay) {\n                return;\n            }\n            // if estimated load time of new segment is completely unreasonable, ignore and do not emergency switch down\n            if (fragLevelNextLoadedDelay > duration * 10) {\n                return;\n            }\n            hls.nextLoadLevel = hls.nextAutoLevel = nextLoadLevel;\n            if (loadedFirstByte) {\n                // If there has been loading progress, sample bandwidth using loading time offset by minimum TTFB time\n                this.bwEstimator.sample(timeLoading - Math.min(ttfbEstimate, ttfb), stats.loaded);\n            } else {\n                // If there has been no loading progress, sample TTFB\n                this.bwEstimator.sampleTTFB(timeLoading);\n            }\n            const nextLoadLevelBitrate = levels[nextLoadLevel].maxBitrate;\n            if (this.getBwEstimate() * this.hls.config.abrBandWidthUpFactor > nextLoadLevelBitrate) {\n                this.resetEstimator(nextLoadLevelBitrate);\n            }\n            this.clearTimer();\n            logger.warn(`[abr] Fragment ${frag.sn}${part ? \" part \" + part.index : \"\"} of level ${frag.level} is loading too slowly;\n      Time to underbuffer: ${bufferStarvationDelay.toFixed(3)} s\n      Estimated load time for current fragment: ${fragLoadedDelay.toFixed(3)} s\n      Estimated load time for down switch fragment: ${fragLevelNextLoadedDelay.toFixed(3)} s\n      TTFB estimate: ${ttfb | 0} ms\n      Current BW estimate: ${isFiniteNumber(bwEstimate) ? bwEstimate | 0 : \"Unknown\"} bps\n      New BW estimate: ${this.getBwEstimate() | 0} bps\n      Switching to level ${nextLoadLevel} @ ${nextLoadLevelBitrate | 0} bps`);\n            hls.trigger(Events.FRAG_LOAD_EMERGENCY_ABORTED, {\n                frag,\n                part,\n                stats\n            });\n        };\n        this.hls = _hls;\n        this.bwEstimator = this.initEstimator();\n        this.registerListeners();\n    }\n    resetEstimator(abrEwmaDefaultEstimate) {\n        if (abrEwmaDefaultEstimate) {\n            logger.log(`setting initial bwe to ${abrEwmaDefaultEstimate}`);\n            this.hls.config.abrEwmaDefaultEstimate = abrEwmaDefaultEstimate;\n        }\n        this.firstSelection = -1;\n        this.bwEstimator = this.initEstimator();\n    }\n    initEstimator() {\n        const config = this.hls.config;\n        return new EwmaBandWidthEstimator(config.abrEwmaSlowVoD, config.abrEwmaFastVoD, config.abrEwmaDefaultEstimate);\n    }\n    registerListeners() {\n        const { hls } = this;\n        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.on(Events.FRAG_LOADING, this.onFragLoading, this);\n        hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);\n        hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n        hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n        hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n        hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n        hls.on(Events.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this);\n        hls.on(Events.ERROR, this.onError, this);\n    }\n    unregisterListeners() {\n        const { hls } = this;\n        if (!hls) {\n            return;\n        }\n        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.off(Events.FRAG_LOADING, this.onFragLoading, this);\n        hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);\n        hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n        hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n        hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n        hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n        hls.off(Events.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this);\n        hls.off(Events.ERROR, this.onError, this);\n    }\n    destroy() {\n        this.unregisterListeners();\n        this.clearTimer();\n        // @ts-ignore\n        this.hls = this._abandonRulesCheck = null;\n        this.fragCurrent = this.partCurrent = null;\n    }\n    onManifestLoading(event, data) {\n        this.lastLoadedFragLevel = -1;\n        this.firstSelection = -1;\n        this.lastLevelLoadSec = 0;\n        this.fragCurrent = this.partCurrent = null;\n        this.onLevelsUpdated();\n        this.clearTimer();\n    }\n    onLevelsUpdated() {\n        if (this.lastLoadedFragLevel > -1 && this.fragCurrent) {\n            this.lastLoadedFragLevel = this.fragCurrent.level;\n        }\n        this._nextAutoLevel = -1;\n        this.onMaxAutoLevelUpdated();\n        this.codecTiers = null;\n        this.audioTracksByGroup = null;\n    }\n    onMaxAutoLevelUpdated() {\n        this.firstSelection = -1;\n        this.nextAutoLevelKey = \"\";\n    }\n    onFragLoading(event, data) {\n        const frag = data.frag;\n        if (this.ignoreFragment(frag)) {\n            return;\n        }\n        if (!frag.bitrateTest) {\n            var _data$part;\n            this.fragCurrent = frag;\n            this.partCurrent = (_data$part = data.part) != null ? _data$part : null;\n        }\n        this.clearTimer();\n        this.timer = self.setInterval(this._abandonRulesCheck, 100);\n    }\n    onLevelSwitching(event, data) {\n        this.clearTimer();\n    }\n    onError(event, data) {\n        if (data.fatal) {\n            return;\n        }\n        switch(data.details){\n            case ErrorDetails.BUFFER_ADD_CODEC_ERROR:\n            case ErrorDetails.BUFFER_APPEND_ERROR:\n                // Reset last loaded level so that a new selection can be made after calling recoverMediaError\n                this.lastLoadedFragLevel = -1;\n                this.firstSelection = -1;\n                break;\n            case ErrorDetails.FRAG_LOAD_TIMEOUT:\n                {\n                    const frag = data.frag;\n                    const { fragCurrent, partCurrent: part } = this;\n                    if (frag && fragCurrent && frag.sn === fragCurrent.sn && frag.level === fragCurrent.level) {\n                        const now = performance.now();\n                        const stats = part ? part.stats : frag.stats;\n                        const timeLoading = now - stats.loading.start;\n                        const ttfb = stats.loading.first ? stats.loading.first - stats.loading.start : -1;\n                        const loadedFirstByte = stats.loaded && ttfb > -1;\n                        if (loadedFirstByte) {\n                            const ttfbEstimate = this.bwEstimator.getEstimateTTFB();\n                            this.bwEstimator.sample(timeLoading - Math.min(ttfbEstimate, ttfb), stats.loaded);\n                        } else {\n                            this.bwEstimator.sampleTTFB(timeLoading);\n                        }\n                    }\n                    break;\n                }\n        }\n    }\n    getTimeToLoadFrag(timeToFirstByteSec, bandwidth, fragSizeBits, isSwitch) {\n        const fragLoadSec = timeToFirstByteSec + fragSizeBits / bandwidth;\n        const playlistLoadSec = isSwitch ? this.lastLevelLoadSec : 0;\n        return fragLoadSec + playlistLoadSec;\n    }\n    onLevelLoaded(event, data) {\n        const config = this.hls.config;\n        const { loading } = data.stats;\n        const timeLoadingMs = loading.end - loading.start;\n        if (isFiniteNumber(timeLoadingMs)) {\n            this.lastLevelLoadSec = timeLoadingMs / 1000;\n        }\n        if (data.details.live) {\n            this.bwEstimator.update(config.abrEwmaSlowLive, config.abrEwmaFastLive);\n        } else {\n            this.bwEstimator.update(config.abrEwmaSlowVoD, config.abrEwmaFastVoD);\n        }\n    }\n    onFragLoaded(event, { frag, part }) {\n        const stats = part ? part.stats : frag.stats;\n        if (frag.type === PlaylistLevelType.MAIN) {\n            this.bwEstimator.sampleTTFB(stats.loading.first - stats.loading.start);\n        }\n        if (this.ignoreFragment(frag)) {\n            return;\n        }\n        // stop monitoring bw once frag loaded\n        this.clearTimer();\n        // reset forced auto level value so that next level will be selected\n        if (frag.level === this._nextAutoLevel) {\n            this._nextAutoLevel = -1;\n        }\n        this.firstSelection = -1;\n        // compute level average bitrate\n        if (this.hls.config.abrMaxWithRealBitrate) {\n            const duration = part ? part.duration : frag.duration;\n            const level = this.hls.levels[frag.level];\n            const loadedBytes = (level.loaded ? level.loaded.bytes : 0) + stats.loaded;\n            const loadedDuration = (level.loaded ? level.loaded.duration : 0) + duration;\n            level.loaded = {\n                bytes: loadedBytes,\n                duration: loadedDuration\n            };\n            level.realBitrate = Math.round(8 * loadedBytes / loadedDuration);\n        }\n        if (frag.bitrateTest) {\n            const fragBufferedData = {\n                stats,\n                frag,\n                part,\n                id: frag.type\n            };\n            this.onFragBuffered(Events.FRAG_BUFFERED, fragBufferedData);\n            frag.bitrateTest = false;\n        } else {\n            // store level id after successful fragment load for playback\n            this.lastLoadedFragLevel = frag.level;\n        }\n    }\n    onFragBuffered(event, data) {\n        const { frag, part } = data;\n        const stats = part != null && part.stats.loaded ? part.stats : frag.stats;\n        if (stats.aborted) {\n            return;\n        }\n        if (this.ignoreFragment(frag)) {\n            return;\n        }\n        // Use the difference between parsing and request instead of buffering and request to compute fragLoadingProcessing;\n        // rationale is that buffer appending only happens once media is attached. This can happen when config.startFragPrefetch\n        // is used. If we used buffering in that case, our BW estimate sample will be very large.\n        const processingMs = stats.parsing.end - stats.loading.start - Math.min(stats.loading.first - stats.loading.start, this.bwEstimator.getEstimateTTFB());\n        this.bwEstimator.sample(processingMs, stats.loaded);\n        stats.bwEstimate = this.getBwEstimate();\n        if (frag.bitrateTest) {\n            this.bitrateTestDelay = processingMs / 1000;\n        } else {\n            this.bitrateTestDelay = 0;\n        }\n    }\n    ignoreFragment(frag) {\n        // Only count non-alt-audio frags which were actually buffered in our BW calculations\n        return frag.type !== PlaylistLevelType.MAIN || frag.sn === \"initSegment\";\n    }\n    clearTimer() {\n        if (this.timer > -1) {\n            self.clearInterval(this.timer);\n            this.timer = -1;\n        }\n    }\n    get firstAutoLevel() {\n        const { maxAutoLevel, minAutoLevel } = this.hls;\n        const bwEstimate = this.getBwEstimate();\n        const maxStartDelay = this.hls.config.maxStarvationDelay;\n        const abrAutoLevel = this.findBestLevel(bwEstimate, minAutoLevel, maxAutoLevel, 0, maxStartDelay, 1, 1);\n        if (abrAutoLevel > -1) {\n            return abrAutoLevel;\n        }\n        const firstLevel = this.hls.firstLevel;\n        const clamped = Math.min(Math.max(firstLevel, minAutoLevel), maxAutoLevel);\n        logger.warn(`[abr] Could not find best starting auto level. Defaulting to first in playlist ${firstLevel} clamped to ${clamped}`);\n        return clamped;\n    }\n    get forcedAutoLevel() {\n        if (this.nextAutoLevelKey) {\n            return -1;\n        }\n        return this._nextAutoLevel;\n    }\n    // return next auto level\n    get nextAutoLevel() {\n        const forcedAutoLevel = this.forcedAutoLevel;\n        const bwEstimator = this.bwEstimator;\n        const useEstimate = bwEstimator.canEstimate();\n        const loadedFirstFrag = this.lastLoadedFragLevel > -1;\n        // in case next auto level has been forced, and bw not available or not reliable, return forced value\n        if (forcedAutoLevel !== -1 && (!useEstimate || !loadedFirstFrag || this.nextAutoLevelKey === this.getAutoLevelKey())) {\n            return forcedAutoLevel;\n        }\n        // compute next level using ABR logic\n        const nextABRAutoLevel = useEstimate && loadedFirstFrag ? this.getNextABRAutoLevel() : this.firstAutoLevel;\n        // use forced auto level while it hasn't errored more than ABR selection\n        if (forcedAutoLevel !== -1) {\n            const levels = this.hls.levels;\n            if (levels.length > Math.max(forcedAutoLevel, nextABRAutoLevel) && levels[forcedAutoLevel].loadError <= levels[nextABRAutoLevel].loadError) {\n                return forcedAutoLevel;\n            }\n        }\n        // save result until state has changed\n        this._nextAutoLevel = nextABRAutoLevel;\n        this.nextAutoLevelKey = this.getAutoLevelKey();\n        return nextABRAutoLevel;\n    }\n    getAutoLevelKey() {\n        var _this$hls$mainForward;\n        return `${this.getBwEstimate()}_${(_this$hls$mainForward = this.hls.mainForwardBufferInfo) == null ? void 0 : _this$hls$mainForward.len}`;\n    }\n    getNextABRAutoLevel() {\n        const { fragCurrent, partCurrent, hls } = this;\n        const { maxAutoLevel, config, minAutoLevel, media } = hls;\n        const currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;\n        // playbackRate is the absolute value of the playback rate; if media.playbackRate is 0, we use 1 to load as\n        // if we're playing back at the normal rate.\n        const playbackRate = media && media.playbackRate !== 0 ? Math.abs(media.playbackRate) : 1.0;\n        const avgbw = this.getBwEstimate();\n        // bufferStarvationDelay is the wall-clock time left until the playback buffer is exhausted.\n        const bufferInfo = hls.mainForwardBufferInfo;\n        const bufferStarvationDelay = (bufferInfo ? bufferInfo.len : 0) / playbackRate;\n        let bwFactor = config.abrBandWidthFactor;\n        let bwUpFactor = config.abrBandWidthUpFactor;\n        // First, look to see if we can find a level matching with our avg bandwidth AND that could also guarantee no rebuffering at all\n        if (bufferStarvationDelay) {\n            const _bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, 0, bwFactor, bwUpFactor);\n            if (_bestLevel >= 0) {\n                return _bestLevel;\n            }\n        }\n        // not possible to get rid of rebuffering... try to find level that will guarantee less than maxStarvationDelay of rebuffering\n        let maxStarvationDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxStarvationDelay) : config.maxStarvationDelay;\n        if (!bufferStarvationDelay) {\n            // in case buffer is empty, let's check if previous fragment was loaded to perform a bitrate test\n            const bitrateTestDelay = this.bitrateTestDelay;\n            if (bitrateTestDelay) {\n                // if it is the case, then we need to adjust our max starvation delay using maxLoadingDelay config value\n                // max video loading delay used in  automatic start level selection :\n                // in that mode ABR controller will ensure that video loading time (ie the time to fetch the first fragment at lowest quality level +\n                // the time to fetch the fragment at the appropriate quality level is less than ```maxLoadingDelay``` )\n                // cap maxLoadingDelay and ensure it is not bigger 'than bitrate test' frag duration\n                const maxLoadingDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxLoadingDelay) : config.maxLoadingDelay;\n                maxStarvationDelay = maxLoadingDelay - bitrateTestDelay;\n                logger.info(`[abr] bitrate test took ${Math.round(1000 * bitrateTestDelay)}ms, set first fragment max fetchDuration to ${Math.round(1000 * maxStarvationDelay)} ms`);\n                // don't use conservative factor on bitrate test\n                bwFactor = bwUpFactor = 1;\n            }\n        }\n        const bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, maxStarvationDelay, bwFactor, bwUpFactor);\n        logger.info(`[abr] ${bufferStarvationDelay ? \"rebuffering expected\" : \"buffer is empty\"}, optimal quality level ${bestLevel}`);\n        if (bestLevel > -1) {\n            return bestLevel;\n        }\n        // If no matching level found, see if min auto level would be a better option\n        const minLevel = hls.levels[minAutoLevel];\n        const autoLevel = hls.levels[hls.loadLevel];\n        if ((minLevel == null ? void 0 : minLevel.bitrate) < (autoLevel == null ? void 0 : autoLevel.bitrate)) {\n            return minAutoLevel;\n        }\n        // or if bitrate is not lower, continue to use loadLevel\n        return hls.loadLevel;\n    }\n    getBwEstimate() {\n        return this.bwEstimator.canEstimate() ? this.bwEstimator.getEstimate() : this.hls.config.abrEwmaDefaultEstimate;\n    }\n    findBestLevel(currentBw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, maxStarvationDelay, bwFactor, bwUpFactor) {\n        var _level$details;\n        const maxFetchDuration = bufferStarvationDelay + maxStarvationDelay;\n        const lastLoadedFragLevel = this.lastLoadedFragLevel;\n        const selectionBaseLevel = lastLoadedFragLevel === -1 ? this.hls.firstLevel : lastLoadedFragLevel;\n        const { fragCurrent, partCurrent } = this;\n        const { levels, allAudioTracks, loadLevel, config } = this.hls;\n        if (levels.length === 1) {\n            return 0;\n        }\n        const level = levels[selectionBaseLevel];\n        const live = !!(level != null && (_level$details = level.details) != null && _level$details.live);\n        const firstSelection = loadLevel === -1 || lastLoadedFragLevel === -1;\n        let currentCodecSet;\n        let currentVideoRange = \"SDR\";\n        let currentFrameRate = (level == null ? void 0 : level.frameRate) || 0;\n        const { audioPreference, videoPreference } = config;\n        const audioTracksByGroup = this.audioTracksByGroup || (this.audioTracksByGroup = getAudioTracksByGroup(allAudioTracks));\n        if (firstSelection) {\n            if (this.firstSelection !== -1) {\n                return this.firstSelection;\n            }\n            const codecTiers = this.codecTiers || (this.codecTiers = getCodecTiers(levels, audioTracksByGroup, minAutoLevel, maxAutoLevel));\n            const startTier = getStartCodecTier(codecTiers, currentVideoRange, currentBw, audioPreference, videoPreference);\n            const { codecSet, videoRanges, minFramerate, minBitrate, preferHDR } = startTier;\n            currentCodecSet = codecSet;\n            currentVideoRange = preferHDR ? videoRanges[videoRanges.length - 1] : videoRanges[0];\n            currentFrameRate = minFramerate;\n            currentBw = Math.max(currentBw, minBitrate);\n            logger.log(`[abr] picked start tier ${JSON.stringify(startTier)}`);\n        } else {\n            currentCodecSet = level == null ? void 0 : level.codecSet;\n            currentVideoRange = level == null ? void 0 : level.videoRange;\n        }\n        const currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;\n        const ttfbEstimateSec = this.bwEstimator.getEstimateTTFB() / 1000;\n        const levelsSkipped = [];\n        for(let i = maxAutoLevel; i >= minAutoLevel; i--){\n            var _levelInfo$supportedR, _levelInfo$supportedR2;\n            const levelInfo = levels[i];\n            const upSwitch = i > selectionBaseLevel;\n            if (!levelInfo) {\n                continue;\n            }\n            if (config.useMediaCapabilities && !levelInfo.supportedResult && !levelInfo.supportedPromise) {\n                const mediaCapabilities = navigator.mediaCapabilities;\n                if (typeof (mediaCapabilities == null ? void 0 : mediaCapabilities.decodingInfo) === \"function\" && requiresMediaCapabilitiesDecodingInfo(levelInfo, audioTracksByGroup, currentVideoRange, currentFrameRate, currentBw, audioPreference)) {\n                    levelInfo.supportedPromise = getMediaDecodingInfoPromise(levelInfo, audioTracksByGroup, mediaCapabilities);\n                    levelInfo.supportedPromise.then((decodingInfo)=>{\n                        levelInfo.supportedResult = decodingInfo;\n                        const levels = this.hls.levels;\n                        const index = levels.indexOf(levelInfo);\n                        if (decodingInfo.error) {\n                            logger.warn(`[abr] MediaCapabilities decodingInfo error: \"${decodingInfo.error}\" for level ${index} ${JSON.stringify(decodingInfo)}`);\n                        } else if (!decodingInfo.supported) {\n                            logger.warn(`[abr] Unsupported MediaCapabilities decodingInfo result for level ${index} ${JSON.stringify(decodingInfo)}`);\n                            if (index > -1 && levels.length > 1) {\n                                logger.log(`[abr] Removing unsupported level ${index}`);\n                                this.hls.removeLevel(index);\n                            }\n                        }\n                    });\n                } else {\n                    levelInfo.supportedResult = SUPPORTED_INFO_DEFAULT;\n                }\n            }\n            // skip candidates which change codec-family or video-range,\n            // and which decrease or increase frame-rate for up and down-switch respectfully\n            if (currentCodecSet && levelInfo.codecSet !== currentCodecSet || currentVideoRange && levelInfo.videoRange !== currentVideoRange || upSwitch && currentFrameRate > levelInfo.frameRate || !upSwitch && currentFrameRate > 0 && currentFrameRate < levelInfo.frameRate || !((_levelInfo$supportedR = levelInfo.supportedResult) != null && (_levelInfo$supportedR2 = _levelInfo$supportedR.decodingInfoResults) != null && _levelInfo$supportedR2[0].smooth)) {\n                levelsSkipped.push(i);\n                continue;\n            }\n            const levelDetails = levelInfo.details;\n            const avgDuration = (partCurrent ? levelDetails == null ? void 0 : levelDetails.partTarget : levelDetails == null ? void 0 : levelDetails.averagetargetduration) || currentFragDuration;\n            let adjustedbw;\n            // follow algorithm captured from stagefright :\n            // https://android.googlesource.com/platform/frameworks/av/+/master/media/libstagefright/httplive/LiveSession.cpp\n            // Pick the highest bandwidth stream below or equal to estimated bandwidth.\n            // consider only 80% of the available bandwidth, but if we are switching up,\n            // be even more conservative (70%) to avoid overestimating and immediately\n            // switching back.\n            if (!upSwitch) {\n                adjustedbw = bwFactor * currentBw;\n            } else {\n                adjustedbw = bwUpFactor * currentBw;\n            }\n            // Use average bitrate when starvation delay (buffer length) is gt or eq two segment durations and rebuffering is not expected (maxStarvationDelay > 0)\n            const bitrate = currentFragDuration && bufferStarvationDelay >= currentFragDuration * 2 && maxStarvationDelay === 0 ? levels[i].averageBitrate : levels[i].maxBitrate;\n            const fetchDuration = this.getTimeToLoadFrag(ttfbEstimateSec, adjustedbw, bitrate * avgDuration, levelDetails === undefined);\n            const canSwitchWithinTolerance = // if adjusted bw is greater than level bitrate AND\n            adjustedbw >= bitrate && // no level change, or new level has no error history\n            (i === lastLoadedFragLevel || levelInfo.loadError === 0 && levelInfo.fragmentError === 0) && // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches\n            // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...\n            // special case to support startLevel = -1 (bitrateTest) on live streams : in that case we should not exit loop so that findBestLevel will return -1\n            (fetchDuration <= ttfbEstimateSec || !isFiniteNumber(fetchDuration) || live && !this.bitrateTestDelay || fetchDuration < maxFetchDuration);\n            if (canSwitchWithinTolerance) {\n                const forcedAutoLevel = this.forcedAutoLevel;\n                if (i !== loadLevel && (forcedAutoLevel === -1 || forcedAutoLevel !== loadLevel)) {\n                    if (levelsSkipped.length) {\n                        logger.trace(`[abr] Skipped level(s) ${levelsSkipped.join(\",\")} of ${maxAutoLevel} max with CODECS and VIDEO-RANGE:\"${levels[levelsSkipped[0]].codecs}\" ${levels[levelsSkipped[0]].videoRange}; not compatible with \"${level.codecs}\" ${currentVideoRange}`);\n                    }\n                    logger.info(`[abr] switch candidate:${selectionBaseLevel}->${i} adjustedbw(${Math.round(adjustedbw)})-bitrate=${Math.round(adjustedbw - bitrate)} ttfb:${ttfbEstimateSec.toFixed(1)} avgDuration:${avgDuration.toFixed(1)} maxFetchDuration:${maxFetchDuration.toFixed(1)} fetchDuration:${fetchDuration.toFixed(1)} firstSelection:${firstSelection} codecSet:${currentCodecSet} videoRange:${currentVideoRange} hls.loadLevel:${loadLevel}`);\n                }\n                if (firstSelection) {\n                    this.firstSelection = i;\n                }\n                // as we are looping from highest to lowest, this will return the best achievable quality level\n                return i;\n            }\n        }\n        // not enough time budget even with quality level 0 ... rebuffering might happen\n        return -1;\n    }\n    set nextAutoLevel(nextLevel) {\n        const value = Math.max(this.hls.minAutoLevel, nextLevel);\n        if (this._nextAutoLevel != value) {\n            this.nextAutoLevelKey = \"\";\n            this._nextAutoLevel = value;\n        }\n    }\n}\n/**\n * @ignore\n * Sub-class specialization of EventHandler base class.\n *\n * TaskLoop allows to schedule a task function being called (optionnaly repeatedly) on the main loop,\n * scheduled asynchroneously, avoiding recursive calls in the same tick.\n *\n * The task itself is implemented in `doTick`. It can be requested and called for single execution\n * using the `tick` method.\n *\n * It will be assured that the task execution method (`tick`) only gets called once per main loop \"tick\",\n * no matter how often it gets requested for execution. Execution in further ticks will be scheduled accordingly.\n *\n * If further execution requests have already been scheduled on the next tick, it can be checked with `hasNextTick`,\n * and cancelled with `clearNextTick`.\n *\n * The task can be scheduled as an interval repeatedly with a period as parameter (see `setInterval`, `clearInterval`).\n *\n * Sub-classes need to implement the `doTick` method which will effectively have the task execution routine.\n *\n * Further explanations:\n *\n * The baseclass has a `tick` method that will schedule the doTick call. It may be called synchroneously\n * only for a stack-depth of one. On re-entrant calls, sub-sequent calls are scheduled for next main loop ticks.\n *\n * When the task execution (`tick` method) is called in re-entrant way this is detected and\n * we are limiting the task execution per call stack to exactly one, but scheduling/post-poning further\n * task processing on the next main loop iteration (also known as \"next tick\" in the Node/JS runtime lingo).\n */ class TaskLoop {\n    constructor(){\n        this._boundTick = void 0;\n        this._tickTimer = null;\n        this._tickInterval = null;\n        this._tickCallCount = 0;\n        this._boundTick = this.tick.bind(this);\n    }\n    destroy() {\n        this.onHandlerDestroying();\n        this.onHandlerDestroyed();\n    }\n    onHandlerDestroying() {\n        // clear all timers before unregistering from event bus\n        this.clearNextTick();\n        this.clearInterval();\n    }\n    onHandlerDestroyed() {}\n    hasInterval() {\n        return !!this._tickInterval;\n    }\n    hasNextTick() {\n        return !!this._tickTimer;\n    }\n    /**\n   * @param millis - Interval time (ms)\n   * @eturns True when interval has been scheduled, false when already scheduled (no effect)\n   */ setInterval(millis) {\n        if (!this._tickInterval) {\n            this._tickCallCount = 0;\n            this._tickInterval = self.setInterval(this._boundTick, millis);\n            return true;\n        }\n        return false;\n    }\n    /**\n   * @returns True when interval was cleared, false when none was set (no effect)\n   */ clearInterval() {\n        if (this._tickInterval) {\n            self.clearInterval(this._tickInterval);\n            this._tickInterval = null;\n            return true;\n        }\n        return false;\n    }\n    /**\n   * @returns True when timeout was cleared, false when none was set (no effect)\n   */ clearNextTick() {\n        if (this._tickTimer) {\n            self.clearTimeout(this._tickTimer);\n            this._tickTimer = null;\n            return true;\n        }\n        return false;\n    }\n    /**\n   * Will call the subclass doTick implementation in this main loop tick\n   * or in the next one (via setTimeout(,0)) in case it has already been called\n   * in this tick (in case this is a re-entrant call).\n   */ tick() {\n        this._tickCallCount++;\n        if (this._tickCallCount === 1) {\n            this.doTick();\n            // re-entrant call to tick from previous doTick call stack\n            // -> schedule a call on the next main loop iteration to process this task processing request\n            if (this._tickCallCount > 1) {\n                // make sure only one timer exists at any time at max\n                this.tickImmediate();\n            }\n            this._tickCallCount = 0;\n        }\n    }\n    tickImmediate() {\n        this.clearNextTick();\n        this._tickTimer = self.setTimeout(this._boundTick, 0);\n    }\n    /**\n   * For subclass to implement task logic\n   * @abstract\n   */ doTick() {}\n}\nvar FragmentState = {\n    NOT_LOADED: \"NOT_LOADED\",\n    APPENDING: \"APPENDING\",\n    PARTIAL: \"PARTIAL\",\n    OK: \"OK\"\n};\nclass FragmentTracker {\n    constructor(hls){\n        this.activePartLists = Object.create(null);\n        this.endListFragments = Object.create(null);\n        this.fragments = Object.create(null);\n        this.timeRanges = Object.create(null);\n        this.bufferPadding = 0.2;\n        this.hls = void 0;\n        this.hasGaps = false;\n        this.hls = hls;\n        this._registerListeners();\n    }\n    _registerListeners() {\n        const { hls } = this;\n        hls.on(Events.BUFFER_APPENDED, this.onBufferAppended, this);\n        hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n        hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);\n    }\n    _unregisterListeners() {\n        const { hls } = this;\n        hls.off(Events.BUFFER_APPENDED, this.onBufferAppended, this);\n        hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n        hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);\n    }\n    destroy() {\n        this._unregisterListeners();\n        // @ts-ignore\n        this.fragments = // @ts-ignore\n        this.activePartLists = // @ts-ignore\n        this.endListFragments = this.timeRanges = null;\n    }\n    /**\n   * Return a Fragment or Part with an appended range that matches the position and levelType\n   * Otherwise, return null\n   */ getAppendedFrag(position, levelType) {\n        const activeParts = this.activePartLists[levelType];\n        if (activeParts) {\n            for(let i = activeParts.length; i--;){\n                const activePart = activeParts[i];\n                if (!activePart) {\n                    break;\n                }\n                const appendedPTS = activePart.end;\n                if (activePart.start <= position && appendedPTS !== null && position <= appendedPTS) {\n                    return activePart;\n                }\n            }\n        }\n        return this.getBufferedFrag(position, levelType);\n    }\n    /**\n   * Return a buffered Fragment that matches the position and levelType.\n   * A buffered Fragment is one whose loading, parsing and appending is done (completed or \"partial\" meaning aborted).\n   * If not found any Fragment, return null\n   */ getBufferedFrag(position, levelType) {\n        const { fragments } = this;\n        const keys = Object.keys(fragments);\n        for(let i = keys.length; i--;){\n            const fragmentEntity = fragments[keys[i]];\n            if ((fragmentEntity == null ? void 0 : fragmentEntity.body.type) === levelType && fragmentEntity.buffered) {\n                const frag = fragmentEntity.body;\n                if (frag.start <= position && position <= frag.end) {\n                    return frag;\n                }\n            }\n        }\n        return null;\n    }\n    /**\n   * Partial fragments effected by coded frame eviction will be removed\n   * The browser will unload parts of the buffer to free up memory for new buffer data\n   * Fragments will need to be reloaded when the buffer is freed up, removing partial fragments will allow them to reload(since there might be parts that are still playable)\n   */ detectEvictedFragments(elementaryStream, timeRange, playlistType, appendedPart) {\n        if (this.timeRanges) {\n            this.timeRanges[elementaryStream] = timeRange;\n        }\n        // Check if any flagged fragments have been unloaded\n        // excluding anything newer than appendedPartSn\n        const appendedPartSn = (appendedPart == null ? void 0 : appendedPart.fragment.sn) || -1;\n        Object.keys(this.fragments).forEach((key)=>{\n            const fragmentEntity = this.fragments[key];\n            if (!fragmentEntity) {\n                return;\n            }\n            if (appendedPartSn >= fragmentEntity.body.sn) {\n                return;\n            }\n            if (!fragmentEntity.buffered && !fragmentEntity.loaded) {\n                if (fragmentEntity.body.type === playlistType) {\n                    this.removeFragment(fragmentEntity.body);\n                }\n                return;\n            }\n            const esData = fragmentEntity.range[elementaryStream];\n            if (!esData) {\n                return;\n            }\n            esData.time.some((time)=>{\n                const isNotBuffered = !this.isTimeBuffered(time.startPTS, time.endPTS, timeRange);\n                if (isNotBuffered) {\n                    // Unregister partial fragment as it needs to load again to be reused\n                    this.removeFragment(fragmentEntity.body);\n                }\n                return isNotBuffered;\n            });\n        });\n    }\n    /**\n   * Checks if the fragment passed in is loaded in the buffer properly\n   * Partially loaded fragments will be registered as a partial fragment\n   */ detectPartialFragments(data) {\n        const timeRanges = this.timeRanges;\n        const { frag, part } = data;\n        if (!timeRanges || frag.sn === \"initSegment\") {\n            return;\n        }\n        const fragKey = getFragmentKey(frag);\n        const fragmentEntity = this.fragments[fragKey];\n        if (!fragmentEntity || fragmentEntity.buffered && frag.gap) {\n            return;\n        }\n        const isFragHint = !frag.relurl;\n        Object.keys(timeRanges).forEach((elementaryStream)=>{\n            const streamInfo = frag.elementaryStreams[elementaryStream];\n            if (!streamInfo) {\n                return;\n            }\n            const timeRange = timeRanges[elementaryStream];\n            const partial = isFragHint || streamInfo.partial === true;\n            fragmentEntity.range[elementaryStream] = this.getBufferedTimes(frag, part, partial, timeRange);\n        });\n        fragmentEntity.loaded = null;\n        if (Object.keys(fragmentEntity.range).length) {\n            fragmentEntity.buffered = true;\n            const endList = fragmentEntity.body.endList = frag.endList || fragmentEntity.body.endList;\n            if (endList) {\n                this.endListFragments[fragmentEntity.body.type] = fragmentEntity;\n            }\n            if (!isPartial(fragmentEntity)) {\n                // Remove older fragment parts from lookup after frag is tracked as buffered\n                this.removeParts(frag.sn - 1, frag.type);\n            }\n        } else {\n            // remove fragment if nothing was appended\n            this.removeFragment(fragmentEntity.body);\n        }\n    }\n    removeParts(snToKeep, levelType) {\n        const activeParts = this.activePartLists[levelType];\n        if (!activeParts) {\n            return;\n        }\n        this.activePartLists[levelType] = activeParts.filter((part)=>part.fragment.sn >= snToKeep);\n    }\n    fragBuffered(frag, force) {\n        const fragKey = getFragmentKey(frag);\n        let fragmentEntity = this.fragments[fragKey];\n        if (!fragmentEntity && force) {\n            fragmentEntity = this.fragments[fragKey] = {\n                body: frag,\n                appendedPTS: null,\n                loaded: null,\n                buffered: false,\n                range: Object.create(null)\n            };\n            if (frag.gap) {\n                this.hasGaps = true;\n            }\n        }\n        if (fragmentEntity) {\n            fragmentEntity.loaded = null;\n            fragmentEntity.buffered = true;\n        }\n    }\n    getBufferedTimes(fragment, part, partial, timeRange) {\n        const buffered = {\n            time: [],\n            partial\n        };\n        const startPTS = fragment.start;\n        const endPTS = fragment.end;\n        const minEndPTS = fragment.minEndPTS || endPTS;\n        const maxStartPTS = fragment.maxStartPTS || startPTS;\n        for(let i = 0; i < timeRange.length; i++){\n            const startTime = timeRange.start(i) - this.bufferPadding;\n            const endTime = timeRange.end(i) + this.bufferPadding;\n            if (maxStartPTS >= startTime && minEndPTS <= endTime) {\n                // Fragment is entirely contained in buffer\n                // No need to check the other timeRange times since it's completely playable\n                buffered.time.push({\n                    startPTS: Math.max(startPTS, timeRange.start(i)),\n                    endPTS: Math.min(endPTS, timeRange.end(i))\n                });\n                break;\n            } else if (startPTS < endTime && endPTS > startTime) {\n                const start = Math.max(startPTS, timeRange.start(i));\n                const end = Math.min(endPTS, timeRange.end(i));\n                if (end > start) {\n                    buffered.partial = true;\n                    // Check for intersection with buffer\n                    // Get playable sections of the fragment\n                    buffered.time.push({\n                        startPTS: start,\n                        endPTS: end\n                    });\n                }\n            } else if (endPTS <= startTime) {\n                break;\n            }\n        }\n        return buffered;\n    }\n    /**\n   * Gets the partial fragment for a certain time\n   */ getPartialFragment(time) {\n        let bestFragment = null;\n        let timePadding;\n        let startTime;\n        let endTime;\n        let bestOverlap = 0;\n        const { bufferPadding, fragments } = this;\n        Object.keys(fragments).forEach((key)=>{\n            const fragmentEntity = fragments[key];\n            if (!fragmentEntity) {\n                return;\n            }\n            if (isPartial(fragmentEntity)) {\n                startTime = fragmentEntity.body.start - bufferPadding;\n                endTime = fragmentEntity.body.end + bufferPadding;\n                if (time >= startTime && time <= endTime) {\n                    // Use the fragment that has the most padding from start and end time\n                    timePadding = Math.min(time - startTime, endTime - time);\n                    if (bestOverlap <= timePadding) {\n                        bestFragment = fragmentEntity.body;\n                        bestOverlap = timePadding;\n                    }\n                }\n            }\n        });\n        return bestFragment;\n    }\n    isEndListAppended(type) {\n        const lastFragmentEntity = this.endListFragments[type];\n        return lastFragmentEntity !== undefined && (lastFragmentEntity.buffered || isPartial(lastFragmentEntity));\n    }\n    getState(fragment) {\n        const fragKey = getFragmentKey(fragment);\n        const fragmentEntity = this.fragments[fragKey];\n        if (fragmentEntity) {\n            if (!fragmentEntity.buffered) {\n                return FragmentState.APPENDING;\n            } else if (isPartial(fragmentEntity)) {\n                return FragmentState.PARTIAL;\n            } else {\n                return FragmentState.OK;\n            }\n        }\n        return FragmentState.NOT_LOADED;\n    }\n    isTimeBuffered(startPTS, endPTS, timeRange) {\n        let startTime;\n        let endTime;\n        for(let i = 0; i < timeRange.length; i++){\n            startTime = timeRange.start(i) - this.bufferPadding;\n            endTime = timeRange.end(i) + this.bufferPadding;\n            if (startPTS >= startTime && endPTS <= endTime) {\n                return true;\n            }\n            if (endPTS <= startTime) {\n                // No need to check the rest of the timeRange as it is in order\n                return false;\n            }\n        }\n        return false;\n    }\n    onFragLoaded(event, data) {\n        const { frag, part } = data;\n        // don't track initsegment (for which sn is not a number)\n        // don't track frags used for bitrateTest, they're irrelevant.\n        if (frag.sn === \"initSegment\" || frag.bitrateTest) {\n            return;\n        }\n        // Fragment entity `loaded` FragLoadedData is null when loading parts\n        const loaded = part ? null : data;\n        const fragKey = getFragmentKey(frag);\n        this.fragments[fragKey] = {\n            body: frag,\n            appendedPTS: null,\n            loaded,\n            buffered: false,\n            range: Object.create(null)\n        };\n    }\n    onBufferAppended(event, data) {\n        const { frag, part, timeRanges } = data;\n        if (frag.sn === \"initSegment\") {\n            return;\n        }\n        const playlistType = frag.type;\n        if (part) {\n            let activeParts = this.activePartLists[playlistType];\n            if (!activeParts) {\n                this.activePartLists[playlistType] = activeParts = [];\n            }\n            activeParts.push(part);\n        }\n        // Store the latest timeRanges loaded in the buffer\n        this.timeRanges = timeRanges;\n        Object.keys(timeRanges).forEach((elementaryStream)=>{\n            const timeRange = timeRanges[elementaryStream];\n            this.detectEvictedFragments(elementaryStream, timeRange, playlistType, part);\n        });\n    }\n    onFragBuffered(event, data) {\n        this.detectPartialFragments(data);\n    }\n    hasFragment(fragment) {\n        const fragKey = getFragmentKey(fragment);\n        return !!this.fragments[fragKey];\n    }\n    hasParts(type) {\n        var _this$activePartLists;\n        return !!((_this$activePartLists = this.activePartLists[type]) != null && _this$activePartLists.length);\n    }\n    removeFragmentsInRange(start, end, playlistType, withGapOnly, unbufferedOnly) {\n        if (withGapOnly && !this.hasGaps) {\n            return;\n        }\n        Object.keys(this.fragments).forEach((key)=>{\n            const fragmentEntity = this.fragments[key];\n            if (!fragmentEntity) {\n                return;\n            }\n            const frag = fragmentEntity.body;\n            if (frag.type !== playlistType || withGapOnly && !frag.gap) {\n                return;\n            }\n            if (frag.start < end && frag.end > start && (fragmentEntity.buffered || unbufferedOnly)) {\n                this.removeFragment(frag);\n            }\n        });\n    }\n    removeFragment(fragment) {\n        const fragKey = getFragmentKey(fragment);\n        fragment.stats.loaded = 0;\n        fragment.clearElementaryStreamInfo();\n        const activeParts = this.activePartLists[fragment.type];\n        if (activeParts) {\n            const snToRemove = fragment.sn;\n            this.activePartLists[fragment.type] = activeParts.filter((part)=>part.fragment.sn !== snToRemove);\n        }\n        delete this.fragments[fragKey];\n        if (fragment.endList) {\n            delete this.endListFragments[fragment.type];\n        }\n    }\n    removeAllFragments() {\n        this.fragments = Object.create(null);\n        this.endListFragments = Object.create(null);\n        this.activePartLists = Object.create(null);\n        this.hasGaps = false;\n    }\n}\nfunction isPartial(fragmentEntity) {\n    var _fragmentEntity$range, _fragmentEntity$range2, _fragmentEntity$range3;\n    return fragmentEntity.buffered && (fragmentEntity.body.gap || ((_fragmentEntity$range = fragmentEntity.range.video) == null ? void 0 : _fragmentEntity$range.partial) || ((_fragmentEntity$range2 = fragmentEntity.range.audio) == null ? void 0 : _fragmentEntity$range2.partial) || ((_fragmentEntity$range3 = fragmentEntity.range.audiovideo) == null ? void 0 : _fragmentEntity$range3.partial));\n}\nfunction getFragmentKey(fragment) {\n    return `${fragment.type}_${fragment.level}_${fragment.sn}`;\n}\n/**\n * Provides methods dealing with buffer length retrieval for example.\n *\n * In general, a helper around HTML5 MediaElement TimeRanges gathered from `buffered` property.\n *\n * Also @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/buffered\n */ const noopBuffered = {\n    length: 0,\n    start: ()=>0,\n    end: ()=>0\n};\nclass BufferHelper {\n    /**\n   * Return true if `media`'s buffered include `position`\n   */ static isBuffered(media, position) {\n        try {\n            if (media) {\n                const buffered = BufferHelper.getBuffered(media);\n                for(let i = 0; i < buffered.length; i++){\n                    if (position >= buffered.start(i) && position <= buffered.end(i)) {\n                        return true;\n                    }\n                }\n            }\n        } catch (error) {\n        // this is to catch\n        // InvalidStateError: Failed to read the 'buffered' property from 'SourceBuffer':\n        // This SourceBuffer has been removed from the parent media source\n        }\n        return false;\n    }\n    static bufferInfo(media, pos, maxHoleDuration) {\n        try {\n            if (media) {\n                const vbuffered = BufferHelper.getBuffered(media);\n                const buffered = [];\n                let i;\n                for(i = 0; i < vbuffered.length; i++){\n                    buffered.push({\n                        start: vbuffered.start(i),\n                        end: vbuffered.end(i)\n                    });\n                }\n                return this.bufferedInfo(buffered, pos, maxHoleDuration);\n            }\n        } catch (error) {\n        // this is to catch\n        // InvalidStateError: Failed to read the 'buffered' property from 'SourceBuffer':\n        // This SourceBuffer has been removed from the parent media source\n        }\n        return {\n            len: 0,\n            start: pos,\n            end: pos,\n            nextStart: undefined\n        };\n    }\n    static bufferedInfo(buffered, pos, maxHoleDuration) {\n        pos = Math.max(0, pos);\n        // sort on buffer.start/smaller end (IE does not always return sorted buffered range)\n        buffered.sort(function(a, b) {\n            const diff = a.start - b.start;\n            if (diff) {\n                return diff;\n            } else {\n                return b.end - a.end;\n            }\n        });\n        let buffered2 = [];\n        if (maxHoleDuration) {\n            // there might be some small holes between buffer time range\n            // consider that holes smaller than maxHoleDuration are irrelevant and build another\n            // buffer time range representations that discards those holes\n            for(let i = 0; i < buffered.length; i++){\n                const buf2len = buffered2.length;\n                if (buf2len) {\n                    const buf2end = buffered2[buf2len - 1].end;\n                    // if small hole (value between 0 or maxHoleDuration ) or overlapping (negative)\n                    if (buffered[i].start - buf2end < maxHoleDuration) {\n                        // merge overlapping time ranges\n                        // update lastRange.end only if smaller than item.end\n                        // e.g.  [ 1, 15] with  [ 2,8] => [ 1,15] (no need to modify lastRange.end)\n                        // whereas [ 1, 8] with  [ 2,15] => [ 1,15] ( lastRange should switch from [1,8] to [1,15])\n                        if (buffered[i].end > buf2end) {\n                            buffered2[buf2len - 1].end = buffered[i].end;\n                        }\n                    } else {\n                        // big hole\n                        buffered2.push(buffered[i]);\n                    }\n                } else {\n                    // first value\n                    buffered2.push(buffered[i]);\n                }\n            }\n        } else {\n            buffered2 = buffered;\n        }\n        let bufferLen = 0;\n        // bufferStartNext can possibly be undefined based on the conditional logic below\n        let bufferStartNext;\n        // bufferStart and bufferEnd are buffer boundaries around current video position\n        let bufferStart = pos;\n        let bufferEnd = pos;\n        for(let i = 0; i < buffered2.length; i++){\n            const start = buffered2[i].start;\n            const end = buffered2[i].end;\n            // logger.log('buf start/end:' + buffered.start(i) + '/' + buffered.end(i));\n            if (pos + maxHoleDuration >= start && pos < end) {\n                // play position is inside this buffer TimeRange, retrieve end of buffer position and buffer length\n                bufferStart = start;\n                bufferEnd = end;\n                bufferLen = bufferEnd - pos;\n            } else if (pos + maxHoleDuration < start) {\n                bufferStartNext = start;\n                break;\n            }\n        }\n        return {\n            len: bufferLen,\n            start: bufferStart || 0,\n            end: bufferEnd || 0,\n            nextStart: bufferStartNext\n        };\n    }\n    /**\n   * Safe method to get buffered property.\n   * SourceBuffer.buffered may throw if SourceBuffer is removed from it's MediaSource\n   */ static getBuffered(media) {\n        try {\n            return media.buffered;\n        } catch (e) {\n            logger.log(\"failed to get media.buffered\", e);\n            return noopBuffered;\n        }\n    }\n}\nclass ChunkMetadata {\n    constructor(level, sn, id, size = 0, part = -1, partial = false){\n        this.level = void 0;\n        this.sn = void 0;\n        this.part = void 0;\n        this.id = void 0;\n        this.size = void 0;\n        this.partial = void 0;\n        this.transmuxing = getNewPerformanceTiming();\n        this.buffering = {\n            audio: getNewPerformanceTiming(),\n            video: getNewPerformanceTiming(),\n            audiovideo: getNewPerformanceTiming()\n        };\n        this.level = level;\n        this.sn = sn;\n        this.id = id;\n        this.size = size;\n        this.part = part;\n        this.partial = partial;\n    }\n}\nfunction getNewPerformanceTiming() {\n    return {\n        start: 0,\n        executeStart: 0,\n        executeEnd: 0,\n        end: 0\n    };\n}\nfunction findFirstFragWithCC(fragments, cc) {\n    for(let i = 0, len = fragments.length; i < len; i++){\n        var _fragments$i;\n        if (((_fragments$i = fragments[i]) == null ? void 0 : _fragments$i.cc) === cc) {\n            return fragments[i];\n        }\n    }\n    return null;\n}\nfunction shouldAlignOnDiscontinuities(lastFrag, switchDetails, details) {\n    if (switchDetails) {\n        if (details.endCC > details.startCC || lastFrag && lastFrag.cc < details.startCC) {\n            return true;\n        }\n    }\n    return false;\n}\n// Find the first frag in the previous level which matches the CC of the first frag of the new level\nfunction findDiscontinuousReferenceFrag(prevDetails, curDetails) {\n    const prevFrags = prevDetails.fragments;\n    const curFrags = curDetails.fragments;\n    if (!curFrags.length || !prevFrags.length) {\n        logger.log(\"No fragments to align\");\n        return;\n    }\n    const prevStartFrag = findFirstFragWithCC(prevFrags, curFrags[0].cc);\n    if (!prevStartFrag || prevStartFrag && !prevStartFrag.startPTS) {\n        logger.log(\"No frag in previous level to align on\");\n        return;\n    }\n    return prevStartFrag;\n}\nfunction adjustFragmentStart(frag, sliding) {\n    if (frag) {\n        const start = frag.start + sliding;\n        frag.start = frag.startPTS = start;\n        frag.endPTS = start + frag.duration;\n    }\n}\nfunction adjustSlidingStart(sliding, details) {\n    // Update segments\n    const fragments = details.fragments;\n    for(let i = 0, len = fragments.length; i < len; i++){\n        adjustFragmentStart(fragments[i], sliding);\n    }\n    // Update LL-HLS parts at the end of the playlist\n    if (details.fragmentHint) {\n        adjustFragmentStart(details.fragmentHint, sliding);\n    }\n    details.alignedSliding = true;\n}\n/**\n * Using the parameters of the last level, this function computes PTS' of the new fragments so that they form a\n * contiguous stream with the last fragments.\n * The PTS of a fragment lets Hls.js know where it fits into a stream - by knowing every PTS, we know which fragment to\n * download at any given time. PTS is normally computed when the fragment is demuxed, so taking this step saves us time\n * and an extra download.\n * @param lastFrag\n * @param lastLevel\n * @param details\n */ function alignStream(lastFrag, switchDetails, details) {\n    if (!switchDetails) {\n        return;\n    }\n    alignDiscontinuities(lastFrag, details, switchDetails);\n    if (!details.alignedSliding && switchDetails) {\n        // If the PTS wasn't figured out via discontinuity sequence that means there was no CC increase within the level.\n        // Aligning via Program Date Time should therefore be reliable, since PDT should be the same within the same\n        // discontinuity sequence.\n        alignMediaPlaylistByPDT(details, switchDetails);\n    }\n    if (!details.alignedSliding && switchDetails && !details.skippedSegments) {\n        // Try to align on sn so that we pick a better start fragment.\n        // Do not perform this on playlists with delta updates as this is only to align levels on switch\n        // and adjustSliding only adjusts fragments after skippedSegments.\n        adjustSliding(switchDetails, details);\n    }\n}\n/**\n * Computes the PTS if a new level's fragments using the PTS of a fragment in the last level which shares the same\n * discontinuity sequence.\n * @param lastFrag - The last Fragment which shares the same discontinuity sequence\n * @param lastLevel - The details of the last loaded level\n * @param details - The details of the new level\n */ function alignDiscontinuities(lastFrag, details, switchDetails) {\n    if (shouldAlignOnDiscontinuities(lastFrag, switchDetails, details)) {\n        const referenceFrag = findDiscontinuousReferenceFrag(switchDetails, details);\n        if (referenceFrag && isFiniteNumber(referenceFrag.start)) {\n            logger.log(`Adjusting PTS using last level due to CC increase within current level ${details.url}`);\n            adjustSlidingStart(referenceFrag.start, details);\n        }\n    }\n}\n/**\n * Ensures appropriate time-alignment between renditions based on PDT.\n * This function assumes the timelines represented in `refDetails` are accurate, including the PDTs\n * for the last discontinuity sequence number shared by both playlists when present,\n * and uses the \"wallclock\"/PDT timeline as a cross-reference to `details`, adjusting the presentation\n * times/timelines of `details` accordingly.\n * Given the asynchronous nature of fetches and initial loads of live `main` and audio/subtitle tracks,\n * the primary purpose of this function is to ensure the \"local timelines\" of audio/subtitle tracks\n * are aligned to the main/video timeline, using PDT as the cross-reference/\"anchor\" that should\n * be consistent across playlists, per the HLS spec.\n * @param details - The details of the rendition you'd like to time-align (e.g. an audio rendition).\n * @param refDetails - The details of the reference rendition with start and PDT times for alignment.\n */ function alignMediaPlaylistByPDT(details, refDetails) {\n    if (!details.hasProgramDateTime || !refDetails.hasProgramDateTime) {\n        return;\n    }\n    const fragments = details.fragments;\n    const refFragments = refDetails.fragments;\n    if (!fragments.length || !refFragments.length) {\n        return;\n    }\n    // Calculate a delta to apply to all fragments according to the delta in PDT times and start times\n    // of a fragment in the reference details, and a fragment in the target details of the same discontinuity.\n    // If a fragment of the same discontinuity was not found use the middle fragment of both.\n    let refFrag;\n    let frag;\n    const targetCC = Math.min(refDetails.endCC, details.endCC);\n    if (refDetails.startCC < targetCC && details.startCC < targetCC) {\n        refFrag = findFirstFragWithCC(refFragments, targetCC);\n        frag = findFirstFragWithCC(fragments, targetCC);\n    }\n    if (!refFrag || !frag) {\n        refFrag = refFragments[Math.floor(refFragments.length / 2)];\n        frag = findFirstFragWithCC(fragments, refFrag.cc) || fragments[Math.floor(fragments.length / 2)];\n    }\n    const refPDT = refFrag.programDateTime;\n    const targetPDT = frag.programDateTime;\n    if (!refPDT || !targetPDT) {\n        return;\n    }\n    const delta = (targetPDT - refPDT) / 1000 - (frag.start - refFrag.start);\n    adjustSlidingStart(delta, details);\n}\nconst MIN_CHUNK_SIZE = Math.pow(2, 17); // 128kb\nclass FragmentLoader {\n    constructor(config){\n        this.config = void 0;\n        this.loader = null;\n        this.partLoadTimeout = -1;\n        this.config = config;\n    }\n    destroy() {\n        if (this.loader) {\n            this.loader.destroy();\n            this.loader = null;\n        }\n    }\n    abort() {\n        if (this.loader) {\n            // Abort the loader for current fragment. Only one may load at any given time\n            this.loader.abort();\n        }\n    }\n    load(frag, onProgress) {\n        const url = frag.url;\n        if (!url) {\n            return Promise.reject(new LoadError({\n                type: ErrorTypes.NETWORK_ERROR,\n                details: ErrorDetails.FRAG_LOAD_ERROR,\n                fatal: false,\n                frag,\n                error: new Error(`Fragment does not have a ${url ? \"part list\" : \"url\"}`),\n                networkDetails: null\n            }));\n        }\n        this.abort();\n        const config = this.config;\n        const FragmentILoader = config.fLoader;\n        const DefaultILoader = config.loader;\n        return new Promise((resolve, reject)=>{\n            if (this.loader) {\n                this.loader.destroy();\n            }\n            if (frag.gap) {\n                if (frag.tagList.some((tags)=>tags[0] === \"GAP\")) {\n                    reject(createGapLoadError(frag));\n                    return;\n                } else {\n                    // Reset temporary treatment as GAP tag\n                    frag.gap = false;\n                }\n            }\n            const loader = this.loader = frag.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);\n            const loaderContext = createLoaderContext(frag);\n            const loadPolicy = getLoaderConfigWithoutReties(config.fragLoadPolicy.default);\n            const loaderConfig = {\n                loadPolicy,\n                timeout: loadPolicy.maxLoadTimeMs,\n                maxRetry: 0,\n                retryDelay: 0,\n                maxRetryDelay: 0,\n                highWaterMark: frag.sn === \"initSegment\" ? Infinity : MIN_CHUNK_SIZE\n            };\n            // Assign frag stats to the loader's stats reference\n            frag.stats = loader.stats;\n            loader.load(loaderContext, loaderConfig, {\n                onSuccess: (response, stats, context, networkDetails)=>{\n                    this.resetLoader(frag, loader);\n                    let payload = response.data;\n                    if (context.resetIV && frag.decryptdata) {\n                        frag.decryptdata.iv = new Uint8Array(payload.slice(0, 16));\n                        payload = payload.slice(16);\n                    }\n                    resolve({\n                        frag,\n                        part: null,\n                        payload,\n                        networkDetails\n                    });\n                },\n                onError: (response, context, networkDetails, stats)=>{\n                    this.resetLoader(frag, loader);\n                    reject(new LoadError({\n                        type: ErrorTypes.NETWORK_ERROR,\n                        details: ErrorDetails.FRAG_LOAD_ERROR,\n                        fatal: false,\n                        frag,\n                        response: _objectSpread2({\n                            url,\n                            data: undefined\n                        }, response),\n                        error: new Error(`HTTP Error ${response.code} ${response.text}`),\n                        networkDetails,\n                        stats\n                    }));\n                },\n                onAbort: (stats, context, networkDetails)=>{\n                    this.resetLoader(frag, loader);\n                    reject(new LoadError({\n                        type: ErrorTypes.NETWORK_ERROR,\n                        details: ErrorDetails.INTERNAL_ABORTED,\n                        fatal: false,\n                        frag,\n                        error: new Error(\"Aborted\"),\n                        networkDetails,\n                        stats\n                    }));\n                },\n                onTimeout: (stats, context, networkDetails)=>{\n                    this.resetLoader(frag, loader);\n                    reject(new LoadError({\n                        type: ErrorTypes.NETWORK_ERROR,\n                        details: ErrorDetails.FRAG_LOAD_TIMEOUT,\n                        fatal: false,\n                        frag,\n                        error: new Error(`Timeout after ${loaderConfig.timeout}ms`),\n                        networkDetails,\n                        stats\n                    }));\n                },\n                onProgress: (stats, context, data, networkDetails)=>{\n                    if (onProgress) {\n                        onProgress({\n                            frag,\n                            part: null,\n                            payload: data,\n                            networkDetails\n                        });\n                    }\n                }\n            });\n        });\n    }\n    loadPart(frag, part, onProgress) {\n        this.abort();\n        const config = this.config;\n        const FragmentILoader = config.fLoader;\n        const DefaultILoader = config.loader;\n        return new Promise((resolve, reject)=>{\n            if (this.loader) {\n                this.loader.destroy();\n            }\n            if (frag.gap || part.gap) {\n                reject(createGapLoadError(frag, part));\n                return;\n            }\n            const loader = this.loader = frag.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);\n            const loaderContext = createLoaderContext(frag, part);\n            // Should we define another load policy for parts?\n            const loadPolicy = getLoaderConfigWithoutReties(config.fragLoadPolicy.default);\n            const loaderConfig = {\n                loadPolicy,\n                timeout: loadPolicy.maxLoadTimeMs,\n                maxRetry: 0,\n                retryDelay: 0,\n                maxRetryDelay: 0,\n                highWaterMark: MIN_CHUNK_SIZE\n            };\n            // Assign part stats to the loader's stats reference\n            part.stats = loader.stats;\n            loader.load(loaderContext, loaderConfig, {\n                onSuccess: (response, stats, context, networkDetails)=>{\n                    this.resetLoader(frag, loader);\n                    this.updateStatsFromPart(frag, part);\n                    const partLoadedData = {\n                        frag,\n                        part,\n                        payload: response.data,\n                        networkDetails\n                    };\n                    onProgress(partLoadedData);\n                    resolve(partLoadedData);\n                },\n                onError: (response, context, networkDetails, stats)=>{\n                    this.resetLoader(frag, loader);\n                    reject(new LoadError({\n                        type: ErrorTypes.NETWORK_ERROR,\n                        details: ErrorDetails.FRAG_LOAD_ERROR,\n                        fatal: false,\n                        frag,\n                        part,\n                        response: _objectSpread2({\n                            url: loaderContext.url,\n                            data: undefined\n                        }, response),\n                        error: new Error(`HTTP Error ${response.code} ${response.text}`),\n                        networkDetails,\n                        stats\n                    }));\n                },\n                onAbort: (stats, context, networkDetails)=>{\n                    frag.stats.aborted = part.stats.aborted;\n                    this.resetLoader(frag, loader);\n                    reject(new LoadError({\n                        type: ErrorTypes.NETWORK_ERROR,\n                        details: ErrorDetails.INTERNAL_ABORTED,\n                        fatal: false,\n                        frag,\n                        part,\n                        error: new Error(\"Aborted\"),\n                        networkDetails,\n                        stats\n                    }));\n                },\n                onTimeout: (stats, context, networkDetails)=>{\n                    this.resetLoader(frag, loader);\n                    reject(new LoadError({\n                        type: ErrorTypes.NETWORK_ERROR,\n                        details: ErrorDetails.FRAG_LOAD_TIMEOUT,\n                        fatal: false,\n                        frag,\n                        part,\n                        error: new Error(`Timeout after ${loaderConfig.timeout}ms`),\n                        networkDetails,\n                        stats\n                    }));\n                }\n            });\n        });\n    }\n    updateStatsFromPart(frag, part) {\n        const fragStats = frag.stats;\n        const partStats = part.stats;\n        const partTotal = partStats.total;\n        fragStats.loaded += partStats.loaded;\n        if (partTotal) {\n            const estTotalParts = Math.round(frag.duration / part.duration);\n            const estLoadedParts = Math.min(Math.round(fragStats.loaded / partTotal), estTotalParts);\n            const estRemainingParts = estTotalParts - estLoadedParts;\n            const estRemainingBytes = estRemainingParts * Math.round(fragStats.loaded / estLoadedParts);\n            fragStats.total = fragStats.loaded + estRemainingBytes;\n        } else {\n            fragStats.total = Math.max(fragStats.loaded, fragStats.total);\n        }\n        const fragLoading = fragStats.loading;\n        const partLoading = partStats.loading;\n        if (fragLoading.start) {\n            // add to fragment loader latency\n            fragLoading.first += partLoading.first - partLoading.start;\n        } else {\n            fragLoading.start = partLoading.start;\n            fragLoading.first = partLoading.first;\n        }\n        fragLoading.end = partLoading.end;\n    }\n    resetLoader(frag, loader) {\n        frag.loader = null;\n        if (this.loader === loader) {\n            self.clearTimeout(this.partLoadTimeout);\n            this.loader = null;\n        }\n        loader.destroy();\n    }\n}\nfunction createLoaderContext(frag, part = null) {\n    const segment = part || frag;\n    const loaderContext = {\n        frag,\n        part,\n        responseType: \"arraybuffer\",\n        url: segment.url,\n        headers: {},\n        rangeStart: 0,\n        rangeEnd: 0\n    };\n    const start = segment.byteRangeStartOffset;\n    const end = segment.byteRangeEndOffset;\n    if (isFiniteNumber(start) && isFiniteNumber(end)) {\n        var _frag$decryptdata;\n        let byteRangeStart = start;\n        let byteRangeEnd = end;\n        if (frag.sn === \"initSegment\" && ((_frag$decryptdata = frag.decryptdata) == null ? void 0 : _frag$decryptdata.method) === \"AES-128\") {\n            // MAP segment encrypted with method 'AES-128', when served with HTTP Range,\n            // has the unencrypted size specified in the range.\n            // Ref: https://tools.ietf.org/html/draft-pantos-hls-rfc8216bis-08#section-6.3.6\n            const fragmentLen = end - start;\n            if (fragmentLen % 16) {\n                byteRangeEnd = end + (16 - fragmentLen % 16);\n            }\n            if (start !== 0) {\n                loaderContext.resetIV = true;\n                byteRangeStart = start - 16;\n            }\n        }\n        loaderContext.rangeStart = byteRangeStart;\n        loaderContext.rangeEnd = byteRangeEnd;\n    }\n    return loaderContext;\n}\nfunction createGapLoadError(frag, part) {\n    const error = new Error(`GAP ${frag.gap ? \"tag\" : \"attribute\"} found`);\n    const errorData = {\n        type: ErrorTypes.MEDIA_ERROR,\n        details: ErrorDetails.FRAG_GAP,\n        fatal: false,\n        frag,\n        error,\n        networkDetails: null\n    };\n    if (part) {\n        errorData.part = part;\n    }\n    (part ? part : frag).stats.aborted = true;\n    return new LoadError(errorData);\n}\nclass LoadError extends Error {\n    constructor(data){\n        super(data.error.message);\n        this.data = void 0;\n        this.data = data;\n    }\n}\nclass AESCrypto {\n    constructor(subtle, iv){\n        this.subtle = void 0;\n        this.aesIV = void 0;\n        this.subtle = subtle;\n        this.aesIV = iv;\n    }\n    decrypt(data, key) {\n        return this.subtle.decrypt({\n            name: \"AES-CBC\",\n            iv: this.aesIV\n        }, key, data);\n    }\n}\nclass FastAESKey {\n    constructor(subtle, key){\n        this.subtle = void 0;\n        this.key = void 0;\n        this.subtle = subtle;\n        this.key = key;\n    }\n    expandKey() {\n        return this.subtle.importKey(\"raw\", this.key, {\n            name: \"AES-CBC\"\n        }, false, [\n            \"encrypt\",\n            \"decrypt\"\n        ]);\n    }\n}\n// PKCS7\nfunction removePadding(array) {\n    const outputBytes = array.byteLength;\n    const paddingBytes = outputBytes && new DataView(array.buffer).getUint8(outputBytes - 1);\n    if (paddingBytes) {\n        return sliceUint8(array, 0, outputBytes - paddingBytes);\n    }\n    return array;\n}\nclass AESDecryptor {\n    constructor(){\n        this.rcon = [\n            0x0,\n            0x1,\n            0x2,\n            0x4,\n            0x8,\n            0x10,\n            0x20,\n            0x40,\n            0x80,\n            0x1b,\n            0x36\n        ];\n        this.subMix = [\n            new Uint32Array(256),\n            new Uint32Array(256),\n            new Uint32Array(256),\n            new Uint32Array(256)\n        ];\n        this.invSubMix = [\n            new Uint32Array(256),\n            new Uint32Array(256),\n            new Uint32Array(256),\n            new Uint32Array(256)\n        ];\n        this.sBox = new Uint32Array(256);\n        this.invSBox = new Uint32Array(256);\n        this.key = new Uint32Array(0);\n        this.ksRows = 0;\n        this.keySize = 0;\n        this.keySchedule = void 0;\n        this.invKeySchedule = void 0;\n        this.initTable();\n    }\n    // Using view.getUint32() also swaps the byte order.\n    uint8ArrayToUint32Array_(arrayBuffer) {\n        const view = new DataView(arrayBuffer);\n        const newArray = new Uint32Array(4);\n        for(let i = 0; i < 4; i++){\n            newArray[i] = view.getUint32(i * 4);\n        }\n        return newArray;\n    }\n    initTable() {\n        const sBox = this.sBox;\n        const invSBox = this.invSBox;\n        const subMix = this.subMix;\n        const subMix0 = subMix[0];\n        const subMix1 = subMix[1];\n        const subMix2 = subMix[2];\n        const subMix3 = subMix[3];\n        const invSubMix = this.invSubMix;\n        const invSubMix0 = invSubMix[0];\n        const invSubMix1 = invSubMix[1];\n        const invSubMix2 = invSubMix[2];\n        const invSubMix3 = invSubMix[3];\n        const d = new Uint32Array(256);\n        let x = 0;\n        let xi = 0;\n        let i = 0;\n        for(i = 0; i < 256; i++){\n            if (i < 128) {\n                d[i] = i << 1;\n            } else {\n                d[i] = i << 1 ^ 0x11b;\n            }\n        }\n        for(i = 0; i < 256; i++){\n            let sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;\n            sx = sx >>> 8 ^ sx & 0xff ^ 0x63;\n            sBox[x] = sx;\n            invSBox[sx] = x;\n            // Compute multiplication\n            const x2 = d[x];\n            const x4 = d[x2];\n            const x8 = d[x4];\n            // Compute sub/invSub bytes, mix columns tables\n            let t = d[sx] * 0x101 ^ sx * 0x1010100;\n            subMix0[x] = t << 24 | t >>> 8;\n            subMix1[x] = t << 16 | t >>> 16;\n            subMix2[x] = t << 8 | t >>> 24;\n            subMix3[x] = t;\n            // Compute inv sub bytes, inv mix columns tables\n            t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;\n            invSubMix0[sx] = t << 24 | t >>> 8;\n            invSubMix1[sx] = t << 16 | t >>> 16;\n            invSubMix2[sx] = t << 8 | t >>> 24;\n            invSubMix3[sx] = t;\n            // Compute next counter\n            if (!x) {\n                x = xi = 1;\n            } else {\n                x = x2 ^ d[d[d[x8 ^ x2]]];\n                xi ^= d[d[xi]];\n            }\n        }\n    }\n    expandKey(keyBuffer) {\n        // convert keyBuffer to Uint32Array\n        const key = this.uint8ArrayToUint32Array_(keyBuffer);\n        let sameKey = true;\n        let offset = 0;\n        while(offset < key.length && sameKey){\n            sameKey = key[offset] === this.key[offset];\n            offset++;\n        }\n        if (sameKey) {\n            return;\n        }\n        this.key = key;\n        const keySize = this.keySize = key.length;\n        if (keySize !== 4 && keySize !== 6 && keySize !== 8) {\n            throw new Error(\"Invalid aes key size=\" + keySize);\n        }\n        const ksRows = this.ksRows = (keySize + 6 + 1) * 4;\n        let ksRow;\n        let invKsRow;\n        const keySchedule = this.keySchedule = new Uint32Array(ksRows);\n        const invKeySchedule = this.invKeySchedule = new Uint32Array(ksRows);\n        const sbox = this.sBox;\n        const rcon = this.rcon;\n        const invSubMix = this.invSubMix;\n        const invSubMix0 = invSubMix[0];\n        const invSubMix1 = invSubMix[1];\n        const invSubMix2 = invSubMix[2];\n        const invSubMix3 = invSubMix[3];\n        let prev;\n        let t;\n        for(ksRow = 0; ksRow < ksRows; ksRow++){\n            if (ksRow < keySize) {\n                prev = keySchedule[ksRow] = key[ksRow];\n                continue;\n            }\n            t = prev;\n            if (ksRow % keySize === 0) {\n                // Rot word\n                t = t << 8 | t >>> 24;\n                // Sub word\n                t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];\n                // Mix Rcon\n                t ^= rcon[ksRow / keySize | 0] << 24;\n            } else if (keySize > 6 && ksRow % keySize === 4) {\n                // Sub word\n                t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];\n            }\n            keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t) >>> 0;\n        }\n        for(invKsRow = 0; invKsRow < ksRows; invKsRow++){\n            ksRow = ksRows - invKsRow;\n            if (invKsRow & 3) {\n                t = keySchedule[ksRow];\n            } else {\n                t = keySchedule[ksRow - 4];\n            }\n            if (invKsRow < 4 || ksRow <= 4) {\n                invKeySchedule[invKsRow] = t;\n            } else {\n                invKeySchedule[invKsRow] = invSubMix0[sbox[t >>> 24]] ^ invSubMix1[sbox[t >>> 16 & 0xff]] ^ invSubMix2[sbox[t >>> 8 & 0xff]] ^ invSubMix3[sbox[t & 0xff]];\n            }\n            invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;\n        }\n    }\n    // Adding this as a method greatly improves performance.\n    networkToHostOrderSwap(word) {\n        return word << 24 | (word & 0xff00) << 8 | (word & 0xff0000) >> 8 | word >>> 24;\n    }\n    decrypt(inputArrayBuffer, offset, aesIV) {\n        const nRounds = this.keySize + 6;\n        const invKeySchedule = this.invKeySchedule;\n        const invSBOX = this.invSBox;\n        const invSubMix = this.invSubMix;\n        const invSubMix0 = invSubMix[0];\n        const invSubMix1 = invSubMix[1];\n        const invSubMix2 = invSubMix[2];\n        const invSubMix3 = invSubMix[3];\n        const initVector = this.uint8ArrayToUint32Array_(aesIV);\n        let initVector0 = initVector[0];\n        let initVector1 = initVector[1];\n        let initVector2 = initVector[2];\n        let initVector3 = initVector[3];\n        const inputInt32 = new Int32Array(inputArrayBuffer);\n        const outputInt32 = new Int32Array(inputInt32.length);\n        let t0, t1, t2, t3;\n        let s0, s1, s2, s3;\n        let inputWords0, inputWords1, inputWords2, inputWords3;\n        let ksRow, i;\n        const swapWord = this.networkToHostOrderSwap;\n        while(offset < inputInt32.length){\n            inputWords0 = swapWord(inputInt32[offset]);\n            inputWords1 = swapWord(inputInt32[offset + 1]);\n            inputWords2 = swapWord(inputInt32[offset + 2]);\n            inputWords3 = swapWord(inputInt32[offset + 3]);\n            s0 = inputWords0 ^ invKeySchedule[0];\n            s1 = inputWords3 ^ invKeySchedule[1];\n            s2 = inputWords2 ^ invKeySchedule[2];\n            s3 = inputWords1 ^ invKeySchedule[3];\n            ksRow = 4;\n            // Iterate through the rounds of decryption\n            for(i = 1; i < nRounds; i++){\n                t0 = invSubMix0[s0 >>> 24] ^ invSubMix1[s1 >> 16 & 0xff] ^ invSubMix2[s2 >> 8 & 0xff] ^ invSubMix3[s3 & 0xff] ^ invKeySchedule[ksRow];\n                t1 = invSubMix0[s1 >>> 24] ^ invSubMix1[s2 >> 16 & 0xff] ^ invSubMix2[s3 >> 8 & 0xff] ^ invSubMix3[s0 & 0xff] ^ invKeySchedule[ksRow + 1];\n                t2 = invSubMix0[s2 >>> 24] ^ invSubMix1[s3 >> 16 & 0xff] ^ invSubMix2[s0 >> 8 & 0xff] ^ invSubMix3[s1 & 0xff] ^ invKeySchedule[ksRow + 2];\n                t3 = invSubMix0[s3 >>> 24] ^ invSubMix1[s0 >> 16 & 0xff] ^ invSubMix2[s1 >> 8 & 0xff] ^ invSubMix3[s2 & 0xff] ^ invKeySchedule[ksRow + 3];\n                // Update state\n                s0 = t0;\n                s1 = t1;\n                s2 = t2;\n                s3 = t3;\n                ksRow = ksRow + 4;\n            }\n            // Shift rows, sub bytes, add round key\n            t0 = invSBOX[s0 >>> 24] << 24 ^ invSBOX[s1 >> 16 & 0xff] << 16 ^ invSBOX[s2 >> 8 & 0xff] << 8 ^ invSBOX[s3 & 0xff] ^ invKeySchedule[ksRow];\n            t1 = invSBOX[s1 >>> 24] << 24 ^ invSBOX[s2 >> 16 & 0xff] << 16 ^ invSBOX[s3 >> 8 & 0xff] << 8 ^ invSBOX[s0 & 0xff] ^ invKeySchedule[ksRow + 1];\n            t2 = invSBOX[s2 >>> 24] << 24 ^ invSBOX[s3 >> 16 & 0xff] << 16 ^ invSBOX[s0 >> 8 & 0xff] << 8 ^ invSBOX[s1 & 0xff] ^ invKeySchedule[ksRow + 2];\n            t3 = invSBOX[s3 >>> 24] << 24 ^ invSBOX[s0 >> 16 & 0xff] << 16 ^ invSBOX[s1 >> 8 & 0xff] << 8 ^ invSBOX[s2 & 0xff] ^ invKeySchedule[ksRow + 3];\n            // Write\n            outputInt32[offset] = swapWord(t0 ^ initVector0);\n            outputInt32[offset + 1] = swapWord(t3 ^ initVector1);\n            outputInt32[offset + 2] = swapWord(t2 ^ initVector2);\n            outputInt32[offset + 3] = swapWord(t1 ^ initVector3);\n            // reset initVector to last 4 unsigned int\n            initVector0 = inputWords0;\n            initVector1 = inputWords1;\n            initVector2 = inputWords2;\n            initVector3 = inputWords3;\n            offset = offset + 4;\n        }\n        return outputInt32.buffer;\n    }\n}\nconst CHUNK_SIZE = 16; // 16 bytes, 128 bits\nclass Decrypter {\n    constructor(config, { removePKCS7Padding = true } = {}){\n        this.logEnabled = true;\n        this.removePKCS7Padding = void 0;\n        this.subtle = null;\n        this.softwareDecrypter = null;\n        this.key = null;\n        this.fastAesKey = null;\n        this.remainderData = null;\n        this.currentIV = null;\n        this.currentResult = null;\n        this.useSoftware = void 0;\n        this.useSoftware = config.enableSoftwareAES;\n        this.removePKCS7Padding = removePKCS7Padding;\n        // built in decryptor expects PKCS7 padding\n        if (removePKCS7Padding) {\n            try {\n                const browserCrypto = self.crypto;\n                if (browserCrypto) {\n                    this.subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;\n                }\n            } catch (e) {\n            /* no-op */ }\n        }\n        if (this.subtle === null) {\n            this.useSoftware = true;\n        }\n    }\n    destroy() {\n        this.subtle = null;\n        this.softwareDecrypter = null;\n        this.key = null;\n        this.fastAesKey = null;\n        this.remainderData = null;\n        this.currentIV = null;\n        this.currentResult = null;\n    }\n    isSync() {\n        return this.useSoftware;\n    }\n    flush() {\n        const { currentResult, remainderData } = this;\n        if (!currentResult || remainderData) {\n            this.reset();\n            return null;\n        }\n        const data = new Uint8Array(currentResult);\n        this.reset();\n        if (this.removePKCS7Padding) {\n            return removePadding(data);\n        }\n        return data;\n    }\n    reset() {\n        this.currentResult = null;\n        this.currentIV = null;\n        this.remainderData = null;\n        if (this.softwareDecrypter) {\n            this.softwareDecrypter = null;\n        }\n    }\n    decrypt(data, key, iv) {\n        if (this.useSoftware) {\n            return new Promise((resolve, reject)=>{\n                this.softwareDecrypt(new Uint8Array(data), key, iv);\n                const decryptResult = this.flush();\n                if (decryptResult) {\n                    resolve(decryptResult.buffer);\n                } else {\n                    reject(new Error(\"[softwareDecrypt] Failed to decrypt data\"));\n                }\n            });\n        }\n        return this.webCryptoDecrypt(new Uint8Array(data), key, iv);\n    }\n    // Software decryption is progressive. Progressive decryption may not return a result on each call. Any cached\n    // data is handled in the flush() call\n    softwareDecrypt(data, key, iv) {\n        const { currentIV, currentResult, remainderData } = this;\n        this.logOnce(\"JS AES decrypt\");\n        // The output is staggered during progressive parsing - the current result is cached, and emitted on the next call\n        // This is done in order to strip PKCS7 padding, which is found at the end of each segment. We only know we've reached\n        // the end on flush(), but by that time we have already received all bytes for the segment.\n        // Progressive decryption does not work with WebCrypto\n        if (remainderData) {\n            data = appendUint8Array(remainderData, data);\n            this.remainderData = null;\n        }\n        // Byte length must be a multiple of 16 (AES-128 = 128 bit blocks = 16 bytes)\n        const currentChunk = this.getValidChunk(data);\n        if (!currentChunk.length) {\n            return null;\n        }\n        if (currentIV) {\n            iv = currentIV;\n        }\n        let softwareDecrypter = this.softwareDecrypter;\n        if (!softwareDecrypter) {\n            softwareDecrypter = this.softwareDecrypter = new AESDecryptor();\n        }\n        softwareDecrypter.expandKey(key);\n        const result = currentResult;\n        this.currentResult = softwareDecrypter.decrypt(currentChunk.buffer, 0, iv);\n        this.currentIV = sliceUint8(currentChunk, -16).buffer;\n        if (!result) {\n            return null;\n        }\n        return result;\n    }\n    webCryptoDecrypt(data, key, iv) {\n        const subtle = this.subtle;\n        if (this.key !== key || !this.fastAesKey) {\n            this.key = key;\n            this.fastAesKey = new FastAESKey(subtle, key);\n        }\n        return this.fastAesKey.expandKey().then((aesKey)=>{\n            // decrypt using web crypto\n            if (!subtle) {\n                return Promise.reject(new Error(\"web crypto not initialized\"));\n            }\n            this.logOnce(\"WebCrypto AES decrypt\");\n            const crypto1 = new AESCrypto(subtle, new Uint8Array(iv));\n            return crypto1.decrypt(data.buffer, aesKey);\n        }).catch((err)=>{\n            logger.warn(`[decrypter]: WebCrypto Error, disable WebCrypto API, ${err.name}: ${err.message}`);\n            return this.onWebCryptoError(data, key, iv);\n        });\n    }\n    onWebCryptoError(data, key, iv) {\n        this.useSoftware = true;\n        this.logEnabled = true;\n        this.softwareDecrypt(data, key, iv);\n        const decryptResult = this.flush();\n        if (decryptResult) {\n            return decryptResult.buffer;\n        }\n        throw new Error(\"WebCrypto and softwareDecrypt: failed to decrypt data\");\n    }\n    getValidChunk(data) {\n        let currentChunk = data;\n        const splitPoint = data.length - data.length % CHUNK_SIZE;\n        if (splitPoint !== data.length) {\n            currentChunk = sliceUint8(data, 0, splitPoint);\n            this.remainderData = sliceUint8(data, splitPoint);\n        }\n        return currentChunk;\n    }\n    logOnce(msg) {\n        if (!this.logEnabled) {\n            return;\n        }\n        logger.log(`[decrypter]: ${msg}`);\n        this.logEnabled = false;\n    }\n}\n/**\n *  TimeRanges to string helper\n */ const TimeRanges = {\n    toString: function(r) {\n        let log = \"\";\n        const len = r.length;\n        for(let i = 0; i < len; i++){\n            log += `[${r.start(i).toFixed(3)}-${r.end(i).toFixed(3)}]`;\n        }\n        return log;\n    }\n};\nconst State = {\n    STOPPED: \"STOPPED\",\n    IDLE: \"IDLE\",\n    KEY_LOADING: \"KEY_LOADING\",\n    FRAG_LOADING: \"FRAG_LOADING\",\n    FRAG_LOADING_WAITING_RETRY: \"FRAG_LOADING_WAITING_RETRY\",\n    WAITING_TRACK: \"WAITING_TRACK\",\n    PARSING: \"PARSING\",\n    PARSED: \"PARSED\",\n    ENDED: \"ENDED\",\n    ERROR: \"ERROR\",\n    WAITING_INIT_PTS: \"WAITING_INIT_PTS\",\n    WAITING_LEVEL: \"WAITING_LEVEL\"\n};\nclass BaseStreamController extends TaskLoop {\n    constructor(hls, fragmentTracker, keyLoader, logPrefix, playlistType){\n        super();\n        this.hls = void 0;\n        this.fragPrevious = null;\n        this.fragCurrent = null;\n        this.fragmentTracker = void 0;\n        this.transmuxer = null;\n        this._state = State.STOPPED;\n        this.playlistType = void 0;\n        this.media = null;\n        this.mediaBuffer = null;\n        this.config = void 0;\n        this.bitrateTest = false;\n        this.lastCurrentTime = 0;\n        this.nextLoadPosition = 0;\n        this.startPosition = 0;\n        this.startTimeOffset = null;\n        this.loadedmetadata = false;\n        this.retryDate = 0;\n        this.levels = null;\n        this.fragmentLoader = void 0;\n        this.keyLoader = void 0;\n        this.levelLastLoaded = null;\n        this.startFragRequested = false;\n        this.decrypter = void 0;\n        this.initPTS = [];\n        this.onvseeking = null;\n        this.onvended = null;\n        this.logPrefix = \"\";\n        this.log = void 0;\n        this.warn = void 0;\n        this.playlistType = playlistType;\n        this.logPrefix = logPrefix;\n        this.log = logger.log.bind(logger, `${logPrefix}:`);\n        this.warn = logger.warn.bind(logger, `${logPrefix}:`);\n        this.hls = hls;\n        this.fragmentLoader = new FragmentLoader(hls.config);\n        this.keyLoader = keyLoader;\n        this.fragmentTracker = fragmentTracker;\n        this.config = hls.config;\n        this.decrypter = new Decrypter(hls.config);\n        hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    }\n    doTick() {\n        this.onTickEnd();\n    }\n    onTickEnd() {}\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    startLoad(startPosition) {}\n    stopLoad() {\n        this.fragmentLoader.abort();\n        this.keyLoader.abort(this.playlistType);\n        const frag = this.fragCurrent;\n        if (frag != null && frag.loader) {\n            frag.abortRequests();\n            this.fragmentTracker.removeFragment(frag);\n        }\n        this.resetTransmuxer();\n        this.fragCurrent = null;\n        this.fragPrevious = null;\n        this.clearInterval();\n        this.clearNextTick();\n        this.state = State.STOPPED;\n    }\n    _streamEnded(bufferInfo, levelDetails) {\n        // If playlist is live, there is another buffered range after the current range, nothing buffered, media is detached,\n        // of nothing loading/loaded return false\n        if (levelDetails.live || bufferInfo.nextStart || !bufferInfo.end || !this.media) {\n            return false;\n        }\n        const partList = levelDetails.partList;\n        // Since the last part isn't guaranteed to correspond to the last playlist segment for Low-Latency HLS,\n        // check instead if the last part is buffered.\n        if (partList != null && partList.length) {\n            const lastPart = partList[partList.length - 1];\n            // Checking the midpoint of the part for potential margin of error and related issues.\n            // NOTE: Technically I believe parts could yield content that is < the computed duration (including potential a duration of 0)\n            // and still be spec-compliant, so there may still be edge cases here. Likewise, there could be issues in end of stream\n            // part mismatches for independent audio and video playlists/segments.\n            const lastPartBuffered = BufferHelper.isBuffered(this.media, lastPart.start + lastPart.duration / 2);\n            return lastPartBuffered;\n        }\n        const playlistType = levelDetails.fragments[levelDetails.fragments.length - 1].type;\n        return this.fragmentTracker.isEndListAppended(playlistType);\n    }\n    getLevelDetails() {\n        if (this.levels && this.levelLastLoaded !== null) {\n            var _this$levelLastLoaded;\n            return (_this$levelLastLoaded = this.levelLastLoaded) == null ? void 0 : _this$levelLastLoaded.details;\n        }\n    }\n    onMediaAttached(event, data) {\n        const media = this.media = this.mediaBuffer = data.media;\n        this.onvseeking = this.onMediaSeeking.bind(this);\n        this.onvended = this.onMediaEnded.bind(this);\n        media.addEventListener(\"seeking\", this.onvseeking);\n        media.addEventListener(\"ended\", this.onvended);\n        const config = this.config;\n        if (this.levels && config.autoStartLoad && this.state === State.STOPPED) {\n            this.startLoad(config.startPosition);\n        }\n    }\n    onMediaDetaching() {\n        const media = this.media;\n        if (media != null && media.ended) {\n            this.log(\"MSE detaching and video ended, reset startPosition\");\n            this.startPosition = this.lastCurrentTime = 0;\n        }\n        // remove video listeners\n        if (media && this.onvseeking && this.onvended) {\n            media.removeEventListener(\"seeking\", this.onvseeking);\n            media.removeEventListener(\"ended\", this.onvended);\n            this.onvseeking = this.onvended = null;\n        }\n        if (this.keyLoader) {\n            this.keyLoader.detach();\n        }\n        this.media = this.mediaBuffer = null;\n        this.loadedmetadata = false;\n        this.fragmentTracker.removeAllFragments();\n        this.stopLoad();\n    }\n    onMediaSeeking() {\n        const { config, fragCurrent, media, mediaBuffer, state } = this;\n        const currentTime = media ? media.currentTime : 0;\n        const bufferInfo = BufferHelper.bufferInfo(mediaBuffer ? mediaBuffer : media, currentTime, config.maxBufferHole);\n        this.log(`media seeking to ${isFiniteNumber(currentTime) ? currentTime.toFixed(3) : currentTime}, state: ${state}`);\n        if (this.state === State.ENDED) {\n            this.resetLoadingState();\n        } else if (fragCurrent) {\n            // Seeking while frag load is in progress\n            const tolerance = config.maxFragLookUpTolerance;\n            const fragStartOffset = fragCurrent.start - tolerance;\n            const fragEndOffset = fragCurrent.start + fragCurrent.duration + tolerance;\n            // if seeking out of buffered range or into new one\n            if (!bufferInfo.len || fragEndOffset < bufferInfo.start || fragStartOffset > bufferInfo.end) {\n                const pastFragment = currentTime > fragEndOffset;\n                // if the seek position is outside the current fragment range\n                if (currentTime < fragStartOffset || pastFragment) {\n                    if (pastFragment && fragCurrent.loader) {\n                        this.log(\"seeking outside of buffer while fragment load in progress, cancel fragment load\");\n                        fragCurrent.abortRequests();\n                        this.resetLoadingState();\n                    }\n                    this.fragPrevious = null;\n                }\n            }\n        }\n        if (media) {\n            // Remove gap fragments\n            this.fragmentTracker.removeFragmentsInRange(currentTime, Infinity, this.playlistType, true);\n            this.lastCurrentTime = currentTime;\n        }\n        // in case seeking occurs although no media buffered, adjust startPosition and nextLoadPosition to seek target\n        if (!this.loadedmetadata && !bufferInfo.len) {\n            this.nextLoadPosition = this.startPosition = currentTime;\n        }\n        // Async tick to speed up processing\n        this.tickImmediate();\n    }\n    onMediaEnded() {\n        // reset startPosition and lastCurrentTime to restart playback @ stream beginning\n        this.startPosition = this.lastCurrentTime = 0;\n    }\n    onManifestLoaded(event, data) {\n        this.startTimeOffset = data.startTimeOffset;\n        this.initPTS = [];\n    }\n    onHandlerDestroying() {\n        this.hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n        this.stopLoad();\n        super.onHandlerDestroying();\n        // @ts-ignore\n        this.hls = null;\n    }\n    onHandlerDestroyed() {\n        this.state = State.STOPPED;\n        if (this.fragmentLoader) {\n            this.fragmentLoader.destroy();\n        }\n        if (this.keyLoader) {\n            this.keyLoader.destroy();\n        }\n        if (this.decrypter) {\n            this.decrypter.destroy();\n        }\n        this.hls = this.log = this.warn = this.decrypter = this.keyLoader = this.fragmentLoader = this.fragmentTracker = null;\n        super.onHandlerDestroyed();\n    }\n    loadFragment(frag, level, targetBufferTime) {\n        this._loadFragForPlayback(frag, level, targetBufferTime);\n    }\n    _loadFragForPlayback(frag, level, targetBufferTime) {\n        const progressCallback = (data)=>{\n            if (this.fragContextChanged(frag)) {\n                this.warn(`Fragment ${frag.sn}${data.part ? \" p: \" + data.part.index : \"\"} of level ${frag.level} was dropped during download.`);\n                this.fragmentTracker.removeFragment(frag);\n                return;\n            }\n            frag.stats.chunkCount++;\n            this._handleFragmentLoadProgress(data);\n        };\n        this._doFragLoad(frag, level, targetBufferTime, progressCallback).then((data)=>{\n            if (!data) {\n                // if we're here we probably needed to backtrack or are waiting for more parts\n                return;\n            }\n            const state = this.state;\n            if (this.fragContextChanged(frag)) {\n                if (state === State.FRAG_LOADING || !this.fragCurrent && state === State.PARSING) {\n                    this.fragmentTracker.removeFragment(frag);\n                    this.state = State.IDLE;\n                }\n                return;\n            }\n            if (\"payload\" in data) {\n                this.log(`Loaded fragment ${frag.sn} of level ${frag.level}`);\n                this.hls.trigger(Events.FRAG_LOADED, data);\n            }\n            // Pass through the whole payload; controllers not implementing progressive loading receive data from this callback\n            this._handleFragmentLoadComplete(data);\n        }).catch((reason)=>{\n            if (this.state === State.STOPPED || this.state === State.ERROR) {\n                return;\n            }\n            this.warn(reason);\n            this.resetFragmentLoading(frag);\n        });\n    }\n    clearTrackerIfNeeded(frag) {\n        var _this$mediaBuffer;\n        const { fragmentTracker } = this;\n        const fragState = fragmentTracker.getState(frag);\n        if (fragState === FragmentState.APPENDING) {\n            // Lower the buffer size and try again\n            const playlistType = frag.type;\n            const bufferedInfo = this.getFwdBufferInfo(this.mediaBuffer, playlistType);\n            const minForwardBufferLength = Math.max(frag.duration, bufferedInfo ? bufferedInfo.len : this.config.maxBufferLength);\n            if (this.reduceMaxBufferLength(minForwardBufferLength)) {\n                fragmentTracker.removeFragment(frag);\n            }\n        } else if (((_this$mediaBuffer = this.mediaBuffer) == null ? void 0 : _this$mediaBuffer.buffered.length) === 0) {\n            // Stop gap for bad tracker / buffer flush behavior\n            fragmentTracker.removeAllFragments();\n        } else if (fragmentTracker.hasParts(frag.type)) {\n            // In low latency mode, remove fragments for which only some parts were buffered\n            fragmentTracker.detectPartialFragments({\n                frag,\n                part: null,\n                stats: frag.stats,\n                id: frag.type\n            });\n            if (fragmentTracker.getState(frag) === FragmentState.PARTIAL) {\n                fragmentTracker.removeFragment(frag);\n            }\n        }\n    }\n    checkLiveUpdate(details) {\n        if (details.updated && !details.live) {\n            // Live stream ended, update fragment tracker\n            const lastFragment = details.fragments[details.fragments.length - 1];\n            this.fragmentTracker.detectPartialFragments({\n                frag: lastFragment,\n                part: null,\n                stats: lastFragment.stats,\n                id: lastFragment.type\n            });\n        }\n        if (!details.fragments[0]) {\n            details.deltaUpdateFailed = true;\n        }\n    }\n    flushMainBuffer(startOffset, endOffset, type = null) {\n        if (!(startOffset - endOffset)) {\n            return;\n        }\n        // When alternate audio is playing, the audio-stream-controller is responsible for the audio buffer. Otherwise,\n        // passing a null type flushes both buffers\n        const flushScope = {\n            startOffset,\n            endOffset,\n            type\n        };\n        this.hls.trigger(Events.BUFFER_FLUSHING, flushScope);\n    }\n    _loadInitSegment(frag, level) {\n        this._doFragLoad(frag, level).then((data)=>{\n            if (!data || this.fragContextChanged(frag) || !this.levels) {\n                throw new Error(\"init load aborted\");\n            }\n            return data;\n        }).then((data)=>{\n            const { hls } = this;\n            const { payload } = data;\n            const decryptData = frag.decryptdata;\n            // check to see if the payload needs to be decrypted\n            if (payload && payload.byteLength > 0 && decryptData != null && decryptData.key && decryptData.iv && decryptData.method === \"AES-128\") {\n                const startTime = self.performance.now();\n                // decrypt init segment data\n                return this.decrypter.decrypt(new Uint8Array(payload), decryptData.key.buffer, decryptData.iv.buffer).catch((err)=>{\n                    hls.trigger(Events.ERROR, {\n                        type: ErrorTypes.MEDIA_ERROR,\n                        details: ErrorDetails.FRAG_DECRYPT_ERROR,\n                        fatal: false,\n                        error: err,\n                        reason: err.message,\n                        frag\n                    });\n                    throw err;\n                }).then((decryptedData)=>{\n                    const endTime = self.performance.now();\n                    hls.trigger(Events.FRAG_DECRYPTED, {\n                        frag,\n                        payload: decryptedData,\n                        stats: {\n                            tstart: startTime,\n                            tdecrypt: endTime\n                        }\n                    });\n                    data.payload = decryptedData;\n                    return this.completeInitSegmentLoad(data);\n                });\n            }\n            return this.completeInitSegmentLoad(data);\n        }).catch((reason)=>{\n            if (this.state === State.STOPPED || this.state === State.ERROR) {\n                return;\n            }\n            this.warn(reason);\n            this.resetFragmentLoading(frag);\n        });\n    }\n    completeInitSegmentLoad(data) {\n        const { levels } = this;\n        if (!levels) {\n            throw new Error(\"init load aborted, missing levels\");\n        }\n        const stats = data.frag.stats;\n        this.state = State.IDLE;\n        data.frag.data = new Uint8Array(data.payload);\n        stats.parsing.start = stats.buffering.start = self.performance.now();\n        stats.parsing.end = stats.buffering.end = self.performance.now();\n        this.tick();\n    }\n    fragContextChanged(frag) {\n        const { fragCurrent } = this;\n        return !frag || !fragCurrent || frag.sn !== fragCurrent.sn || frag.level !== fragCurrent.level;\n    }\n    fragBufferedComplete(frag, part) {\n        var _frag$startPTS, _frag$endPTS, _this$fragCurrent, _this$fragPrevious;\n        const media = this.mediaBuffer ? this.mediaBuffer : this.media;\n        this.log(`Buffered ${frag.type} sn: ${frag.sn}${part ? \" part: \" + part.index : \"\"} of ${this.playlistType === PlaylistLevelType.MAIN ? \"level\" : \"track\"} ${frag.level} (frag:[${((_frag$startPTS = frag.startPTS) != null ? _frag$startPTS : NaN).toFixed(3)}-${((_frag$endPTS = frag.endPTS) != null ? _frag$endPTS : NaN).toFixed(3)}] > buffer:${media ? TimeRanges.toString(BufferHelper.getBuffered(media)) : \"(detached)\"})`);\n        if (frag.sn !== \"initSegment\") {\n            var _this$levels;\n            if (frag.type !== PlaylistLevelType.SUBTITLE) {\n                const el = frag.elementaryStreams;\n                if (!Object.keys(el).some((type)=>!!el[type])) {\n                    // empty segment\n                    this.state = State.IDLE;\n                    return;\n                }\n            }\n            const level = (_this$levels = this.levels) == null ? void 0 : _this$levels[frag.level];\n            if (level != null && level.fragmentError) {\n                this.log(`Resetting level fragment error count of ${level.fragmentError} on frag buffered`);\n                level.fragmentError = 0;\n            }\n        }\n        this.state = State.IDLE;\n        if (!media) {\n            return;\n        }\n        if (!this.loadedmetadata && frag.type == PlaylistLevelType.MAIN && media.buffered.length && ((_this$fragCurrent = this.fragCurrent) == null ? void 0 : _this$fragCurrent.sn) === ((_this$fragPrevious = this.fragPrevious) == null ? void 0 : _this$fragPrevious.sn)) {\n            this.loadedmetadata = true;\n            this.seekToStartPos();\n        }\n        this.tick();\n    }\n    seekToStartPos() {}\n    _handleFragmentLoadComplete(fragLoadedEndData) {\n        const { transmuxer } = this;\n        if (!transmuxer) {\n            return;\n        }\n        const { frag, part, partsLoaded } = fragLoadedEndData;\n        // If we did not load parts, or loaded all parts, we have complete (not partial) fragment data\n        const complete = !partsLoaded || partsLoaded.length === 0 || partsLoaded.some((fragLoaded)=>!fragLoaded);\n        const chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount + 1, 0, part ? part.index : -1, !complete);\n        transmuxer.flush(chunkMeta);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _handleFragmentLoadProgress(frag) {}\n    _doFragLoad(frag, level, targetBufferTime = null, progressCallback) {\n        var _frag$decryptdata;\n        const details = level == null ? void 0 : level.details;\n        if (!this.levels || !details) {\n            throw new Error(`frag load aborted, missing level${details ? \"\" : \" detail\"}s`);\n        }\n        let keyLoadingPromise = null;\n        if (frag.encrypted && !((_frag$decryptdata = frag.decryptdata) != null && _frag$decryptdata.key)) {\n            this.log(`Loading key for ${frag.sn} of [${details.startSN}-${details.endSN}], ${this.logPrefix === \"[stream-controller]\" ? \"level\" : \"track\"} ${frag.level}`);\n            this.state = State.KEY_LOADING;\n            this.fragCurrent = frag;\n            keyLoadingPromise = this.keyLoader.load(frag).then((keyLoadedData)=>{\n                if (!this.fragContextChanged(keyLoadedData.frag)) {\n                    this.hls.trigger(Events.KEY_LOADED, keyLoadedData);\n                    if (this.state === State.KEY_LOADING) {\n                        this.state = State.IDLE;\n                    }\n                    return keyLoadedData;\n                }\n            });\n            this.hls.trigger(Events.KEY_LOADING, {\n                frag\n            });\n            if (this.fragCurrent === null) {\n                keyLoadingPromise = Promise.reject(new Error(`frag load aborted, context changed in KEY_LOADING`));\n            }\n        } else if (!frag.encrypted && details.encryptedFragments.length) {\n            this.keyLoader.loadClear(frag, details.encryptedFragments);\n        }\n        targetBufferTime = Math.max(frag.start, targetBufferTime || 0);\n        if (this.config.lowLatencyMode && frag.sn !== \"initSegment\") {\n            const partList = details.partList;\n            if (partList && progressCallback) {\n                if (targetBufferTime > frag.end && details.fragmentHint) {\n                    frag = details.fragmentHint;\n                }\n                const partIndex = this.getNextPart(partList, frag, targetBufferTime);\n                if (partIndex > -1) {\n                    const part = partList[partIndex];\n                    this.log(`Loading part sn: ${frag.sn} p: ${part.index} cc: ${frag.cc} of playlist [${details.startSN}-${details.endSN}] parts [0-${partIndex}-${partList.length - 1}] ${this.logPrefix === \"[stream-controller]\" ? \"level\" : \"track\"}: ${frag.level}, target: ${parseFloat(targetBufferTime.toFixed(3))}`);\n                    this.nextLoadPosition = part.start + part.duration;\n                    this.state = State.FRAG_LOADING;\n                    let _result;\n                    if (keyLoadingPromise) {\n                        _result = keyLoadingPromise.then((keyLoadedData)=>{\n                            if (!keyLoadedData || this.fragContextChanged(keyLoadedData.frag)) {\n                                return null;\n                            }\n                            return this.doFragPartsLoad(frag, part, level, progressCallback);\n                        }).catch((error)=>this.handleFragLoadError(error));\n                    } else {\n                        _result = this.doFragPartsLoad(frag, part, level, progressCallback).catch((error)=>this.handleFragLoadError(error));\n                    }\n                    this.hls.trigger(Events.FRAG_LOADING, {\n                        frag,\n                        part,\n                        targetBufferTime\n                    });\n                    if (this.fragCurrent === null) {\n                        return Promise.reject(new Error(`frag load aborted, context changed in FRAG_LOADING parts`));\n                    }\n                    return _result;\n                } else if (!frag.url || this.loadedEndOfParts(partList, targetBufferTime)) {\n                    // Fragment hint has no parts\n                    return Promise.resolve(null);\n                }\n            }\n        }\n        this.log(`Loading fragment ${frag.sn} cc: ${frag.cc} ${details ? \"of [\" + details.startSN + \"-\" + details.endSN + \"] \" : \"\"}${this.logPrefix === \"[stream-controller]\" ? \"level\" : \"track\"}: ${frag.level}, target: ${parseFloat(targetBufferTime.toFixed(3))}`);\n        // Don't update nextLoadPosition for fragments which are not buffered\n        if (isFiniteNumber(frag.sn) && !this.bitrateTest) {\n            this.nextLoadPosition = frag.start + frag.duration;\n        }\n        this.state = State.FRAG_LOADING;\n        // Load key before streaming fragment data\n        const dataOnProgress = this.config.progressive;\n        let result;\n        if (dataOnProgress && keyLoadingPromise) {\n            result = keyLoadingPromise.then((keyLoadedData)=>{\n                if (!keyLoadedData || this.fragContextChanged(keyLoadedData == null ? void 0 : keyLoadedData.frag)) {\n                    return null;\n                }\n                return this.fragmentLoader.load(frag, progressCallback);\n            }).catch((error)=>this.handleFragLoadError(error));\n        } else {\n            // load unencrypted fragment data with progress event,\n            // or handle fragment result after key and fragment are finished loading\n            result = Promise.all([\n                this.fragmentLoader.load(frag, dataOnProgress ? progressCallback : undefined),\n                keyLoadingPromise\n            ]).then(([fragLoadedData])=>{\n                if (!dataOnProgress && fragLoadedData && progressCallback) {\n                    progressCallback(fragLoadedData);\n                }\n                return fragLoadedData;\n            }).catch((error)=>this.handleFragLoadError(error));\n        }\n        this.hls.trigger(Events.FRAG_LOADING, {\n            frag,\n            targetBufferTime\n        });\n        if (this.fragCurrent === null) {\n            return Promise.reject(new Error(`frag load aborted, context changed in FRAG_LOADING`));\n        }\n        return result;\n    }\n    doFragPartsLoad(frag, fromPart, level, progressCallback) {\n        return new Promise((resolve, reject)=>{\n            var _level$details;\n            const partsLoaded = [];\n            const initialPartList = (_level$details = level.details) == null ? void 0 : _level$details.partList;\n            const loadPart = (part)=>{\n                this.fragmentLoader.loadPart(frag, part, progressCallback).then((partLoadedData)=>{\n                    partsLoaded[part.index] = partLoadedData;\n                    const loadedPart = partLoadedData.part;\n                    this.hls.trigger(Events.FRAG_LOADED, partLoadedData);\n                    const nextPart = getPartWith(level, frag.sn, part.index + 1) || findPart(initialPartList, frag.sn, part.index + 1);\n                    if (nextPart) {\n                        loadPart(nextPart);\n                    } else {\n                        return resolve({\n                            frag,\n                            part: loadedPart,\n                            partsLoaded\n                        });\n                    }\n                }).catch(reject);\n            };\n            loadPart(fromPart);\n        });\n    }\n    handleFragLoadError(error) {\n        if (\"data\" in error) {\n            const data = error.data;\n            if (error.data && data.details === ErrorDetails.INTERNAL_ABORTED) {\n                this.handleFragLoadAborted(data.frag, data.part);\n            } else {\n                this.hls.trigger(Events.ERROR, data);\n            }\n        } else {\n            this.hls.trigger(Events.ERROR, {\n                type: ErrorTypes.OTHER_ERROR,\n                details: ErrorDetails.INTERNAL_EXCEPTION,\n                err: error,\n                error,\n                fatal: true\n            });\n        }\n        return null;\n    }\n    _handleTransmuxerFlush(chunkMeta) {\n        const context = this.getCurrentContext(chunkMeta);\n        if (!context || this.state !== State.PARSING) {\n            if (!this.fragCurrent && this.state !== State.STOPPED && this.state !== State.ERROR) {\n                this.state = State.IDLE;\n            }\n            return;\n        }\n        const { frag, part, level } = context;\n        const now = self.performance.now();\n        frag.stats.parsing.end = now;\n        if (part) {\n            part.stats.parsing.end = now;\n        }\n        this.updateLevelTiming(frag, part, level, chunkMeta.partial);\n    }\n    getCurrentContext(chunkMeta) {\n        const { levels, fragCurrent } = this;\n        const { level: levelIndex, sn, part: partIndex } = chunkMeta;\n        if (!(levels != null && levels[levelIndex])) {\n            this.warn(`Levels object was unset while buffering fragment ${sn} of level ${levelIndex}. The current chunk will not be buffered.`);\n            return null;\n        }\n        const level = levels[levelIndex];\n        const part = partIndex > -1 ? getPartWith(level, sn, partIndex) : null;\n        const frag = part ? part.fragment : getFragmentWithSN(level, sn, fragCurrent);\n        if (!frag) {\n            return null;\n        }\n        if (fragCurrent && fragCurrent !== frag) {\n            frag.stats = fragCurrent.stats;\n        }\n        return {\n            frag,\n            part,\n            level\n        };\n    }\n    bufferFragmentData(data, frag, part, chunkMeta, noBacktracking) {\n        var _buffer;\n        if (!data || this.state !== State.PARSING) {\n            return;\n        }\n        const { data1, data2 } = data;\n        let buffer = data1;\n        if (data1 && data2) {\n            // Combine the moof + mdat so that we buffer with a single append\n            buffer = appendUint8Array(data1, data2);\n        }\n        if (!((_buffer = buffer) != null && _buffer.length)) {\n            return;\n        }\n        const segment = {\n            type: data.type,\n            frag,\n            part,\n            chunkMeta,\n            parent: frag.type,\n            data: buffer\n        };\n        this.hls.trigger(Events.BUFFER_APPENDING, segment);\n        if (data.dropped && data.independent && !part) {\n            if (noBacktracking) {\n                return;\n            }\n            // Clear buffer so that we reload previous segments sequentially if required\n            this.flushBufferGap(frag);\n        }\n    }\n    flushBufferGap(frag) {\n        const media = this.media;\n        if (!media) {\n            return;\n        }\n        // If currentTime is not buffered, clear the back buffer so that we can backtrack as much as needed\n        if (!BufferHelper.isBuffered(media, media.currentTime)) {\n            this.flushMainBuffer(0, frag.start);\n            return;\n        }\n        // Remove back-buffer without interrupting playback to allow back tracking\n        const currentTime = media.currentTime;\n        const bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);\n        const fragDuration = frag.duration;\n        const segmentFraction = Math.min(this.config.maxFragLookUpTolerance * 2, fragDuration * 0.25);\n        const start = Math.max(Math.min(frag.start - segmentFraction, bufferInfo.end - segmentFraction), currentTime + segmentFraction);\n        if (frag.start - start > segmentFraction) {\n            this.flushMainBuffer(start, frag.start);\n        }\n    }\n    getFwdBufferInfo(bufferable, type) {\n        const pos = this.getLoadPosition();\n        if (!isFiniteNumber(pos)) {\n            return null;\n        }\n        return this.getFwdBufferInfoAtPos(bufferable, pos, type);\n    }\n    getFwdBufferInfoAtPos(bufferable, pos, type) {\n        const { config: { maxBufferHole } } = this;\n        const bufferInfo = BufferHelper.bufferInfo(bufferable, pos, maxBufferHole);\n        // Workaround flaw in getting forward buffer when maxBufferHole is smaller than gap at current pos\n        if (bufferInfo.len === 0 && bufferInfo.nextStart !== undefined) {\n            const bufferedFragAtPos = this.fragmentTracker.getBufferedFrag(pos, type);\n            if (bufferedFragAtPos && bufferInfo.nextStart < bufferedFragAtPos.end) {\n                return BufferHelper.bufferInfo(bufferable, pos, Math.max(bufferInfo.nextStart, maxBufferHole));\n            }\n        }\n        return bufferInfo;\n    }\n    getMaxBufferLength(levelBitrate) {\n        const { config } = this;\n        let maxBufLen;\n        if (levelBitrate) {\n            maxBufLen = Math.max(8 * config.maxBufferSize / levelBitrate, config.maxBufferLength);\n        } else {\n            maxBufLen = config.maxBufferLength;\n        }\n        return Math.min(maxBufLen, config.maxMaxBufferLength);\n    }\n    reduceMaxBufferLength(threshold) {\n        const config = this.config;\n        const minLength = threshold || config.maxBufferLength;\n        if (config.maxMaxBufferLength >= minLength) {\n            // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...\n            config.maxMaxBufferLength /= 2;\n            this.warn(`Reduce max buffer length to ${config.maxMaxBufferLength}s`);\n            return true;\n        }\n        return false;\n    }\n    getAppendedFrag(position, playlistType = PlaylistLevelType.MAIN) {\n        const fragOrPart = this.fragmentTracker.getAppendedFrag(position, PlaylistLevelType.MAIN);\n        if (fragOrPart && \"fragment\" in fragOrPart) {\n            return fragOrPart.fragment;\n        }\n        return fragOrPart;\n    }\n    getNextFragment(pos, levelDetails) {\n        const fragments = levelDetails.fragments;\n        const fragLen = fragments.length;\n        if (!fragLen) {\n            return null;\n        }\n        // find fragment index, contiguous with end of buffer position\n        const { config } = this;\n        const start = fragments[0].start;\n        let frag;\n        if (levelDetails.live) {\n            const initialLiveManifestSize = config.initialLiveManifestSize;\n            if (fragLen < initialLiveManifestSize) {\n                this.warn(`Not enough fragments to start playback (have: ${fragLen}, need: ${initialLiveManifestSize})`);\n                return null;\n            }\n            // The real fragment start times for a live stream are only known after the PTS range for that level is known.\n            // In order to discover the range, we load the best matching fragment for that level and demux it.\n            // Do not load using live logic if the starting frag is requested - we want to use getFragmentAtPosition() so that\n            // we get the fragment matching that start time\n            if (!levelDetails.PTSKnown && !this.startFragRequested && this.startPosition === -1 || pos < start) {\n                frag = this.getInitialLiveFragment(levelDetails, fragments);\n                this.startPosition = this.nextLoadPosition = frag ? this.hls.liveSyncPosition || frag.start : pos;\n            }\n        } else if (pos <= start) {\n            // VoD playlist: if loadPosition before start of playlist, load first fragment\n            frag = fragments[0];\n        }\n        // If we haven't run into any special cases already, just load the fragment most closely matching the requested position\n        if (!frag) {\n            const end = config.lowLatencyMode ? levelDetails.partEnd : levelDetails.fragmentEnd;\n            frag = this.getFragmentAtPosition(pos, end, levelDetails);\n        }\n        return this.mapToInitFragWhenRequired(frag);\n    }\n    isLoopLoading(frag, targetBufferTime) {\n        const trackerState = this.fragmentTracker.getState(frag);\n        return (trackerState === FragmentState.OK || trackerState === FragmentState.PARTIAL && !!frag.gap) && this.nextLoadPosition > targetBufferTime;\n    }\n    getNextFragmentLoopLoading(frag, levelDetails, bufferInfo, playlistType, maxBufLen) {\n        const gapStart = frag.gap;\n        const nextFragment = this.getNextFragment(this.nextLoadPosition, levelDetails);\n        if (nextFragment === null) {\n            return nextFragment;\n        }\n        frag = nextFragment;\n        if (gapStart && frag && !frag.gap && bufferInfo.nextStart) {\n            // Media buffered after GAP tags should not make the next buffer timerange exceed forward buffer length\n            const nextbufferInfo = this.getFwdBufferInfoAtPos(this.mediaBuffer ? this.mediaBuffer : this.media, bufferInfo.nextStart, playlistType);\n            if (nextbufferInfo !== null && bufferInfo.len + nextbufferInfo.len >= maxBufLen) {\n                // Returning here might result in not finding an audio and video candiate to skip to\n                this.log(`buffer full after gaps in \"${playlistType}\" playlist starting at sn: ${frag.sn}`);\n                return null;\n            }\n        }\n        return frag;\n    }\n    mapToInitFragWhenRequired(frag) {\n        // If an initSegment is present, it must be buffered first\n        if (frag != null && frag.initSegment && !(frag != null && frag.initSegment.data) && !this.bitrateTest) {\n            return frag.initSegment;\n        }\n        return frag;\n    }\n    getNextPart(partList, frag, targetBufferTime) {\n        let nextPart = -1;\n        let contiguous = false;\n        let independentAttrOmitted = true;\n        for(let i = 0, len = partList.length; i < len; i++){\n            const part = partList[i];\n            independentAttrOmitted = independentAttrOmitted && !part.independent;\n            if (nextPart > -1 && targetBufferTime < part.start) {\n                break;\n            }\n            const loaded = part.loaded;\n            if (loaded) {\n                nextPart = -1;\n            } else if ((contiguous || part.independent || independentAttrOmitted) && part.fragment === frag) {\n                nextPart = i;\n            }\n            contiguous = loaded;\n        }\n        return nextPart;\n    }\n    loadedEndOfParts(partList, targetBufferTime) {\n        const lastPart = partList[partList.length - 1];\n        return lastPart && targetBufferTime > lastPart.start && lastPart.loaded;\n    }\n    /*\n   This method is used find the best matching first fragment for a live playlist. This fragment is used to calculate the\n   \"sliding\" of the playlist, which is its offset from the start of playback. After sliding we can compute the real\n   start and end times for each fragment in the playlist (after which this method will not need to be called).\n  */ getInitialLiveFragment(levelDetails, fragments) {\n        const fragPrevious = this.fragPrevious;\n        let frag = null;\n        if (fragPrevious) {\n            if (levelDetails.hasProgramDateTime) {\n                // Prefer using PDT, because it can be accurate enough to choose the correct fragment without knowing the level sliding\n                this.log(`Live playlist, switching playlist, load frag with same PDT: ${fragPrevious.programDateTime}`);\n                frag = findFragmentByPDT(fragments, fragPrevious.endProgramDateTime, this.config.maxFragLookUpTolerance);\n            }\n            if (!frag) {\n                // SN does not need to be accurate between renditions, but depending on the packaging it may be so.\n                const targetSN = fragPrevious.sn + 1;\n                if (targetSN >= levelDetails.startSN && targetSN <= levelDetails.endSN) {\n                    const fragNext = fragments[targetSN - levelDetails.startSN];\n                    // Ensure that we're staying within the continuity range, since PTS resets upon a new range\n                    if (fragPrevious.cc === fragNext.cc) {\n                        frag = fragNext;\n                        this.log(`Live playlist, switching playlist, load frag with next SN: ${frag.sn}`);\n                    }\n                }\n                // It's important to stay within the continuity range if available; otherwise the fragments in the playlist\n                // will have the wrong start times\n                if (!frag) {\n                    frag = findFragWithCC(fragments, fragPrevious.cc);\n                    if (frag) {\n                        this.log(`Live playlist, switching playlist, load frag with same CC: ${frag.sn}`);\n                    }\n                }\n            }\n        } else {\n            // Find a new start fragment when fragPrevious is null\n            const liveStart = this.hls.liveSyncPosition;\n            if (liveStart !== null) {\n                frag = this.getFragmentAtPosition(liveStart, this.bitrateTest ? levelDetails.fragmentEnd : levelDetails.edge, levelDetails);\n            }\n        }\n        return frag;\n    }\n    /*\n  This method finds the best matching fragment given the provided position.\n   */ getFragmentAtPosition(bufferEnd, end, levelDetails) {\n        const { config } = this;\n        let { fragPrevious } = this;\n        let { fragments, endSN } = levelDetails;\n        const { fragmentHint } = levelDetails;\n        const tolerance = config.maxFragLookUpTolerance;\n        const partList = levelDetails.partList;\n        const loadingParts = !!(config.lowLatencyMode && partList != null && partList.length && fragmentHint);\n        if (loadingParts && fragmentHint && !this.bitrateTest) {\n            // Include incomplete fragment with parts at end\n            fragments = fragments.concat(fragmentHint);\n            endSN = fragmentHint.sn;\n        }\n        let frag;\n        if (bufferEnd < end) {\n            const lookupTolerance = bufferEnd > end - tolerance ? 0 : tolerance;\n            // Remove the tolerance if it would put the bufferEnd past the actual end of stream\n            // Uses buffer and sequence number to calculate switch segment (required if using EXT-X-DISCONTINUITY-SEQUENCE)\n            frag = findFragmentByPTS(fragPrevious, fragments, bufferEnd, lookupTolerance);\n        } else {\n            // reach end of playlist\n            frag = fragments[fragments.length - 1];\n        }\n        if (frag) {\n            const curSNIdx = frag.sn - levelDetails.startSN;\n            // Move fragPrevious forward to support forcing the next fragment to load\n            // when the buffer catches up to a previously buffered range.\n            const fragState = this.fragmentTracker.getState(frag);\n            if (fragState === FragmentState.OK || fragState === FragmentState.PARTIAL && frag.gap) {\n                fragPrevious = frag;\n            }\n            if (fragPrevious && frag.sn === fragPrevious.sn && (!loadingParts || partList[0].fragment.sn > frag.sn)) {\n                // Force the next fragment to load if the previous one was already selected. This can occasionally happen with\n                // non-uniform fragment durations\n                const sameLevel = fragPrevious && frag.level === fragPrevious.level;\n                if (sameLevel) {\n                    const nextFrag = fragments[curSNIdx + 1];\n                    if (frag.sn < endSN && this.fragmentTracker.getState(nextFrag) !== FragmentState.OK) {\n                        frag = nextFrag;\n                    } else {\n                        frag = null;\n                    }\n                }\n            }\n        }\n        return frag;\n    }\n    synchronizeToLiveEdge(levelDetails) {\n        const { config, media } = this;\n        if (!media) {\n            return;\n        }\n        const liveSyncPosition = this.hls.liveSyncPosition;\n        const currentTime = media.currentTime;\n        const start = levelDetails.fragments[0].start;\n        const end = levelDetails.edge;\n        const withinSlidingWindow = currentTime >= start - config.maxFragLookUpTolerance && currentTime <= end;\n        // Continue if we can seek forward to sync position or if current time is outside of sliding window\n        if (liveSyncPosition !== null && media.duration > liveSyncPosition && (currentTime < liveSyncPosition || !withinSlidingWindow)) {\n            // Continue if buffer is starving or if current time is behind max latency\n            const maxLatency = config.liveMaxLatencyDuration !== undefined ? config.liveMaxLatencyDuration : config.liveMaxLatencyDurationCount * levelDetails.targetduration;\n            if (!withinSlidingWindow && media.readyState < 4 || currentTime < end - maxLatency) {\n                if (!this.loadedmetadata) {\n                    this.nextLoadPosition = liveSyncPosition;\n                }\n                // Only seek if ready and there is not a significant forward buffer available for playback\n                if (media.readyState) {\n                    this.warn(`Playback: ${currentTime.toFixed(3)} is located too far from the end of live sliding playlist: ${end}, reset currentTime to : ${liveSyncPosition.toFixed(3)}`);\n                    media.currentTime = liveSyncPosition;\n                }\n            }\n        }\n    }\n    alignPlaylists(details, previousDetails, switchDetails) {\n        // FIXME: If not for `shouldAlignOnDiscontinuities` requiring fragPrevious.cc,\n        //  this could all go in level-helper mergeDetails()\n        const length = details.fragments.length;\n        if (!length) {\n            this.warn(`No fragments in live playlist`);\n            return 0;\n        }\n        const slidingStart = details.fragments[0].start;\n        const firstLevelLoad = !previousDetails;\n        const aligned = details.alignedSliding && isFiniteNumber(slidingStart);\n        if (firstLevelLoad || !aligned && !slidingStart) {\n            const { fragPrevious } = this;\n            alignStream(fragPrevious, switchDetails, details);\n            const alignedSlidingStart = details.fragments[0].start;\n            this.log(`Live playlist sliding: ${alignedSlidingStart.toFixed(2)} start-sn: ${previousDetails ? previousDetails.startSN : \"na\"}->${details.startSN} prev-sn: ${fragPrevious ? fragPrevious.sn : \"na\"} fragments: ${length}`);\n            return alignedSlidingStart;\n        }\n        return slidingStart;\n    }\n    waitForCdnTuneIn(details) {\n        // Wait for Low-Latency CDN Tune-in to get an updated playlist\n        const advancePartLimit = 3;\n        return details.live && details.canBlockReload && details.partTarget && details.tuneInGoal > Math.max(details.partHoldBack, details.partTarget * advancePartLimit);\n    }\n    setStartPosition(details, sliding) {\n        // compute start position if set to -1. use it straight away if value is defined\n        let startPosition = this.startPosition;\n        if (startPosition < sliding) {\n            startPosition = -1;\n        }\n        if (startPosition === -1 || this.lastCurrentTime === -1) {\n            // Use Playlist EXT-X-START:TIME-OFFSET when set\n            // Prioritize Multivariant Playlist offset so that main, audio, and subtitle stream-controller start times match\n            const offsetInMultivariantPlaylist = this.startTimeOffset !== null;\n            const startTimeOffset = offsetInMultivariantPlaylist ? this.startTimeOffset : details.startTimeOffset;\n            if (startTimeOffset !== null && isFiniteNumber(startTimeOffset)) {\n                startPosition = sliding + startTimeOffset;\n                if (startTimeOffset < 0) {\n                    startPosition += details.totalduration;\n                }\n                startPosition = Math.min(Math.max(sliding, startPosition), sliding + details.totalduration);\n                this.log(`Start time offset ${startTimeOffset} found in ${offsetInMultivariantPlaylist ? \"multivariant\" : \"media\"} playlist, adjust startPosition to ${startPosition}`);\n                this.startPosition = startPosition;\n            } else if (details.live) {\n                // Leave this.startPosition at -1, so that we can use `getInitialLiveFragment` logic when startPosition has\n                // not been specified via the config or an as an argument to startLoad (#3736).\n                startPosition = this.hls.liveSyncPosition || sliding;\n            } else {\n                this.startPosition = startPosition = 0;\n            }\n            this.lastCurrentTime = startPosition;\n        }\n        this.nextLoadPosition = startPosition;\n    }\n    getLoadPosition() {\n        const { media } = this;\n        // if we have not yet loaded any fragment, start loading from start position\n        let pos = 0;\n        if (this.loadedmetadata && media) {\n            pos = media.currentTime;\n        } else if (this.nextLoadPosition) {\n            pos = this.nextLoadPosition;\n        }\n        return pos;\n    }\n    handleFragLoadAborted(frag, part) {\n        if (this.transmuxer && frag.sn !== \"initSegment\" && frag.stats.aborted) {\n            this.warn(`Fragment ${frag.sn}${part ? \" part \" + part.index : \"\"} of level ${frag.level} was aborted`);\n            this.resetFragmentLoading(frag);\n        }\n    }\n    resetFragmentLoading(frag) {\n        if (!this.fragCurrent || !this.fragContextChanged(frag) && this.state !== State.FRAG_LOADING_WAITING_RETRY) {\n            this.state = State.IDLE;\n        }\n    }\n    onFragmentOrKeyLoadError(filterType, data) {\n        if (data.chunkMeta && !data.frag) {\n            const context = this.getCurrentContext(data.chunkMeta);\n            if (context) {\n                data.frag = context.frag;\n            }\n        }\n        const frag = data.frag;\n        // Handle frag error related to caller's filterType\n        if (!frag || frag.type !== filterType || !this.levels) {\n            return;\n        }\n        if (this.fragContextChanged(frag)) {\n            var _this$fragCurrent2;\n            this.warn(`Frag load error must match current frag to retry ${frag.url} > ${(_this$fragCurrent2 = this.fragCurrent) == null ? void 0 : _this$fragCurrent2.url}`);\n            return;\n        }\n        const gapTagEncountered = data.details === ErrorDetails.FRAG_GAP;\n        if (gapTagEncountered) {\n            this.fragmentTracker.fragBuffered(frag, true);\n        }\n        // keep retrying until the limit will be reached\n        const errorAction = data.errorAction;\n        const { action, retryCount = 0, retryConfig } = errorAction || {};\n        if (errorAction && action === NetworkErrorAction.RetryRequest && retryConfig) {\n            this.resetStartWhenNotLoaded(this.levelLastLoaded);\n            const delay = getRetryDelay(retryConfig, retryCount);\n            this.warn(`Fragment ${frag.sn} of ${filterType} ${frag.level} errored with ${data.details}, retrying loading ${retryCount + 1}/${retryConfig.maxNumRetry} in ${delay}ms`);\n            errorAction.resolved = true;\n            this.retryDate = self.performance.now() + delay;\n            this.state = State.FRAG_LOADING_WAITING_RETRY;\n        } else if (retryConfig && errorAction) {\n            this.resetFragmentErrors(filterType);\n            if (retryCount < retryConfig.maxNumRetry) {\n                // Network retry is skipped when level switch is preferred\n                if (!gapTagEncountered && action !== NetworkErrorAction.RemoveAlternatePermanently) {\n                    errorAction.resolved = true;\n                }\n            } else {\n                logger.warn(`${data.details} reached or exceeded max retry (${retryCount})`);\n                return;\n            }\n        } else if ((errorAction == null ? void 0 : errorAction.action) === NetworkErrorAction.SendAlternateToPenaltyBox) {\n            this.state = State.WAITING_LEVEL;\n        } else {\n            this.state = State.ERROR;\n        }\n        // Perform next async tick sooner to speed up error action resolution\n        this.tickImmediate();\n    }\n    reduceLengthAndFlushBuffer(data) {\n        // if in appending state\n        if (this.state === State.PARSING || this.state === State.PARSED) {\n            const playlistType = data.parent;\n            const bufferedInfo = this.getFwdBufferInfo(this.mediaBuffer, playlistType);\n            // 0.5 : tolerance needed as some browsers stalls playback before reaching buffered end\n            // reduce max buf len if current position is buffered\n            const buffered = bufferedInfo && bufferedInfo.len > 0.5;\n            if (buffered) {\n                this.reduceMaxBufferLength(bufferedInfo.len);\n            }\n            const flushBuffer = !buffered;\n            if (flushBuffer) {\n                // current position is not buffered, but browser is still complaining about buffer full error\n                // this happens on IE/Edge, refer to https://github.com/video-dev/hls.js/pull/708\n                // in that case flush the whole audio buffer to recover\n                this.warn(`Buffer full error while media.currentTime is not buffered, flush ${playlistType} buffer`);\n            }\n            if (data.frag) {\n                this.fragmentTracker.removeFragment(data.frag);\n                this.nextLoadPosition = data.frag.start;\n            }\n            this.resetLoadingState();\n            return flushBuffer;\n        }\n        return false;\n    }\n    resetFragmentErrors(filterType) {\n        if (filterType === PlaylistLevelType.AUDIO) {\n            // Reset current fragment since audio track audio is essential and may not have a fail-over track\n            this.fragCurrent = null;\n        }\n        // Fragment errors that result in a level switch or redundant fail-over\n        // should reset the stream controller state to idle\n        if (!this.loadedmetadata) {\n            this.startFragRequested = false;\n        }\n        if (this.state !== State.STOPPED) {\n            this.state = State.IDLE;\n        }\n    }\n    afterBufferFlushed(media, bufferType, playlistType) {\n        if (!media) {\n            return;\n        }\n        // After successful buffer flushing, filter flushed fragments from bufferedFrags use mediaBuffered instead of media\n        // (so that we will check against video.buffered ranges in case of alt audio track)\n        const bufferedTimeRanges = BufferHelper.getBuffered(media);\n        this.fragmentTracker.detectEvictedFragments(bufferType, bufferedTimeRanges, playlistType);\n        if (this.state === State.ENDED) {\n            this.resetLoadingState();\n        }\n    }\n    resetLoadingState() {\n        this.log(\"Reset loading state\");\n        this.fragCurrent = null;\n        this.fragPrevious = null;\n        this.state = State.IDLE;\n    }\n    resetStartWhenNotLoaded(level) {\n        // if loadedmetadata is not set, it means that first frag request failed\n        // in that case, reset startFragRequested flag\n        if (!this.loadedmetadata) {\n            this.startFragRequested = false;\n            const details = level ? level.details : null;\n            if (details != null && details.live) {\n                // Update the start position and return to IDLE to recover live start\n                this.startPosition = -1;\n                this.setStartPosition(details, 0);\n                this.resetLoadingState();\n            } else {\n                this.nextLoadPosition = this.startPosition;\n            }\n        }\n    }\n    resetWhenMissingContext(chunkMeta) {\n        this.warn(`The loading context changed while buffering fragment ${chunkMeta.sn} of level ${chunkMeta.level}. This chunk will not be buffered.`);\n        this.removeUnbufferedFrags();\n        this.resetStartWhenNotLoaded(this.levelLastLoaded);\n        this.resetLoadingState();\n    }\n    removeUnbufferedFrags(start = 0) {\n        this.fragmentTracker.removeFragmentsInRange(start, Infinity, this.playlistType, false, true);\n    }\n    updateLevelTiming(frag, part, level, partial) {\n        var _this$transmuxer;\n        const details = level.details;\n        if (!details) {\n            this.warn(\"level.details undefined\");\n            return;\n        }\n        const parsed = Object.keys(frag.elementaryStreams).reduce((result, type)=>{\n            const info = frag.elementaryStreams[type];\n            if (info) {\n                const parsedDuration = info.endPTS - info.startPTS;\n                if (parsedDuration <= 0) {\n                    // Destroy the transmuxer after it's next time offset failed to advance because duration was <= 0.\n                    // The new transmuxer will be configured with a time offset matching the next fragment start,\n                    // preventing the timeline from shifting.\n                    this.warn(`Could not parse fragment ${frag.sn} ${type} duration reliably (${parsedDuration})`);\n                    return result || false;\n                }\n                const drift = partial ? 0 : updateFragPTSDTS(details, frag, info.startPTS, info.endPTS, info.startDTS, info.endDTS);\n                this.hls.trigger(Events.LEVEL_PTS_UPDATED, {\n                    details,\n                    level,\n                    drift,\n                    type,\n                    frag,\n                    start: info.startPTS,\n                    end: info.endPTS\n                });\n                return true;\n            }\n            return result;\n        }, false);\n        if (!parsed && ((_this$transmuxer = this.transmuxer) == null ? void 0 : _this$transmuxer.error) === null) {\n            const error = new Error(`Found no media in fragment ${frag.sn} of level ${frag.level} resetting transmuxer to fallback to playlist timing`);\n            if (level.fragmentError === 0) {\n                // Mark and track the odd empty segment as a gap to avoid reloading\n                level.fragmentError++;\n                frag.gap = true;\n                this.fragmentTracker.removeFragment(frag);\n                this.fragmentTracker.fragBuffered(frag, true);\n            }\n            this.warn(error.message);\n            this.hls.trigger(Events.ERROR, {\n                type: ErrorTypes.MEDIA_ERROR,\n                details: ErrorDetails.FRAG_PARSING_ERROR,\n                fatal: false,\n                error,\n                frag,\n                reason: `Found no media in msn ${frag.sn} of level \"${level.url}\"`\n            });\n            if (!this.hls) {\n                return;\n            }\n            this.resetTransmuxer();\n        // For this error fallthrough. Marking parsed will allow advancing to next fragment.\n        }\n        this.state = State.PARSED;\n        this.hls.trigger(Events.FRAG_PARSED, {\n            frag,\n            part\n        });\n    }\n    resetTransmuxer() {\n        if (this.transmuxer) {\n            this.transmuxer.destroy();\n            this.transmuxer = null;\n        }\n    }\n    recoverWorkerError(data) {\n        if (data.event === \"demuxerWorker\") {\n            this.fragmentTracker.removeAllFragments();\n            this.resetTransmuxer();\n            this.resetStartWhenNotLoaded(this.levelLastLoaded);\n            this.resetLoadingState();\n        }\n    }\n    set state(nextState) {\n        const previousState = this._state;\n        if (previousState !== nextState) {\n            this._state = nextState;\n            this.log(`${previousState}->${nextState}`);\n        }\n    }\n    get state() {\n        return this._state;\n    }\n}\nclass ChunkCache {\n    constructor(){\n        this.chunks = [];\n        this.dataLength = 0;\n    }\n    push(chunk) {\n        this.chunks.push(chunk);\n        this.dataLength += chunk.length;\n    }\n    flush() {\n        const { chunks, dataLength } = this;\n        let result;\n        if (!chunks.length) {\n            return new Uint8Array(0);\n        } else if (chunks.length === 1) {\n            result = chunks[0];\n        } else {\n            result = concatUint8Arrays(chunks, dataLength);\n        }\n        this.reset();\n        return result;\n    }\n    reset() {\n        this.chunks.length = 0;\n        this.dataLength = 0;\n    }\n}\nfunction concatUint8Arrays(chunks, dataLength) {\n    const result = new Uint8Array(dataLength);\n    let offset = 0;\n    for(let i = 0; i < chunks.length; i++){\n        const chunk = chunks[i];\n        result.set(chunk, offset);\n        offset += chunk.length;\n    }\n    return result;\n}\n// ensure the worker ends up in the bundle\n// If the worker should not be included this gets aliased to empty.js\nfunction hasUMDWorker() {\n    return typeof __HLS_WORKER_BUNDLE__ === \"function\";\n}\nfunction injectWorker() {\n    const blob = new self.Blob([\n        `var exports={};var module={exports:exports};function define(f){f()};define.amd=true;(${__HLS_WORKER_BUNDLE__.toString()})(true);`\n    ], {\n        type: \"text/javascript\"\n    });\n    const objectURL = self.URL.createObjectURL(blob);\n    const worker = new self.Worker(objectURL);\n    return {\n        worker,\n        objectURL\n    };\n}\nfunction loadWorker(path) {\n    const scriptURL = new self.URL(path, self.location.href).href;\n    const worker = new self.Worker(scriptURL);\n    return {\n        worker,\n        scriptURL\n    };\n}\nfunction dummyTrack(type = \"\", inputTimeScale = 90000) {\n    return {\n        type,\n        id: -1,\n        pid: -1,\n        inputTimeScale,\n        sequenceNumber: -1,\n        samples: [],\n        dropped: 0\n    };\n}\nclass BaseAudioDemuxer {\n    constructor(){\n        this._audioTrack = void 0;\n        this._id3Track = void 0;\n        this.frameIndex = 0;\n        this.cachedData = null;\n        this.basePTS = null;\n        this.initPTS = null;\n        this.lastPTS = null;\n    }\n    resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n        this._id3Track = {\n            type: \"id3\",\n            id: 3,\n            pid: -1,\n            inputTimeScale: 90000,\n            sequenceNumber: 0,\n            samples: [],\n            dropped: 0\n        };\n    }\n    resetTimeStamp(deaultTimestamp) {\n        this.initPTS = deaultTimestamp;\n        this.resetContiguity();\n    }\n    resetContiguity() {\n        this.basePTS = null;\n        this.lastPTS = null;\n        this.frameIndex = 0;\n    }\n    canParse(data, offset) {\n        return false;\n    }\n    appendFrame(track, data, offset) {}\n    // feed incoming data to the front of the parsing pipeline\n    demux(data, timeOffset) {\n        if (this.cachedData) {\n            data = appendUint8Array(this.cachedData, data);\n            this.cachedData = null;\n        }\n        let id3Data = getID3Data(data, 0);\n        let offset = id3Data ? id3Data.length : 0;\n        let lastDataIndex;\n        const track = this._audioTrack;\n        const id3Track = this._id3Track;\n        const timestamp = id3Data ? getTimeStamp(id3Data) : undefined;\n        const length = data.length;\n        if (this.basePTS === null || this.frameIndex === 0 && isFiniteNumber(timestamp)) {\n            this.basePTS = initPTSFn(timestamp, timeOffset, this.initPTS);\n            this.lastPTS = this.basePTS;\n        }\n        if (this.lastPTS === null) {\n            this.lastPTS = this.basePTS;\n        }\n        // more expressive than alternative: id3Data?.length\n        if (id3Data && id3Data.length > 0) {\n            id3Track.samples.push({\n                pts: this.lastPTS,\n                dts: this.lastPTS,\n                data: id3Data,\n                type: MetadataSchema.audioId3,\n                duration: Number.POSITIVE_INFINITY\n            });\n        }\n        while(offset < length){\n            if (this.canParse(data, offset)) {\n                const frame = this.appendFrame(track, data, offset);\n                if (frame) {\n                    this.frameIndex++;\n                    this.lastPTS = frame.sample.pts;\n                    offset += frame.length;\n                    lastDataIndex = offset;\n                } else {\n                    offset = length;\n                }\n            } else if (canParse$2(data, offset)) {\n                // after a ID3.canParse, a call to ID3.getID3Data *should* always returns some data\n                id3Data = getID3Data(data, offset);\n                id3Track.samples.push({\n                    pts: this.lastPTS,\n                    dts: this.lastPTS,\n                    data: id3Data,\n                    type: MetadataSchema.audioId3,\n                    duration: Number.POSITIVE_INFINITY\n                });\n                offset += id3Data.length;\n                lastDataIndex = offset;\n            } else {\n                offset++;\n            }\n            if (offset === length && lastDataIndex !== length) {\n                const partialData = sliceUint8(data, lastDataIndex);\n                if (this.cachedData) {\n                    this.cachedData = appendUint8Array(this.cachedData, partialData);\n                } else {\n                    this.cachedData = partialData;\n                }\n            }\n        }\n        return {\n            audioTrack: track,\n            videoTrack: dummyTrack(),\n            id3Track,\n            textTrack: dummyTrack()\n        };\n    }\n    demuxSampleAes(data, keyData, timeOffset) {\n        return Promise.reject(new Error(`[${this}] This demuxer does not support Sample-AES decryption`));\n    }\n    flush(timeOffset) {\n        // Parse cache in case of remaining frames.\n        const cachedData = this.cachedData;\n        if (cachedData) {\n            this.cachedData = null;\n            this.demux(cachedData, 0);\n        }\n        return {\n            audioTrack: this._audioTrack,\n            videoTrack: dummyTrack(),\n            id3Track: this._id3Track,\n            textTrack: dummyTrack()\n        };\n    }\n    destroy() {}\n}\n/**\n * Initialize PTS\n * <p>\n *    use timestamp unless it is undefined, NaN or Infinity\n * </p>\n */ const initPTSFn = (timestamp, timeOffset, initPTS)=>{\n    if (isFiniteNumber(timestamp)) {\n        return timestamp * 90;\n    }\n    const init90kHz = initPTS ? initPTS.baseTime * 90000 / initPTS.timescale : 0;\n    return timeOffset * 90000 + init90kHz;\n};\n/**\n * ADTS parser helper\n * @link https://wiki.multimedia.cx/index.php?title=ADTS\n */ function getAudioConfig(observer, data, offset, audioCodec) {\n    let adtsObjectType;\n    let adtsExtensionSamplingIndex;\n    let adtsChannelConfig;\n    let config;\n    const userAgent = navigator.userAgent.toLowerCase();\n    const manifestCodec = audioCodec;\n    const adtsSamplingRates = [\n        96000,\n        88200,\n        64000,\n        48000,\n        44100,\n        32000,\n        24000,\n        22050,\n        16000,\n        12000,\n        11025,\n        8000,\n        7350\n    ];\n    // byte 2\n    adtsObjectType = ((data[offset + 2] & 0xc0) >>> 6) + 1;\n    const adtsSamplingIndex = (data[offset + 2] & 0x3c) >>> 2;\n    if (adtsSamplingIndex > adtsSamplingRates.length - 1) {\n        const error = new Error(`invalid ADTS sampling index:${adtsSamplingIndex}`);\n        observer.emit(Events.ERROR, Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.FRAG_PARSING_ERROR,\n            fatal: true,\n            error,\n            reason: error.message\n        });\n        return;\n    }\n    adtsChannelConfig = (data[offset + 2] & 0x01) << 2;\n    // byte 3\n    adtsChannelConfig |= (data[offset + 3] & 0xc0) >>> 6;\n    logger.log(`manifest codec:${audioCodec}, ADTS type:${adtsObjectType}, samplingIndex:${adtsSamplingIndex}`);\n    // firefox: freq less than 24kHz = AAC SBR (HE-AAC)\n    if (/firefox/i.test(userAgent)) {\n        if (adtsSamplingIndex >= 6) {\n            adtsObjectType = 5;\n            config = new Array(4);\n            // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies\n            // there is a factor 2 between frame sample rate and output sample rate\n            // multiply frequency by 2 (see table below, equivalent to substract 3)\n            adtsExtensionSamplingIndex = adtsSamplingIndex - 3;\n        } else {\n            adtsObjectType = 2;\n            config = new Array(2);\n            adtsExtensionSamplingIndex = adtsSamplingIndex;\n        }\n    // Android : always use AAC\n    } else if (userAgent.indexOf(\"android\") !== -1) {\n        adtsObjectType = 2;\n        config = new Array(2);\n        adtsExtensionSamplingIndex = adtsSamplingIndex;\n    } else {\n        /*  for other browsers (Chrome/Vivaldi/Opera ...)\n        always force audio type to be HE-AAC SBR, as some browsers do not support audio codec switch properly (like Chrome ...)\n    */ adtsObjectType = 5;\n        config = new Array(4);\n        // if (manifest codec is HE-AAC or HE-AACv2) OR (manifest codec not specified AND frequency less than 24kHz)\n        if (audioCodec && (audioCodec.indexOf(\"mp4a.40.29\") !== -1 || audioCodec.indexOf(\"mp4a.40.5\") !== -1) || !audioCodec && adtsSamplingIndex >= 6) {\n            // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies\n            // there is a factor 2 between frame sample rate and output sample rate\n            // multiply frequency by 2 (see table below, equivalent to substract 3)\n            adtsExtensionSamplingIndex = adtsSamplingIndex - 3;\n        } else {\n            // if (manifest codec is AAC) AND (frequency less than 24kHz AND nb channel is 1) OR (manifest codec not specified and mono audio)\n            // Chrome fails to play back with low frequency AAC LC mono when initialized with HE-AAC.  This is not a problem with stereo.\n            if (audioCodec && audioCodec.indexOf(\"mp4a.40.2\") !== -1 && (adtsSamplingIndex >= 6 && adtsChannelConfig === 1 || /vivaldi/i.test(userAgent)) || !audioCodec && adtsChannelConfig === 1) {\n                adtsObjectType = 2;\n                config = new Array(2);\n            }\n            adtsExtensionSamplingIndex = adtsSamplingIndex;\n        }\n    }\n    /* refer to http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Specific_Config\n      ISO 14496-3 (AAC).pdf - Table 1.13  Syntax of AudioSpecificConfig()\n    Audio Profile / Audio Object Type\n    0: Null\n    1: AAC Main\n    2: AAC LC (Low Complexity)\n    3: AAC SSR (Scalable Sample Rate)\n    4: AAC LTP (Long Term Prediction)\n    5: SBR (Spectral Band Replication)\n    6: AAC Scalable\n   sampling freq\n    0: 96000 Hz\n    1: 88200 Hz\n    2: 64000 Hz\n    3: 48000 Hz\n    4: 44100 Hz\n    5: 32000 Hz\n    6: 24000 Hz\n    7: 22050 Hz\n    8: 16000 Hz\n    9: 12000 Hz\n    10: 11025 Hz\n    11: 8000 Hz\n    12: 7350 Hz\n    13: Reserved\n    14: Reserved\n    15: frequency is written explictly\n    Channel Configurations\n    These are the channel configurations:\n    0: Defined in AOT Specifc Config\n    1: 1 channel: front-center\n    2: 2 channels: front-left, front-right\n  */ // audioObjectType = profile => profile, the MPEG-4 Audio Object Type minus 1\n    config[0] = adtsObjectType << 3;\n    // samplingFrequencyIndex\n    config[0] |= (adtsSamplingIndex & 0x0e) >> 1;\n    config[1] |= (adtsSamplingIndex & 0x01) << 7;\n    // channelConfiguration\n    config[1] |= adtsChannelConfig << 3;\n    if (adtsObjectType === 5) {\n        // adtsExtensionSamplingIndex\n        config[1] |= (adtsExtensionSamplingIndex & 0x0e) >> 1;\n        config[2] = (adtsExtensionSamplingIndex & 0x01) << 7;\n        // adtsObjectType (force to 2, chrome is checking that object type is less than 5 ???\n        //    https://chromium.googlesource.com/chromium/src.git/+/master/media/formats/mp4/aac.cc\n        config[2] |= 2 << 2;\n        config[3] = 0;\n    }\n    return {\n        config,\n        samplerate: adtsSamplingRates[adtsSamplingIndex],\n        channelCount: adtsChannelConfig,\n        codec: \"mp4a.40.\" + adtsObjectType,\n        manifestCodec\n    };\n}\nfunction isHeaderPattern$1(data, offset) {\n    return data[offset] === 0xff && (data[offset + 1] & 0xf6) === 0xf0;\n}\nfunction getHeaderLength(data, offset) {\n    return data[offset + 1] & 0x01 ? 7 : 9;\n}\nfunction getFullFrameLength(data, offset) {\n    return (data[offset + 3] & 0x03) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 0xe0) >>> 5;\n}\nfunction canGetFrameLength(data, offset) {\n    return offset + 5 < data.length;\n}\nfunction isHeader$1(data, offset) {\n    // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1\n    // Layer bits (position 14 and 15) in header should be always 0 for ADTS\n    // More info https://wiki.multimedia.cx/index.php?title=ADTS\n    return offset + 1 < data.length && isHeaderPattern$1(data, offset);\n}\nfunction canParse$1(data, offset) {\n    return canGetFrameLength(data, offset) && isHeaderPattern$1(data, offset) && getFullFrameLength(data, offset) <= data.length - offset;\n}\nfunction probe$1(data, offset) {\n    // same as isHeader but we also check that ADTS frame follows last ADTS frame\n    // or end of data is reached\n    if (isHeader$1(data, offset)) {\n        // ADTS header Length\n        const headerLength = getHeaderLength(data, offset);\n        if (offset + headerLength >= data.length) {\n            return false;\n        }\n        // ADTS frame Length\n        const frameLength = getFullFrameLength(data, offset);\n        if (frameLength <= headerLength) {\n            return false;\n        }\n        const newOffset = offset + frameLength;\n        return newOffset === data.length || isHeader$1(data, newOffset);\n    }\n    return false;\n}\nfunction initTrackConfig(track, observer, data, offset, audioCodec) {\n    if (!track.samplerate) {\n        const config = getAudioConfig(observer, data, offset, audioCodec);\n        if (!config) {\n            return;\n        }\n        track.config = config.config;\n        track.samplerate = config.samplerate;\n        track.channelCount = config.channelCount;\n        track.codec = config.codec;\n        track.manifestCodec = config.manifestCodec;\n        logger.log(`parsed codec:${track.codec}, rate:${config.samplerate}, channels:${config.channelCount}`);\n    }\n}\nfunction getFrameDuration(samplerate) {\n    return 1024 * 90000 / samplerate;\n}\nfunction parseFrameHeader(data, offset) {\n    // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header\n    const headerLength = getHeaderLength(data, offset);\n    if (offset + headerLength <= data.length) {\n        // retrieve frame size\n        const frameLength = getFullFrameLength(data, offset) - headerLength;\n        if (frameLength > 0) {\n            // logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}`);\n            return {\n                headerLength,\n                frameLength\n            };\n        }\n    }\n}\nfunction appendFrame$2(track, data, offset, pts, frameIndex) {\n    const frameDuration = getFrameDuration(track.samplerate);\n    const stamp = pts + frameIndex * frameDuration;\n    const header = parseFrameHeader(data, offset);\n    let unit;\n    if (header) {\n        const { frameLength, headerLength } = header;\n        const _length = headerLength + frameLength;\n        const missing = Math.max(0, offset + _length - data.length);\n        // logger.log(`AAC frame ${frameIndex}, pts:${stamp} length@offset/total: ${frameLength}@${offset+headerLength}/${data.byteLength} missing: ${missing}`);\n        if (missing) {\n            unit = new Uint8Array(_length - headerLength);\n            unit.set(data.subarray(offset + headerLength, data.length), 0);\n        } else {\n            unit = data.subarray(offset + headerLength, offset + _length);\n        }\n        const _sample = {\n            unit,\n            pts: stamp\n        };\n        if (!missing) {\n            track.samples.push(_sample);\n        }\n        return {\n            sample: _sample,\n            length: _length,\n            missing\n        };\n    }\n    // overflow incomplete header\n    const length = data.length - offset;\n    unit = new Uint8Array(length);\n    unit.set(data.subarray(offset, data.length), 0);\n    const sample = {\n        unit,\n        pts: stamp\n    };\n    return {\n        sample,\n        length,\n        missing: -1\n    };\n}\n/**\n *  MPEG parser helper\n */ let chromeVersion$1 = null;\nconst BitratesMap = [\n    32,\n    64,\n    96,\n    128,\n    160,\n    192,\n    224,\n    256,\n    288,\n    320,\n    352,\n    384,\n    416,\n    448,\n    32,\n    48,\n    56,\n    64,\n    80,\n    96,\n    112,\n    128,\n    160,\n    192,\n    224,\n    256,\n    320,\n    384,\n    32,\n    40,\n    48,\n    56,\n    64,\n    80,\n    96,\n    112,\n    128,\n    160,\n    192,\n    224,\n    256,\n    320,\n    32,\n    48,\n    56,\n    64,\n    80,\n    96,\n    112,\n    128,\n    144,\n    160,\n    176,\n    192,\n    224,\n    256,\n    8,\n    16,\n    24,\n    32,\n    40,\n    48,\n    56,\n    64,\n    80,\n    96,\n    112,\n    128,\n    144,\n    160\n];\nconst SamplingRateMap = [\n    44100,\n    48000,\n    32000,\n    22050,\n    24000,\n    16000,\n    11025,\n    12000,\n    8000\n];\nconst SamplesCoefficients = [\n    // MPEG 2.5\n    [\n        0,\n        // Reserved\n        72,\n        // Layer3\n        144,\n        // Layer2\n        12 // Layer1\n    ],\n    // Reserved\n    [\n        0,\n        // Reserved\n        0,\n        // Layer3\n        0,\n        // Layer2\n        0 // Layer1\n    ],\n    // MPEG 2\n    [\n        0,\n        // Reserved\n        72,\n        // Layer3\n        144,\n        // Layer2\n        12 // Layer1\n    ],\n    // MPEG 1\n    [\n        0,\n        // Reserved\n        144,\n        // Layer3\n        144,\n        // Layer2\n        12 // Layer1\n    ]\n];\nconst BytesInSlot = [\n    0,\n    // Reserved\n    1,\n    // Layer3\n    1,\n    // Layer2\n    4 // Layer1\n];\nfunction appendFrame$1(track, data, offset, pts, frameIndex) {\n    // Using http://www.datavoyage.com/mpgscript/mpeghdr.htm as a reference\n    if (offset + 24 > data.length) {\n        return;\n    }\n    const header = parseHeader(data, offset);\n    if (header && offset + header.frameLength <= data.length) {\n        const frameDuration = header.samplesPerFrame * 90000 / header.sampleRate;\n        const stamp = pts + frameIndex * frameDuration;\n        const sample = {\n            unit: data.subarray(offset, offset + header.frameLength),\n            pts: stamp,\n            dts: stamp\n        };\n        track.config = [];\n        track.channelCount = header.channelCount;\n        track.samplerate = header.sampleRate;\n        track.samples.push(sample);\n        return {\n            sample,\n            length: header.frameLength,\n            missing: 0\n        };\n    }\n}\nfunction parseHeader(data, offset) {\n    const mpegVersion = data[offset + 1] >> 3 & 3;\n    const mpegLayer = data[offset + 1] >> 1 & 3;\n    const bitRateIndex = data[offset + 2] >> 4 & 15;\n    const sampleRateIndex = data[offset + 2] >> 2 & 3;\n    if (mpegVersion !== 1 && bitRateIndex !== 0 && bitRateIndex !== 15 && sampleRateIndex !== 3) {\n        const paddingBit = data[offset + 2] >> 1 & 1;\n        const channelMode = data[offset + 3] >> 6;\n        const columnInBitrates = mpegVersion === 3 ? 3 - mpegLayer : mpegLayer === 3 ? 3 : 4;\n        const bitRate = BitratesMap[columnInBitrates * 14 + bitRateIndex - 1] * 1000;\n        const columnInSampleRates = mpegVersion === 3 ? 0 : mpegVersion === 2 ? 1 : 2;\n        const sampleRate = SamplingRateMap[columnInSampleRates * 3 + sampleRateIndex];\n        const channelCount = channelMode === 3 ? 1 : 2; // If bits of channel mode are `11` then it is a single channel (Mono)\n        const sampleCoefficient = SamplesCoefficients[mpegVersion][mpegLayer];\n        const bytesInSlot = BytesInSlot[mpegLayer];\n        const samplesPerFrame = sampleCoefficient * 8 * bytesInSlot;\n        const frameLength = Math.floor(sampleCoefficient * bitRate / sampleRate + paddingBit) * bytesInSlot;\n        if (chromeVersion$1 === null) {\n            const userAgent = navigator.userAgent || \"\";\n            const result = userAgent.match(/Chrome\\/(\\d+)/i);\n            chromeVersion$1 = result ? parseInt(result[1]) : 0;\n        }\n        const needChromeFix = !!chromeVersion$1 && chromeVersion$1 <= 87;\n        if (needChromeFix && mpegLayer === 2 && bitRate >= 224000 && channelMode === 0) {\n            // Work around bug in Chromium by setting channelMode to dual-channel (01) instead of stereo (00)\n            data[offset + 3] = data[offset + 3] | 0x80;\n        }\n        return {\n            sampleRate,\n            channelCount,\n            frameLength,\n            samplesPerFrame\n        };\n    }\n}\nfunction isHeaderPattern(data, offset) {\n    return data[offset] === 0xff && (data[offset + 1] & 0xe0) === 0xe0 && (data[offset + 1] & 0x06) !== 0x00;\n}\nfunction isHeader(data, offset) {\n    // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1\n    // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)\n    // More info http://www.mp3-tech.org/programmer/frame_header.html\n    return offset + 1 < data.length && isHeaderPattern(data, offset);\n}\nfunction canParse(data, offset) {\n    const headerSize = 4;\n    return isHeaderPattern(data, offset) && headerSize <= data.length - offset;\n}\nfunction probe(data, offset) {\n    // same as isHeader but we also check that MPEG frame follows last MPEG frame\n    // or end of data is reached\n    if (offset + 1 < data.length && isHeaderPattern(data, offset)) {\n        // MPEG header Length\n        const headerLength = 4;\n        // MPEG frame Length\n        const header = parseHeader(data, offset);\n        let frameLength = headerLength;\n        if (header != null && header.frameLength) {\n            frameLength = header.frameLength;\n        }\n        const newOffset = offset + frameLength;\n        return newOffset === data.length || isHeader(data, newOffset);\n    }\n    return false;\n}\n/**\n * AAC demuxer\n */ class AACDemuxer extends BaseAudioDemuxer {\n    constructor(observer, config){\n        super();\n        this.observer = void 0;\n        this.config = void 0;\n        this.observer = observer;\n        this.config = config;\n    }\n    resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n        super.resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration);\n        this._audioTrack = {\n            container: \"audio/adts\",\n            type: \"audio\",\n            id: 2,\n            pid: -1,\n            sequenceNumber: 0,\n            segmentCodec: \"aac\",\n            samples: [],\n            manifestCodec: audioCodec,\n            duration: trackDuration,\n            inputTimeScale: 90000,\n            dropped: 0\n        };\n    }\n    // Source for probe info - https://wiki.multimedia.cx/index.php?title=ADTS\n    static probe(data) {\n        if (!data) {\n            return false;\n        }\n        // Check for the ADTS sync word\n        // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1\n        // Layer bits (position 14 and 15) in header should be always 0 for ADTS\n        // More info https://wiki.multimedia.cx/index.php?title=ADTS\n        const id3Data = getID3Data(data, 0);\n        let offset = (id3Data == null ? void 0 : id3Data.length) || 0;\n        if (probe(data, offset)) {\n            return false;\n        }\n        for(let length = data.length; offset < length; offset++){\n            if (probe$1(data, offset)) {\n                logger.log(\"ADTS sync word found !\");\n                return true;\n            }\n        }\n        return false;\n    }\n    canParse(data, offset) {\n        return canParse$1(data, offset);\n    }\n    appendFrame(track, data, offset) {\n        initTrackConfig(track, this.observer, data, offset, track.manifestCodec);\n        const frame = appendFrame$2(track, data, offset, this.basePTS, this.frameIndex);\n        if (frame && frame.missing === 0) {\n            return frame;\n        }\n    }\n}\nconst emsgSchemePattern = /\\/emsg[-/]ID3/i;\nclass MP4Demuxer {\n    constructor(observer, config){\n        this.remainderData = null;\n        this.timeOffset = 0;\n        this.config = void 0;\n        this.videoTrack = void 0;\n        this.audioTrack = void 0;\n        this.id3Track = void 0;\n        this.txtTrack = void 0;\n        this.config = config;\n    }\n    resetTimeStamp() {}\n    resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n        const videoTrack = this.videoTrack = dummyTrack(\"video\", 1);\n        const audioTrack = this.audioTrack = dummyTrack(\"audio\", 1);\n        const captionTrack = this.txtTrack = dummyTrack(\"text\", 1);\n        this.id3Track = dummyTrack(\"id3\", 1);\n        this.timeOffset = 0;\n        if (!(initSegment != null && initSegment.byteLength)) {\n            return;\n        }\n        const initData = parseInitSegment(initSegment);\n        if (initData.video) {\n            const { id, timescale, codec } = initData.video;\n            videoTrack.id = id;\n            videoTrack.timescale = captionTrack.timescale = timescale;\n            videoTrack.codec = codec;\n        }\n        if (initData.audio) {\n            const { id, timescale, codec } = initData.audio;\n            audioTrack.id = id;\n            audioTrack.timescale = timescale;\n            audioTrack.codec = codec;\n        }\n        captionTrack.id = RemuxerTrackIdConfig.text;\n        videoTrack.sampleDuration = 0;\n        videoTrack.duration = audioTrack.duration = trackDuration;\n    }\n    resetContiguity() {\n        this.remainderData = null;\n    }\n    static probe(data) {\n        return hasMoofData(data);\n    }\n    demux(data, timeOffset) {\n        this.timeOffset = timeOffset;\n        // Load all data into the avc track. The CMAF remuxer will look for the data in the samples object; the rest of the fields do not matter\n        let videoSamples = data;\n        const videoTrack = this.videoTrack;\n        const textTrack = this.txtTrack;\n        if (this.config.progressive) {\n            // Split the bytestream into two ranges: one encompassing all data up until the start of the last moof, and everything else.\n            // This is done to guarantee that we're sending valid data to MSE - when demuxing progressively, we have no guarantee\n            // that the fetch loader gives us flush moof+mdat pairs. If we push jagged data to MSE, it will throw an exception.\n            if (this.remainderData) {\n                videoSamples = appendUint8Array(this.remainderData, data);\n            }\n            const segmentedData = segmentValidRange(videoSamples);\n            this.remainderData = segmentedData.remainder;\n            videoTrack.samples = segmentedData.valid || new Uint8Array();\n        } else {\n            videoTrack.samples = videoSamples;\n        }\n        const id3Track = this.extractID3Track(videoTrack, timeOffset);\n        textTrack.samples = parseSamples(timeOffset, videoTrack);\n        return {\n            videoTrack,\n            audioTrack: this.audioTrack,\n            id3Track,\n            textTrack: this.txtTrack\n        };\n    }\n    flush() {\n        const timeOffset = this.timeOffset;\n        const videoTrack = this.videoTrack;\n        const textTrack = this.txtTrack;\n        videoTrack.samples = this.remainderData || new Uint8Array();\n        this.remainderData = null;\n        const id3Track = this.extractID3Track(videoTrack, this.timeOffset);\n        textTrack.samples = parseSamples(timeOffset, videoTrack);\n        return {\n            videoTrack,\n            audioTrack: dummyTrack(),\n            id3Track,\n            textTrack: dummyTrack()\n        };\n    }\n    extractID3Track(videoTrack, timeOffset) {\n        const id3Track = this.id3Track;\n        if (videoTrack.samples.length) {\n            const emsgs = findBox(videoTrack.samples, [\n                \"emsg\"\n            ]);\n            if (emsgs) {\n                emsgs.forEach((data)=>{\n                    const emsgInfo = parseEmsg(data);\n                    if (emsgSchemePattern.test(emsgInfo.schemeIdUri)) {\n                        const pts = isFiniteNumber(emsgInfo.presentationTime) ? emsgInfo.presentationTime / emsgInfo.timeScale : timeOffset + emsgInfo.presentationTimeDelta / emsgInfo.timeScale;\n                        let duration = emsgInfo.eventDuration === 0xffffffff ? Number.POSITIVE_INFINITY : emsgInfo.eventDuration / emsgInfo.timeScale;\n                        // Safari takes anything <= 0.001 seconds and maps it to Infinity\n                        if (duration <= 0.001) {\n                            duration = Number.POSITIVE_INFINITY;\n                        }\n                        const payload = emsgInfo.payload;\n                        id3Track.samples.push({\n                            data: payload,\n                            len: payload.byteLength,\n                            dts: pts,\n                            pts: pts,\n                            type: MetadataSchema.emsg,\n                            duration: duration\n                        });\n                    }\n                });\n            }\n        }\n        return id3Track;\n    }\n    demuxSampleAes(data, keyData, timeOffset) {\n        return Promise.reject(new Error(\"The MP4 demuxer does not support SAMPLE-AES decryption\"));\n    }\n    destroy() {}\n}\nconst getAudioBSID = (data, offset)=>{\n    // check the bsid to confirm ac-3 | ec-3\n    let bsid = 0;\n    let numBits = 5;\n    offset += numBits;\n    const temp = new Uint32Array(1); // unsigned 32 bit for temporary storage\n    const mask = new Uint32Array(1); // unsigned 32 bit mask value\n    const byte = new Uint8Array(1); // unsigned 8 bit for temporary storage\n    while(numBits > 0){\n        byte[0] = data[offset];\n        // read remaining bits, upto 8 bits at a time\n        const bits = Math.min(numBits, 8);\n        const shift = 8 - bits;\n        mask[0] = 0xff000000 >>> 24 + shift << shift;\n        temp[0] = (byte[0] & mask[0]) >> shift;\n        bsid = !bsid ? temp[0] : bsid << bits | temp[0];\n        offset += 1;\n        numBits -= bits;\n    }\n    return bsid;\n};\nclass AC3Demuxer extends BaseAudioDemuxer {\n    constructor(observer){\n        super();\n        this.observer = void 0;\n        this.observer = observer;\n    }\n    resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n        super.resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration);\n        this._audioTrack = {\n            container: \"audio/ac-3\",\n            type: \"audio\",\n            id: 2,\n            pid: -1,\n            sequenceNumber: 0,\n            segmentCodec: \"ac3\",\n            samples: [],\n            manifestCodec: audioCodec,\n            duration: trackDuration,\n            inputTimeScale: 90000,\n            dropped: 0\n        };\n    }\n    canParse(data, offset) {\n        return offset + 64 < data.length;\n    }\n    appendFrame(track, data, offset) {\n        const frameLength = appendFrame(track, data, offset, this.basePTS, this.frameIndex);\n        if (frameLength !== -1) {\n            const sample = track.samples[track.samples.length - 1];\n            return {\n                sample,\n                length: frameLength,\n                missing: 0\n            };\n        }\n    }\n    static probe(data) {\n        if (!data) {\n            return false;\n        }\n        const id3Data = getID3Data(data, 0);\n        if (!id3Data) {\n            return false;\n        }\n        // look for the ac-3 sync bytes\n        const offset = id3Data.length;\n        if (data[offset] === 0x0b && data[offset + 1] === 0x77 && getTimeStamp(id3Data) !== undefined && // check the bsid to confirm ac-3\n        getAudioBSID(data, offset) < 16) {\n            return true;\n        }\n        return false;\n    }\n}\nfunction appendFrame(track, data, start, pts, frameIndex) {\n    if (start + 8 > data.length) {\n        return -1; // not enough bytes left\n    }\n    if (data[start] !== 0x0b || data[start + 1] !== 0x77) {\n        return -1; // invalid magic\n    }\n    // get sample rate\n    const samplingRateCode = data[start + 4] >> 6;\n    if (samplingRateCode >= 3) {\n        return -1; // invalid sampling rate\n    }\n    const samplingRateMap = [\n        48000,\n        44100,\n        32000\n    ];\n    const sampleRate = samplingRateMap[samplingRateCode];\n    // get frame size\n    const frameSizeCode = data[start + 4] & 0x3f;\n    const frameSizeMap = [\n        64,\n        69,\n        96,\n        64,\n        70,\n        96,\n        80,\n        87,\n        120,\n        80,\n        88,\n        120,\n        96,\n        104,\n        144,\n        96,\n        105,\n        144,\n        112,\n        121,\n        168,\n        112,\n        122,\n        168,\n        128,\n        139,\n        192,\n        128,\n        140,\n        192,\n        160,\n        174,\n        240,\n        160,\n        175,\n        240,\n        192,\n        208,\n        288,\n        192,\n        209,\n        288,\n        224,\n        243,\n        336,\n        224,\n        244,\n        336,\n        256,\n        278,\n        384,\n        256,\n        279,\n        384,\n        320,\n        348,\n        480,\n        320,\n        349,\n        480,\n        384,\n        417,\n        576,\n        384,\n        418,\n        576,\n        448,\n        487,\n        672,\n        448,\n        488,\n        672,\n        512,\n        557,\n        768,\n        512,\n        558,\n        768,\n        640,\n        696,\n        960,\n        640,\n        697,\n        960,\n        768,\n        835,\n        1152,\n        768,\n        836,\n        1152,\n        896,\n        975,\n        1344,\n        896,\n        976,\n        1344,\n        1024,\n        1114,\n        1536,\n        1024,\n        1115,\n        1536,\n        1152,\n        1253,\n        1728,\n        1152,\n        1254,\n        1728,\n        1280,\n        1393,\n        1920,\n        1280,\n        1394,\n        1920\n    ];\n    const frameLength = frameSizeMap[frameSizeCode * 3 + samplingRateCode] * 2;\n    if (start + frameLength > data.length) {\n        return -1;\n    }\n    // get channel count\n    const channelMode = data[start + 6] >> 5;\n    let skipCount = 0;\n    if (channelMode === 2) {\n        skipCount += 2;\n    } else {\n        if (channelMode & 1 && channelMode !== 1) {\n            skipCount += 2;\n        }\n        if (channelMode & 4) {\n            skipCount += 2;\n        }\n    }\n    const lfeon = (data[start + 6] << 8 | data[start + 7]) >> 12 - skipCount & 1;\n    const channelsMap = [\n        2,\n        1,\n        2,\n        3,\n        3,\n        4,\n        4,\n        5\n    ];\n    const channelCount = channelsMap[channelMode] + lfeon;\n    // build dac3 box\n    const bsid = data[start + 5] >> 3;\n    const bsmod = data[start + 5] & 7;\n    const config = new Uint8Array([\n        samplingRateCode << 6 | bsid << 1 | bsmod >> 2,\n        (bsmod & 3) << 6 | channelMode << 3 | lfeon << 2 | frameSizeCode >> 4,\n        frameSizeCode << 4 & 0xe0\n    ]);\n    const frameDuration = 1536 / sampleRate * 90000;\n    const stamp = pts + frameIndex * frameDuration;\n    const unit = data.subarray(start, start + frameLength);\n    track.config = config;\n    track.channelCount = channelCount;\n    track.samplerate = sampleRate;\n    track.samples.push({\n        unit,\n        pts: stamp\n    });\n    return frameLength;\n}\nclass BaseVideoParser {\n    constructor(){\n        this.VideoSample = null;\n    }\n    createVideoSample(key, pts, dts, debug) {\n        return {\n            key,\n            frame: false,\n            pts,\n            dts,\n            units: [],\n            debug,\n            length: 0\n        };\n    }\n    getLastNalUnit(samples) {\n        var _VideoSample;\n        let VideoSample = this.VideoSample;\n        let lastUnit;\n        // try to fallback to previous sample if current one is empty\n        if (!VideoSample || VideoSample.units.length === 0) {\n            VideoSample = samples[samples.length - 1];\n        }\n        if ((_VideoSample = VideoSample) != null && _VideoSample.units) {\n            const units = VideoSample.units;\n            lastUnit = units[units.length - 1];\n        }\n        return lastUnit;\n    }\n    pushAccessUnit(VideoSample, videoTrack) {\n        if (VideoSample.units.length && VideoSample.frame) {\n            // if sample does not have PTS/DTS, patch with last sample PTS/DTS\n            if (VideoSample.pts === undefined) {\n                const samples = videoTrack.samples;\n                const nbSamples = samples.length;\n                if (nbSamples) {\n                    const lastSample = samples[nbSamples - 1];\n                    VideoSample.pts = lastSample.pts;\n                    VideoSample.dts = lastSample.dts;\n                } else {\n                    // dropping samples, no timestamp found\n                    videoTrack.dropped++;\n                    return;\n                }\n            }\n            videoTrack.samples.push(VideoSample);\n        }\n        if (VideoSample.debug.length) {\n            logger.log(VideoSample.pts + \"/\" + VideoSample.dts + \":\" + VideoSample.debug);\n        }\n    }\n}\n/**\n * Parser for exponential Golomb codes, a variable-bitwidth number encoding scheme used by h264.\n */ class ExpGolomb {\n    constructor(data){\n        this.data = void 0;\n        this.bytesAvailable = void 0;\n        this.word = void 0;\n        this.bitsAvailable = void 0;\n        this.data = data;\n        // the number of bytes left to examine in this.data\n        this.bytesAvailable = data.byteLength;\n        // the current word being examined\n        this.word = 0; // :uint\n        // the number of bits left to examine in the current word\n        this.bitsAvailable = 0; // :uint\n    }\n    // ():void\n    loadWord() {\n        const data = this.data;\n        const bytesAvailable = this.bytesAvailable;\n        const position = data.byteLength - bytesAvailable;\n        const workingBytes = new Uint8Array(4);\n        const availableBytes = Math.min(4, bytesAvailable);\n        if (availableBytes === 0) {\n            throw new Error(\"no bytes available\");\n        }\n        workingBytes.set(data.subarray(position, position + availableBytes));\n        this.word = new DataView(workingBytes.buffer).getUint32(0);\n        // track the amount of this.data that has been processed\n        this.bitsAvailable = availableBytes * 8;\n        this.bytesAvailable -= availableBytes;\n    }\n    // (count:int):void\n    skipBits(count) {\n        let skipBytes; // :int\n        count = Math.min(count, this.bytesAvailable * 8 + this.bitsAvailable);\n        if (this.bitsAvailable > count) {\n            this.word <<= count;\n            this.bitsAvailable -= count;\n        } else {\n            count -= this.bitsAvailable;\n            skipBytes = count >> 3;\n            count -= skipBytes << 3;\n            this.bytesAvailable -= skipBytes;\n            this.loadWord();\n            this.word <<= count;\n            this.bitsAvailable -= count;\n        }\n    }\n    // (size:int):uint\n    readBits(size) {\n        let bits = Math.min(this.bitsAvailable, size); // :uint\n        const valu = this.word >>> 32 - bits; // :uint\n        if (size > 32) {\n            logger.error(\"Cannot read more than 32 bits at a time\");\n        }\n        this.bitsAvailable -= bits;\n        if (this.bitsAvailable > 0) {\n            this.word <<= bits;\n        } else if (this.bytesAvailable > 0) {\n            this.loadWord();\n        } else {\n            throw new Error(\"no bits available\");\n        }\n        bits = size - bits;\n        if (bits > 0 && this.bitsAvailable) {\n            return valu << bits | this.readBits(bits);\n        } else {\n            return valu;\n        }\n    }\n    // ():uint\n    skipLZ() {\n        let leadingZeroCount; // :uint\n        for(leadingZeroCount = 0; leadingZeroCount < this.bitsAvailable; ++leadingZeroCount){\n            if ((this.word & 0x80000000 >>> leadingZeroCount) !== 0) {\n                // the first bit of working word is 1\n                this.word <<= leadingZeroCount;\n                this.bitsAvailable -= leadingZeroCount;\n                return leadingZeroCount;\n            }\n        }\n        // we exhausted word and still have not found a 1\n        this.loadWord();\n        return leadingZeroCount + this.skipLZ();\n    }\n    // ():void\n    skipUEG() {\n        this.skipBits(1 + this.skipLZ());\n    }\n    // ():void\n    skipEG() {\n        this.skipBits(1 + this.skipLZ());\n    }\n    // ():uint\n    readUEG() {\n        const clz = this.skipLZ(); // :uint\n        return this.readBits(clz + 1) - 1;\n    }\n    // ():int\n    readEG() {\n        const valu = this.readUEG(); // :int\n        if (0x01 & valu) {\n            // the number is odd if the low order bit is set\n            return 1 + valu >>> 1; // add 1 to make it even, and divide by 2\n        } else {\n            return -1 * (valu >>> 1); // divide by two then make it negative\n        }\n    }\n    // Some convenience functions\n    // :Boolean\n    readBoolean() {\n        return this.readBits(1) === 1;\n    }\n    // ():int\n    readUByte() {\n        return this.readBits(8);\n    }\n    // ():int\n    readUShort() {\n        return this.readBits(16);\n    }\n    // ():int\n    readUInt() {\n        return this.readBits(32);\n    }\n    /**\n   * Advance the ExpGolomb decoder past a scaling list. The scaling\n   * list is optionally transmitted as part of a sequence parameter\n   * set and is not relevant to transmuxing.\n   * @param count the number of entries in this scaling list\n   * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1\n   */ skipScalingList(count) {\n        let lastScale = 8;\n        let nextScale = 8;\n        let deltaScale;\n        for(let j = 0; j < count; j++){\n            if (nextScale !== 0) {\n                deltaScale = this.readEG();\n                nextScale = (lastScale + deltaScale + 256) % 256;\n            }\n            lastScale = nextScale === 0 ? lastScale : nextScale;\n        }\n    }\n    /**\n   * Read a sequence parameter set and return some interesting video\n   * properties. A sequence parameter set is the H264 metadata that\n   * describes the properties of upcoming video frames.\n   * @returns an object with configuration parsed from the\n   * sequence parameter set, including the dimensions of the\n   * associated video frames.\n   */ readSPS() {\n        let frameCropLeftOffset = 0;\n        let frameCropRightOffset = 0;\n        let frameCropTopOffset = 0;\n        let frameCropBottomOffset = 0;\n        let numRefFramesInPicOrderCntCycle;\n        let scalingListCount;\n        let i;\n        const readUByte = this.readUByte.bind(this);\n        const readBits = this.readBits.bind(this);\n        const readUEG = this.readUEG.bind(this);\n        const readBoolean = this.readBoolean.bind(this);\n        const skipBits = this.skipBits.bind(this);\n        const skipEG = this.skipEG.bind(this);\n        const skipUEG = this.skipUEG.bind(this);\n        const skipScalingList = this.skipScalingList.bind(this);\n        readUByte();\n        const profileIdc = readUByte(); // profile_idc\n        readBits(5); // profileCompat constraint_set[0-4]_flag, u(5)\n        skipBits(3); // reserved_zero_3bits u(3),\n        readUByte(); // level_idc u(8)\n        skipUEG(); // seq_parameter_set_id\n        // some profiles have more optional data we don't need\n        if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128) {\n            const chromaFormatIdc = readUEG();\n            if (chromaFormatIdc === 3) {\n                skipBits(1);\n            } // separate_colour_plane_flag\n            skipUEG(); // bit_depth_luma_minus8\n            skipUEG(); // bit_depth_chroma_minus8\n            skipBits(1); // qpprime_y_zero_transform_bypass_flag\n            if (readBoolean()) {\n                // seq_scaling_matrix_present_flag\n                scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;\n                for(i = 0; i < scalingListCount; i++){\n                    if (readBoolean()) {\n                        // seq_scaling_list_present_flag[ i ]\n                        if (i < 6) {\n                            skipScalingList(16);\n                        } else {\n                            skipScalingList(64);\n                        }\n                    }\n                }\n            }\n        }\n        skipUEG(); // log2_max_frame_num_minus4\n        const picOrderCntType = readUEG();\n        if (picOrderCntType === 0) {\n            readUEG(); // log2_max_pic_order_cnt_lsb_minus4\n        } else if (picOrderCntType === 1) {\n            skipBits(1); // delta_pic_order_always_zero_flag\n            skipEG(); // offset_for_non_ref_pic\n            skipEG(); // offset_for_top_to_bottom_field\n            numRefFramesInPicOrderCntCycle = readUEG();\n            for(i = 0; i < numRefFramesInPicOrderCntCycle; i++){\n                skipEG();\n            } // offset_for_ref_frame[ i ]\n        }\n        skipUEG(); // max_num_ref_frames\n        skipBits(1); // gaps_in_frame_num_value_allowed_flag\n        const picWidthInMbsMinus1 = readUEG();\n        const picHeightInMapUnitsMinus1 = readUEG();\n        const frameMbsOnlyFlag = readBits(1);\n        if (frameMbsOnlyFlag === 0) {\n            skipBits(1);\n        } // mb_adaptive_frame_field_flag\n        skipBits(1); // direct_8x8_inference_flag\n        if (readBoolean()) {\n            // frame_cropping_flag\n            frameCropLeftOffset = readUEG();\n            frameCropRightOffset = readUEG();\n            frameCropTopOffset = readUEG();\n            frameCropBottomOffset = readUEG();\n        }\n        let pixelRatio = [\n            1,\n            1\n        ];\n        if (readBoolean()) {\n            // vui_parameters_present_flag\n            if (readBoolean()) {\n                // aspect_ratio_info_present_flag\n                const aspectRatioIdc = readUByte();\n                switch(aspectRatioIdc){\n                    case 1:\n                        pixelRatio = [\n                            1,\n                            1\n                        ];\n                        break;\n                    case 2:\n                        pixelRatio = [\n                            12,\n                            11\n                        ];\n                        break;\n                    case 3:\n                        pixelRatio = [\n                            10,\n                            11\n                        ];\n                        break;\n                    case 4:\n                        pixelRatio = [\n                            16,\n                            11\n                        ];\n                        break;\n                    case 5:\n                        pixelRatio = [\n                            40,\n                            33\n                        ];\n                        break;\n                    case 6:\n                        pixelRatio = [\n                            24,\n                            11\n                        ];\n                        break;\n                    case 7:\n                        pixelRatio = [\n                            20,\n                            11\n                        ];\n                        break;\n                    case 8:\n                        pixelRatio = [\n                            32,\n                            11\n                        ];\n                        break;\n                    case 9:\n                        pixelRatio = [\n                            80,\n                            33\n                        ];\n                        break;\n                    case 10:\n                        pixelRatio = [\n                            18,\n                            11\n                        ];\n                        break;\n                    case 11:\n                        pixelRatio = [\n                            15,\n                            11\n                        ];\n                        break;\n                    case 12:\n                        pixelRatio = [\n                            64,\n                            33\n                        ];\n                        break;\n                    case 13:\n                        pixelRatio = [\n                            160,\n                            99\n                        ];\n                        break;\n                    case 14:\n                        pixelRatio = [\n                            4,\n                            3\n                        ];\n                        break;\n                    case 15:\n                        pixelRatio = [\n                            3,\n                            2\n                        ];\n                        break;\n                    case 16:\n                        pixelRatio = [\n                            2,\n                            1\n                        ];\n                        break;\n                    case 255:\n                        {\n                            pixelRatio = [\n                                readUByte() << 8 | readUByte(),\n                                readUByte() << 8 | readUByte()\n                            ];\n                            break;\n                        }\n                }\n            }\n        }\n        return {\n            width: Math.ceil((picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2),\n            height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - (frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset),\n            pixelRatio: pixelRatio\n        };\n    }\n    readSliceType() {\n        // skip NALu type\n        this.readUByte();\n        // discard first_mb_in_slice\n        this.readUEG();\n        // return slice_type\n        return this.readUEG();\n    }\n}\nclass AvcVideoParser extends BaseVideoParser {\n    parseAVCPES(track, textTrack, pes, last, duration) {\n        const units = this.parseAVCNALu(track, pes.data);\n        let VideoSample = this.VideoSample;\n        let push;\n        let spsfound = false;\n        // free pes.data to save up some memory\n        pes.data = null;\n        // if new NAL units found and last sample still there, let's push ...\n        // this helps parsing streams with missing AUD (only do this if AUD never found)\n        if (VideoSample && units.length && !track.audFound) {\n            this.pushAccessUnit(VideoSample, track);\n            VideoSample = this.VideoSample = this.createVideoSample(false, pes.pts, pes.dts, \"\");\n        }\n        units.forEach((unit)=>{\n            var _VideoSample2;\n            switch(unit.type){\n                // NDR\n                case 1:\n                    {\n                        let iskey = false;\n                        push = true;\n                        const data = unit.data;\n                        // only check slice type to detect KF in case SPS found in same packet (any keyframe is preceded by SPS ...)\n                        if (spsfound && data.length > 4) {\n                            // retrieve slice type by parsing beginning of NAL unit (follow H264 spec, slice_header definition) to detect keyframe embedded in NDR\n                            const sliceType = new ExpGolomb(data).readSliceType();\n                            // 2 : I slice, 4 : SI slice, 7 : I slice, 9: SI slice\n                            // SI slice : A slice that is coded using intra prediction only and using quantisation of the prediction samples.\n                            // An SI slice can be coded such that its decoded samples can be constructed identically to an SP slice.\n                            // I slice: A slice that is not an SI slice that is decoded using intra prediction only.\n                            // if (sliceType === 2 || sliceType === 7) {\n                            if (sliceType === 2 || sliceType === 4 || sliceType === 7 || sliceType === 9) {\n                                iskey = true;\n                            }\n                        }\n                        if (iskey) {\n                            var _VideoSample;\n                            // if we have non-keyframe data already, that cannot belong to the same frame as a keyframe, so force a push\n                            if ((_VideoSample = VideoSample) != null && _VideoSample.frame && !VideoSample.key) {\n                                this.pushAccessUnit(VideoSample, track);\n                                VideoSample = this.VideoSample = null;\n                            }\n                        }\n                        if (!VideoSample) {\n                            VideoSample = this.VideoSample = this.createVideoSample(true, pes.pts, pes.dts, \"\");\n                        }\n                        VideoSample.frame = true;\n                        VideoSample.key = iskey;\n                        break;\n                    // IDR\n                    }\n                case 5:\n                    push = true;\n                    // handle PES not starting with AUD\n                    // if we have frame data already, that cannot belong to the same frame, so force a push\n                    if ((_VideoSample2 = VideoSample) != null && _VideoSample2.frame && !VideoSample.key) {\n                        this.pushAccessUnit(VideoSample, track);\n                        VideoSample = this.VideoSample = null;\n                    }\n                    if (!VideoSample) {\n                        VideoSample = this.VideoSample = this.createVideoSample(true, pes.pts, pes.dts, \"\");\n                    }\n                    VideoSample.key = true;\n                    VideoSample.frame = true;\n                    break;\n                // SEI\n                case 6:\n                    {\n                        push = true;\n                        parseSEIMessageFromNALu(unit.data, 1, pes.pts, textTrack.samples);\n                        break;\n                    // SPS\n                    }\n                case 7:\n                    {\n                        var _track$pixelRatio, _track$pixelRatio2;\n                        push = true;\n                        spsfound = true;\n                        const sps = unit.data;\n                        const expGolombDecoder = new ExpGolomb(sps);\n                        const config = expGolombDecoder.readSPS();\n                        if (!track.sps || track.width !== config.width || track.height !== config.height || ((_track$pixelRatio = track.pixelRatio) == null ? void 0 : _track$pixelRatio[0]) !== config.pixelRatio[0] || ((_track$pixelRatio2 = track.pixelRatio) == null ? void 0 : _track$pixelRatio2[1]) !== config.pixelRatio[1]) {\n                            track.width = config.width;\n                            track.height = config.height;\n                            track.pixelRatio = config.pixelRatio;\n                            track.sps = [\n                                sps\n                            ];\n                            track.duration = duration;\n                            const codecarray = sps.subarray(1, 4);\n                            let codecstring = \"avc1.\";\n                            for(let i = 0; i < 3; i++){\n                                let h = codecarray[i].toString(16);\n                                if (h.length < 2) {\n                                    h = \"0\" + h;\n                                }\n                                codecstring += h;\n                            }\n                            track.codec = codecstring;\n                        }\n                        break;\n                    }\n                // PPS\n                case 8:\n                    push = true;\n                    track.pps = [\n                        unit.data\n                    ];\n                    break;\n                // AUD\n                case 9:\n                    push = true;\n                    track.audFound = true;\n                    if (VideoSample) {\n                        this.pushAccessUnit(VideoSample, track);\n                    }\n                    VideoSample = this.VideoSample = this.createVideoSample(false, pes.pts, pes.dts, \"\");\n                    break;\n                // Filler Data\n                case 12:\n                    push = true;\n                    break;\n                default:\n                    push = false;\n                    if (VideoSample) {\n                        VideoSample.debug += \"unknown NAL \" + unit.type + \" \";\n                    }\n                    break;\n            }\n            if (VideoSample && push) {\n                const units = VideoSample.units;\n                units.push(unit);\n            }\n        });\n        // if last PES packet, push samples\n        if (last && VideoSample) {\n            this.pushAccessUnit(VideoSample, track);\n            this.VideoSample = null;\n        }\n    }\n    parseAVCNALu(track, array) {\n        const len = array.byteLength;\n        let state = track.naluState || 0;\n        const lastState = state;\n        const units = [];\n        let i = 0;\n        let value;\n        let overflow;\n        let unitType;\n        let lastUnitStart = -1;\n        let lastUnitType = 0;\n        // logger.log('PES:' + Hex.hexDump(array));\n        if (state === -1) {\n            // special use case where we found 3 or 4-byte start codes exactly at the end of previous PES packet\n            lastUnitStart = 0;\n            // NALu type is value read from offset 0\n            lastUnitType = array[0] & 0x1f;\n            state = 0;\n            i = 1;\n        }\n        while(i < len){\n            value = array[i++];\n            // optimization. state 0 and 1 are the predominant case. let's handle them outside of the switch/case\n            if (!state) {\n                state = value ? 0 : 1;\n                continue;\n            }\n            if (state === 1) {\n                state = value ? 0 : 2;\n                continue;\n            }\n            // here we have state either equal to 2 or 3\n            if (!value) {\n                state = 3;\n            } else if (value === 1) {\n                overflow = i - state - 1;\n                if (lastUnitStart >= 0) {\n                    const unit = {\n                        data: array.subarray(lastUnitStart, overflow),\n                        type: lastUnitType\n                    };\n                    // logger.log('pushing NALU, type/size:' + unit.type + '/' + unit.data.byteLength);\n                    units.push(unit);\n                } else {\n                    // lastUnitStart is undefined => this is the first start code found in this PES packet\n                    // first check if start code delimiter is overlapping between 2 PES packets,\n                    // ie it started in last packet (lastState not zero)\n                    // and ended at the beginning of this PES packet (i <= 4 - lastState)\n                    const lastUnit = this.getLastNalUnit(track.samples);\n                    if (lastUnit) {\n                        if (lastState && i <= 4 - lastState) {\n                            // start delimiter overlapping between PES packets\n                            // strip start delimiter bytes from the end of last NAL unit\n                            // check if lastUnit had a state different from zero\n                            if (lastUnit.state) {\n                                // strip last bytes\n                                lastUnit.data = lastUnit.data.subarray(0, lastUnit.data.byteLength - lastState);\n                            }\n                        }\n                        // If NAL units are not starting right at the beginning of the PES packet, push preceding data into previous NAL unit.\n                        if (overflow > 0) {\n                            // logger.log('first NALU found with overflow:' + overflow);\n                            lastUnit.data = appendUint8Array(lastUnit.data, array.subarray(0, overflow));\n                            lastUnit.state = 0;\n                        }\n                    }\n                }\n                // check if we can read unit type\n                if (i < len) {\n                    unitType = array[i] & 0x1f;\n                    // logger.log('find NALU @ offset:' + i + ',type:' + unitType);\n                    lastUnitStart = i;\n                    lastUnitType = unitType;\n                    state = 0;\n                } else {\n                    // not enough byte to read unit type. let's read it on next PES parsing\n                    state = -1;\n                }\n            } else {\n                state = 0;\n            }\n        }\n        if (lastUnitStart >= 0 && state >= 0) {\n            const unit = {\n                data: array.subarray(lastUnitStart, len),\n                type: lastUnitType,\n                state: state\n            };\n            units.push(unit);\n        // logger.log('pushing NALU, type/size/state:' + unit.type + '/' + unit.data.byteLength + '/' + state);\n        }\n        // no NALu found\n        if (units.length === 0) {\n            // append pes.data to previous NAL unit\n            const lastUnit = this.getLastNalUnit(track.samples);\n            if (lastUnit) {\n                lastUnit.data = appendUint8Array(lastUnit.data, array);\n            }\n        }\n        track.naluState = state;\n        return units;\n    }\n}\n/**\n * SAMPLE-AES decrypter\n */ class SampleAesDecrypter {\n    constructor(observer, config, keyData){\n        this.keyData = void 0;\n        this.decrypter = void 0;\n        this.keyData = keyData;\n        this.decrypter = new Decrypter(config, {\n            removePKCS7Padding: false\n        });\n    }\n    decryptBuffer(encryptedData) {\n        return this.decrypter.decrypt(encryptedData, this.keyData.key.buffer, this.keyData.iv.buffer);\n    }\n    // AAC - encrypt all full 16 bytes blocks starting from offset 16\n    decryptAacSample(samples, sampleIndex, callback) {\n        const curUnit = samples[sampleIndex].unit;\n        if (curUnit.length <= 16) {\n            // No encrypted portion in this sample (first 16 bytes is not\n            // encrypted, see https://developer.apple.com/library/archive/documentation/AudioVideo/Conceptual/HLS_Sample_Encryption/Encryption/Encryption.html),\n            return;\n        }\n        const encryptedData = curUnit.subarray(16, curUnit.length - curUnit.length % 16);\n        const encryptedBuffer = encryptedData.buffer.slice(encryptedData.byteOffset, encryptedData.byteOffset + encryptedData.length);\n        this.decryptBuffer(encryptedBuffer).then((decryptedBuffer)=>{\n            const decryptedData = new Uint8Array(decryptedBuffer);\n            curUnit.set(decryptedData, 16);\n            if (!this.decrypter.isSync()) {\n                this.decryptAacSamples(samples, sampleIndex + 1, callback);\n            }\n        });\n    }\n    decryptAacSamples(samples, sampleIndex, callback) {\n        for(;; sampleIndex++){\n            if (sampleIndex >= samples.length) {\n                callback();\n                return;\n            }\n            if (samples[sampleIndex].unit.length < 32) {\n                continue;\n            }\n            this.decryptAacSample(samples, sampleIndex, callback);\n            if (!this.decrypter.isSync()) {\n                return;\n            }\n        }\n    }\n    // AVC - encrypt one 16 bytes block out of ten, starting from offset 32\n    getAvcEncryptedData(decodedData) {\n        const encryptedDataLen = Math.floor((decodedData.length - 48) / 160) * 16 + 16;\n        const encryptedData = new Int8Array(encryptedDataLen);\n        let outputPos = 0;\n        for(let inputPos = 32; inputPos < decodedData.length - 16; inputPos += 160, outputPos += 16){\n            encryptedData.set(decodedData.subarray(inputPos, inputPos + 16), outputPos);\n        }\n        return encryptedData;\n    }\n    getAvcDecryptedUnit(decodedData, decryptedData) {\n        const uint8DecryptedData = new Uint8Array(decryptedData);\n        let inputPos = 0;\n        for(let outputPos = 32; outputPos < decodedData.length - 16; outputPos += 160, inputPos += 16){\n            decodedData.set(uint8DecryptedData.subarray(inputPos, inputPos + 16), outputPos);\n        }\n        return decodedData;\n    }\n    decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit) {\n        const decodedData = discardEPB(curUnit.data);\n        const encryptedData = this.getAvcEncryptedData(decodedData);\n        this.decryptBuffer(encryptedData.buffer).then((decryptedBuffer)=>{\n            curUnit.data = this.getAvcDecryptedUnit(decodedData, decryptedBuffer);\n            if (!this.decrypter.isSync()) {\n                this.decryptAvcSamples(samples, sampleIndex, unitIndex + 1, callback);\n            }\n        });\n    }\n    decryptAvcSamples(samples, sampleIndex, unitIndex, callback) {\n        if (samples instanceof Uint8Array) {\n            throw new Error(\"Cannot decrypt samples of type Uint8Array\");\n        }\n        for(;; sampleIndex++, unitIndex = 0){\n            if (sampleIndex >= samples.length) {\n                callback();\n                return;\n            }\n            const curUnits = samples[sampleIndex].units;\n            for(;; unitIndex++){\n                if (unitIndex >= curUnits.length) {\n                    break;\n                }\n                const curUnit = curUnits[unitIndex];\n                if (curUnit.data.length <= 48 || curUnit.type !== 1 && curUnit.type !== 5) {\n                    continue;\n                }\n                this.decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit);\n                if (!this.decrypter.isSync()) {\n                    return;\n                }\n            }\n        }\n    }\n}\nconst PACKET_LENGTH = 188;\nclass TSDemuxer {\n    constructor(observer, config, typeSupported){\n        this.observer = void 0;\n        this.config = void 0;\n        this.typeSupported = void 0;\n        this.sampleAes = null;\n        this.pmtParsed = false;\n        this.audioCodec = void 0;\n        this.videoCodec = void 0;\n        this._duration = 0;\n        this._pmtId = -1;\n        this._videoTrack = void 0;\n        this._audioTrack = void 0;\n        this._id3Track = void 0;\n        this._txtTrack = void 0;\n        this.aacOverFlow = null;\n        this.remainderData = null;\n        this.videoParser = void 0;\n        this.observer = observer;\n        this.config = config;\n        this.typeSupported = typeSupported;\n        this.videoParser = new AvcVideoParser();\n    }\n    static probe(data) {\n        const syncOffset = TSDemuxer.syncOffset(data);\n        if (syncOffset > 0) {\n            logger.warn(`MPEG2-TS detected but first sync word found @ offset ${syncOffset}`);\n        }\n        return syncOffset !== -1;\n    }\n    static syncOffset(data) {\n        const length = data.length;\n        let scanwindow = Math.min(PACKET_LENGTH * 5, length - PACKET_LENGTH) + 1;\n        let i = 0;\n        while(i < scanwindow){\n            // a TS init segment should contain at least 2 TS packets: PAT and PMT, each starting with 0x47\n            let foundPat = false;\n            let packetStart = -1;\n            let tsPackets = 0;\n            for(let j = i; j < length; j += PACKET_LENGTH){\n                if (data[j] === 0x47 && (length - j === PACKET_LENGTH || data[j + PACKET_LENGTH] === 0x47)) {\n                    tsPackets++;\n                    if (packetStart === -1) {\n                        packetStart = j;\n                        // First sync word found at offset, increase scan length (#5251)\n                        if (packetStart !== 0) {\n                            scanwindow = Math.min(packetStart + PACKET_LENGTH * 99, data.length - PACKET_LENGTH) + 1;\n                        }\n                    }\n                    if (!foundPat) {\n                        foundPat = parsePID(data, j) === 0;\n                    }\n                    // Sync word found at 0 with 3 packets, or found at offset least 2 packets up to scanwindow (#5501)\n                    if (foundPat && tsPackets > 1 && (packetStart === 0 && tsPackets > 2 || j + PACKET_LENGTH > scanwindow)) {\n                        return packetStart;\n                    }\n                } else if (tsPackets) {\n                    // Exit if sync word found, but does not contain contiguous packets\n                    return -1;\n                } else {\n                    break;\n                }\n            }\n            i++;\n        }\n        return -1;\n    }\n    /**\n   * Creates a track model internal to demuxer used to drive remuxing input\n   */ static createTrack(type, duration) {\n        return {\n            container: type === \"video\" || type === \"audio\" ? \"video/mp2t\" : undefined,\n            type,\n            id: RemuxerTrackIdConfig[type],\n            pid: -1,\n            inputTimeScale: 90000,\n            sequenceNumber: 0,\n            samples: [],\n            dropped: 0,\n            duration: type === \"audio\" ? duration : undefined\n        };\n    }\n    /**\n   * Initializes a new init segment on the demuxer/remuxer interface. Needed for discontinuities/track-switches (or at stream start)\n   * Resets all internal track instances of the demuxer.\n   */ resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n        this.pmtParsed = false;\n        this._pmtId = -1;\n        this._videoTrack = TSDemuxer.createTrack(\"video\");\n        this._audioTrack = TSDemuxer.createTrack(\"audio\", trackDuration);\n        this._id3Track = TSDemuxer.createTrack(\"id3\");\n        this._txtTrack = TSDemuxer.createTrack(\"text\");\n        this._audioTrack.segmentCodec = \"aac\";\n        // flush any partial content\n        this.aacOverFlow = null;\n        this.remainderData = null;\n        this.audioCodec = audioCodec;\n        this.videoCodec = videoCodec;\n        this._duration = trackDuration;\n    }\n    resetTimeStamp() {}\n    resetContiguity() {\n        const { _audioTrack, _videoTrack, _id3Track } = this;\n        if (_audioTrack) {\n            _audioTrack.pesData = null;\n        }\n        if (_videoTrack) {\n            _videoTrack.pesData = null;\n        }\n        if (_id3Track) {\n            _id3Track.pesData = null;\n        }\n        this.aacOverFlow = null;\n        this.remainderData = null;\n    }\n    demux(data, timeOffset, isSampleAes = false, flush = false) {\n        if (!isSampleAes) {\n            this.sampleAes = null;\n        }\n        let pes;\n        const videoTrack = this._videoTrack;\n        const audioTrack = this._audioTrack;\n        const id3Track = this._id3Track;\n        const textTrack = this._txtTrack;\n        let videoPid = videoTrack.pid;\n        let videoData = videoTrack.pesData;\n        let audioPid = audioTrack.pid;\n        let id3Pid = id3Track.pid;\n        let audioData = audioTrack.pesData;\n        let id3Data = id3Track.pesData;\n        let unknownPID = null;\n        let pmtParsed = this.pmtParsed;\n        let pmtId = this._pmtId;\n        let len = data.length;\n        if (this.remainderData) {\n            data = appendUint8Array(this.remainderData, data);\n            len = data.length;\n            this.remainderData = null;\n        }\n        if (len < PACKET_LENGTH && !flush) {\n            this.remainderData = data;\n            return {\n                audioTrack,\n                videoTrack,\n                id3Track,\n                textTrack\n            };\n        }\n        const syncOffset = Math.max(0, TSDemuxer.syncOffset(data));\n        len -= (len - syncOffset) % PACKET_LENGTH;\n        if (len < data.byteLength && !flush) {\n            this.remainderData = new Uint8Array(data.buffer, len, data.buffer.byteLength - len);\n        }\n        // loop through TS packets\n        let tsPacketErrors = 0;\n        for(let start = syncOffset; start < len; start += PACKET_LENGTH){\n            if (data[start] === 0x47) {\n                const stt = !!(data[start + 1] & 0x40);\n                const pid = parsePID(data, start);\n                const atf = (data[start + 3] & 0x30) >> 4;\n                // if an adaption field is present, its length is specified by the fifth byte of the TS packet header.\n                let offset;\n                if (atf > 1) {\n                    offset = start + 5 + data[start + 4];\n                    // continue if there is only adaptation field\n                    if (offset === start + PACKET_LENGTH) {\n                        continue;\n                    }\n                } else {\n                    offset = start + 4;\n                }\n                switch(pid){\n                    case videoPid:\n                        if (stt) {\n                            if (videoData && (pes = parsePES(videoData))) {\n                                this.videoParser.parseAVCPES(videoTrack, textTrack, pes, false, this._duration);\n                            }\n                            videoData = {\n                                data: [],\n                                size: 0\n                            };\n                        }\n                        if (videoData) {\n                            videoData.data.push(data.subarray(offset, start + PACKET_LENGTH));\n                            videoData.size += start + PACKET_LENGTH - offset;\n                        }\n                        break;\n                    case audioPid:\n                        if (stt) {\n                            if (audioData && (pes = parsePES(audioData))) {\n                                switch(audioTrack.segmentCodec){\n                                    case \"aac\":\n                                        this.parseAACPES(audioTrack, pes);\n                                        break;\n                                    case \"mp3\":\n                                        this.parseMPEGPES(audioTrack, pes);\n                                        break;\n                                    case \"ac3\":\n                                        {\n                                            this.parseAC3PES(audioTrack, pes);\n                                        }\n                                        break;\n                                }\n                            }\n                            audioData = {\n                                data: [],\n                                size: 0\n                            };\n                        }\n                        if (audioData) {\n                            audioData.data.push(data.subarray(offset, start + PACKET_LENGTH));\n                            audioData.size += start + PACKET_LENGTH - offset;\n                        }\n                        break;\n                    case id3Pid:\n                        if (stt) {\n                            if (id3Data && (pes = parsePES(id3Data))) {\n                                this.parseID3PES(id3Track, pes);\n                            }\n                            id3Data = {\n                                data: [],\n                                size: 0\n                            };\n                        }\n                        if (id3Data) {\n                            id3Data.data.push(data.subarray(offset, start + PACKET_LENGTH));\n                            id3Data.size += start + PACKET_LENGTH - offset;\n                        }\n                        break;\n                    case 0:\n                        if (stt) {\n                            offset += data[offset] + 1;\n                        }\n                        pmtId = this._pmtId = parsePAT(data, offset);\n                        break;\n                    case pmtId:\n                        {\n                            if (stt) {\n                                offset += data[offset] + 1;\n                            }\n                            const parsedPIDs = parsePMT(data, offset, this.typeSupported, isSampleAes);\n                            // only update track id if track PID found while parsing PMT\n                            // this is to avoid resetting the PID to -1 in case\n                            // track PID transiently disappears from the stream\n                            // this could happen in case of transient missing audio samples for example\n                            // NOTE this is only the PID of the track as found in TS,\n                            // but we are not using this for MP4 track IDs.\n                            videoPid = parsedPIDs.videoPid;\n                            if (videoPid > 0) {\n                                videoTrack.pid = videoPid;\n                                videoTrack.segmentCodec = parsedPIDs.segmentVideoCodec;\n                            }\n                            audioPid = parsedPIDs.audioPid;\n                            if (audioPid > 0) {\n                                audioTrack.pid = audioPid;\n                                audioTrack.segmentCodec = parsedPIDs.segmentAudioCodec;\n                            }\n                            id3Pid = parsedPIDs.id3Pid;\n                            if (id3Pid > 0) {\n                                id3Track.pid = id3Pid;\n                            }\n                            if (unknownPID !== null && !pmtParsed) {\n                                logger.warn(`MPEG-TS PMT found at ${start} after unknown PID '${unknownPID}'. Backtracking to sync byte @${syncOffset} to parse all TS packets.`);\n                                unknownPID = null;\n                                // we set it to -188, the += 188 in the for loop will reset start to 0\n                                start = syncOffset - 188;\n                            }\n                            pmtParsed = this.pmtParsed = true;\n                            break;\n                        }\n                    case 0x11:\n                    case 0x1fff:\n                        break;\n                    default:\n                        unknownPID = pid;\n                        break;\n                }\n            } else {\n                tsPacketErrors++;\n            }\n        }\n        if (tsPacketErrors > 0) {\n            const error = new Error(`Found ${tsPacketErrors} TS packet/s that do not start with 0x47`);\n            this.observer.emit(Events.ERROR, Events.ERROR, {\n                type: ErrorTypes.MEDIA_ERROR,\n                details: ErrorDetails.FRAG_PARSING_ERROR,\n                fatal: false,\n                error,\n                reason: error.message\n            });\n        }\n        videoTrack.pesData = videoData;\n        audioTrack.pesData = audioData;\n        id3Track.pesData = id3Data;\n        const demuxResult = {\n            audioTrack,\n            videoTrack,\n            id3Track,\n            textTrack\n        };\n        if (flush) {\n            this.extractRemainingSamples(demuxResult);\n        }\n        return demuxResult;\n    }\n    flush() {\n        const { remainderData } = this;\n        this.remainderData = null;\n        let result;\n        if (remainderData) {\n            result = this.demux(remainderData, -1, false, true);\n        } else {\n            result = {\n                videoTrack: this._videoTrack,\n                audioTrack: this._audioTrack,\n                id3Track: this._id3Track,\n                textTrack: this._txtTrack\n            };\n        }\n        this.extractRemainingSamples(result);\n        if (this.sampleAes) {\n            return this.decrypt(result, this.sampleAes);\n        }\n        return result;\n    }\n    extractRemainingSamples(demuxResult) {\n        const { audioTrack, videoTrack, id3Track, textTrack } = demuxResult;\n        const videoData = videoTrack.pesData;\n        const audioData = audioTrack.pesData;\n        const id3Data = id3Track.pesData;\n        // try to parse last PES packets\n        let pes;\n        if (videoData && (pes = parsePES(videoData))) {\n            this.videoParser.parseAVCPES(videoTrack, textTrack, pes, true, this._duration);\n            videoTrack.pesData = null;\n        } else {\n            // either avcData null or PES truncated, keep it for next frag parsing\n            videoTrack.pesData = videoData;\n        }\n        if (audioData && (pes = parsePES(audioData))) {\n            switch(audioTrack.segmentCodec){\n                case \"aac\":\n                    this.parseAACPES(audioTrack, pes);\n                    break;\n                case \"mp3\":\n                    this.parseMPEGPES(audioTrack, pes);\n                    break;\n                case \"ac3\":\n                    {\n                        this.parseAC3PES(audioTrack, pes);\n                    }\n                    break;\n            }\n            audioTrack.pesData = null;\n        } else {\n            if (audioData != null && audioData.size) {\n                logger.log(\"last AAC PES packet truncated,might overlap between fragments\");\n            }\n            // either audioData null or PES truncated, keep it for next frag parsing\n            audioTrack.pesData = audioData;\n        }\n        if (id3Data && (pes = parsePES(id3Data))) {\n            this.parseID3PES(id3Track, pes);\n            id3Track.pesData = null;\n        } else {\n            // either id3Data null or PES truncated, keep it for next frag parsing\n            id3Track.pesData = id3Data;\n        }\n    }\n    demuxSampleAes(data, keyData, timeOffset) {\n        const demuxResult = this.demux(data, timeOffset, true, !this.config.progressive);\n        const sampleAes = this.sampleAes = new SampleAesDecrypter(this.observer, this.config, keyData);\n        return this.decrypt(demuxResult, sampleAes);\n    }\n    decrypt(demuxResult, sampleAes) {\n        return new Promise((resolve)=>{\n            const { audioTrack, videoTrack } = demuxResult;\n            if (audioTrack.samples && audioTrack.segmentCodec === \"aac\") {\n                sampleAes.decryptAacSamples(audioTrack.samples, 0, ()=>{\n                    if (videoTrack.samples) {\n                        sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, ()=>{\n                            resolve(demuxResult);\n                        });\n                    } else {\n                        resolve(demuxResult);\n                    }\n                });\n            } else if (videoTrack.samples) {\n                sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, ()=>{\n                    resolve(demuxResult);\n                });\n            }\n        });\n    }\n    destroy() {\n        this._duration = 0;\n    }\n    parseAACPES(track, pes) {\n        let startOffset = 0;\n        const aacOverFlow = this.aacOverFlow;\n        let data = pes.data;\n        if (aacOverFlow) {\n            this.aacOverFlow = null;\n            const frameMissingBytes = aacOverFlow.missing;\n            const sampleLength = aacOverFlow.sample.unit.byteLength;\n            // logger.log(`AAC: append overflowing ${sampleLength} bytes to beginning of new PES`);\n            if (frameMissingBytes === -1) {\n                data = appendUint8Array(aacOverFlow.sample.unit, data);\n            } else {\n                const frameOverflowBytes = sampleLength - frameMissingBytes;\n                aacOverFlow.sample.unit.set(data.subarray(0, frameMissingBytes), frameOverflowBytes);\n                track.samples.push(aacOverFlow.sample);\n                startOffset = aacOverFlow.missing;\n            }\n        }\n        // look for ADTS header (0xFFFx)\n        let offset;\n        let len;\n        for(offset = startOffset, len = data.length; offset < len - 1; offset++){\n            if (isHeader$1(data, offset)) {\n                break;\n            }\n        }\n        // if ADTS header does not start straight from the beginning of the PES payload, raise an error\n        if (offset !== startOffset) {\n            let reason;\n            const recoverable = offset < len - 1;\n            if (recoverable) {\n                reason = `AAC PES did not start with ADTS header,offset:${offset}`;\n            } else {\n                reason = \"No ADTS header found in AAC PES\";\n            }\n            const error = new Error(reason);\n            logger.warn(`parsing error: ${reason}`);\n            this.observer.emit(Events.ERROR, Events.ERROR, {\n                type: ErrorTypes.MEDIA_ERROR,\n                details: ErrorDetails.FRAG_PARSING_ERROR,\n                fatal: false,\n                levelRetry: recoverable,\n                error,\n                reason\n            });\n            if (!recoverable) {\n                return;\n            }\n        }\n        initTrackConfig(track, this.observer, data, offset, this.audioCodec);\n        let pts;\n        if (pes.pts !== undefined) {\n            pts = pes.pts;\n        } else if (aacOverFlow) {\n            // if last AAC frame is overflowing, we should ensure timestamps are contiguous:\n            // first sample PTS should be equal to last sample PTS + frameDuration\n            const frameDuration = getFrameDuration(track.samplerate);\n            pts = aacOverFlow.sample.pts + frameDuration;\n        } else {\n            logger.warn(\"[tsdemuxer]: AAC PES unknown PTS\");\n            return;\n        }\n        // scan for aac samples\n        let frameIndex = 0;\n        let frame;\n        while(offset < len){\n            frame = appendFrame$2(track, data, offset, pts, frameIndex);\n            offset += frame.length;\n            if (!frame.missing) {\n                frameIndex++;\n                for(; offset < len - 1; offset++){\n                    if (isHeader$1(data, offset)) {\n                        break;\n                    }\n                }\n            } else {\n                this.aacOverFlow = frame;\n                break;\n            }\n        }\n    }\n    parseMPEGPES(track, pes) {\n        const data = pes.data;\n        const length = data.length;\n        let frameIndex = 0;\n        let offset = 0;\n        const pts = pes.pts;\n        if (pts === undefined) {\n            logger.warn(\"[tsdemuxer]: MPEG PES unknown PTS\");\n            return;\n        }\n        while(offset < length){\n            if (isHeader(data, offset)) {\n                const frame = appendFrame$1(track, data, offset, pts, frameIndex);\n                if (frame) {\n                    offset += frame.length;\n                    frameIndex++;\n                } else {\n                    break;\n                }\n            } else {\n                // nothing found, keep looking\n                offset++;\n            }\n        }\n    }\n    parseAC3PES(track, pes) {\n        {\n            const data = pes.data;\n            const pts = pes.pts;\n            if (pts === undefined) {\n                logger.warn(\"[tsdemuxer]: AC3 PES unknown PTS\");\n                return;\n            }\n            const length = data.length;\n            let frameIndex = 0;\n            let offset = 0;\n            let parsed;\n            while(offset < length && (parsed = appendFrame(track, data, offset, pts, frameIndex++)) > 0){\n                offset += parsed;\n            }\n        }\n    }\n    parseID3PES(id3Track, pes) {\n        if (pes.pts === undefined) {\n            logger.warn(\"[tsdemuxer]: ID3 PES unknown PTS\");\n            return;\n        }\n        const id3Sample = _extends({}, pes, {\n            type: this._videoTrack ? MetadataSchema.emsg : MetadataSchema.audioId3,\n            duration: Number.POSITIVE_INFINITY\n        });\n        id3Track.samples.push(id3Sample);\n    }\n}\nfunction parsePID(data, offset) {\n    // pid is a 13-bit field starting at the last bit of TS[1]\n    return ((data[offset + 1] & 0x1f) << 8) + data[offset + 2];\n}\nfunction parsePAT(data, offset) {\n    // skip the PSI header and parse the first PMT entry\n    return (data[offset + 10] & 0x1f) << 8 | data[offset + 11];\n}\nfunction parsePMT(data, offset, typeSupported, isSampleAes) {\n    const result = {\n        audioPid: -1,\n        videoPid: -1,\n        id3Pid: -1,\n        segmentVideoCodec: \"avc\",\n        segmentAudioCodec: \"aac\"\n    };\n    const sectionLength = (data[offset + 1] & 0x0f) << 8 | data[offset + 2];\n    const tableEnd = offset + 3 + sectionLength - 4;\n    // to determine where the table is, we have to figure out how\n    // long the program info descriptors are\n    const programInfoLength = (data[offset + 10] & 0x0f) << 8 | data[offset + 11];\n    // advance the offset to the first entry in the mapping table\n    offset += 12 + programInfoLength;\n    while(offset < tableEnd){\n        const pid = parsePID(data, offset);\n        const esInfoLength = (data[offset + 3] & 0x0f) << 8 | data[offset + 4];\n        switch(data[offset]){\n            case 0xcf:\n                // SAMPLE-AES AAC\n                if (!isSampleAes) {\n                    logEncryptedSamplesFoundInUnencryptedStream(\"ADTS AAC\");\n                    break;\n                }\n            /* falls through */ case 0x0f:\n                // ISO/IEC 13818-7 ADTS AAC (MPEG-2 lower bit-rate audio)\n                // logger.log('AAC PID:'  + pid);\n                if (result.audioPid === -1) {\n                    result.audioPid = pid;\n                }\n                break;\n            // Packetized metadata (ID3)\n            case 0x15:\n                // logger.log('ID3 PID:'  + pid);\n                if (result.id3Pid === -1) {\n                    result.id3Pid = pid;\n                }\n                break;\n            case 0xdb:\n                // SAMPLE-AES AVC\n                if (!isSampleAes) {\n                    logEncryptedSamplesFoundInUnencryptedStream(\"H.264\");\n                    break;\n                }\n            /* falls through */ case 0x1b:\n                // ITU-T Rec. H.264 and ISO/IEC 14496-10 (lower bit-rate video)\n                // logger.log('AVC PID:'  + pid);\n                if (result.videoPid === -1) {\n                    result.videoPid = pid;\n                    result.segmentVideoCodec = \"avc\";\n                }\n                break;\n            // ISO/IEC 11172-3 (MPEG-1 audio)\n            // or ISO/IEC 13818-3 (MPEG-2 halved sample rate audio)\n            case 0x03:\n            case 0x04:\n                // logger.log('MPEG PID:'  + pid);\n                if (!typeSupported.mpeg && !typeSupported.mp3) {\n                    logger.log(\"MPEG audio found, not supported in this browser\");\n                } else if (result.audioPid === -1) {\n                    result.audioPid = pid;\n                    result.segmentAudioCodec = \"mp3\";\n                }\n                break;\n            case 0xc1:\n                // SAMPLE-AES AC3\n                if (!isSampleAes) {\n                    logEncryptedSamplesFoundInUnencryptedStream(\"AC-3\");\n                    break;\n                }\n            /* falls through */ case 0x81:\n                {\n                    if (!typeSupported.ac3) {\n                        logger.log(\"AC-3 audio found, not supported in this browser\");\n                    } else if (result.audioPid === -1) {\n                        result.audioPid = pid;\n                        result.segmentAudioCodec = \"ac3\";\n                    }\n                }\n                break;\n            case 0x06:\n                // stream_type 6 can mean a lot of different things in case of DVB.\n                // We need to look at the descriptors. Right now, we're only interested\n                // in AC-3 audio, so we do the descriptor parsing only when we don't have\n                // an audio PID yet.\n                if (result.audioPid === -1 && esInfoLength > 0) {\n                    let parsePos = offset + 5;\n                    let remaining = esInfoLength;\n                    while(remaining > 2){\n                        const descriptorId = data[parsePos];\n                        switch(descriptorId){\n                            case 0x6a:\n                                // DVB Descriptor for AC-3\n                                {\n                                    if (typeSupported.ac3 !== true) {\n                                        logger.log(\"AC-3 audio found, not supported in this browser for now\");\n                                    } else {\n                                        result.audioPid = pid;\n                                        result.segmentAudioCodec = \"ac3\";\n                                    }\n                                }\n                                break;\n                        }\n                        const descriptorLen = data[parsePos + 1] + 2;\n                        parsePos += descriptorLen;\n                        remaining -= descriptorLen;\n                    }\n                }\n                break;\n            case 0xc2:\n            /* falls through */ case 0x87:\n                logger.warn(\"Unsupported EC-3 in M2TS found\");\n                break;\n            case 0x24:\n                logger.warn(\"Unsupported HEVC in M2TS found\");\n                break;\n        }\n        // move to the next table entry\n        // skip past the elementary stream descriptors, if present\n        offset += esInfoLength + 5;\n    }\n    return result;\n}\nfunction logEncryptedSamplesFoundInUnencryptedStream(type) {\n    logger.log(`${type} with AES-128-CBC encryption found in unencrypted stream`);\n}\nfunction parsePES(stream) {\n    let i = 0;\n    let frag;\n    let pesLen;\n    let pesHdrLen;\n    let pesPts;\n    let pesDts;\n    const data = stream.data;\n    // safety check\n    if (!stream || stream.size === 0) {\n        return null;\n    }\n    // we might need up to 19 bytes to read PES header\n    // if first chunk of data is less than 19 bytes, let's merge it with following ones until we get 19 bytes\n    // usually only one merge is needed (and this is rare ...)\n    while(data[0].length < 19 && data.length > 1){\n        data[0] = appendUint8Array(data[0], data[1]);\n        data.splice(1, 1);\n    }\n    // retrieve PTS/DTS from first fragment\n    frag = data[0];\n    const pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];\n    if (pesPrefix === 1) {\n        pesLen = (frag[4] << 8) + frag[5];\n        // if PES parsed length is not zero and greater than total received length, stop parsing. PES might be truncated\n        // minus 6 : PES header size\n        if (pesLen && pesLen > stream.size - 6) {\n            return null;\n        }\n        const pesFlags = frag[7];\n        if (pesFlags & 0xc0) {\n            /* PES header described here : http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\n          as PTS / DTS is 33 bit we cannot use bitwise operator in JS,\n          as Bitwise operators treat their operands as a sequence of 32 bits */ pesPts = (frag[9] & 0x0e) * 536870912 + // 1 << 29\n            (frag[10] & 0xff) * 4194304 + // 1 << 22\n            (frag[11] & 0xfe) * 16384 + // 1 << 14\n            (frag[12] & 0xff) * 128 + // 1 << 7\n            (frag[13] & 0xfe) / 2;\n            if (pesFlags & 0x40) {\n                pesDts = (frag[14] & 0x0e) * 536870912 + // 1 << 29\n                (frag[15] & 0xff) * 4194304 + // 1 << 22\n                (frag[16] & 0xfe) * 16384 + // 1 << 14\n                (frag[17] & 0xff) * 128 + // 1 << 7\n                (frag[18] & 0xfe) / 2;\n                if (pesPts - pesDts > 60 * 90000) {\n                    logger.warn(`${Math.round((pesPts - pesDts) / 90000)}s delta between PTS and DTS, align them`);\n                    pesPts = pesDts;\n                }\n            } else {\n                pesDts = pesPts;\n            }\n        }\n        pesHdrLen = frag[8];\n        // 9 bytes : 6 bytes for PES header + 3 bytes for PES extension\n        let payloadStartOffset = pesHdrLen + 9;\n        if (stream.size <= payloadStartOffset) {\n            return null;\n        }\n        stream.size -= payloadStartOffset;\n        // reassemble PES packet\n        const pesData = new Uint8Array(stream.size);\n        for(let j = 0, dataLen = data.length; j < dataLen; j++){\n            frag = data[j];\n            let len = frag.byteLength;\n            if (payloadStartOffset) {\n                if (payloadStartOffset > len) {\n                    // trim full frag if PES header bigger than frag\n                    payloadStartOffset -= len;\n                    continue;\n                } else {\n                    // trim partial frag if PES header smaller than frag\n                    frag = frag.subarray(payloadStartOffset);\n                    len -= payloadStartOffset;\n                    payloadStartOffset = 0;\n                }\n            }\n            pesData.set(frag, i);\n            i += len;\n        }\n        if (pesLen) {\n            // payload size : remove PES header + PES extension\n            pesLen -= pesHdrLen + 3;\n        }\n        return {\n            data: pesData,\n            pts: pesPts,\n            dts: pesDts,\n            len: pesLen\n        };\n    }\n    return null;\n}\n/**\n * MP3 demuxer\n */ class MP3Demuxer extends BaseAudioDemuxer {\n    resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n        super.resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration);\n        this._audioTrack = {\n            container: \"audio/mpeg\",\n            type: \"audio\",\n            id: 2,\n            pid: -1,\n            sequenceNumber: 0,\n            segmentCodec: \"mp3\",\n            samples: [],\n            manifestCodec: audioCodec,\n            duration: trackDuration,\n            inputTimeScale: 90000,\n            dropped: 0\n        };\n    }\n    static probe(data) {\n        if (!data) {\n            return false;\n        }\n        // check if data contains ID3 timestamp and MPEG sync word\n        // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1\n        // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)\n        // More info http://www.mp3-tech.org/programmer/frame_header.html\n        const id3Data = getID3Data(data, 0);\n        let offset = (id3Data == null ? void 0 : id3Data.length) || 0;\n        // Check for ac-3|ec-3 sync bytes and return false if present\n        if (id3Data && data[offset] === 0x0b && data[offset + 1] === 0x77 && getTimeStamp(id3Data) !== undefined && // check the bsid to confirm ac-3 or ec-3 (not mp3)\n        getAudioBSID(data, offset) <= 16) {\n            return false;\n        }\n        for(let length = data.length; offset < length; offset++){\n            if (probe(data, offset)) {\n                logger.log(\"MPEG Audio sync word found !\");\n                return true;\n            }\n        }\n        return false;\n    }\n    canParse(data, offset) {\n        return canParse(data, offset);\n    }\n    appendFrame(track, data, offset) {\n        if (this.basePTS === null) {\n            return;\n        }\n        return appendFrame$1(track, data, offset, this.basePTS, this.frameIndex);\n    }\n}\n/**\n *  AAC helper\n */ class AAC {\n    static getSilentFrame(codec, channelCount) {\n        switch(codec){\n            case \"mp4a.40.2\":\n                if (channelCount === 1) {\n                    return new Uint8Array([\n                        0x00,\n                        0xc8,\n                        0x00,\n                        0x80,\n                        0x23,\n                        0x80\n                    ]);\n                } else if (channelCount === 2) {\n                    return new Uint8Array([\n                        0x21,\n                        0x00,\n                        0x49,\n                        0x90,\n                        0x02,\n                        0x19,\n                        0x00,\n                        0x23,\n                        0x80\n                    ]);\n                } else if (channelCount === 3) {\n                    return new Uint8Array([\n                        0x00,\n                        0xc8,\n                        0x00,\n                        0x80,\n                        0x20,\n                        0x84,\n                        0x01,\n                        0x26,\n                        0x40,\n                        0x08,\n                        0x64,\n                        0x00,\n                        0x8e\n                    ]);\n                } else if (channelCount === 4) {\n                    return new Uint8Array([\n                        0x00,\n                        0xc8,\n                        0x00,\n                        0x80,\n                        0x20,\n                        0x84,\n                        0x01,\n                        0x26,\n                        0x40,\n                        0x08,\n                        0x64,\n                        0x00,\n                        0x80,\n                        0x2c,\n                        0x80,\n                        0x08,\n                        0x02,\n                        0x38\n                    ]);\n                } else if (channelCount === 5) {\n                    return new Uint8Array([\n                        0x00,\n                        0xc8,\n                        0x00,\n                        0x80,\n                        0x20,\n                        0x84,\n                        0x01,\n                        0x26,\n                        0x40,\n                        0x08,\n                        0x64,\n                        0x00,\n                        0x82,\n                        0x30,\n                        0x04,\n                        0x99,\n                        0x00,\n                        0x21,\n                        0x90,\n                        0x02,\n                        0x38\n                    ]);\n                } else if (channelCount === 6) {\n                    return new Uint8Array([\n                        0x00,\n                        0xc8,\n                        0x00,\n                        0x80,\n                        0x20,\n                        0x84,\n                        0x01,\n                        0x26,\n                        0x40,\n                        0x08,\n                        0x64,\n                        0x00,\n                        0x82,\n                        0x30,\n                        0x04,\n                        0x99,\n                        0x00,\n                        0x21,\n                        0x90,\n                        0x02,\n                        0x00,\n                        0xb2,\n                        0x00,\n                        0x20,\n                        0x08,\n                        0xe0\n                    ]);\n                }\n                break;\n            // handle HE-AAC below (mp4a.40.5 / mp4a.40.29)\n            default:\n                if (channelCount === 1) {\n                    // ffmpeg -y -f lavfi -i \"aevalsrc=0:d=0.05\" -c:a libfdk_aac -profile:a aac_he -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n                    return new Uint8Array([\n                        0x1,\n                        0x40,\n                        0x22,\n                        0x80,\n                        0xa3,\n                        0x4e,\n                        0xe6,\n                        0x80,\n                        0xba,\n                        0x8,\n                        0x0,\n                        0x0,\n                        0x0,\n                        0x1c,\n                        0x6,\n                        0xf1,\n                        0xc1,\n                        0xa,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5e\n                    ]);\n                } else if (channelCount === 2) {\n                    // ffmpeg -y -f lavfi -i \"aevalsrc=0|0:d=0.05\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n                    return new Uint8Array([\n                        0x1,\n                        0x40,\n                        0x22,\n                        0x80,\n                        0xa3,\n                        0x5e,\n                        0xe6,\n                        0x80,\n                        0xba,\n                        0x8,\n                        0x0,\n                        0x0,\n                        0x0,\n                        0x0,\n                        0x95,\n                        0x0,\n                        0x6,\n                        0xf1,\n                        0xa1,\n                        0xa,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5e\n                    ]);\n                } else if (channelCount === 3) {\n                    // ffmpeg -y -f lavfi -i \"aevalsrc=0|0|0:d=0.05\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n                    return new Uint8Array([\n                        0x1,\n                        0x40,\n                        0x22,\n                        0x80,\n                        0xa3,\n                        0x5e,\n                        0xe6,\n                        0x80,\n                        0xba,\n                        0x8,\n                        0x0,\n                        0x0,\n                        0x0,\n                        0x0,\n                        0x95,\n                        0x0,\n                        0x6,\n                        0xf1,\n                        0xa1,\n                        0xa,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5a,\n                        0x5e\n                    ]);\n                }\n                break;\n        }\n        return undefined;\n    }\n}\n/**\n * Generate MP4 Box\n */ const UINT32_MAX = Math.pow(2, 32) - 1;\nclass MP4 {\n    static init() {\n        MP4.types = {\n            avc1: [],\n            // codingname\n            avcC: [],\n            btrt: [],\n            dinf: [],\n            dref: [],\n            esds: [],\n            ftyp: [],\n            hdlr: [],\n            mdat: [],\n            mdhd: [],\n            mdia: [],\n            mfhd: [],\n            minf: [],\n            moof: [],\n            moov: [],\n            mp4a: [],\n            \".mp3\": [],\n            dac3: [],\n            \"ac-3\": [],\n            mvex: [],\n            mvhd: [],\n            pasp: [],\n            sdtp: [],\n            stbl: [],\n            stco: [],\n            stsc: [],\n            stsd: [],\n            stsz: [],\n            stts: [],\n            tfdt: [],\n            tfhd: [],\n            traf: [],\n            trak: [],\n            trun: [],\n            trex: [],\n            tkhd: [],\n            vmhd: [],\n            smhd: []\n        };\n        let i;\n        for(i in MP4.types){\n            if (MP4.types.hasOwnProperty(i)) {\n                MP4.types[i] = [\n                    i.charCodeAt(0),\n                    i.charCodeAt(1),\n                    i.charCodeAt(2),\n                    i.charCodeAt(3)\n                ];\n            }\n        }\n        const videoHdlr = new Uint8Array([\n            0x00,\n            // version 0\n            0x00,\n            0x00,\n            0x00,\n            // flags\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            // pre_defined\n            0x76,\n            0x69,\n            0x64,\n            0x65,\n            // handler_type: 'vide'\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            // reserved\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            // reserved\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            // reserved\n            0x56,\n            0x69,\n            0x64,\n            0x65,\n            0x6f,\n            0x48,\n            0x61,\n            0x6e,\n            0x64,\n            0x6c,\n            0x65,\n            0x72,\n            0x00 // name: 'VideoHandler'\n        ]);\n        const audioHdlr = new Uint8Array([\n            0x00,\n            // version 0\n            0x00,\n            0x00,\n            0x00,\n            // flags\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            // pre_defined\n            0x73,\n            0x6f,\n            0x75,\n            0x6e,\n            // handler_type: 'soun'\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            // reserved\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            // reserved\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            // reserved\n            0x53,\n            0x6f,\n            0x75,\n            0x6e,\n            0x64,\n            0x48,\n            0x61,\n            0x6e,\n            0x64,\n            0x6c,\n            0x65,\n            0x72,\n            0x00 // name: 'SoundHandler'\n        ]);\n        MP4.HDLR_TYPES = {\n            video: videoHdlr,\n            audio: audioHdlr\n        };\n        const dref = new Uint8Array([\n            0x00,\n            // version 0\n            0x00,\n            0x00,\n            0x00,\n            // flags\n            0x00,\n            0x00,\n            0x00,\n            0x01,\n            // entry_count\n            0x00,\n            0x00,\n            0x00,\n            0x0c,\n            // entry_size\n            0x75,\n            0x72,\n            0x6c,\n            0x20,\n            // 'url' type\n            0x00,\n            // version 0\n            0x00,\n            0x00,\n            0x01 // entry_flags\n        ]);\n        const stco = new Uint8Array([\n            0x00,\n            // version\n            0x00,\n            0x00,\n            0x00,\n            // flags\n            0x00,\n            0x00,\n            0x00,\n            0x00 // entry_count\n        ]);\n        MP4.STTS = MP4.STSC = MP4.STCO = stco;\n        MP4.STSZ = new Uint8Array([\n            0x00,\n            // version\n            0x00,\n            0x00,\n            0x00,\n            // flags\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            // sample_size\n            0x00,\n            0x00,\n            0x00,\n            0x00 // sample_count\n        ]);\n        MP4.VMHD = new Uint8Array([\n            0x00,\n            // version\n            0x00,\n            0x00,\n            0x01,\n            // flags\n            0x00,\n            0x00,\n            // graphicsmode\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00 // opcolor\n        ]);\n        MP4.SMHD = new Uint8Array([\n            0x00,\n            // version\n            0x00,\n            0x00,\n            0x00,\n            // flags\n            0x00,\n            0x00,\n            // balance\n            0x00,\n            0x00 // reserved\n        ]);\n        MP4.STSD = new Uint8Array([\n            0x00,\n            // version 0\n            0x00,\n            0x00,\n            0x00,\n            // flags\n            0x00,\n            0x00,\n            0x00,\n            0x01\n        ]); // entry_count\n        const majorBrand = new Uint8Array([\n            105,\n            115,\n            111,\n            109\n        ]); // isom\n        const avc1Brand = new Uint8Array([\n            97,\n            118,\n            99,\n            49\n        ]); // avc1\n        const minorVersion = new Uint8Array([\n            0,\n            0,\n            0,\n            1\n        ]);\n        MP4.FTYP = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);\n        MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));\n    }\n    static box(type, ...payload) {\n        let size = 8;\n        let i = payload.length;\n        const len = i;\n        // calculate the total size we need to allocate\n        while(i--){\n            size += payload[i].byteLength;\n        }\n        const result = new Uint8Array(size);\n        result[0] = size >> 24 & 0xff;\n        result[1] = size >> 16 & 0xff;\n        result[2] = size >> 8 & 0xff;\n        result[3] = size & 0xff;\n        result.set(type, 4);\n        // copy the payload into the result\n        for(i = 0, size = 8; i < len; i++){\n            // copy payload[i] array @ offset size\n            result.set(payload[i], size);\n            size += payload[i].byteLength;\n        }\n        return result;\n    }\n    static hdlr(type) {\n        return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);\n    }\n    static mdat(data) {\n        return MP4.box(MP4.types.mdat, data);\n    }\n    static mdhd(timescale, duration) {\n        duration *= timescale;\n        const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n        const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n        return MP4.box(MP4.types.mdhd, new Uint8Array([\n            0x01,\n            // version 1\n            0x00,\n            0x00,\n            0x00,\n            // flags\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x02,\n            // creation_time\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x03,\n            // modification_time\n            timescale >> 24 & 0xff,\n            timescale >> 16 & 0xff,\n            timescale >> 8 & 0xff,\n            timescale & 0xff,\n            // timescale\n            upperWordDuration >> 24,\n            upperWordDuration >> 16 & 0xff,\n            upperWordDuration >> 8 & 0xff,\n            upperWordDuration & 0xff,\n            lowerWordDuration >> 24,\n            lowerWordDuration >> 16 & 0xff,\n            lowerWordDuration >> 8 & 0xff,\n            lowerWordDuration & 0xff,\n            0x55,\n            0xc4,\n            // 'und' language (undetermined)\n            0x00,\n            0x00\n        ]));\n    }\n    static mdia(track) {\n        return MP4.box(MP4.types.mdia, MP4.mdhd(track.timescale, track.duration), MP4.hdlr(track.type), MP4.minf(track));\n    }\n    static mfhd(sequenceNumber) {\n        return MP4.box(MP4.types.mfhd, new Uint8Array([\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            // flags\n            sequenceNumber >> 24,\n            sequenceNumber >> 16 & 0xff,\n            sequenceNumber >> 8 & 0xff,\n            sequenceNumber & 0xff // sequence_number\n        ]));\n    }\n    static minf(track) {\n        if (track.type === \"audio\") {\n            return MP4.box(MP4.types.minf, MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF, MP4.stbl(track));\n        } else {\n            return MP4.box(MP4.types.minf, MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF, MP4.stbl(track));\n        }\n    }\n    static moof(sn, baseMediaDecodeTime, track) {\n        return MP4.box(MP4.types.moof, MP4.mfhd(sn), MP4.traf(track, baseMediaDecodeTime));\n    }\n    static moov(tracks) {\n        let i = tracks.length;\n        const boxes = [];\n        while(i--){\n            boxes[i] = MP4.trak(tracks[i]);\n        }\n        return MP4.box.apply(null, [\n            MP4.types.moov,\n            MP4.mvhd(tracks[0].timescale, tracks[0].duration)\n        ].concat(boxes).concat(MP4.mvex(tracks)));\n    }\n    static mvex(tracks) {\n        let i = tracks.length;\n        const boxes = [];\n        while(i--){\n            boxes[i] = MP4.trex(tracks[i]);\n        }\n        return MP4.box.apply(null, [\n            MP4.types.mvex,\n            ...boxes\n        ]);\n    }\n    static mvhd(timescale, duration) {\n        duration *= timescale;\n        const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n        const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n        const bytes = new Uint8Array([\n            0x01,\n            // version 1\n            0x00,\n            0x00,\n            0x00,\n            // flags\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x02,\n            // creation_time\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x03,\n            // modification_time\n            timescale >> 24 & 0xff,\n            timescale >> 16 & 0xff,\n            timescale >> 8 & 0xff,\n            timescale & 0xff,\n            // timescale\n            upperWordDuration >> 24,\n            upperWordDuration >> 16 & 0xff,\n            upperWordDuration >> 8 & 0xff,\n            upperWordDuration & 0xff,\n            lowerWordDuration >> 24,\n            lowerWordDuration >> 16 & 0xff,\n            lowerWordDuration >> 8 & 0xff,\n            lowerWordDuration & 0xff,\n            0x00,\n            0x01,\n            0x00,\n            0x00,\n            // 1.0 rate\n            0x01,\n            0x00,\n            // 1.0 volume\n            0x00,\n            0x00,\n            // reserved\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            // reserved\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            // reserved\n            0x00,\n            0x01,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x01,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x40,\n            0x00,\n            0x00,\n            0x00,\n            // transformation: unity matrix\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            // pre_defined\n            0xff,\n            0xff,\n            0xff,\n            0xff // next_track_ID\n        ]);\n        return MP4.box(MP4.types.mvhd, bytes);\n    }\n    static sdtp(track) {\n        const samples = track.samples || [];\n        const bytes = new Uint8Array(4 + samples.length);\n        let i;\n        let flags;\n        // leave the full box header (4 bytes) all zero\n        // write the sample table\n        for(i = 0; i < samples.length; i++){\n            flags = samples[i].flags;\n            bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;\n        }\n        return MP4.box(MP4.types.sdtp, bytes);\n    }\n    static stbl(track) {\n        return MP4.box(MP4.types.stbl, MP4.stsd(track), MP4.box(MP4.types.stts, MP4.STTS), MP4.box(MP4.types.stsc, MP4.STSC), MP4.box(MP4.types.stsz, MP4.STSZ), MP4.box(MP4.types.stco, MP4.STCO));\n    }\n    static avc1(track) {\n        let sps = [];\n        let pps = [];\n        let i;\n        let data;\n        let len;\n        // assemble the SPSs\n        for(i = 0; i < track.sps.length; i++){\n            data = track.sps[i];\n            len = data.byteLength;\n            sps.push(len >>> 8 & 0xff);\n            sps.push(len & 0xff);\n            // SPS\n            sps = sps.concat(Array.prototype.slice.call(data));\n        }\n        // assemble the PPSs\n        for(i = 0; i < track.pps.length; i++){\n            data = track.pps[i];\n            len = data.byteLength;\n            pps.push(len >>> 8 & 0xff);\n            pps.push(len & 0xff);\n            pps = pps.concat(Array.prototype.slice.call(data));\n        }\n        const avcc = MP4.box(MP4.types.avcC, new Uint8Array([\n            0x01,\n            // version\n            sps[3],\n            // profile\n            sps[4],\n            // profile compat\n            sps[5],\n            // level\n            0xfc | 3,\n            // lengthSizeMinusOne, hard-coded to 4 bytes\n            0xe0 | track.sps.length // 3bit reserved (111) + numOfSequenceParameterSets\n        ].concat(sps).concat([\n            track.pps.length // numOfPictureParameterSets\n        ]).concat(pps))); // \"PPS\"\n        const width = track.width;\n        const height = track.height;\n        const hSpacing = track.pixelRatio[0];\n        const vSpacing = track.pixelRatio[1];\n        return MP4.box(MP4.types.avc1, new Uint8Array([\n            0x00,\n            0x00,\n            0x00,\n            // reserved\n            0x00,\n            0x00,\n            0x00,\n            // reserved\n            0x00,\n            0x01,\n            // data_reference_index\n            0x00,\n            0x00,\n            // pre_defined\n            0x00,\n            0x00,\n            // reserved\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            // pre_defined\n            width >> 8 & 0xff,\n            width & 0xff,\n            // width\n            height >> 8 & 0xff,\n            height & 0xff,\n            // height\n            0x00,\n            0x48,\n            0x00,\n            0x00,\n            // horizresolution\n            0x00,\n            0x48,\n            0x00,\n            0x00,\n            // vertresolution\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            // reserved\n            0x00,\n            0x01,\n            // frame_count\n            0x12,\n            0x64,\n            0x61,\n            0x69,\n            0x6c,\n            // dailymotion/hls.js\n            0x79,\n            0x6d,\n            0x6f,\n            0x74,\n            0x69,\n            0x6f,\n            0x6e,\n            0x2f,\n            0x68,\n            0x6c,\n            0x73,\n            0x2e,\n            0x6a,\n            0x73,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            // compressorname\n            0x00,\n            0x18,\n            // depth = 24\n            0x11,\n            0x11\n        ]), // pre_defined = -1\n        avcc, MP4.box(MP4.types.btrt, new Uint8Array([\n            0x00,\n            0x1c,\n            0x9c,\n            0x80,\n            // bufferSizeDB\n            0x00,\n            0x2d,\n            0xc6,\n            0xc0,\n            // maxBitrate\n            0x00,\n            0x2d,\n            0xc6,\n            0xc0\n        ])), // avgBitrate\n        MP4.box(MP4.types.pasp, new Uint8Array([\n            hSpacing >> 24,\n            // hSpacing\n            hSpacing >> 16 & 0xff,\n            hSpacing >> 8 & 0xff,\n            hSpacing & 0xff,\n            vSpacing >> 24,\n            // vSpacing\n            vSpacing >> 16 & 0xff,\n            vSpacing >> 8 & 0xff,\n            vSpacing & 0xff\n        ])));\n    }\n    static esds(track) {\n        const configlen = track.config.length;\n        return new Uint8Array([\n            0x00,\n            // version 0\n            0x00,\n            0x00,\n            0x00,\n            // flags\n            0x03,\n            // descriptor_type\n            0x17 + configlen,\n            // length\n            0x00,\n            0x01,\n            // es_id\n            0x00,\n            // stream_priority\n            0x04,\n            // descriptor_type\n            0x0f + configlen,\n            // length\n            0x40,\n            // codec : mpeg4_audio\n            0x15,\n            // stream_type\n            0x00,\n            0x00,\n            0x00,\n            // buffer_size\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            // maxBitrate\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            // avgBitrate\n            0x05 // descriptor_type\n        ].concat([\n            configlen\n        ]).concat(track.config).concat([\n            0x06,\n            0x01,\n            0x02\n        ])); // GASpecificConfig)); // length + audio config descriptor\n    }\n    static audioStsd(track) {\n        const samplerate = track.samplerate;\n        return new Uint8Array([\n            0x00,\n            0x00,\n            0x00,\n            // reserved\n            0x00,\n            0x00,\n            0x00,\n            // reserved\n            0x00,\n            0x01,\n            // data_reference_index\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            // reserved\n            0x00,\n            track.channelCount,\n            // channelcount\n            0x00,\n            0x10,\n            // sampleSize:16bits\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            // reserved2\n            samplerate >> 8 & 0xff,\n            samplerate & 0xff,\n            //\n            0x00,\n            0x00\n        ]);\n    }\n    static mp4a(track) {\n        return MP4.box(MP4.types.mp4a, MP4.audioStsd(track), MP4.box(MP4.types.esds, MP4.esds(track)));\n    }\n    static mp3(track) {\n        return MP4.box(MP4.types[\".mp3\"], MP4.audioStsd(track));\n    }\n    static ac3(track) {\n        return MP4.box(MP4.types[\"ac-3\"], MP4.audioStsd(track), MP4.box(MP4.types.dac3, track.config));\n    }\n    static stsd(track) {\n        if (track.type === \"audio\") {\n            if (track.segmentCodec === \"mp3\" && track.codec === \"mp3\") {\n                return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp3(track));\n            }\n            if (track.segmentCodec === \"ac3\") {\n                return MP4.box(MP4.types.stsd, MP4.STSD, MP4.ac3(track));\n            }\n            return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(track));\n        } else {\n            return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(track));\n        }\n    }\n    static tkhd(track) {\n        const id = track.id;\n        const duration = track.duration * track.timescale;\n        const width = track.width;\n        const height = track.height;\n        const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n        const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n        return MP4.box(MP4.types.tkhd, new Uint8Array([\n            0x01,\n            // version 1\n            0x00,\n            0x00,\n            0x07,\n            // flags\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x02,\n            // creation_time\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x03,\n            // modification_time\n            id >> 24 & 0xff,\n            id >> 16 & 0xff,\n            id >> 8 & 0xff,\n            id & 0xff,\n            // track_ID\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            // reserved\n            upperWordDuration >> 24,\n            upperWordDuration >> 16 & 0xff,\n            upperWordDuration >> 8 & 0xff,\n            upperWordDuration & 0xff,\n            lowerWordDuration >> 24,\n            lowerWordDuration >> 16 & 0xff,\n            lowerWordDuration >> 8 & 0xff,\n            lowerWordDuration & 0xff,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            // reserved\n            0x00,\n            0x00,\n            // layer\n            0x00,\n            0x00,\n            // alternate_group\n            0x00,\n            0x00,\n            // non-audio track volume\n            0x00,\n            0x00,\n            // reserved\n            0x00,\n            0x01,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x01,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            0x40,\n            0x00,\n            0x00,\n            0x00,\n            // transformation: unity matrix\n            width >> 8 & 0xff,\n            width & 0xff,\n            0x00,\n            0x00,\n            // width\n            height >> 8 & 0xff,\n            height & 0xff,\n            0x00,\n            0x00 // height\n        ]));\n    }\n    static traf(track, baseMediaDecodeTime) {\n        const sampleDependencyTable = MP4.sdtp(track);\n        const id = track.id;\n        const upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1));\n        const lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));\n        return MP4.box(MP4.types.traf, MP4.box(MP4.types.tfhd, new Uint8Array([\n            0x00,\n            // version 0\n            0x00,\n            0x00,\n            0x00,\n            // flags\n            id >> 24,\n            id >> 16 & 0xff,\n            id >> 8 & 0xff,\n            id & 0xff // track_ID\n        ])), MP4.box(MP4.types.tfdt, new Uint8Array([\n            0x01,\n            // version 1\n            0x00,\n            0x00,\n            0x00,\n            // flags\n            upperWordBaseMediaDecodeTime >> 24,\n            upperWordBaseMediaDecodeTime >> 16 & 0xff,\n            upperWordBaseMediaDecodeTime >> 8 & 0xff,\n            upperWordBaseMediaDecodeTime & 0xff,\n            lowerWordBaseMediaDecodeTime >> 24,\n            lowerWordBaseMediaDecodeTime >> 16 & 0xff,\n            lowerWordBaseMediaDecodeTime >> 8 & 0xff,\n            lowerWordBaseMediaDecodeTime & 0xff\n        ])), MP4.trun(track, sampleDependencyTable.length + 16 + // tfhd\n        20 + // tfdt\n        8 + // traf header\n        16 + // mfhd\n        8 + // moof header\n        8), // mdat header\n        sampleDependencyTable);\n    }\n    /**\n   * Generate a track box.\n   * @param track a track definition\n   */ static trak(track) {\n        track.duration = track.duration || 0xffffffff;\n        return MP4.box(MP4.types.trak, MP4.tkhd(track), MP4.mdia(track));\n    }\n    static trex(track) {\n        const id = track.id;\n        return MP4.box(MP4.types.trex, new Uint8Array([\n            0x00,\n            // version 0\n            0x00,\n            0x00,\n            0x00,\n            // flags\n            id >> 24,\n            id >> 16 & 0xff,\n            id >> 8 & 0xff,\n            id & 0xff,\n            // track_ID\n            0x00,\n            0x00,\n            0x00,\n            0x01,\n            // default_sample_description_index\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            // default_sample_duration\n            0x00,\n            0x00,\n            0x00,\n            0x00,\n            // default_sample_size\n            0x00,\n            0x01,\n            0x00,\n            0x01 // default_sample_flags\n        ]));\n    }\n    static trun(track, offset) {\n        const samples = track.samples || [];\n        const len = samples.length;\n        const arraylen = 12 + 16 * len;\n        const array = new Uint8Array(arraylen);\n        let i;\n        let sample;\n        let duration;\n        let size;\n        let flags;\n        let cts;\n        offset += 8 + arraylen;\n        array.set([\n            track.type === \"video\" ? 0x01 : 0x00,\n            // version 1 for video with signed-int sample_composition_time_offset\n            0x00,\n            0x0f,\n            0x01,\n            // flags\n            len >>> 24 & 0xff,\n            len >>> 16 & 0xff,\n            len >>> 8 & 0xff,\n            len & 0xff,\n            // sample_count\n            offset >>> 24 & 0xff,\n            offset >>> 16 & 0xff,\n            offset >>> 8 & 0xff,\n            offset & 0xff // data_offset\n        ], 0);\n        for(i = 0; i < len; i++){\n            sample = samples[i];\n            duration = sample.duration;\n            size = sample.size;\n            flags = sample.flags;\n            cts = sample.cts;\n            array.set([\n                duration >>> 24 & 0xff,\n                duration >>> 16 & 0xff,\n                duration >>> 8 & 0xff,\n                duration & 0xff,\n                // sample_duration\n                size >>> 24 & 0xff,\n                size >>> 16 & 0xff,\n                size >>> 8 & 0xff,\n                size & 0xff,\n                // sample_size\n                flags.isLeading << 2 | flags.dependsOn,\n                flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.paddingValue << 1 | flags.isNonSync,\n                flags.degradPrio & 0xf0 << 8,\n                flags.degradPrio & 0x0f,\n                // sample_flags\n                cts >>> 24 & 0xff,\n                cts >>> 16 & 0xff,\n                cts >>> 8 & 0xff,\n                cts & 0xff // sample_composition_time_offset\n            ], 12 + 16 * i);\n        }\n        return MP4.box(MP4.types.trun, array);\n    }\n    static initSegment(tracks) {\n        if (!MP4.types) {\n            MP4.init();\n        }\n        const movie = MP4.moov(tracks);\n        const result = appendUint8Array(MP4.FTYP, movie);\n        return result;\n    }\n}\nMP4.types = void 0;\nMP4.HDLR_TYPES = void 0;\nMP4.STTS = void 0;\nMP4.STSC = void 0;\nMP4.STCO = void 0;\nMP4.STSZ = void 0;\nMP4.VMHD = void 0;\nMP4.SMHD = void 0;\nMP4.STSD = void 0;\nMP4.FTYP = void 0;\nMP4.DINF = void 0;\nconst MPEG_TS_CLOCK_FREQ_HZ = 90000;\nfunction toTimescaleFromBase(baseTime, destScale, srcBase = 1, round = false) {\n    const result = baseTime * destScale * srcBase; // equivalent to `(value * scale) / (1 / base)`\n    return round ? Math.round(result) : result;\n}\nfunction toTimescaleFromScale(baseTime, destScale, srcScale = 1, round = false) {\n    return toTimescaleFromBase(baseTime, destScale, 1 / srcScale, round);\n}\nfunction toMsFromMpegTsClock(baseTime, round = false) {\n    return toTimescaleFromBase(baseTime, 1000, 1 / MPEG_TS_CLOCK_FREQ_HZ, round);\n}\nfunction toMpegTsClockFromTimescale(baseTime, srcScale = 1) {\n    return toTimescaleFromBase(baseTime, MPEG_TS_CLOCK_FREQ_HZ, 1 / srcScale);\n}\nconst MAX_SILENT_FRAME_DURATION = 10 * 1000; // 10 seconds\nconst AAC_SAMPLES_PER_FRAME = 1024;\nconst MPEG_AUDIO_SAMPLE_PER_FRAME = 1152;\nconst AC3_SAMPLES_PER_FRAME = 1536;\nlet chromeVersion = null;\nlet safariWebkitVersion = null;\nclass MP4Remuxer {\n    constructor(observer, config, typeSupported, vendor = \"\"){\n        this.observer = void 0;\n        this.config = void 0;\n        this.typeSupported = void 0;\n        this.ISGenerated = false;\n        this._initPTS = null;\n        this._initDTS = null;\n        this.nextAvcDts = null;\n        this.nextAudioPts = null;\n        this.videoSampleDuration = null;\n        this.isAudioContiguous = false;\n        this.isVideoContiguous = false;\n        this.videoTrackConfig = void 0;\n        this.observer = observer;\n        this.config = config;\n        this.typeSupported = typeSupported;\n        this.ISGenerated = false;\n        if (chromeVersion === null) {\n            const userAgent = navigator.userAgent || \"\";\n            const result = userAgent.match(/Chrome\\/(\\d+)/i);\n            chromeVersion = result ? parseInt(result[1]) : 0;\n        }\n        if (safariWebkitVersion === null) {\n            const result = navigator.userAgent.match(/Safari\\/(\\d+)/i);\n            safariWebkitVersion = result ? parseInt(result[1]) : 0;\n        }\n    }\n    destroy() {\n        // @ts-ignore\n        this.config = this.videoTrackConfig = this._initPTS = this._initDTS = null;\n    }\n    resetTimeStamp(defaultTimeStamp) {\n        logger.log(\"[mp4-remuxer]: initPTS & initDTS reset\");\n        this._initPTS = this._initDTS = defaultTimeStamp;\n    }\n    resetNextTimestamp() {\n        logger.log(\"[mp4-remuxer]: reset next timestamp\");\n        this.isVideoContiguous = false;\n        this.isAudioContiguous = false;\n    }\n    resetInitSegment() {\n        logger.log(\"[mp4-remuxer]: ISGenerated flag reset\");\n        this.ISGenerated = false;\n        this.videoTrackConfig = undefined;\n    }\n    getVideoStartPts(videoSamples) {\n        let rolloverDetected = false;\n        const startPTS = videoSamples.reduce((minPTS, sample)=>{\n            const delta = sample.pts - minPTS;\n            if (delta < -4294967296) {\n                // 2^32, see PTSNormalize for reasoning, but we're hitting a rollover here, and we don't want that to impact the timeOffset calculation\n                rolloverDetected = true;\n                return normalizePts(minPTS, sample.pts);\n            } else if (delta > 0) {\n                return minPTS;\n            } else {\n                return sample.pts;\n            }\n        }, videoSamples[0].pts);\n        if (rolloverDetected) {\n            logger.debug(\"PTS rollover detected\");\n        }\n        return startPTS;\n    }\n    remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, flush, playlistType) {\n        let video;\n        let audio;\n        let initSegment;\n        let text;\n        let id3;\n        let independent;\n        let audioTimeOffset = timeOffset;\n        let videoTimeOffset = timeOffset;\n        // If we're remuxing audio and video progressively, wait until we've received enough samples for each track before proceeding.\n        // This is done to synchronize the audio and video streams. We know if the current segment will have samples if the \"pid\"\n        // parameter is greater than -1. The pid is set when the PMT is parsed, which contains the tracks list.\n        // However, if the initSegment has already been generated, or we've reached the end of a segment (flush),\n        // then we can remux one track without waiting for the other.\n        const hasAudio = audioTrack.pid > -1;\n        const hasVideo = videoTrack.pid > -1;\n        const length = videoTrack.samples.length;\n        const enoughAudioSamples = audioTrack.samples.length > 0;\n        const enoughVideoSamples = flush && length > 0 || length > 1;\n        const canRemuxAvc = (!hasAudio || enoughAudioSamples) && (!hasVideo || enoughVideoSamples) || this.ISGenerated || flush;\n        if (canRemuxAvc) {\n            if (this.ISGenerated) {\n                var _videoTrack$pixelRati, _config$pixelRatio, _videoTrack$pixelRati2, _config$pixelRatio2;\n                const config = this.videoTrackConfig;\n                if (config && (videoTrack.width !== config.width || videoTrack.height !== config.height || ((_videoTrack$pixelRati = videoTrack.pixelRatio) == null ? void 0 : _videoTrack$pixelRati[0]) !== ((_config$pixelRatio = config.pixelRatio) == null ? void 0 : _config$pixelRatio[0]) || ((_videoTrack$pixelRati2 = videoTrack.pixelRatio) == null ? void 0 : _videoTrack$pixelRati2[1]) !== ((_config$pixelRatio2 = config.pixelRatio) == null ? void 0 : _config$pixelRatio2[1]))) {\n                    this.resetInitSegment();\n                }\n            } else {\n                initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);\n            }\n            const isVideoContiguous = this.isVideoContiguous;\n            let firstKeyFrameIndex = -1;\n            let firstKeyFramePTS;\n            if (enoughVideoSamples) {\n                firstKeyFrameIndex = findKeyframeIndex(videoTrack.samples);\n                if (!isVideoContiguous && this.config.forceKeyFrameOnDiscontinuity) {\n                    independent = true;\n                    if (firstKeyFrameIndex > 0) {\n                        logger.warn(`[mp4-remuxer]: Dropped ${firstKeyFrameIndex} out of ${length} video samples due to a missing keyframe`);\n                        const startPTS = this.getVideoStartPts(videoTrack.samples);\n                        videoTrack.samples = videoTrack.samples.slice(firstKeyFrameIndex);\n                        videoTrack.dropped += firstKeyFrameIndex;\n                        videoTimeOffset += (videoTrack.samples[0].pts - startPTS) / videoTrack.inputTimeScale;\n                        firstKeyFramePTS = videoTimeOffset;\n                    } else if (firstKeyFrameIndex === -1) {\n                        logger.warn(`[mp4-remuxer]: No keyframe found out of ${length} video samples`);\n                        independent = false;\n                    }\n                }\n            }\n            if (this.ISGenerated) {\n                if (enoughAudioSamples && enoughVideoSamples) {\n                    // timeOffset is expected to be the offset of the first timestamp of this fragment (first DTS)\n                    // if first audio DTS is not aligned with first video DTS then we need to take that into account\n                    // when providing timeOffset to remuxAudio / remuxVideo. if we don't do that, there might be a permanent / small\n                    // drift between audio and video streams\n                    const startPTS = this.getVideoStartPts(videoTrack.samples);\n                    const tsDelta = normalizePts(audioTrack.samples[0].pts, startPTS) - startPTS;\n                    const audiovideoTimestampDelta = tsDelta / videoTrack.inputTimeScale;\n                    audioTimeOffset += Math.max(0, audiovideoTimestampDelta);\n                    videoTimeOffset += Math.max(0, -audiovideoTimestampDelta);\n                }\n                // Purposefully remuxing audio before video, so that remuxVideo can use nextAudioPts, which is calculated in remuxAudio.\n                if (enoughAudioSamples) {\n                    // if initSegment was generated without audio samples, regenerate it again\n                    if (!audioTrack.samplerate) {\n                        logger.warn(\"[mp4-remuxer]: regenerate InitSegment as audio detected\");\n                        initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);\n                    }\n                    audio = this.remuxAudio(audioTrack, audioTimeOffset, this.isAudioContiguous, accurateTimeOffset, hasVideo || enoughVideoSamples || playlistType === PlaylistLevelType.AUDIO ? videoTimeOffset : undefined);\n                    if (enoughVideoSamples) {\n                        const audioTrackLength = audio ? audio.endPTS - audio.startPTS : 0;\n                        // if initSegment was generated without video samples, regenerate it again\n                        if (!videoTrack.inputTimeScale) {\n                            logger.warn(\"[mp4-remuxer]: regenerate InitSegment as video detected\");\n                            initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);\n                        }\n                        video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, audioTrackLength);\n                    }\n                } else if (enoughVideoSamples) {\n                    video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, 0);\n                }\n                if (video) {\n                    video.firstKeyFrame = firstKeyFrameIndex;\n                    video.independent = firstKeyFrameIndex !== -1;\n                    video.firstKeyFramePTS = firstKeyFramePTS;\n                }\n            }\n        }\n        // Allow ID3 and text to remux, even if more audio/video samples are required\n        if (this.ISGenerated && this._initPTS && this._initDTS) {\n            if (id3Track.samples.length) {\n                id3 = flushTextTrackMetadataCueSamples(id3Track, timeOffset, this._initPTS, this._initDTS);\n            }\n            if (textTrack.samples.length) {\n                text = flushTextTrackUserdataCueSamples(textTrack, timeOffset, this._initPTS);\n            }\n        }\n        return {\n            audio,\n            video,\n            initSegment,\n            independent,\n            text,\n            id3\n        };\n    }\n    generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset) {\n        const audioSamples = audioTrack.samples;\n        const videoSamples = videoTrack.samples;\n        const typeSupported = this.typeSupported;\n        const tracks = {};\n        const _initPTS = this._initPTS;\n        let computePTSDTS = !_initPTS || accurateTimeOffset;\n        let container = \"audio/mp4\";\n        let initPTS;\n        let initDTS;\n        let timescale;\n        if (computePTSDTS) {\n            initPTS = initDTS = Infinity;\n        }\n        if (audioTrack.config && audioSamples.length) {\n            // let's use audio sampling rate as MP4 time scale.\n            // rationale is that there is a integer nb of audio frames per audio sample (1024 for AAC)\n            // using audio sampling rate here helps having an integer MP4 frame duration\n            // this avoids potential rounding issue and AV sync issue\n            audioTrack.timescale = audioTrack.samplerate;\n            switch(audioTrack.segmentCodec){\n                case \"mp3\":\n                    if (typeSupported.mpeg) {\n                        // Chrome and Safari\n                        container = \"audio/mpeg\";\n                        audioTrack.codec = \"\";\n                    } else if (typeSupported.mp3) {\n                        // Firefox\n                        audioTrack.codec = \"mp3\";\n                    }\n                    break;\n                case \"ac3\":\n                    audioTrack.codec = \"ac-3\";\n                    break;\n            }\n            tracks.audio = {\n                id: \"audio\",\n                container: container,\n                codec: audioTrack.codec,\n                initSegment: audioTrack.segmentCodec === \"mp3\" && typeSupported.mpeg ? new Uint8Array(0) : MP4.initSegment([\n                    audioTrack\n                ]),\n                metadata: {\n                    channelCount: audioTrack.channelCount\n                }\n            };\n            if (computePTSDTS) {\n                timescale = audioTrack.inputTimeScale;\n                if (!_initPTS || timescale !== _initPTS.timescale) {\n                    // remember first PTS of this demuxing context. for audio, PTS = DTS\n                    initPTS = initDTS = audioSamples[0].pts - Math.round(timescale * timeOffset);\n                } else {\n                    computePTSDTS = false;\n                }\n            }\n        }\n        if (videoTrack.sps && videoTrack.pps && videoSamples.length) {\n            // let's use input time scale as MP4 video timescale\n            // we use input time scale straight away to avoid rounding issues on frame duration / cts computation\n            videoTrack.timescale = videoTrack.inputTimeScale;\n            tracks.video = {\n                id: \"main\",\n                container: \"video/mp4\",\n                codec: videoTrack.codec,\n                initSegment: MP4.initSegment([\n                    videoTrack\n                ]),\n                metadata: {\n                    width: videoTrack.width,\n                    height: videoTrack.height\n                }\n            };\n            if (computePTSDTS) {\n                timescale = videoTrack.inputTimeScale;\n                if (!_initPTS || timescale !== _initPTS.timescale) {\n                    const startPTS = this.getVideoStartPts(videoSamples);\n                    const startOffset = Math.round(timescale * timeOffset);\n                    initDTS = Math.min(initDTS, normalizePts(videoSamples[0].dts, startPTS) - startOffset);\n                    initPTS = Math.min(initPTS, startPTS - startOffset);\n                } else {\n                    computePTSDTS = false;\n                }\n            }\n            this.videoTrackConfig = {\n                width: videoTrack.width,\n                height: videoTrack.height,\n                pixelRatio: videoTrack.pixelRatio\n            };\n        }\n        if (Object.keys(tracks).length) {\n            this.ISGenerated = true;\n            if (computePTSDTS) {\n                this._initPTS = {\n                    baseTime: initPTS,\n                    timescale: timescale\n                };\n                this._initDTS = {\n                    baseTime: initDTS,\n                    timescale: timescale\n                };\n            } else {\n                initPTS = timescale = undefined;\n            }\n            return {\n                tracks,\n                initPTS,\n                timescale\n            };\n        }\n    }\n    remuxVideo(track, timeOffset, contiguous, audioTrackLength) {\n        const timeScale = track.inputTimeScale;\n        const inputSamples = track.samples;\n        const outputSamples = [];\n        const nbSamples = inputSamples.length;\n        const initPTS = this._initPTS;\n        let nextAvcDts = this.nextAvcDts;\n        let offset = 8;\n        let mp4SampleDuration = this.videoSampleDuration;\n        let firstDTS;\n        let lastDTS;\n        let minPTS = Number.POSITIVE_INFINITY;\n        let maxPTS = Number.NEGATIVE_INFINITY;\n        let sortSamples = false;\n        // if parsed fragment is contiguous with last one, let's use last DTS value as reference\n        if (!contiguous || nextAvcDts === null) {\n            const pts = timeOffset * timeScale;\n            const cts = inputSamples[0].pts - normalizePts(inputSamples[0].dts, inputSamples[0].pts);\n            if (chromeVersion && nextAvcDts !== null && Math.abs(pts - cts - nextAvcDts) < 15000) {\n                // treat as contigous to adjust samples that would otherwise produce video buffer gaps in Chrome\n                contiguous = true;\n            } else {\n                // if not contiguous, let's use target timeOffset\n                nextAvcDts = pts - cts;\n            }\n        }\n        // PTS is coded on 33bits, and can loop from -2^32 to 2^32\n        // PTSNormalize will make PTS/DTS value monotonic, we use last known DTS value as reference value\n        const initTime = initPTS.baseTime * timeScale / initPTS.timescale;\n        for(let i = 0; i < nbSamples; i++){\n            const sample = inputSamples[i];\n            sample.pts = normalizePts(sample.pts - initTime, nextAvcDts);\n            sample.dts = normalizePts(sample.dts - initTime, nextAvcDts);\n            if (sample.dts < inputSamples[i > 0 ? i - 1 : i].dts) {\n                sortSamples = true;\n            }\n        }\n        // sort video samples by DTS then PTS then demux id order\n        if (sortSamples) {\n            inputSamples.sort(function(a, b) {\n                const deltadts = a.dts - b.dts;\n                const deltapts = a.pts - b.pts;\n                return deltadts || deltapts;\n            });\n        }\n        // Get first/last DTS\n        firstDTS = inputSamples[0].dts;\n        lastDTS = inputSamples[inputSamples.length - 1].dts;\n        // Sample duration (as expected by trun MP4 boxes), should be the delta between sample DTS\n        // set this constant duration as being the avg delta between consecutive DTS.\n        const inputDuration = lastDTS - firstDTS;\n        const averageSampleDuration = inputDuration ? Math.round(inputDuration / (nbSamples - 1)) : mp4SampleDuration || track.inputTimeScale / 30;\n        // if fragment are contiguous, detect hole/overlapping between fragments\n        if (contiguous) {\n            // check timestamp continuity across consecutive fragments (this is to remove inter-fragment gap/hole)\n            const delta = firstDTS - nextAvcDts;\n            const foundHole = delta > averageSampleDuration;\n            const foundOverlap = delta < -1;\n            if (foundHole || foundOverlap) {\n                if (foundHole) {\n                    logger.warn(`AVC: ${toMsFromMpegTsClock(delta, true)} ms (${delta}dts) hole between fragments detected at ${timeOffset.toFixed(3)}`);\n                } else {\n                    logger.warn(`AVC: ${toMsFromMpegTsClock(-delta, true)} ms (${delta}dts) overlapping between fragments detected at ${timeOffset.toFixed(3)}`);\n                }\n                if (!foundOverlap || nextAvcDts >= inputSamples[0].pts || chromeVersion) {\n                    firstDTS = nextAvcDts;\n                    const firstPTS = inputSamples[0].pts - delta;\n                    if (foundHole) {\n                        inputSamples[0].dts = firstDTS;\n                        inputSamples[0].pts = firstPTS;\n                    } else {\n                        for(let i = 0; i < inputSamples.length; i++){\n                            if (inputSamples[i].dts > firstPTS) {\n                                break;\n                            }\n                            inputSamples[i].dts -= delta;\n                            inputSamples[i].pts -= delta;\n                        }\n                    }\n                    logger.log(`Video: Initial PTS/DTS adjusted: ${toMsFromMpegTsClock(firstPTS, true)}/${toMsFromMpegTsClock(firstDTS, true)}, delta: ${toMsFromMpegTsClock(delta, true)} ms`);\n                }\n            }\n        }\n        firstDTS = Math.max(0, firstDTS);\n        let nbNalu = 0;\n        let naluLen = 0;\n        let dtsStep = firstDTS;\n        for(let i = 0; i < nbSamples; i++){\n            // compute total/avc sample length and nb of NAL units\n            const sample = inputSamples[i];\n            const units = sample.units;\n            const nbUnits = units.length;\n            let sampleLen = 0;\n            for(let j = 0; j < nbUnits; j++){\n                sampleLen += units[j].data.length;\n            }\n            naluLen += sampleLen;\n            nbNalu += nbUnits;\n            sample.length = sampleLen;\n            // ensure sample monotonic DTS\n            if (sample.dts < dtsStep) {\n                sample.dts = dtsStep;\n                dtsStep += averageSampleDuration / 4 | 0 || 1;\n            } else {\n                dtsStep = sample.dts;\n            }\n            minPTS = Math.min(sample.pts, minPTS);\n            maxPTS = Math.max(sample.pts, maxPTS);\n        }\n        lastDTS = inputSamples[nbSamples - 1].dts;\n        /* concatenate the video data and construct the mdat in place\n      (need 8 more bytes to fill length and mpdat type) */ const mdatSize = naluLen + 4 * nbNalu + 8;\n        let mdat;\n        try {\n            mdat = new Uint8Array(mdatSize);\n        } catch (err) {\n            this.observer.emit(Events.ERROR, Events.ERROR, {\n                type: ErrorTypes.MUX_ERROR,\n                details: ErrorDetails.REMUX_ALLOC_ERROR,\n                fatal: false,\n                error: err,\n                bytes: mdatSize,\n                reason: `fail allocating video mdat ${mdatSize}`\n            });\n            return;\n        }\n        const view = new DataView(mdat.buffer);\n        view.setUint32(0, mdatSize);\n        mdat.set(MP4.types.mdat, 4);\n        let stretchedLastFrame = false;\n        let minDtsDelta = Number.POSITIVE_INFINITY;\n        let minPtsDelta = Number.POSITIVE_INFINITY;\n        let maxDtsDelta = Number.NEGATIVE_INFINITY;\n        let maxPtsDelta = Number.NEGATIVE_INFINITY;\n        for(let i = 0; i < nbSamples; i++){\n            const VideoSample = inputSamples[i];\n            const VideoSampleUnits = VideoSample.units;\n            let mp4SampleLength = 0;\n            // convert NALU bitstream to MP4 format (prepend NALU with size field)\n            for(let j = 0, nbUnits = VideoSampleUnits.length; j < nbUnits; j++){\n                const unit = VideoSampleUnits[j];\n                const unitData = unit.data;\n                const unitDataLen = unit.data.byteLength;\n                view.setUint32(offset, unitDataLen);\n                offset += 4;\n                mdat.set(unitData, offset);\n                offset += unitDataLen;\n                mp4SampleLength += 4 + unitDataLen;\n            }\n            // expected sample duration is the Decoding Timestamp diff of consecutive samples\n            let ptsDelta;\n            if (i < nbSamples - 1) {\n                mp4SampleDuration = inputSamples[i + 1].dts - VideoSample.dts;\n                ptsDelta = inputSamples[i + 1].pts - VideoSample.pts;\n            } else {\n                const config = this.config;\n                const lastFrameDuration = i > 0 ? VideoSample.dts - inputSamples[i - 1].dts : averageSampleDuration;\n                ptsDelta = i > 0 ? VideoSample.pts - inputSamples[i - 1].pts : averageSampleDuration;\n                if (config.stretchShortVideoTrack && this.nextAudioPts !== null) {\n                    // In some cases, a segment's audio track duration may exceed the video track duration.\n                    // Since we've already remuxed audio, and we know how long the audio track is, we look to\n                    // see if the delta to the next segment is longer than maxBufferHole.\n                    // If so, playback would potentially get stuck, so we artificially inflate\n                    // the duration of the last frame to minimize any potential gap between segments.\n                    const gapTolerance = Math.floor(config.maxBufferHole * timeScale);\n                    const deltaToFrameEnd = (audioTrackLength ? minPTS + audioTrackLength * timeScale : this.nextAudioPts) - VideoSample.pts;\n                    if (deltaToFrameEnd > gapTolerance) {\n                        // We subtract lastFrameDuration from deltaToFrameEnd to try to prevent any video\n                        // frame overlap. maxBufferHole should be >> lastFrameDuration anyway.\n                        mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;\n                        if (mp4SampleDuration < 0) {\n                            mp4SampleDuration = lastFrameDuration;\n                        } else {\n                            stretchedLastFrame = true;\n                        }\n                        logger.log(`[mp4-remuxer]: It is approximately ${deltaToFrameEnd / 90} ms to the next segment; using duration ${mp4SampleDuration / 90} ms for the last video frame.`);\n                    } else {\n                        mp4SampleDuration = lastFrameDuration;\n                    }\n                } else {\n                    mp4SampleDuration = lastFrameDuration;\n                }\n            }\n            const compositionTimeOffset = Math.round(VideoSample.pts - VideoSample.dts);\n            minDtsDelta = Math.min(minDtsDelta, mp4SampleDuration);\n            maxDtsDelta = Math.max(maxDtsDelta, mp4SampleDuration);\n            minPtsDelta = Math.min(minPtsDelta, ptsDelta);\n            maxPtsDelta = Math.max(maxPtsDelta, ptsDelta);\n            outputSamples.push(new Mp4Sample(VideoSample.key, mp4SampleDuration, mp4SampleLength, compositionTimeOffset));\n        }\n        if (outputSamples.length) {\n            if (chromeVersion) {\n                if (chromeVersion < 70) {\n                    // Chrome workaround, mark first sample as being a Random Access Point (keyframe) to avoid sourcebuffer append issue\n                    // https://code.google.com/p/chromium/issues/detail?id=229412\n                    const flags = outputSamples[0].flags;\n                    flags.dependsOn = 2;\n                    flags.isNonSync = 0;\n                }\n            } else if (safariWebkitVersion) {\n                // Fix for \"CNN special report, with CC\" in test-streams (Safari browser only)\n                // Ignore DTS when frame durations are irregular. Safari MSE does not handle this leading to gaps.\n                if (maxPtsDelta - minPtsDelta < maxDtsDelta - minDtsDelta && averageSampleDuration / maxDtsDelta < 0.025 && outputSamples[0].cts === 0) {\n                    logger.warn(\"Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration.\");\n                    let dts = firstDTS;\n                    for(let i = 0, len = outputSamples.length; i < len; i++){\n                        const nextDts = dts + outputSamples[i].duration;\n                        const pts = dts + outputSamples[i].cts;\n                        if (i < len - 1) {\n                            const nextPts = nextDts + outputSamples[i + 1].cts;\n                            outputSamples[i].duration = nextPts - pts;\n                        } else {\n                            outputSamples[i].duration = i ? outputSamples[i - 1].duration : averageSampleDuration;\n                        }\n                        outputSamples[i].cts = 0;\n                        dts = nextDts;\n                    }\n                }\n            }\n        }\n        // next AVC sample DTS should be equal to last sample DTS + last sample duration (in PES timescale)\n        mp4SampleDuration = stretchedLastFrame || !mp4SampleDuration ? averageSampleDuration : mp4SampleDuration;\n        this.nextAvcDts = nextAvcDts = lastDTS + mp4SampleDuration;\n        this.videoSampleDuration = mp4SampleDuration;\n        this.isVideoContiguous = true;\n        const moof = MP4.moof(track.sequenceNumber++, firstDTS, _extends({}, track, {\n            samples: outputSamples\n        }));\n        const type = \"video\";\n        const data = {\n            data1: moof,\n            data2: mdat,\n            startPTS: minPTS / timeScale,\n            endPTS: (maxPTS + mp4SampleDuration) / timeScale,\n            startDTS: firstDTS / timeScale,\n            endDTS: nextAvcDts / timeScale,\n            type,\n            hasAudio: false,\n            hasVideo: true,\n            nb: outputSamples.length,\n            dropped: track.dropped\n        };\n        track.samples = [];\n        track.dropped = 0;\n        return data;\n    }\n    getSamplesPerFrame(track) {\n        switch(track.segmentCodec){\n            case \"mp3\":\n                return MPEG_AUDIO_SAMPLE_PER_FRAME;\n            case \"ac3\":\n                return AC3_SAMPLES_PER_FRAME;\n            default:\n                return AAC_SAMPLES_PER_FRAME;\n        }\n    }\n    remuxAudio(track, timeOffset, contiguous, accurateTimeOffset, videoTimeOffset) {\n        const inputTimeScale = track.inputTimeScale;\n        const mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale;\n        const scaleFactor = inputTimeScale / mp4timeScale;\n        const mp4SampleDuration = this.getSamplesPerFrame(track);\n        const inputSampleDuration = mp4SampleDuration * scaleFactor;\n        const initPTS = this._initPTS;\n        const rawMPEG = track.segmentCodec === \"mp3\" && this.typeSupported.mpeg;\n        const outputSamples = [];\n        const alignedWithVideo = videoTimeOffset !== undefined;\n        let inputSamples = track.samples;\n        let offset = rawMPEG ? 0 : 8;\n        let nextAudioPts = this.nextAudioPts || -1;\n        // window.audioSamples ? window.audioSamples.push(inputSamples.map(s => s.pts)) : (window.audioSamples = [inputSamples.map(s => s.pts)]);\n        // for audio samples, also consider consecutive fragments as being contiguous (even if a level switch occurs),\n        // for sake of clarity:\n        // consecutive fragments are frags with\n        //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR\n        //  - less than 20 audio frames distance\n        // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)\n        // this helps ensuring audio continuity\n        // and this also avoids audio glitches/cut when switching quality, or reporting wrong duration on first audio frame\n        const timeOffsetMpegTS = timeOffset * inputTimeScale;\n        const initTime = initPTS.baseTime * inputTimeScale / initPTS.timescale;\n        this.isAudioContiguous = contiguous = contiguous || inputSamples.length && nextAudioPts > 0 && (accurateTimeOffset && Math.abs(timeOffsetMpegTS - nextAudioPts) < 9000 || Math.abs(normalizePts(inputSamples[0].pts - initTime, timeOffsetMpegTS) - nextAudioPts) < 20 * inputSampleDuration);\n        // compute normalized PTS\n        inputSamples.forEach(function(sample) {\n            sample.pts = normalizePts(sample.pts - initTime, timeOffsetMpegTS);\n        });\n        if (!contiguous || nextAudioPts < 0) {\n            // filter out sample with negative PTS that are not playable anyway\n            // if we don't remove these negative samples, they will shift all audio samples forward.\n            // leading to audio overlap between current / next fragment\n            inputSamples = inputSamples.filter((sample)=>sample.pts >= 0);\n            // in case all samples have negative PTS, and have been filtered out, return now\n            if (!inputSamples.length) {\n                return;\n            }\n            if (videoTimeOffset === 0) {\n                // Set the start to 0 to match video so that start gaps larger than inputSampleDuration are filled with silence\n                nextAudioPts = 0;\n            } else if (accurateTimeOffset && !alignedWithVideo) {\n                // When not seeking, not live, and LevelDetails.PTSKnown, use fragment start as predicted next audio PTS\n                nextAudioPts = Math.max(0, timeOffsetMpegTS);\n            } else {\n                // if frags are not contiguous and if we cant trust time offset, let's use first sample PTS as next audio PTS\n                nextAudioPts = inputSamples[0].pts;\n            }\n        }\n        // If the audio track is missing samples, the frames seem to get \"left-shifted\" within the\n        // resulting mp4 segment, causing sync issues and leaving gaps at the end of the audio segment.\n        // In an effort to prevent this from happening, we inject frames here where there are gaps.\n        // When possible, we inject a silent frame; when that's not possible, we duplicate the last\n        // frame.\n        if (track.segmentCodec === \"aac\") {\n            const maxAudioFramesDrift = this.config.maxAudioFramesDrift;\n            for(let i = 0, nextPts = nextAudioPts; i < inputSamples.length; i++){\n                // First, let's see how far off this frame is from where we expect it to be\n                const sample = inputSamples[i];\n                const pts = sample.pts;\n                const delta = pts - nextPts;\n                const duration = Math.abs(1000 * delta / inputTimeScale);\n                // When remuxing with video, if we're overlapping by more than a duration, drop this sample to stay in sync\n                if (delta <= -maxAudioFramesDrift * inputSampleDuration && alignedWithVideo) {\n                    if (i === 0) {\n                        logger.warn(`Audio frame @ ${(pts / inputTimeScale).toFixed(3)}s overlaps nextAudioPts by ${Math.round(1000 * delta / inputTimeScale)} ms.`);\n                        this.nextAudioPts = nextAudioPts = nextPts = pts;\n                    }\n                } else if (delta >= maxAudioFramesDrift * inputSampleDuration && duration < MAX_SILENT_FRAME_DURATION && alignedWithVideo) {\n                    let missing = Math.round(delta / inputSampleDuration);\n                    // Adjust nextPts so that silent samples are aligned with media pts. This will prevent media samples from\n                    // later being shifted if nextPts is based on timeOffset and delta is not a multiple of inputSampleDuration.\n                    nextPts = pts - missing * inputSampleDuration;\n                    if (nextPts < 0) {\n                        missing--;\n                        nextPts += inputSampleDuration;\n                    }\n                    if (i === 0) {\n                        this.nextAudioPts = nextAudioPts = nextPts;\n                    }\n                    logger.warn(`[mp4-remuxer]: Injecting ${missing} audio frame @ ${(nextPts / inputTimeScale).toFixed(3)}s due to ${Math.round(1000 * delta / inputTimeScale)} ms gap.`);\n                    for(let j = 0; j < missing; j++){\n                        const newStamp = Math.max(nextPts, 0);\n                        let fillFrame = AAC.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);\n                        if (!fillFrame) {\n                            logger.log(\"[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead.\");\n                            fillFrame = sample.unit.subarray();\n                        }\n                        inputSamples.splice(i, 0, {\n                            unit: fillFrame,\n                            pts: newStamp\n                        });\n                        nextPts += inputSampleDuration;\n                        i++;\n                    }\n                }\n                sample.pts = nextPts;\n                nextPts += inputSampleDuration;\n            }\n        }\n        let firstPTS = null;\n        let lastPTS = null;\n        let mdat;\n        let mdatSize = 0;\n        let sampleLength = inputSamples.length;\n        while(sampleLength--){\n            mdatSize += inputSamples[sampleLength].unit.byteLength;\n        }\n        for(let j = 0, _nbSamples = inputSamples.length; j < _nbSamples; j++){\n            const audioSample = inputSamples[j];\n            const unit = audioSample.unit;\n            let pts = audioSample.pts;\n            if (lastPTS !== null) {\n                // If we have more than one sample, set the duration of the sample to the \"real\" duration; the PTS diff with\n                // the previous sample\n                const prevSample = outputSamples[j - 1];\n                prevSample.duration = Math.round((pts - lastPTS) / scaleFactor);\n            } else {\n                if (contiguous && track.segmentCodec === \"aac\") {\n                    // set PTS/DTS to expected PTS/DTS\n                    pts = nextAudioPts;\n                }\n                // remember first PTS of our audioSamples\n                firstPTS = pts;\n                if (mdatSize > 0) {\n                    /* concatenate the audio data and construct the mdat in place\n            (need 8 more bytes to fill length and mdat type) */ mdatSize += offset;\n                    try {\n                        mdat = new Uint8Array(mdatSize);\n                    } catch (err) {\n                        this.observer.emit(Events.ERROR, Events.ERROR, {\n                            type: ErrorTypes.MUX_ERROR,\n                            details: ErrorDetails.REMUX_ALLOC_ERROR,\n                            fatal: false,\n                            error: err,\n                            bytes: mdatSize,\n                            reason: `fail allocating audio mdat ${mdatSize}`\n                        });\n                        return;\n                    }\n                    if (!rawMPEG) {\n                        const view = new DataView(mdat.buffer);\n                        view.setUint32(0, mdatSize);\n                        mdat.set(MP4.types.mdat, 4);\n                    }\n                } else {\n                    // no audio samples\n                    return;\n                }\n            }\n            mdat.set(unit, offset);\n            const unitLen = unit.byteLength;\n            offset += unitLen;\n            // Default the sample's duration to the computed mp4SampleDuration, which will either be 1024 for AAC or 1152 for MPEG\n            // In the case that we have 1 sample, this will be the duration. If we have more than one sample, the duration\n            // becomes the PTS diff with the previous sample\n            outputSamples.push(new Mp4Sample(true, mp4SampleDuration, unitLen, 0));\n            lastPTS = pts;\n        }\n        // We could end up with no audio samples if all input samples were overlapping with the previously remuxed ones\n        const nbSamples = outputSamples.length;\n        if (!nbSamples) {\n            return;\n        }\n        // The next audio sample PTS should be equal to last sample PTS + duration\n        const lastSample = outputSamples[outputSamples.length - 1];\n        this.nextAudioPts = nextAudioPts = lastPTS + scaleFactor * lastSample.duration;\n        // Set the track samples from inputSamples to outputSamples before remuxing\n        const moof = rawMPEG ? new Uint8Array(0) : MP4.moof(track.sequenceNumber++, firstPTS / scaleFactor, _extends({}, track, {\n            samples: outputSamples\n        }));\n        // Clear the track samples. This also clears the samples array in the demuxer, since the reference is shared\n        track.samples = [];\n        const start = firstPTS / inputTimeScale;\n        const end = nextAudioPts / inputTimeScale;\n        const type = \"audio\";\n        const audioData = {\n            data1: moof,\n            data2: mdat,\n            startPTS: start,\n            endPTS: end,\n            startDTS: start,\n            endDTS: end,\n            type,\n            hasAudio: true,\n            hasVideo: false,\n            nb: nbSamples\n        };\n        this.isAudioContiguous = true;\n        return audioData;\n    }\n    remuxEmptyAudio(track, timeOffset, contiguous, videoData) {\n        const inputTimeScale = track.inputTimeScale;\n        const mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale;\n        const scaleFactor = inputTimeScale / mp4timeScale;\n        const nextAudioPts = this.nextAudioPts;\n        // sync with video's timestamp\n        const initDTS = this._initDTS;\n        const init90kHz = initDTS.baseTime * 90000 / initDTS.timescale;\n        const startDTS = (nextAudioPts !== null ? nextAudioPts : videoData.startDTS * inputTimeScale) + init90kHz;\n        const endDTS = videoData.endDTS * inputTimeScale + init90kHz;\n        // one sample's duration value\n        const frameDuration = scaleFactor * AAC_SAMPLES_PER_FRAME;\n        // samples count of this segment's duration\n        const nbSamples = Math.ceil((endDTS - startDTS) / frameDuration);\n        // silent frame\n        const silentFrame = AAC.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);\n        logger.warn(\"[mp4-remuxer]: remux empty Audio\");\n        // Can't remux if we can't generate a silent frame...\n        if (!silentFrame) {\n            logger.trace(\"[mp4-remuxer]: Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec\");\n            return;\n        }\n        const samples = [];\n        for(let i = 0; i < nbSamples; i++){\n            const stamp = startDTS + i * frameDuration;\n            samples.push({\n                unit: silentFrame,\n                pts: stamp,\n                dts: stamp\n            });\n        }\n        track.samples = samples;\n        return this.remuxAudio(track, timeOffset, contiguous, false);\n    }\n}\nfunction normalizePts(value, reference) {\n    let offset;\n    if (reference === null) {\n        return value;\n    }\n    if (reference < value) {\n        // - 2^33\n        offset = -8589934592;\n    } else {\n        // + 2^33\n        offset = 8589934592;\n    }\n    /* PTS is 33bit (from 0 to 2^33 -1)\n    if diff between value and reference is bigger than half of the amplitude (2^32) then it means that\n    PTS looping occured. fill the gap */ while(Math.abs(value - reference) > 4294967296){\n        value += offset;\n    }\n    return value;\n}\nfunction findKeyframeIndex(samples) {\n    for(let i = 0; i < samples.length; i++){\n        if (samples[i].key) {\n            return i;\n        }\n    }\n    return -1;\n}\nfunction flushTextTrackMetadataCueSamples(track, timeOffset, initPTS, initDTS) {\n    const length = track.samples.length;\n    if (!length) {\n        return;\n    }\n    const inputTimeScale = track.inputTimeScale;\n    for(let index = 0; index < length; index++){\n        const sample = track.samples[index];\n        // setting id3 pts, dts to relative time\n        // using this._initPTS and this._initDTS to calculate relative time\n        sample.pts = normalizePts(sample.pts - initPTS.baseTime * inputTimeScale / initPTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;\n        sample.dts = normalizePts(sample.dts - initDTS.baseTime * inputTimeScale / initDTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;\n    }\n    const samples = track.samples;\n    track.samples = [];\n    return {\n        samples\n    };\n}\nfunction flushTextTrackUserdataCueSamples(track, timeOffset, initPTS) {\n    const length = track.samples.length;\n    if (!length) {\n        return;\n    }\n    const inputTimeScale = track.inputTimeScale;\n    for(let index = 0; index < length; index++){\n        const sample = track.samples[index];\n        // setting text pts, dts to relative time\n        // using this._initPTS and this._initDTS to calculate relative time\n        sample.pts = normalizePts(sample.pts - initPTS.baseTime * inputTimeScale / initPTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;\n    }\n    track.samples.sort((a, b)=>a.pts - b.pts);\n    const samples = track.samples;\n    track.samples = [];\n    return {\n        samples\n    };\n}\nclass Mp4Sample {\n    constructor(isKeyframe, duration, size, cts){\n        this.size = void 0;\n        this.duration = void 0;\n        this.cts = void 0;\n        this.flags = void 0;\n        this.duration = duration;\n        this.size = size;\n        this.cts = cts;\n        this.flags = {\n            isLeading: 0,\n            isDependedOn: 0,\n            hasRedundancy: 0,\n            degradPrio: 0,\n            dependsOn: isKeyframe ? 2 : 1,\n            isNonSync: isKeyframe ? 0 : 1\n        };\n    }\n}\nclass PassThroughRemuxer {\n    constructor(){\n        this.emitInitSegment = false;\n        this.audioCodec = void 0;\n        this.videoCodec = void 0;\n        this.initData = void 0;\n        this.initPTS = null;\n        this.initTracks = void 0;\n        this.lastEndTime = null;\n    }\n    destroy() {}\n    resetTimeStamp(defaultInitPTS) {\n        this.initPTS = defaultInitPTS;\n        this.lastEndTime = null;\n    }\n    resetNextTimestamp() {\n        this.lastEndTime = null;\n    }\n    resetInitSegment(initSegment, audioCodec, videoCodec, decryptdata) {\n        this.audioCodec = audioCodec;\n        this.videoCodec = videoCodec;\n        this.generateInitSegment(patchEncyptionData(initSegment, decryptdata));\n        this.emitInitSegment = true;\n    }\n    generateInitSegment(initSegment) {\n        let { audioCodec, videoCodec } = this;\n        if (!(initSegment != null && initSegment.byteLength)) {\n            this.initTracks = undefined;\n            this.initData = undefined;\n            return;\n        }\n        const initData = this.initData = parseInitSegment(initSegment);\n        // Get codec from initSegment or fallback to default\n        if (initData.audio) {\n            audioCodec = getParsedTrackCodec(initData.audio, ElementaryStreamTypes.AUDIO);\n        }\n        if (initData.video) {\n            videoCodec = getParsedTrackCodec(initData.video, ElementaryStreamTypes.VIDEO);\n        }\n        const tracks = {};\n        if (initData.audio && initData.video) {\n            tracks.audiovideo = {\n                container: \"video/mp4\",\n                codec: audioCodec + \",\" + videoCodec,\n                initSegment,\n                id: \"main\"\n            };\n        } else if (initData.audio) {\n            tracks.audio = {\n                container: \"audio/mp4\",\n                codec: audioCodec,\n                initSegment,\n                id: \"audio\"\n            };\n        } else if (initData.video) {\n            tracks.video = {\n                container: \"video/mp4\",\n                codec: videoCodec,\n                initSegment,\n                id: \"main\"\n            };\n        } else {\n            logger.warn(\"[passthrough-remuxer.ts]: initSegment does not contain moov or trak boxes.\");\n        }\n        this.initTracks = tracks;\n    }\n    remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset) {\n        var _initData, _initData2;\n        let { initPTS, lastEndTime } = this;\n        const result = {\n            audio: undefined,\n            video: undefined,\n            text: textTrack,\n            id3: id3Track,\n            initSegment: undefined\n        };\n        // If we haven't yet set a lastEndDTS, or it was reset, set it to the provided timeOffset. We want to use the\n        // lastEndDTS over timeOffset whenever possible; during progressive playback, the media source will not update\n        // the media duration (which is what timeOffset is provided as) before we need to process the next chunk.\n        if (!isFiniteNumber(lastEndTime)) {\n            lastEndTime = this.lastEndTime = timeOffset || 0;\n        }\n        // The binary segment data is added to the videoTrack in the mp4demuxer. We don't check to see if the data is only\n        // audio or video (or both); adding it to video was an arbitrary choice.\n        const data = videoTrack.samples;\n        if (!(data != null && data.length)) {\n            return result;\n        }\n        const initSegment = {\n            initPTS: undefined,\n            timescale: 1\n        };\n        let initData = this.initData;\n        if (!((_initData = initData) != null && _initData.length)) {\n            this.generateInitSegment(data);\n            initData = this.initData;\n        }\n        if (!((_initData2 = initData) != null && _initData2.length)) {\n            // We can't remux if the initSegment could not be generated\n            logger.warn(\"[passthrough-remuxer.ts]: Failed to generate initSegment.\");\n            return result;\n        }\n        if (this.emitInitSegment) {\n            initSegment.tracks = this.initTracks;\n            this.emitInitSegment = false;\n        }\n        const duration = getDuration(data, initData);\n        const startDTS = getStartDTS(initData, data);\n        const decodeTime = startDTS === null ? timeOffset : startDTS;\n        if (isInvalidInitPts(initPTS, decodeTime, timeOffset, duration) || initSegment.timescale !== initPTS.timescale && accurateTimeOffset) {\n            initSegment.initPTS = decodeTime - timeOffset;\n            if (initPTS && initPTS.timescale === 1) {\n                logger.warn(`Adjusting initPTS by ${initSegment.initPTS - initPTS.baseTime}`);\n            }\n            this.initPTS = initPTS = {\n                baseTime: initSegment.initPTS,\n                timescale: 1\n            };\n        }\n        const startTime = audioTrack ? decodeTime - initPTS.baseTime / initPTS.timescale : lastEndTime;\n        const endTime = startTime + duration;\n        offsetStartDTS(initData, data, initPTS.baseTime / initPTS.timescale);\n        if (duration > 0) {\n            this.lastEndTime = endTime;\n        } else {\n            logger.warn(\"Duration parsed from mp4 should be greater than zero\");\n            this.resetNextTimestamp();\n        }\n        const hasAudio = !!initData.audio;\n        const hasVideo = !!initData.video;\n        let type = \"\";\n        if (hasAudio) {\n            type += \"audio\";\n        }\n        if (hasVideo) {\n            type += \"video\";\n        }\n        const track = {\n            data1: data,\n            startPTS: startTime,\n            startDTS: startTime,\n            endPTS: endTime,\n            endDTS: endTime,\n            type,\n            hasAudio,\n            hasVideo,\n            nb: 1,\n            dropped: 0\n        };\n        result.audio = track.type === \"audio\" ? track : undefined;\n        result.video = track.type !== \"audio\" ? track : undefined;\n        result.initSegment = initSegment;\n        result.id3 = flushTextTrackMetadataCueSamples(id3Track, timeOffset, initPTS, initPTS);\n        if (textTrack.samples.length) {\n            result.text = flushTextTrackUserdataCueSamples(textTrack, timeOffset, initPTS);\n        }\n        return result;\n    }\n}\nfunction isInvalidInitPts(initPTS, startDTS, timeOffset, duration) {\n    if (initPTS === null) {\n        return true;\n    }\n    // InitPTS is invalid when distance from program would be more than segment duration or a minimum of one second\n    const minDuration = Math.max(duration, 1);\n    const startTime = startDTS - initPTS.baseTime / initPTS.timescale;\n    return Math.abs(startTime - timeOffset) > minDuration;\n}\nfunction getParsedTrackCodec(track, type) {\n    const parsedCodec = track == null ? void 0 : track.codec;\n    if (parsedCodec && parsedCodec.length > 4) {\n        return parsedCodec;\n    }\n    if (type === ElementaryStreamTypes.AUDIO) {\n        if (parsedCodec === \"ec-3\" || parsedCodec === \"ac-3\" || parsedCodec === \"alac\") {\n            return parsedCodec;\n        }\n        if (parsedCodec === \"fLaC\" || parsedCodec === \"Opus\") {\n            // Opting not to get `preferManagedMediaSource` from player config for isSupported() check for simplicity\n            const preferManagedMediaSource = false;\n            return getCodecCompatibleName(parsedCodec, preferManagedMediaSource);\n        }\n        const result = \"mp4a.40.5\";\n        logger.info(`Parsed audio codec \"${parsedCodec}\" or audio object type not handled. Using \"${result}\"`);\n        return result;\n    }\n    // Provide defaults based on codec type\n    // This allows for some playback of some fmp4 playlists without CODECS defined in manifest\n    logger.warn(`Unhandled video codec \"${parsedCodec}\"`);\n    if (parsedCodec === \"hvc1\" || parsedCodec === \"hev1\") {\n        return \"hvc1.1.6.L120.90\";\n    }\n    if (parsedCodec === \"av01\") {\n        return \"av01.0.04M.08\";\n    }\n    return \"avc1.42e01e\";\n}\nlet now;\n// performance.now() not available on WebWorker, at least on Safari Desktop\ntry {\n    now = self.performance.now.bind(self.performance);\n} catch (err) {\n    logger.debug(\"Unable to use Performance API on this environment\");\n    now = optionalSelf == null ? void 0 : optionalSelf.Date.now;\n}\nconst muxConfig = [\n    {\n        demux: MP4Demuxer,\n        remux: PassThroughRemuxer\n    },\n    {\n        demux: TSDemuxer,\n        remux: MP4Remuxer\n    },\n    {\n        demux: AACDemuxer,\n        remux: MP4Remuxer\n    },\n    {\n        demux: MP3Demuxer,\n        remux: MP4Remuxer\n    }\n];\n{\n    muxConfig.splice(2, 0, {\n        demux: AC3Demuxer,\n        remux: MP4Remuxer\n    });\n}class Transmuxer {\n    constructor(observer, typeSupported, config, vendor, id){\n        this.async = false;\n        this.observer = void 0;\n        this.typeSupported = void 0;\n        this.config = void 0;\n        this.vendor = void 0;\n        this.id = void 0;\n        this.demuxer = void 0;\n        this.remuxer = void 0;\n        this.decrypter = void 0;\n        this.probe = void 0;\n        this.decryptionPromise = null;\n        this.transmuxConfig = void 0;\n        this.currentTransmuxState = void 0;\n        this.observer = observer;\n        this.typeSupported = typeSupported;\n        this.config = config;\n        this.vendor = vendor;\n        this.id = id;\n    }\n    configure(transmuxConfig) {\n        this.transmuxConfig = transmuxConfig;\n        if (this.decrypter) {\n            this.decrypter.reset();\n        }\n    }\n    push(data, decryptdata, chunkMeta, state) {\n        const stats = chunkMeta.transmuxing;\n        stats.executeStart = now();\n        let uintData = new Uint8Array(data);\n        const { currentTransmuxState, transmuxConfig } = this;\n        if (state) {\n            this.currentTransmuxState = state;\n        }\n        const { contiguous, discontinuity, trackSwitch, accurateTimeOffset, timeOffset, initSegmentChange } = state || currentTransmuxState;\n        const { audioCodec, videoCodec, defaultInitPts, duration, initSegmentData } = transmuxConfig;\n        const keyData = getEncryptionType(uintData, decryptdata);\n        if (keyData && keyData.method === \"AES-128\") {\n            const decrypter = this.getDecrypter();\n            // Software decryption is synchronous; webCrypto is not\n            if (decrypter.isSync()) {\n                // Software decryption is progressive. Progressive decryption may not return a result on each call. Any cached\n                // data is handled in the flush() call\n                let decryptedData = decrypter.softwareDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer);\n                // For Low-Latency HLS Parts, decrypt in place, since part parsing is expected on push progress\n                const loadingParts = chunkMeta.part > -1;\n                if (loadingParts) {\n                    decryptedData = decrypter.flush();\n                }\n                if (!decryptedData) {\n                    stats.executeEnd = now();\n                    return emptyResult(chunkMeta);\n                }\n                uintData = new Uint8Array(decryptedData);\n            } else {\n                this.decryptionPromise = decrypter.webCryptoDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer).then((decryptedData)=>{\n                    // Calling push here is important; if flush() is called while this is still resolving, this ensures that\n                    // the decrypted data has been transmuxed\n                    const result = this.push(decryptedData, null, chunkMeta);\n                    this.decryptionPromise = null;\n                    return result;\n                });\n                return this.decryptionPromise;\n            }\n        }\n        const resetMuxers = this.needsProbing(discontinuity, trackSwitch);\n        if (resetMuxers) {\n            const error = this.configureTransmuxer(uintData);\n            if (error) {\n                logger.warn(`[transmuxer] ${error.message}`);\n                this.observer.emit(Events.ERROR, Events.ERROR, {\n                    type: ErrorTypes.MEDIA_ERROR,\n                    details: ErrorDetails.FRAG_PARSING_ERROR,\n                    fatal: false,\n                    error,\n                    reason: error.message\n                });\n                stats.executeEnd = now();\n                return emptyResult(chunkMeta);\n            }\n        }\n        if (discontinuity || trackSwitch || initSegmentChange || resetMuxers) {\n            this.resetInitSegment(initSegmentData, audioCodec, videoCodec, duration, decryptdata);\n        }\n        if (discontinuity || initSegmentChange || resetMuxers) {\n            this.resetInitialTimestamp(defaultInitPts);\n        }\n        if (!contiguous) {\n            this.resetContiguity();\n        }\n        const result = this.transmux(uintData, keyData, timeOffset, accurateTimeOffset, chunkMeta);\n        const currentState = this.currentTransmuxState;\n        currentState.contiguous = true;\n        currentState.discontinuity = false;\n        currentState.trackSwitch = false;\n        stats.executeEnd = now();\n        return result;\n    }\n    // Due to data caching, flush calls can produce more than one TransmuxerResult (hence the Array type)\n    flush(chunkMeta) {\n        const stats = chunkMeta.transmuxing;\n        stats.executeStart = now();\n        const { decrypter, currentTransmuxState, decryptionPromise } = this;\n        if (decryptionPromise) {\n            // Upon resolution, the decryption promise calls push() and returns its TransmuxerResult up the stack. Therefore\n            // only flushing is required for async decryption\n            return decryptionPromise.then(()=>{\n                return this.flush(chunkMeta);\n            });\n        }\n        const transmuxResults = [];\n        const { timeOffset } = currentTransmuxState;\n        if (decrypter) {\n            // The decrypter may have data cached, which needs to be demuxed. In this case we'll have two TransmuxResults\n            // This happens in the case that we receive only 1 push call for a segment (either for non-progressive downloads,\n            // or for progressive downloads with small segments)\n            const decryptedData = decrypter.flush();\n            if (decryptedData) {\n                // Push always returns a TransmuxerResult if decryptdata is null\n                transmuxResults.push(this.push(decryptedData, null, chunkMeta));\n            }\n        }\n        const { demuxer, remuxer } = this;\n        if (!demuxer || !remuxer) {\n            // If probing failed, then Hls.js has been given content its not able to handle\n            stats.executeEnd = now();\n            return [\n                emptyResult(chunkMeta)\n            ];\n        }\n        const demuxResultOrPromise = demuxer.flush(timeOffset);\n        if (isPromise(demuxResultOrPromise)) {\n            // Decrypt final SAMPLE-AES samples\n            return demuxResultOrPromise.then((demuxResult)=>{\n                this.flushRemux(transmuxResults, demuxResult, chunkMeta);\n                return transmuxResults;\n            });\n        }\n        this.flushRemux(transmuxResults, demuxResultOrPromise, chunkMeta);\n        return transmuxResults;\n    }\n    flushRemux(transmuxResults, demuxResult, chunkMeta) {\n        const { audioTrack, videoTrack, id3Track, textTrack } = demuxResult;\n        const { accurateTimeOffset, timeOffset } = this.currentTransmuxState;\n        logger.log(`[transmuxer.ts]: Flushed fragment ${chunkMeta.sn}${chunkMeta.part > -1 ? \" p: \" + chunkMeta.part : \"\"} of level ${chunkMeta.level}`);\n        const remuxResult = this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, true, this.id);\n        transmuxResults.push({\n            remuxResult,\n            chunkMeta\n        });\n        chunkMeta.transmuxing.executeEnd = now();\n    }\n    resetInitialTimestamp(defaultInitPts) {\n        const { demuxer, remuxer } = this;\n        if (!demuxer || !remuxer) {\n            return;\n        }\n        demuxer.resetTimeStamp(defaultInitPts);\n        remuxer.resetTimeStamp(defaultInitPts);\n    }\n    resetContiguity() {\n        const { demuxer, remuxer } = this;\n        if (!demuxer || !remuxer) {\n            return;\n        }\n        demuxer.resetContiguity();\n        remuxer.resetNextTimestamp();\n    }\n    resetInitSegment(initSegmentData, audioCodec, videoCodec, trackDuration, decryptdata) {\n        const { demuxer, remuxer } = this;\n        if (!demuxer || !remuxer) {\n            return;\n        }\n        demuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec, trackDuration);\n        remuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec, decryptdata);\n    }\n    destroy() {\n        if (this.demuxer) {\n            this.demuxer.destroy();\n            this.demuxer = undefined;\n        }\n        if (this.remuxer) {\n            this.remuxer.destroy();\n            this.remuxer = undefined;\n        }\n    }\n    transmux(data, keyData, timeOffset, accurateTimeOffset, chunkMeta) {\n        let result;\n        if (keyData && keyData.method === \"SAMPLE-AES\") {\n            result = this.transmuxSampleAes(data, keyData, timeOffset, accurateTimeOffset, chunkMeta);\n        } else {\n            result = this.transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta);\n        }\n        return result;\n    }\n    transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta) {\n        const { audioTrack, videoTrack, id3Track, textTrack } = this.demuxer.demux(data, timeOffset, false, !this.config.progressive);\n        const remuxResult = this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, false, this.id);\n        return {\n            remuxResult,\n            chunkMeta\n        };\n    }\n    transmuxSampleAes(data, decryptData, timeOffset, accurateTimeOffset, chunkMeta) {\n        return this.demuxer.demuxSampleAes(data, decryptData, timeOffset).then((demuxResult)=>{\n            const remuxResult = this.remuxer.remux(demuxResult.audioTrack, demuxResult.videoTrack, demuxResult.id3Track, demuxResult.textTrack, timeOffset, accurateTimeOffset, false, this.id);\n            return {\n                remuxResult,\n                chunkMeta\n            };\n        });\n    }\n    configureTransmuxer(data) {\n        const { config, observer, typeSupported, vendor } = this;\n        // probe for content type\n        let mux;\n        for(let i = 0, len = muxConfig.length; i < len; i++){\n            var _muxConfig$i$demux;\n            if ((_muxConfig$i$demux = muxConfig[i].demux) != null && _muxConfig$i$demux.probe(data)) {\n                mux = muxConfig[i];\n                break;\n            }\n        }\n        if (!mux) {\n            return new Error(\"Failed to find demuxer by probing fragment data\");\n        }\n        // so let's check that current remuxer and demuxer are still valid\n        const demuxer = this.demuxer;\n        const remuxer = this.remuxer;\n        const Remuxer = mux.remux;\n        const Demuxer = mux.demux;\n        if (!remuxer || !(remuxer instanceof Remuxer)) {\n            this.remuxer = new Remuxer(observer, config, typeSupported, vendor);\n        }\n        if (!demuxer || !(demuxer instanceof Demuxer)) {\n            this.demuxer = new Demuxer(observer, config, typeSupported);\n            this.probe = Demuxer.probe;\n        }\n    }\n    needsProbing(discontinuity, trackSwitch) {\n        // in case of continuity change, or track switch\n        // we might switch from content type (AAC container to TS container, or TS to fmp4 for example)\n        return !this.demuxer || !this.remuxer || discontinuity || trackSwitch;\n    }\n    getDecrypter() {\n        let decrypter = this.decrypter;\n        if (!decrypter) {\n            decrypter = this.decrypter = new Decrypter(this.config);\n        }\n        return decrypter;\n    }\n}\nfunction getEncryptionType(data, decryptData) {\n    let encryptionType = null;\n    if (data.byteLength > 0 && (decryptData == null ? void 0 : decryptData.key) != null && decryptData.iv !== null && decryptData.method != null) {\n        encryptionType = decryptData;\n    }\n    return encryptionType;\n}\nconst emptyResult = (chunkMeta)=>({\n        remuxResult: {},\n        chunkMeta\n    });\nfunction isPromise(p) {\n    return \"then\" in p && p.then instanceof Function;\n}\nclass TransmuxConfig {\n    constructor(audioCodec, videoCodec, initSegmentData, duration, defaultInitPts){\n        this.audioCodec = void 0;\n        this.videoCodec = void 0;\n        this.initSegmentData = void 0;\n        this.duration = void 0;\n        this.defaultInitPts = void 0;\n        this.audioCodec = audioCodec;\n        this.videoCodec = videoCodec;\n        this.initSegmentData = initSegmentData;\n        this.duration = duration;\n        this.defaultInitPts = defaultInitPts || null;\n    }\n}\nclass TransmuxState {\n    constructor(discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange){\n        this.discontinuity = void 0;\n        this.contiguous = void 0;\n        this.accurateTimeOffset = void 0;\n        this.trackSwitch = void 0;\n        this.timeOffset = void 0;\n        this.initSegmentChange = void 0;\n        this.discontinuity = discontinuity;\n        this.contiguous = contiguous;\n        this.accurateTimeOffset = accurateTimeOffset;\n        this.trackSwitch = trackSwitch;\n        this.timeOffset = timeOffset;\n        this.initSegmentChange = initSegmentChange;\n    }\n}\nvar eventemitter3 = {\n    exports: {}\n};\n(function(module) {\n    var has = Object.prototype.hasOwnProperty, prefix = \"~\";\n    /**\n\t * Constructor to create a storage for our `EE` objects.\n\t * An `Events` instance is a plain object whose properties are event names.\n\t *\n\t * @constructor\n\t * @private\n\t */ function Events() {}\n    //\n    // We try to not inherit from `Object.prototype`. In some engines creating an\n    // instance in this way is faster than calling `Object.create(null)` directly.\n    // If `Object.create(null)` is not supported we prefix the event names with a\n    // character to make sure that the built-in object properties are not\n    // overridden or used as an attack vector.\n    //\n    if (Object.create) {\n        Events.prototype = Object.create(null);\n        //\n        // This hack is needed because the `__proto__` property is still inherited in\n        // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n        //\n        if (!new Events().__proto__) prefix = false;\n    }\n    /**\n\t * Representation of a single event listener.\n\t *\n\t * @param {Function} fn The listener function.\n\t * @param {*} context The context to invoke the listener with.\n\t * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n\t * @constructor\n\t * @private\n\t */ function EE(fn, context, once) {\n        this.fn = fn;\n        this.context = context;\n        this.once = once || false;\n    }\n    /**\n\t * Add a listener for a given event.\n\t *\n\t * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n\t * @param {(String|Symbol)} event The event name.\n\t * @param {Function} fn The listener function.\n\t * @param {*} context The context to invoke the listener with.\n\t * @param {Boolean} once Specify if the listener is a one-time listener.\n\t * @returns {EventEmitter}\n\t * @private\n\t */ function addListener(emitter, event, fn, context, once) {\n        if (typeof fn !== \"function\") {\n            throw new TypeError(\"The listener must be a function\");\n        }\n        var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;\n        if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n        else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n        else emitter._events[evt] = [\n            emitter._events[evt],\n            listener\n        ];\n        return emitter;\n    }\n    /**\n\t * Clear event by name.\n\t *\n\t * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n\t * @param {(String|Symbol)} evt The Event name.\n\t * @private\n\t */ function clearEvent(emitter, evt) {\n        if (--emitter._eventsCount === 0) emitter._events = new Events();\n        else delete emitter._events[evt];\n    }\n    /**\n\t * Minimal `EventEmitter` interface that is molded against the Node.js\n\t * `EventEmitter` interface.\n\t *\n\t * @constructor\n\t * @public\n\t */ function EventEmitter() {\n        this._events = new Events();\n        this._eventsCount = 0;\n    }\n    /**\n\t * Return an array listing the events for which the emitter has registered\n\t * listeners.\n\t *\n\t * @returns {Array}\n\t * @public\n\t */ EventEmitter.prototype.eventNames = function eventNames() {\n        var names = [], events, name;\n        if (this._eventsCount === 0) return names;\n        for(name in events = this._events){\n            if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n        }\n        if (Object.getOwnPropertySymbols) {\n            return names.concat(Object.getOwnPropertySymbols(events));\n        }\n        return names;\n    };\n    /**\n\t * Return the listeners registered for a given event.\n\t *\n\t * @param {(String|Symbol)} event The event name.\n\t * @returns {Array} The registered listeners.\n\t * @public\n\t */ EventEmitter.prototype.listeners = function listeners(event) {\n        var evt = prefix ? prefix + event : event, handlers = this._events[evt];\n        if (!handlers) return [];\n        if (handlers.fn) return [\n            handlers.fn\n        ];\n        for(var i = 0, l = handlers.length, ee = new Array(l); i < l; i++){\n            ee[i] = handlers[i].fn;\n        }\n        return ee;\n    };\n    /**\n\t * Return the number of listeners listening to a given event.\n\t *\n\t * @param {(String|Symbol)} event The event name.\n\t * @returns {Number} The number of listeners.\n\t * @public\n\t */ EventEmitter.prototype.listenerCount = function listenerCount(event) {\n        var evt = prefix ? prefix + event : event, listeners = this._events[evt];\n        if (!listeners) return 0;\n        if (listeners.fn) return 1;\n        return listeners.length;\n    };\n    /**\n\t * Calls each of the listeners registered for a given event.\n\t *\n\t * @param {(String|Symbol)} event The event name.\n\t * @returns {Boolean} `true` if the event had listeners, else `false`.\n\t * @public\n\t */ EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n        var evt = prefix ? prefix + event : event;\n        if (!this._events[evt]) return false;\n        var listeners = this._events[evt], len = arguments.length, args, i;\n        if (listeners.fn) {\n            if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n            switch(len){\n                case 1:\n                    return listeners.fn.call(listeners.context), true;\n                case 2:\n                    return listeners.fn.call(listeners.context, a1), true;\n                case 3:\n                    return listeners.fn.call(listeners.context, a1, a2), true;\n                case 4:\n                    return listeners.fn.call(listeners.context, a1, a2, a3), true;\n                case 5:\n                    return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n                case 6:\n                    return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n            }\n            for(i = 1, args = new Array(len - 1); i < len; i++){\n                args[i - 1] = arguments[i];\n            }\n            listeners.fn.apply(listeners.context, args);\n        } else {\n            var length = listeners.length, j;\n            for(i = 0; i < length; i++){\n                if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n                switch(len){\n                    case 1:\n                        listeners[i].fn.call(listeners[i].context);\n                        break;\n                    case 2:\n                        listeners[i].fn.call(listeners[i].context, a1);\n                        break;\n                    case 3:\n                        listeners[i].fn.call(listeners[i].context, a1, a2);\n                        break;\n                    case 4:\n                        listeners[i].fn.call(listeners[i].context, a1, a2, a3);\n                        break;\n                    default:\n                        if (!args) for(j = 1, args = new Array(len - 1); j < len; j++){\n                            args[j - 1] = arguments[j];\n                        }\n                        listeners[i].fn.apply(listeners[i].context, args);\n                }\n            }\n        }\n        return true;\n    };\n    /**\n\t * Add a listener for a given event.\n\t *\n\t * @param {(String|Symbol)} event The event name.\n\t * @param {Function} fn The listener function.\n\t * @param {*} [context=this] The context to invoke the listener with.\n\t * @returns {EventEmitter} `this`.\n\t * @public\n\t */ EventEmitter.prototype.on = function on(event, fn, context) {\n        return addListener(this, event, fn, context, false);\n    };\n    /**\n\t * Add a one-time listener for a given event.\n\t *\n\t * @param {(String|Symbol)} event The event name.\n\t * @param {Function} fn The listener function.\n\t * @param {*} [context=this] The context to invoke the listener with.\n\t * @returns {EventEmitter} `this`.\n\t * @public\n\t */ EventEmitter.prototype.once = function once(event, fn, context) {\n        return addListener(this, event, fn, context, true);\n    };\n    /**\n\t * Remove the listeners of a given event.\n\t *\n\t * @param {(String|Symbol)} event The event name.\n\t * @param {Function} fn Only remove the listeners that match this function.\n\t * @param {*} context Only remove the listeners that have this context.\n\t * @param {Boolean} once Only remove one-time listeners.\n\t * @returns {EventEmitter} `this`.\n\t * @public\n\t */ EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n        var evt = prefix ? prefix + event : event;\n        if (!this._events[evt]) return this;\n        if (!fn) {\n            clearEvent(this, evt);\n            return this;\n        }\n        var listeners = this._events[evt];\n        if (listeners.fn) {\n            if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {\n                clearEvent(this, evt);\n            }\n        } else {\n            for(var i = 0, events = [], length = listeners.length; i < length; i++){\n                if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {\n                    events.push(listeners[i]);\n                }\n            }\n            //\n            // Reset the array, or remove it completely if we have no more listeners.\n            //\n            if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n            else clearEvent(this, evt);\n        }\n        return this;\n    };\n    /**\n\t * Remove all listeners, or those of the specified event.\n\t *\n\t * @param {(String|Symbol)} [event] The event name.\n\t * @returns {EventEmitter} `this`.\n\t * @public\n\t */ EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n        var evt;\n        if (event) {\n            evt = prefix ? prefix + event : event;\n            if (this._events[evt]) clearEvent(this, evt);\n        } else {\n            this._events = new Events();\n            this._eventsCount = 0;\n        }\n        return this;\n    };\n    //\n    // Alias methods names because people roll like that.\n    //\n    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n    EventEmitter.prototype.addListener = EventEmitter.prototype.on;\n    //\n    // Expose the prefix.\n    //\n    EventEmitter.prefixed = prefix;\n    //\n    // Allow `EventEmitter` to be imported as module namespace.\n    //\n    EventEmitter.EventEmitter = EventEmitter;\n    //\n    // Expose the module.\n    //\n    {\n        module.exports = EventEmitter;\n    }\n})(eventemitter3);\nvar eventemitter3Exports = eventemitter3.exports;\nvar EventEmitter = /*@__PURE__*/ getDefaultExportFromCjs(eventemitter3Exports);\nclass TransmuxerInterface {\n    constructor(hls, id, onTransmuxComplete, onFlush){\n        this.error = null;\n        this.hls = void 0;\n        this.id = void 0;\n        this.observer = void 0;\n        this.frag = null;\n        this.part = null;\n        this.useWorker = void 0;\n        this.workerContext = null;\n        this.onwmsg = void 0;\n        this.transmuxer = null;\n        this.onTransmuxComplete = void 0;\n        this.onFlush = void 0;\n        const config = hls.config;\n        this.hls = hls;\n        this.id = id;\n        this.useWorker = !!config.enableWorker;\n        this.onTransmuxComplete = onTransmuxComplete;\n        this.onFlush = onFlush;\n        const forwardMessage = (ev, data)=>{\n            data = data || {};\n            data.frag = this.frag;\n            data.id = this.id;\n            if (ev === Events.ERROR) {\n                this.error = data.error;\n            }\n            this.hls.trigger(ev, data);\n        };\n        // forward events to main thread\n        this.observer = new EventEmitter();\n        this.observer.on(Events.FRAG_DECRYPTED, forwardMessage);\n        this.observer.on(Events.ERROR, forwardMessage);\n        const MediaSource = getMediaSource(config.preferManagedMediaSource) || {\n            isTypeSupported: ()=>false\n        };\n        const m2tsTypeSupported = {\n            mpeg: MediaSource.isTypeSupported(\"audio/mpeg\"),\n            mp3: MediaSource.isTypeSupported('audio/mp4; codecs=\"mp3\"'),\n            ac3: MediaSource.isTypeSupported('audio/mp4; codecs=\"ac-3\"')\n        };\n        // navigator.vendor is not always available in Web Worker\n        // refer to https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope/navigator\n        const vendor = navigator.vendor;\n        if (this.useWorker && typeof Worker !== \"undefined\") {\n            const canCreateWorker = config.workerPath || hasUMDWorker();\n            if (canCreateWorker) {\n                try {\n                    if (config.workerPath) {\n                        logger.log(`loading Web Worker ${config.workerPath} for \"${id}\"`);\n                        this.workerContext = loadWorker(config.workerPath);\n                    } else {\n                        logger.log(`injecting Web Worker for \"${id}\"`);\n                        this.workerContext = injectWorker();\n                    }\n                    this.onwmsg = (ev)=>this.onWorkerMessage(ev);\n                    const { worker } = this.workerContext;\n                    worker.addEventListener(\"message\", this.onwmsg);\n                    worker.onerror = (event)=>{\n                        const error = new Error(`${event.message}  (${event.filename}:${event.lineno})`);\n                        config.enableWorker = false;\n                        logger.warn(`Error in \"${id}\" Web Worker, fallback to inline`);\n                        this.hls.trigger(Events.ERROR, {\n                            type: ErrorTypes.OTHER_ERROR,\n                            details: ErrorDetails.INTERNAL_EXCEPTION,\n                            fatal: false,\n                            event: \"demuxerWorker\",\n                            error\n                        });\n                    };\n                    worker.postMessage({\n                        cmd: \"init\",\n                        typeSupported: m2tsTypeSupported,\n                        vendor: vendor,\n                        id: id,\n                        config: JSON.stringify(config)\n                    });\n                } catch (err) {\n                    logger.warn(`Error setting up \"${id}\" Web Worker, fallback to inline`, err);\n                    this.resetWorker();\n                    this.error = null;\n                    this.transmuxer = new Transmuxer(this.observer, m2tsTypeSupported, config, vendor, id);\n                }\n                return;\n            }\n        }\n        this.transmuxer = new Transmuxer(this.observer, m2tsTypeSupported, config, vendor, id);\n    }\n    resetWorker() {\n        if (this.workerContext) {\n            const { worker, objectURL } = this.workerContext;\n            if (objectURL) {\n                // revoke the Object URL that was used to create transmuxer worker, so as not to leak it\n                self.URL.revokeObjectURL(objectURL);\n            }\n            worker.removeEventListener(\"message\", this.onwmsg);\n            worker.onerror = null;\n            worker.terminate();\n            this.workerContext = null;\n        }\n    }\n    destroy() {\n        if (this.workerContext) {\n            this.resetWorker();\n            this.onwmsg = undefined;\n        } else {\n            const transmuxer = this.transmuxer;\n            if (transmuxer) {\n                transmuxer.destroy();\n                this.transmuxer = null;\n            }\n        }\n        const observer = this.observer;\n        if (observer) {\n            observer.removeAllListeners();\n        }\n        this.frag = null;\n        // @ts-ignore\n        this.observer = null;\n        // @ts-ignore\n        this.hls = null;\n    }\n    push(data, initSegmentData, audioCodec, videoCodec, frag, part, duration, accurateTimeOffset, chunkMeta, defaultInitPTS) {\n        var _frag$initSegment, _lastFrag$initSegment;\n        chunkMeta.transmuxing.start = self.performance.now();\n        const { transmuxer } = this;\n        const timeOffset = part ? part.start : frag.start;\n        // TODO: push \"clear-lead\" decrypt data for unencrypted fragments in streams with encrypted ones\n        const decryptdata = frag.decryptdata;\n        const lastFrag = this.frag;\n        const discontinuity = !(lastFrag && frag.cc === lastFrag.cc);\n        const trackSwitch = !(lastFrag && chunkMeta.level === lastFrag.level);\n        const snDiff = lastFrag ? chunkMeta.sn - lastFrag.sn : -1;\n        const partDiff = this.part ? chunkMeta.part - this.part.index : -1;\n        const progressive = snDiff === 0 && chunkMeta.id > 1 && chunkMeta.id === (lastFrag == null ? void 0 : lastFrag.stats.chunkCount);\n        const contiguous = !trackSwitch && (snDiff === 1 || snDiff === 0 && (partDiff === 1 || progressive && partDiff <= 0));\n        const now = self.performance.now();\n        if (trackSwitch || snDiff || frag.stats.parsing.start === 0) {\n            frag.stats.parsing.start = now;\n        }\n        if (part && (partDiff || !contiguous)) {\n            part.stats.parsing.start = now;\n        }\n        const initSegmentChange = !(lastFrag && ((_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.url) === ((_lastFrag$initSegment = lastFrag.initSegment) == null ? void 0 : _lastFrag$initSegment.url));\n        const state = new TransmuxState(discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange);\n        if (!contiguous || discontinuity || initSegmentChange) {\n            logger.log(`[transmuxer-interface, ${frag.type}]: Starting new transmux session for sn: ${chunkMeta.sn} p: ${chunkMeta.part} level: ${chunkMeta.level} id: ${chunkMeta.id}\n        discontinuity: ${discontinuity}\n        trackSwitch: ${trackSwitch}\n        contiguous: ${contiguous}\n        accurateTimeOffset: ${accurateTimeOffset}\n        timeOffset: ${timeOffset}\n        initSegmentChange: ${initSegmentChange}`);\n            const config = new TransmuxConfig(audioCodec, videoCodec, initSegmentData, duration, defaultInitPTS);\n            this.configureTransmuxer(config);\n        }\n        this.frag = frag;\n        this.part = part;\n        // Frags with sn of 'initSegment' are not transmuxed\n        if (this.workerContext) {\n            // post fragment payload as transferable objects for ArrayBuffer (no copy)\n            this.workerContext.worker.postMessage({\n                cmd: \"demux\",\n                data,\n                decryptdata,\n                chunkMeta,\n                state\n            }, data instanceof ArrayBuffer ? [\n                data\n            ] : []);\n        } else if (transmuxer) {\n            const transmuxResult = transmuxer.push(data, decryptdata, chunkMeta, state);\n            if (isPromise(transmuxResult)) {\n                transmuxer.async = true;\n                transmuxResult.then((data)=>{\n                    this.handleTransmuxComplete(data);\n                }).catch((error)=>{\n                    this.transmuxerError(error, chunkMeta, \"transmuxer-interface push error\");\n                });\n            } else {\n                transmuxer.async = false;\n                this.handleTransmuxComplete(transmuxResult);\n            }\n        }\n    }\n    flush(chunkMeta) {\n        chunkMeta.transmuxing.start = self.performance.now();\n        const { transmuxer } = this;\n        if (this.workerContext) {\n            this.workerContext.worker.postMessage({\n                cmd: \"flush\",\n                chunkMeta\n            });\n        } else if (transmuxer) {\n            let transmuxResult = transmuxer.flush(chunkMeta);\n            const asyncFlush = isPromise(transmuxResult);\n            if (asyncFlush || transmuxer.async) {\n                if (!isPromise(transmuxResult)) {\n                    transmuxResult = Promise.resolve(transmuxResult);\n                }\n                transmuxResult.then((data)=>{\n                    this.handleFlushResult(data, chunkMeta);\n                }).catch((error)=>{\n                    this.transmuxerError(error, chunkMeta, \"transmuxer-interface flush error\");\n                });\n            } else {\n                this.handleFlushResult(transmuxResult, chunkMeta);\n            }\n        }\n    }\n    transmuxerError(error, chunkMeta, reason) {\n        if (!this.hls) {\n            return;\n        }\n        this.error = error;\n        this.hls.trigger(Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.FRAG_PARSING_ERROR,\n            chunkMeta,\n            fatal: false,\n            error,\n            err: error,\n            reason\n        });\n    }\n    handleFlushResult(results, chunkMeta) {\n        results.forEach((result)=>{\n            this.handleTransmuxComplete(result);\n        });\n        this.onFlush(chunkMeta);\n    }\n    onWorkerMessage(ev) {\n        const data = ev.data;\n        const hls = this.hls;\n        switch(data.event){\n            case \"init\":\n                {\n                    var _this$workerContext;\n                    const objectURL = (_this$workerContext = this.workerContext) == null ? void 0 : _this$workerContext.objectURL;\n                    if (objectURL) {\n                        // revoke the Object URL that was used to create transmuxer worker, so as not to leak it\n                        self.URL.revokeObjectURL(objectURL);\n                    }\n                    break;\n                }\n            case \"transmuxComplete\":\n                {\n                    this.handleTransmuxComplete(data.data);\n                    break;\n                }\n            case \"flush\":\n                {\n                    this.onFlush(data.data);\n                    break;\n                }\n            // pass logs from the worker thread to the main logger\n            case \"workerLog\":\n                if (logger[data.data.logType]) {\n                    logger[data.data.logType](data.data.message);\n                }\n                break;\n            default:\n                {\n                    data.data = data.data || {};\n                    data.data.frag = this.frag;\n                    data.data.id = this.id;\n                    hls.trigger(data.event, data.data);\n                    break;\n                }\n        }\n    }\n    configureTransmuxer(config) {\n        const { transmuxer } = this;\n        if (this.workerContext) {\n            this.workerContext.worker.postMessage({\n                cmd: \"configure\",\n                config\n            });\n        } else if (transmuxer) {\n            transmuxer.configure(config);\n        }\n    }\n    handleTransmuxComplete(result) {\n        result.chunkMeta.transmuxing.end = self.performance.now();\n        this.onTransmuxComplete(result);\n    }\n}\nfunction subtitleOptionsIdentical(trackList1, trackList2) {\n    if (trackList1.length !== trackList2.length) {\n        return false;\n    }\n    for(let i = 0; i < trackList1.length; i++){\n        if (!mediaAttributesIdentical(trackList1[i].attrs, trackList2[i].attrs)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction mediaAttributesIdentical(attrs1, attrs2, customAttributes) {\n    // Media options with the same rendition ID must be bit identical\n    const stableRenditionId = attrs1[\"STABLE-RENDITION-ID\"];\n    if (stableRenditionId && !customAttributes) {\n        return stableRenditionId === attrs2[\"STABLE-RENDITION-ID\"];\n    }\n    // When rendition ID is not present, compare attributes\n    return !(customAttributes || [\n        \"LANGUAGE\",\n        \"NAME\",\n        \"CHARACTERISTICS\",\n        \"AUTOSELECT\",\n        \"DEFAULT\",\n        \"FORCED\",\n        \"ASSOC-LANGUAGE\"\n    ]).some((subtitleAttribute)=>attrs1[subtitleAttribute] !== attrs2[subtitleAttribute]);\n}\nfunction subtitleTrackMatchesTextTrack(subtitleTrack, textTrack) {\n    return textTrack.label.toLowerCase() === subtitleTrack.name.toLowerCase() && (!textTrack.language || textTrack.language.toLowerCase() === (subtitleTrack.lang || \"\").toLowerCase());\n}\nconst TICK_INTERVAL$2 = 100; // how often to tick in ms\nclass AudioStreamController extends BaseStreamController {\n    constructor(hls, fragmentTracker, keyLoader){\n        super(hls, fragmentTracker, keyLoader, \"[audio-stream-controller]\", PlaylistLevelType.AUDIO);\n        this.videoBuffer = null;\n        this.videoTrackCC = -1;\n        this.waitingVideoCC = -1;\n        this.bufferedTrack = null;\n        this.switchingTrack = null;\n        this.trackId = -1;\n        this.waitingData = null;\n        this.mainDetails = null;\n        this.flushing = false;\n        this.bufferFlushed = false;\n        this.cachedTrackLoadedData = null;\n        this._registerListeners();\n    }\n    onHandlerDestroying() {\n        this._unregisterListeners();\n        super.onHandlerDestroying();\n        this.mainDetails = null;\n        this.bufferedTrack = null;\n        this.switchingTrack = null;\n    }\n    _registerListeners() {\n        const { hls } = this;\n        hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n        hls.on(Events.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this);\n        hls.on(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n        hls.on(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);\n        hls.on(Events.ERROR, this.onError, this);\n        hls.on(Events.BUFFER_RESET, this.onBufferReset, this);\n        hls.on(Events.BUFFER_CREATED, this.onBufferCreated, this);\n        hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n        hls.on(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n        hls.on(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);\n        hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    }\n    _unregisterListeners() {\n        const { hls } = this;\n        hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n        hls.off(Events.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this);\n        hls.off(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n        hls.off(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);\n        hls.off(Events.ERROR, this.onError, this);\n        hls.off(Events.BUFFER_RESET, this.onBufferReset, this);\n        hls.off(Events.BUFFER_CREATED, this.onBufferCreated, this);\n        hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n        hls.off(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n        hls.off(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);\n        hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    }\n    // INIT_PTS_FOUND is triggered when the video track parsed in the stream-controller has a new PTS value\n    onInitPtsFound(event, { frag, id, initPTS, timescale }) {\n        // Always update the new INIT PTS\n        // Can change due level switch\n        if (id === \"main\") {\n            const cc = frag.cc;\n            this.initPTS[frag.cc] = {\n                baseTime: initPTS,\n                timescale\n            };\n            this.log(`InitPTS for cc: ${cc} found from main: ${initPTS}`);\n            this.videoTrackCC = cc;\n            // If we are waiting, tick immediately to unblock audio fragment transmuxing\n            if (this.state === State.WAITING_INIT_PTS) {\n                this.tick();\n            }\n        }\n    }\n    startLoad(startPosition) {\n        if (!this.levels) {\n            this.startPosition = startPosition;\n            this.state = State.STOPPED;\n            return;\n        }\n        const lastCurrentTime = this.lastCurrentTime;\n        this.stopLoad();\n        this.setInterval(TICK_INTERVAL$2);\n        if (lastCurrentTime > 0 && startPosition === -1) {\n            this.log(`Override startPosition with lastCurrentTime @${lastCurrentTime.toFixed(3)}`);\n            startPosition = lastCurrentTime;\n            this.state = State.IDLE;\n        } else {\n            this.loadedmetadata = false;\n            this.state = State.WAITING_TRACK;\n        }\n        this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;\n        this.tick();\n    }\n    doTick() {\n        switch(this.state){\n            case State.IDLE:\n                this.doTickIdle();\n                break;\n            case State.WAITING_TRACK:\n                {\n                    var _levels$trackId;\n                    const { levels, trackId } = this;\n                    const details = levels == null ? void 0 : (_levels$trackId = levels[trackId]) == null ? void 0 : _levels$trackId.details;\n                    if (details) {\n                        if (this.waitForCdnTuneIn(details)) {\n                            break;\n                        }\n                        this.state = State.WAITING_INIT_PTS;\n                    }\n                    break;\n                }\n            case State.FRAG_LOADING_WAITING_RETRY:\n                {\n                    var _this$media;\n                    const now = performance.now();\n                    const retryDate = this.retryDate;\n                    // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading\n                    if (!retryDate || now >= retryDate || (_this$media = this.media) != null && _this$media.seeking) {\n                        const { levels, trackId } = this;\n                        this.log(\"RetryDate reached, switch back to IDLE state\");\n                        this.resetStartWhenNotLoaded((levels == null ? void 0 : levels[trackId]) || null);\n                        this.state = State.IDLE;\n                    }\n                    break;\n                }\n            case State.WAITING_INIT_PTS:\n                {\n                    // Ensure we don't get stuck in the WAITING_INIT_PTS state if the waiting frag CC doesn't match any initPTS\n                    const waitingData = this.waitingData;\n                    if (waitingData) {\n                        const { frag, part, cache, complete } = waitingData;\n                        if (this.initPTS[frag.cc] !== undefined) {\n                            this.waitingData = null;\n                            this.waitingVideoCC = -1;\n                            this.state = State.FRAG_LOADING;\n                            const payload = cache.flush();\n                            const data = {\n                                frag,\n                                part,\n                                payload,\n                                networkDetails: null\n                            };\n                            this._handleFragmentLoadProgress(data);\n                            if (complete) {\n                                super._handleFragmentLoadComplete(data);\n                            }\n                        } else if (this.videoTrackCC !== this.waitingVideoCC) {\n                            // Drop waiting fragment if videoTrackCC has changed since waitingFragment was set and initPTS was not found\n                            this.log(`Waiting fragment cc (${frag.cc}) cancelled because video is at cc ${this.videoTrackCC}`);\n                            this.clearWaitingFragment();\n                        } else {\n                            // Drop waiting fragment if an earlier fragment is needed\n                            const pos = this.getLoadPosition();\n                            const bufferInfo = BufferHelper.bufferInfo(this.mediaBuffer, pos, this.config.maxBufferHole);\n                            const waitingFragmentAtPosition = fragmentWithinToleranceTest(bufferInfo.end, this.config.maxFragLookUpTolerance, frag);\n                            if (waitingFragmentAtPosition < 0) {\n                                this.log(`Waiting fragment cc (${frag.cc}) @ ${frag.start} cancelled because another fragment at ${bufferInfo.end} is needed`);\n                                this.clearWaitingFragment();\n                            }\n                        }\n                    } else {\n                        this.state = State.IDLE;\n                    }\n                }\n        }\n        this.onTickEnd();\n    }\n    clearWaitingFragment() {\n        const waitingData = this.waitingData;\n        if (waitingData) {\n            this.fragmentTracker.removeFragment(waitingData.frag);\n            this.waitingData = null;\n            this.waitingVideoCC = -1;\n            this.state = State.IDLE;\n        }\n    }\n    resetLoadingState() {\n        this.clearWaitingFragment();\n        super.resetLoadingState();\n    }\n    onTickEnd() {\n        const { media } = this;\n        if (!(media != null && media.readyState)) {\n            // Exit early if we don't have media or if the media hasn't buffered anything yet (readyState 0)\n            return;\n        }\n        this.lastCurrentTime = media.currentTime;\n    }\n    doTickIdle() {\n        const { hls, levels, media, trackId } = this;\n        const config = hls.config;\n        // 1. if video not attached AND\n        //    start fragment already requested OR start frag prefetch not enabled\n        // 2. if tracks or track not loaded and selected\n        // then exit loop\n        // => if media not attached but start frag prefetch is enabled and start frag not requested yet, we will not exit loop\n        if (!media && (this.startFragRequested || !config.startFragPrefetch) || !(levels != null && levels[trackId])) {\n            return;\n        }\n        const levelInfo = levels[trackId];\n        const trackDetails = levelInfo.details;\n        if (!trackDetails || trackDetails.live && this.levelLastLoaded !== levelInfo || this.waitForCdnTuneIn(trackDetails)) {\n            this.state = State.WAITING_TRACK;\n            return;\n        }\n        const bufferable = this.mediaBuffer ? this.mediaBuffer : this.media;\n        if (this.bufferFlushed && bufferable) {\n            this.bufferFlushed = false;\n            this.afterBufferFlushed(bufferable, ElementaryStreamTypes.AUDIO, PlaylistLevelType.AUDIO);\n        }\n        const bufferInfo = this.getFwdBufferInfo(bufferable, PlaylistLevelType.AUDIO);\n        if (bufferInfo === null) {\n            return;\n        }\n        const { bufferedTrack, switchingTrack } = this;\n        if (!switchingTrack && this._streamEnded(bufferInfo, trackDetails)) {\n            hls.trigger(Events.BUFFER_EOS, {\n                type: \"audio\"\n            });\n            this.state = State.ENDED;\n            return;\n        }\n        const mainBufferInfo = this.getFwdBufferInfo(this.videoBuffer ? this.videoBuffer : this.media, PlaylistLevelType.MAIN);\n        const bufferLen = bufferInfo.len;\n        const maxBufLen = this.getMaxBufferLength(mainBufferInfo == null ? void 0 : mainBufferInfo.len);\n        const fragments = trackDetails.fragments;\n        const start = fragments[0].start;\n        let targetBufferTime = this.flushing ? this.getLoadPosition() : bufferInfo.end;\n        if (switchingTrack && media) {\n            const pos = this.getLoadPosition();\n            // STABLE\n            if (bufferedTrack && !mediaAttributesIdentical(switchingTrack.attrs, bufferedTrack.attrs)) {\n                targetBufferTime = pos;\n            }\n            // if currentTime (pos) is less than alt audio playlist start time, it means that alt audio is ahead of currentTime\n            if (trackDetails.PTSKnown && pos < start) {\n                // if everything is buffered from pos to start or if audio buffer upfront, let's seek to start\n                if (bufferInfo.end > start || bufferInfo.nextStart) {\n                    this.log(\"Alt audio track ahead of main track, seek to start of alt audio track\");\n                    media.currentTime = start + 0.05;\n                }\n            }\n        }\n        // if buffer length is less than maxBufLen, or near the end, find a fragment to load\n        if (bufferLen >= maxBufLen && !switchingTrack && targetBufferTime < fragments[fragments.length - 1].start) {\n            return;\n        }\n        let frag = this.getNextFragment(targetBufferTime, trackDetails);\n        let atGap = false;\n        // Avoid loop loading by using nextLoadPosition set for backtracking and skipping consecutive GAP tags\n        if (frag && this.isLoopLoading(frag, targetBufferTime)) {\n            atGap = !!frag.gap;\n            frag = this.getNextFragmentLoopLoading(frag, trackDetails, bufferInfo, PlaylistLevelType.MAIN, maxBufLen);\n        }\n        if (!frag) {\n            this.bufferFlushed = true;\n            return;\n        }\n        // Buffer audio up to one target duration ahead of main buffer\n        const atBufferSyncLimit = mainBufferInfo && frag.start > mainBufferInfo.end + trackDetails.targetduration;\n        if (atBufferSyncLimit || // Or wait for main buffer after buffing some audio\n        !(mainBufferInfo != null && mainBufferInfo.len) && bufferInfo.len) {\n            // Check fragment-tracker for main fragments since GAP segments do not show up in bufferInfo\n            const mainFrag = this.getAppendedFrag(frag.start, PlaylistLevelType.MAIN);\n            if (mainFrag === null) {\n                return;\n            }\n            // Bridge gaps in main buffer\n            atGap || (atGap = !!mainFrag.gap || !!atBufferSyncLimit && mainBufferInfo.len === 0);\n            if (atBufferSyncLimit && !atGap || atGap && bufferInfo.nextStart && bufferInfo.nextStart < mainFrag.end) {\n                return;\n            }\n        }\n        this.loadFragment(frag, levelInfo, targetBufferTime);\n    }\n    getMaxBufferLength(mainBufferLength) {\n        const maxConfigBuffer = super.getMaxBufferLength();\n        if (!mainBufferLength) {\n            return maxConfigBuffer;\n        }\n        return Math.min(Math.max(maxConfigBuffer, mainBufferLength), this.config.maxMaxBufferLength);\n    }\n    onMediaDetaching() {\n        this.videoBuffer = null;\n        this.bufferFlushed = this.flushing = false;\n        super.onMediaDetaching();\n    }\n    onAudioTracksUpdated(event, { audioTracks }) {\n        // Reset tranxmuxer is essential for large context switches (Content Steering)\n        this.resetTransmuxer();\n        this.levels = audioTracks.map((mediaPlaylist)=>new Level(mediaPlaylist));\n    }\n    onAudioTrackSwitching(event, data) {\n        // if any URL found on new audio track, it is an alternate audio track\n        const altAudio = !!data.url;\n        this.trackId = data.id;\n        const { fragCurrent } = this;\n        if (fragCurrent) {\n            fragCurrent.abortRequests();\n            this.removeUnbufferedFrags(fragCurrent.start);\n        }\n        this.resetLoadingState();\n        // destroy useless transmuxer when switching audio to main\n        if (!altAudio) {\n            this.resetTransmuxer();\n        } else {\n            // switching to audio track, start timer if not already started\n            this.setInterval(TICK_INTERVAL$2);\n        }\n        // should we switch tracks ?\n        if (altAudio) {\n            this.switchingTrack = data;\n            // main audio track are handled by stream-controller, just do something if switching to alt audio track\n            this.state = State.IDLE;\n            this.flushAudioIfNeeded(data);\n        } else {\n            this.switchingTrack = null;\n            this.bufferedTrack = data;\n            this.state = State.STOPPED;\n        }\n        this.tick();\n    }\n    onManifestLoading() {\n        this.fragmentTracker.removeAllFragments();\n        this.startPosition = this.lastCurrentTime = 0;\n        this.bufferFlushed = this.flushing = false;\n        this.levels = this.mainDetails = this.waitingData = this.bufferedTrack = this.cachedTrackLoadedData = this.switchingTrack = null;\n        this.startFragRequested = false;\n        this.trackId = this.videoTrackCC = this.waitingVideoCC = -1;\n    }\n    onLevelLoaded(event, data) {\n        this.mainDetails = data.details;\n        if (this.cachedTrackLoadedData !== null) {\n            this.hls.trigger(Events.AUDIO_TRACK_LOADED, this.cachedTrackLoadedData);\n            this.cachedTrackLoadedData = null;\n        }\n    }\n    onAudioTrackLoaded(event, data) {\n        var _track$details;\n        if (this.mainDetails == null) {\n            this.cachedTrackLoadedData = data;\n            return;\n        }\n        const { levels } = this;\n        const { details: newDetails, id: trackId } = data;\n        if (!levels) {\n            this.warn(`Audio tracks were reset while loading level ${trackId}`);\n            return;\n        }\n        this.log(`Audio track ${trackId} loaded [${newDetails.startSN},${newDetails.endSN}]${newDetails.lastPartSn ? `[part-${newDetails.lastPartSn}-${newDetails.lastPartIndex}]` : \"\"},duration:${newDetails.totalduration}`);\n        const track = levels[trackId];\n        let sliding = 0;\n        if (newDetails.live || (_track$details = track.details) != null && _track$details.live) {\n            this.checkLiveUpdate(newDetails);\n            const mainDetails = this.mainDetails;\n            if (newDetails.deltaUpdateFailed || !mainDetails) {\n                return;\n            }\n            if (!track.details && newDetails.hasProgramDateTime && mainDetails.hasProgramDateTime) {\n                // Make sure our audio rendition is aligned with the \"main\" rendition, using\n                // pdt as our reference times.\n                alignMediaPlaylistByPDT(newDetails, mainDetails);\n                sliding = newDetails.fragments[0].start;\n            } else {\n                var _this$levelLastLoaded;\n                sliding = this.alignPlaylists(newDetails, track.details, (_this$levelLastLoaded = this.levelLastLoaded) == null ? void 0 : _this$levelLastLoaded.details);\n            }\n        }\n        track.details = newDetails;\n        this.levelLastLoaded = track;\n        // compute start position if we are aligned with the main playlist\n        if (!this.startFragRequested && (this.mainDetails || !newDetails.live)) {\n            this.setStartPosition(track.details, sliding);\n        }\n        // only switch back to IDLE state if we were waiting for track to start downloading a new fragment\n        if (this.state === State.WAITING_TRACK && !this.waitForCdnTuneIn(newDetails)) {\n            this.state = State.IDLE;\n        }\n        // trigger handler right now\n        this.tick();\n    }\n    _handleFragmentLoadProgress(data) {\n        var _frag$initSegment;\n        const { frag, part, payload } = data;\n        const { config, trackId, levels } = this;\n        if (!levels) {\n            this.warn(`Audio tracks were reset while fragment load was in progress. Fragment ${frag.sn} of level ${frag.level} will not be buffered`);\n            return;\n        }\n        const track = levels[trackId];\n        if (!track) {\n            this.warn(\"Audio track is undefined on fragment load progress\");\n            return;\n        }\n        const details = track.details;\n        if (!details) {\n            this.warn(\"Audio track details undefined on fragment load progress\");\n            this.removeUnbufferedFrags(frag.start);\n            return;\n        }\n        const audioCodec = config.defaultAudioCodec || track.audioCodec || \"mp4a.40.2\";\n        let transmuxer = this.transmuxer;\n        if (!transmuxer) {\n            transmuxer = this.transmuxer = new TransmuxerInterface(this.hls, PlaylistLevelType.AUDIO, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this));\n        }\n        // Check if we have video initPTS\n        // If not we need to wait for it\n        const initPTS = this.initPTS[frag.cc];\n        const initSegmentData = (_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.data;\n        if (initPTS !== undefined) {\n            // this.log(`Transmuxing ${sn} of [${details.startSN} ,${details.endSN}],track ${trackId}`);\n            // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)\n            const accurateTimeOffset = false; // details.PTSKnown || !details.live;\n            const partIndex = part ? part.index : -1;\n            const partial = partIndex !== -1;\n            const chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount, payload.byteLength, partIndex, partial);\n            transmuxer.push(payload, initSegmentData, audioCodec, \"\", frag, part, details.totalduration, accurateTimeOffset, chunkMeta, initPTS);\n        } else {\n            this.log(`Unknown video PTS for cc ${frag.cc}, waiting for video PTS before demuxing audio frag ${frag.sn} of [${details.startSN} ,${details.endSN}],track ${trackId}`);\n            const { cache } = this.waitingData = this.waitingData || {\n                frag,\n                part,\n                cache: new ChunkCache(),\n                complete: false\n            };\n            cache.push(new Uint8Array(payload));\n            this.waitingVideoCC = this.videoTrackCC;\n            this.state = State.WAITING_INIT_PTS;\n        }\n    }\n    _handleFragmentLoadComplete(fragLoadedData) {\n        if (this.waitingData) {\n            this.waitingData.complete = true;\n            return;\n        }\n        super._handleFragmentLoadComplete(fragLoadedData);\n    }\n    onBufferReset() {\n        // reset reference to sourcebuffers\n        this.mediaBuffer = this.videoBuffer = null;\n        this.loadedmetadata = false;\n    }\n    onBufferCreated(event, data) {\n        const audioTrack = data.tracks.audio;\n        if (audioTrack) {\n            this.mediaBuffer = audioTrack.buffer || null;\n        }\n        if (data.tracks.video) {\n            this.videoBuffer = data.tracks.video.buffer || null;\n        }\n    }\n    onFragBuffered(event, data) {\n        const { frag, part } = data;\n        if (frag.type !== PlaylistLevelType.AUDIO) {\n            if (!this.loadedmetadata && frag.type === PlaylistLevelType.MAIN) {\n                const bufferable = this.videoBuffer || this.media;\n                if (bufferable) {\n                    const bufferedTimeRanges = BufferHelper.getBuffered(bufferable);\n                    if (bufferedTimeRanges.length) {\n                        this.loadedmetadata = true;\n                    }\n                }\n            }\n            return;\n        }\n        if (this.fragContextChanged(frag)) {\n            // If a level switch was requested while a fragment was buffering, it will emit the FRAG_BUFFERED event upon completion\n            // Avoid setting state back to IDLE or concluding the audio switch; otherwise, the switched-to track will not buffer\n            this.warn(`Fragment ${frag.sn}${part ? \" p: \" + part.index : \"\"} of level ${frag.level} finished buffering, but was aborted. state: ${this.state}, audioSwitch: ${this.switchingTrack ? this.switchingTrack.name : \"false\"}`);\n            return;\n        }\n        if (frag.sn !== \"initSegment\") {\n            this.fragPrevious = frag;\n            const track = this.switchingTrack;\n            if (track) {\n                this.bufferedTrack = track;\n                this.switchingTrack = null;\n                this.hls.trigger(Events.AUDIO_TRACK_SWITCHED, _objectSpread2({}, track));\n            }\n        }\n        this.fragBufferedComplete(frag, part);\n    }\n    onError(event, data) {\n        var _data$context;\n        if (data.fatal) {\n            this.state = State.ERROR;\n            return;\n        }\n        switch(data.details){\n            case ErrorDetails.FRAG_GAP:\n            case ErrorDetails.FRAG_PARSING_ERROR:\n            case ErrorDetails.FRAG_DECRYPT_ERROR:\n            case ErrorDetails.FRAG_LOAD_ERROR:\n            case ErrorDetails.FRAG_LOAD_TIMEOUT:\n            case ErrorDetails.KEY_LOAD_ERROR:\n            case ErrorDetails.KEY_LOAD_TIMEOUT:\n                this.onFragmentOrKeyLoadError(PlaylistLevelType.AUDIO, data);\n                break;\n            case ErrorDetails.AUDIO_TRACK_LOAD_ERROR:\n            case ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:\n            case ErrorDetails.LEVEL_PARSING_ERROR:\n                // in case of non fatal error while loading track, if not retrying to load track, switch back to IDLE\n                if (!data.levelRetry && this.state === State.WAITING_TRACK && ((_data$context = data.context) == null ? void 0 : _data$context.type) === PlaylistContextType.AUDIO_TRACK) {\n                    this.state = State.IDLE;\n                }\n                break;\n            case ErrorDetails.BUFFER_APPEND_ERROR:\n            case ErrorDetails.BUFFER_FULL_ERROR:\n                if (!data.parent || data.parent !== \"audio\") {\n                    return;\n                }\n                if (data.details === ErrorDetails.BUFFER_APPEND_ERROR) {\n                    this.resetLoadingState();\n                    return;\n                }\n                if (this.reduceLengthAndFlushBuffer(data)) {\n                    this.bufferedTrack = null;\n                    super.flushMainBuffer(0, Number.POSITIVE_INFINITY, \"audio\");\n                }\n                break;\n            case ErrorDetails.INTERNAL_EXCEPTION:\n                this.recoverWorkerError(data);\n                break;\n        }\n    }\n    onBufferFlushing(event, { type }) {\n        if (type !== ElementaryStreamTypes.VIDEO) {\n            this.flushing = true;\n        }\n    }\n    onBufferFlushed(event, { type }) {\n        if (type !== ElementaryStreamTypes.VIDEO) {\n            this.flushing = false;\n            this.bufferFlushed = true;\n            if (this.state === State.ENDED) {\n                this.state = State.IDLE;\n            }\n            const mediaBuffer = this.mediaBuffer || this.media;\n            if (mediaBuffer) {\n                this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.AUDIO);\n                this.tick();\n            }\n        }\n    }\n    _handleTransmuxComplete(transmuxResult) {\n        var _id3$samples;\n        const id = \"audio\";\n        const { hls } = this;\n        const { remuxResult, chunkMeta } = transmuxResult;\n        const context = this.getCurrentContext(chunkMeta);\n        if (!context) {\n            this.resetWhenMissingContext(chunkMeta);\n            return;\n        }\n        const { frag, part, level } = context;\n        const { details } = level;\n        const { audio, text, id3, initSegment } = remuxResult;\n        // Check if the current fragment has been aborted. We check this by first seeing if we're still playing the current level.\n        // If we are, subsequently check if the currently loading fragment (fragCurrent) has changed.\n        if (this.fragContextChanged(frag) || !details) {\n            this.fragmentTracker.removeFragment(frag);\n            return;\n        }\n        this.state = State.PARSING;\n        if (this.switchingTrack && audio) {\n            this.completeAudioSwitch(this.switchingTrack);\n        }\n        if (initSegment != null && initSegment.tracks) {\n            const mapFragment = frag.initSegment || frag;\n            this._bufferInitSegment(level, initSegment.tracks, mapFragment, chunkMeta);\n            hls.trigger(Events.FRAG_PARSING_INIT_SEGMENT, {\n                frag: mapFragment,\n                id,\n                tracks: initSegment.tracks\n            });\n        // Only flush audio from old audio tracks when PTS is known on new audio track\n        }\n        if (audio) {\n            const { startPTS, endPTS, startDTS, endDTS } = audio;\n            if (part) {\n                part.elementaryStreams[ElementaryStreamTypes.AUDIO] = {\n                    startPTS,\n                    endPTS,\n                    startDTS,\n                    endDTS\n                };\n            }\n            frag.setElementaryStreamInfo(ElementaryStreamTypes.AUDIO, startPTS, endPTS, startDTS, endDTS);\n            this.bufferFragmentData(audio, frag, part, chunkMeta);\n        }\n        if (id3 != null && (_id3$samples = id3.samples) != null && _id3$samples.length) {\n            const emittedID3 = _extends({\n                id,\n                frag,\n                details\n            }, id3);\n            hls.trigger(Events.FRAG_PARSING_METADATA, emittedID3);\n        }\n        if (text) {\n            const emittedText = _extends({\n                id,\n                frag,\n                details\n            }, text);\n            hls.trigger(Events.FRAG_PARSING_USERDATA, emittedText);\n        }\n    }\n    _bufferInitSegment(currentLevel, tracks, frag, chunkMeta) {\n        if (this.state !== State.PARSING) {\n            return;\n        }\n        // delete any video track found on audio transmuxer\n        if (tracks.video) {\n            delete tracks.video;\n        }\n        // include levelCodec in audio and video tracks\n        const track = tracks.audio;\n        if (!track) {\n            return;\n        }\n        track.id = \"audio\";\n        const variantAudioCodecs = currentLevel.audioCodec;\n        this.log(`Init audio buffer, container:${track.container}, codecs[level/parsed]=[${variantAudioCodecs}/${track.codec}]`);\n        // SourceBuffer will use track.levelCodec if defined\n        if (variantAudioCodecs && variantAudioCodecs.split(\",\").length === 1) {\n            track.levelCodec = variantAudioCodecs;\n        }\n        this.hls.trigger(Events.BUFFER_CODECS, tracks);\n        const initSegment = track.initSegment;\n        if (initSegment != null && initSegment.byteLength) {\n            const segment = {\n                type: \"audio\",\n                frag,\n                part: null,\n                chunkMeta,\n                parent: frag.type,\n                data: initSegment\n            };\n            this.hls.trigger(Events.BUFFER_APPENDING, segment);\n        }\n        // trigger handler right now\n        this.tickImmediate();\n    }\n    loadFragment(frag, track, targetBufferTime) {\n        // only load if fragment is not loaded or if in audio switch\n        const fragState = this.fragmentTracker.getState(frag);\n        this.fragCurrent = frag;\n        // we force a frag loading in audio switch as fragment tracker might not have evicted previous frags in case of quick audio switch\n        if (this.switchingTrack || fragState === FragmentState.NOT_LOADED || fragState === FragmentState.PARTIAL) {\n            var _track$details2;\n            if (frag.sn === \"initSegment\") {\n                this._loadInitSegment(frag, track);\n            } else if ((_track$details2 = track.details) != null && _track$details2.live && !this.initPTS[frag.cc]) {\n                this.log(`Waiting for video PTS in continuity counter ${frag.cc} of live stream before loading audio fragment ${frag.sn} of level ${this.trackId}`);\n                this.state = State.WAITING_INIT_PTS;\n                const mainDetails = this.mainDetails;\n                if (mainDetails && mainDetails.fragments[0].start !== track.details.fragments[0].start) {\n                    alignMediaPlaylistByPDT(track.details, mainDetails);\n                }\n            } else {\n                this.startFragRequested = true;\n                super.loadFragment(frag, track, targetBufferTime);\n            }\n        } else {\n            this.clearTrackerIfNeeded(frag);\n        }\n    }\n    flushAudioIfNeeded(switchingTrack) {\n        const { media, bufferedTrack } = this;\n        const bufferedAttributes = bufferedTrack == null ? void 0 : bufferedTrack.attrs;\n        const switchAttributes = switchingTrack.attrs;\n        if (media && bufferedAttributes && (bufferedAttributes.CHANNELS !== switchAttributes.CHANNELS || bufferedTrack.name !== switchingTrack.name || bufferedTrack.lang !== switchingTrack.lang)) {\n            this.log(\"Switching audio track : flushing all audio\");\n            super.flushMainBuffer(0, Number.POSITIVE_INFINITY, \"audio\");\n            this.bufferedTrack = null;\n        }\n    }\n    completeAudioSwitch(switchingTrack) {\n        const { hls } = this;\n        this.flushAudioIfNeeded(switchingTrack);\n        this.bufferedTrack = switchingTrack;\n        this.switchingTrack = null;\n        hls.trigger(Events.AUDIO_TRACK_SWITCHED, _objectSpread2({}, switchingTrack));\n    }\n}\nclass AudioTrackController extends BasePlaylistController {\n    constructor(hls){\n        super(hls, \"[audio-track-controller]\");\n        this.tracks = [];\n        this.groupIds = null;\n        this.tracksInGroup = [];\n        this.trackId = -1;\n        this.currentTrack = null;\n        this.selectDefaultTrack = true;\n        this.registerListeners();\n    }\n    registerListeners() {\n        const { hls } = this;\n        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n        hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);\n        hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n        hls.on(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);\n        hls.on(Events.ERROR, this.onError, this);\n    }\n    unregisterListeners() {\n        const { hls } = this;\n        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n        hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);\n        hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n        hls.off(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);\n        hls.off(Events.ERROR, this.onError, this);\n    }\n    destroy() {\n        this.unregisterListeners();\n        this.tracks.length = 0;\n        this.tracksInGroup.length = 0;\n        this.currentTrack = null;\n        super.destroy();\n    }\n    onManifestLoading() {\n        this.tracks = [];\n        this.tracksInGroup = [];\n        this.groupIds = null;\n        this.currentTrack = null;\n        this.trackId = -1;\n        this.selectDefaultTrack = true;\n    }\n    onManifestParsed(event, data) {\n        this.tracks = data.audioTracks || [];\n    }\n    onAudioTrackLoaded(event, data) {\n        const { id, groupId, details } = data;\n        const trackInActiveGroup = this.tracksInGroup[id];\n        if (!trackInActiveGroup || trackInActiveGroup.groupId !== groupId) {\n            this.warn(`Audio track with id:${id} and group:${groupId} not found in active group ${trackInActiveGroup == null ? void 0 : trackInActiveGroup.groupId}`);\n            return;\n        }\n        const curDetails = trackInActiveGroup.details;\n        trackInActiveGroup.details = data.details;\n        this.log(`Audio track ${id} \"${trackInActiveGroup.name}\" lang:${trackInActiveGroup.lang} group:${groupId} loaded [${details.startSN}-${details.endSN}]`);\n        if (id === this.trackId) {\n            this.playlistLoaded(id, data, curDetails);\n        }\n    }\n    onLevelLoading(event, data) {\n        this.switchLevel(data.level);\n    }\n    onLevelSwitching(event, data) {\n        this.switchLevel(data.level);\n    }\n    switchLevel(levelIndex) {\n        const levelInfo = this.hls.levels[levelIndex];\n        if (!levelInfo) {\n            return;\n        }\n        const audioGroups = levelInfo.audioGroups || null;\n        const currentGroups = this.groupIds;\n        let currentTrack = this.currentTrack;\n        if (!audioGroups || (currentGroups == null ? void 0 : currentGroups.length) !== (audioGroups == null ? void 0 : audioGroups.length) || audioGroups != null && audioGroups.some((groupId)=>(currentGroups == null ? void 0 : currentGroups.indexOf(groupId)) === -1)) {\n            this.groupIds = audioGroups;\n            this.trackId = -1;\n            this.currentTrack = null;\n            const audioTracks = this.tracks.filter((track)=>!audioGroups || audioGroups.indexOf(track.groupId) !== -1);\n            if (audioTracks.length) {\n                // Disable selectDefaultTrack if there are no default tracks\n                if (this.selectDefaultTrack && !audioTracks.some((track)=>track.default)) {\n                    this.selectDefaultTrack = false;\n                }\n                // track.id should match hls.audioTracks index\n                audioTracks.forEach((track, i)=>{\n                    track.id = i;\n                });\n            } else if (!currentTrack && !this.tracksInGroup.length) {\n                // Do not dispatch AUDIO_TRACKS_UPDATED when there were and are no tracks\n                return;\n            }\n            this.tracksInGroup = audioTracks;\n            // Find preferred track\n            const audioPreference = this.hls.config.audioPreference;\n            if (!currentTrack && audioPreference) {\n                const groupIndex = findMatchingOption(audioPreference, audioTracks, audioMatchPredicate);\n                if (groupIndex > -1) {\n                    currentTrack = audioTracks[groupIndex];\n                } else {\n                    const allIndex = findMatchingOption(audioPreference, this.tracks);\n                    currentTrack = this.tracks[allIndex];\n                }\n            }\n            // Select initial track\n            let trackId = this.findTrackId(currentTrack);\n            if (trackId === -1 && currentTrack) {\n                trackId = this.findTrackId(null);\n            }\n            // Dispatch events and load track if needed\n            const audioTracksUpdated = {\n                audioTracks\n            };\n            this.log(`Updating audio tracks, ${audioTracks.length} track(s) found in group(s): ${audioGroups == null ? void 0 : audioGroups.join(\",\")}`);\n            this.hls.trigger(Events.AUDIO_TRACKS_UPDATED, audioTracksUpdated);\n            const selectedTrackId = this.trackId;\n            if (trackId !== -1 && selectedTrackId === -1) {\n                this.setAudioTrack(trackId);\n            } else if (audioTracks.length && selectedTrackId === -1) {\n                var _this$groupIds;\n                const error = new Error(`No audio track selected for current audio group-ID(s): ${(_this$groupIds = this.groupIds) == null ? void 0 : _this$groupIds.join(\",\")} track count: ${audioTracks.length}`);\n                this.warn(error.message);\n                this.hls.trigger(Events.ERROR, {\n                    type: ErrorTypes.MEDIA_ERROR,\n                    details: ErrorDetails.AUDIO_TRACK_LOAD_ERROR,\n                    fatal: true,\n                    error\n                });\n            }\n        } else if (this.shouldReloadPlaylist(currentTrack)) {\n            // Retry playlist loading if no playlist is or has been loaded yet\n            this.setAudioTrack(this.trackId);\n        }\n    }\n    onError(event, data) {\n        if (data.fatal || !data.context) {\n            return;\n        }\n        if (data.context.type === PlaylistContextType.AUDIO_TRACK && data.context.id === this.trackId && (!this.groupIds || this.groupIds.indexOf(data.context.groupId) !== -1)) {\n            this.requestScheduled = -1;\n            this.checkRetry(data);\n        }\n    }\n    get allAudioTracks() {\n        return this.tracks;\n    }\n    get audioTracks() {\n        return this.tracksInGroup;\n    }\n    get audioTrack() {\n        return this.trackId;\n    }\n    set audioTrack(newId) {\n        // If audio track is selected from API then don't choose from the manifest default track\n        this.selectDefaultTrack = false;\n        this.setAudioTrack(newId);\n    }\n    setAudioOption(audioOption) {\n        const hls = this.hls;\n        hls.config.audioPreference = audioOption;\n        if (audioOption) {\n            const allAudioTracks = this.allAudioTracks;\n            this.selectDefaultTrack = false;\n            if (allAudioTracks.length) {\n                // First see if current option matches (no switch op)\n                const currentTrack = this.currentTrack;\n                if (currentTrack && matchesOption(audioOption, currentTrack, audioMatchPredicate)) {\n                    return currentTrack;\n                }\n                // Find option in available tracks (tracksInGroup)\n                const groupIndex = findMatchingOption(audioOption, this.tracksInGroup, audioMatchPredicate);\n                if (groupIndex > -1) {\n                    const track = this.tracksInGroup[groupIndex];\n                    this.setAudioTrack(groupIndex);\n                    return track;\n                } else if (currentTrack) {\n                    // Find option in nearest level audio group\n                    let searchIndex = hls.loadLevel;\n                    if (searchIndex === -1) {\n                        searchIndex = hls.firstAutoLevel;\n                    }\n                    const switchIndex = findClosestLevelWithAudioGroup(audioOption, hls.levels, allAudioTracks, searchIndex, audioMatchPredicate);\n                    if (switchIndex === -1) {\n                        // could not find matching variant\n                        return null;\n                    }\n                    // and switch level to acheive the audio group switch\n                    hls.nextLoadLevel = switchIndex;\n                }\n                if (audioOption.channels || audioOption.audioCodec) {\n                    // Could not find a match with codec / channels predicate\n                    // Find a match without channels or codec\n                    const withoutCodecAndChannelsMatch = findMatchingOption(audioOption, allAudioTracks);\n                    if (withoutCodecAndChannelsMatch > -1) {\n                        return allAudioTracks[withoutCodecAndChannelsMatch];\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    setAudioTrack(newId) {\n        const tracks = this.tracksInGroup;\n        // check if level idx is valid\n        if (newId < 0 || newId >= tracks.length) {\n            this.warn(`Invalid audio track id: ${newId}`);\n            return;\n        }\n        // stopping live reloading timer if any\n        this.clearTimer();\n        this.selectDefaultTrack = false;\n        const lastTrack = this.currentTrack;\n        const track = tracks[newId];\n        const trackLoaded = track.details && !track.details.live;\n        if (newId === this.trackId && track === lastTrack && trackLoaded) {\n            return;\n        }\n        this.log(`Switching to audio-track ${newId} \"${track.name}\" lang:${track.lang} group:${track.groupId} channels:${track.channels}`);\n        this.trackId = newId;\n        this.currentTrack = track;\n        this.hls.trigger(Events.AUDIO_TRACK_SWITCHING, _objectSpread2({}, track));\n        // Do not reload track unless live\n        if (trackLoaded) {\n            return;\n        }\n        const hlsUrlParameters = this.switchParams(track.url, lastTrack == null ? void 0 : lastTrack.details);\n        this.loadPlaylist(hlsUrlParameters);\n    }\n    findTrackId(currentTrack) {\n        const audioTracks = this.tracksInGroup;\n        for(let i = 0; i < audioTracks.length; i++){\n            const track = audioTracks[i];\n            if (this.selectDefaultTrack && !track.default) {\n                continue;\n            }\n            if (!currentTrack || matchesOption(currentTrack, track, audioMatchPredicate)) {\n                return i;\n            }\n        }\n        if (currentTrack) {\n            const { name, lang, assocLang, characteristics, audioCodec, channels } = currentTrack;\n            for(let i = 0; i < audioTracks.length; i++){\n                const track = audioTracks[i];\n                if (matchesOption({\n                    name,\n                    lang,\n                    assocLang,\n                    characteristics,\n                    audioCodec,\n                    channels\n                }, track, audioMatchPredicate)) {\n                    return i;\n                }\n            }\n            for(let i = 0; i < audioTracks.length; i++){\n                const track = audioTracks[i];\n                if (mediaAttributesIdentical(currentTrack.attrs, track.attrs, [\n                    \"LANGUAGE\",\n                    \"ASSOC-LANGUAGE\",\n                    \"CHARACTERISTICS\"\n                ])) {\n                    return i;\n                }\n            }\n            for(let i = 0; i < audioTracks.length; i++){\n                const track = audioTracks[i];\n                if (mediaAttributesIdentical(currentTrack.attrs, track.attrs, [\n                    \"LANGUAGE\"\n                ])) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n    loadPlaylist(hlsUrlParameters) {\n        const audioTrack = this.currentTrack;\n        if (this.shouldLoadPlaylist(audioTrack) && audioTrack) {\n            super.loadPlaylist();\n            const id = audioTrack.id;\n            const groupId = audioTrack.groupId;\n            let url = audioTrack.url;\n            if (hlsUrlParameters) {\n                try {\n                    url = hlsUrlParameters.addDirectives(url);\n                } catch (error) {\n                    this.warn(`Could not construct new URL with HLS Delivery Directives: ${error}`);\n                }\n            }\n            // track not retrieved yet, or live playlist we need to (re)load it\n            this.log(`loading audio-track playlist ${id} \"${audioTrack.name}\" lang:${audioTrack.lang} group:${groupId}`);\n            this.clearTimer();\n            this.hls.trigger(Events.AUDIO_TRACK_LOADING, {\n                url,\n                id,\n                groupId,\n                deliveryDirectives: hlsUrlParameters || null\n            });\n        }\n    }\n}\nconst TICK_INTERVAL$1 = 500; // how often to tick in ms\nclass SubtitleStreamController extends BaseStreamController {\n    constructor(hls, fragmentTracker, keyLoader){\n        super(hls, fragmentTracker, keyLoader, \"[subtitle-stream-controller]\", PlaylistLevelType.SUBTITLE);\n        this.currentTrackId = -1;\n        this.tracksBuffered = [];\n        this.mainDetails = null;\n        this._registerListeners();\n    }\n    onHandlerDestroying() {\n        this._unregisterListeners();\n        super.onHandlerDestroying();\n        this.mainDetails = null;\n    }\n    _registerListeners() {\n        const { hls } = this;\n        hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n        hls.on(Events.ERROR, this.onError, this);\n        hls.on(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);\n        hls.on(Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);\n        hls.on(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);\n        hls.on(Events.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this);\n        hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n        hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    }\n    _unregisterListeners() {\n        const { hls } = this;\n        hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n        hls.off(Events.ERROR, this.onError, this);\n        hls.off(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);\n        hls.off(Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);\n        hls.off(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);\n        hls.off(Events.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this);\n        hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n        hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    }\n    startLoad(startPosition) {\n        this.stopLoad();\n        this.state = State.IDLE;\n        this.setInterval(TICK_INTERVAL$1);\n        this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;\n        this.tick();\n    }\n    onManifestLoading() {\n        this.mainDetails = null;\n        this.fragmentTracker.removeAllFragments();\n    }\n    onMediaDetaching() {\n        this.tracksBuffered = [];\n        super.onMediaDetaching();\n    }\n    onLevelLoaded(event, data) {\n        this.mainDetails = data.details;\n    }\n    onSubtitleFragProcessed(event, data) {\n        const { frag, success } = data;\n        this.fragPrevious = frag;\n        this.state = State.IDLE;\n        if (!success) {\n            return;\n        }\n        const buffered = this.tracksBuffered[this.currentTrackId];\n        if (!buffered) {\n            return;\n        }\n        // Create/update a buffered array matching the interface used by BufferHelper.bufferedInfo\n        // so we can re-use the logic used to detect how much has been buffered\n        let timeRange;\n        const fragStart = frag.start;\n        for(let i = 0; i < buffered.length; i++){\n            if (fragStart >= buffered[i].start && fragStart <= buffered[i].end) {\n                timeRange = buffered[i];\n                break;\n            }\n        }\n        const fragEnd = frag.start + frag.duration;\n        if (timeRange) {\n            timeRange.end = fragEnd;\n        } else {\n            timeRange = {\n                start: fragStart,\n                end: fragEnd\n            };\n            buffered.push(timeRange);\n        }\n        this.fragmentTracker.fragBuffered(frag);\n        this.fragBufferedComplete(frag, null);\n    }\n    onBufferFlushing(event, data) {\n        const { startOffset, endOffset } = data;\n        if (startOffset === 0 && endOffset !== Number.POSITIVE_INFINITY) {\n            const endOffsetSubtitles = endOffset - 1;\n            if (endOffsetSubtitles <= 0) {\n                return;\n            }\n            data.endOffsetSubtitles = Math.max(0, endOffsetSubtitles);\n            this.tracksBuffered.forEach((buffered)=>{\n                for(let i = 0; i < buffered.length;){\n                    if (buffered[i].end <= endOffsetSubtitles) {\n                        buffered.shift();\n                        continue;\n                    } else if (buffered[i].start < endOffsetSubtitles) {\n                        buffered[i].start = endOffsetSubtitles;\n                    } else {\n                        break;\n                    }\n                    i++;\n                }\n            });\n            this.fragmentTracker.removeFragmentsInRange(startOffset, endOffsetSubtitles, PlaylistLevelType.SUBTITLE);\n        }\n    }\n    onFragBuffered(event, data) {\n        if (!this.loadedmetadata && data.frag.type === PlaylistLevelType.MAIN) {\n            var _this$media;\n            if ((_this$media = this.media) != null && _this$media.buffered.length) {\n                this.loadedmetadata = true;\n            }\n        }\n    }\n    // If something goes wrong, proceed to next frag, if we were processing one.\n    onError(event, data) {\n        const frag = data.frag;\n        if ((frag == null ? void 0 : frag.type) === PlaylistLevelType.SUBTITLE) {\n            if (this.fragCurrent) {\n                this.fragCurrent.abortRequests();\n            }\n            if (this.state !== State.STOPPED) {\n                this.state = State.IDLE;\n            }\n        }\n    }\n    // Got all new subtitle levels.\n    onSubtitleTracksUpdated(event, { subtitleTracks }) {\n        if (!this.levels || subtitleOptionsIdentical(this.levels, subtitleTracks)) {\n            this.levels = subtitleTracks.map((mediaPlaylist)=>new Level(mediaPlaylist));\n            return;\n        }\n        this.tracksBuffered = [];\n        this.levels = subtitleTracks.map((mediaPlaylist)=>{\n            const level = new Level(mediaPlaylist);\n            this.tracksBuffered[level.id] = [];\n            return level;\n        });\n        this.fragmentTracker.removeFragmentsInRange(0, Number.POSITIVE_INFINITY, PlaylistLevelType.SUBTITLE);\n        this.fragPrevious = null;\n        this.mediaBuffer = null;\n    }\n    onSubtitleTrackSwitch(event, data) {\n        var _this$levels;\n        this.currentTrackId = data.id;\n        if (!((_this$levels = this.levels) != null && _this$levels.length) || this.currentTrackId === -1) {\n            this.clearInterval();\n            return;\n        }\n        // Check if track has the necessary details to load fragments\n        const currentTrack = this.levels[this.currentTrackId];\n        if (currentTrack != null && currentTrack.details) {\n            this.mediaBuffer = this.mediaBufferTimeRanges;\n        } else {\n            this.mediaBuffer = null;\n        }\n        if (currentTrack) {\n            this.setInterval(TICK_INTERVAL$1);\n        }\n    }\n    // Got a new set of subtitle fragments.\n    onSubtitleTrackLoaded(event, data) {\n        var _track$details;\n        const { currentTrackId, levels } = this;\n        const { details: newDetails, id: trackId } = data;\n        if (!levels) {\n            this.warn(`Subtitle tracks were reset while loading level ${trackId}`);\n            return;\n        }\n        const track = levels[currentTrackId];\n        if (trackId >= levels.length || trackId !== currentTrackId || !track) {\n            return;\n        }\n        this.log(`Subtitle track ${trackId} loaded [${newDetails.startSN},${newDetails.endSN}]${newDetails.lastPartSn ? `[part-${newDetails.lastPartSn}-${newDetails.lastPartIndex}]` : \"\"},duration:${newDetails.totalduration}`);\n        this.mediaBuffer = this.mediaBufferTimeRanges;\n        let sliding = 0;\n        if (newDetails.live || (_track$details = track.details) != null && _track$details.live) {\n            const mainDetails = this.mainDetails;\n            if (newDetails.deltaUpdateFailed || !mainDetails) {\n                return;\n            }\n            const mainSlidingStartFragment = mainDetails.fragments[0];\n            if (!track.details) {\n                if (newDetails.hasProgramDateTime && mainDetails.hasProgramDateTime) {\n                    alignMediaPlaylistByPDT(newDetails, mainDetails);\n                    sliding = newDetails.fragments[0].start;\n                } else if (mainSlidingStartFragment) {\n                    // line up live playlist with main so that fragments in range are loaded\n                    sliding = mainSlidingStartFragment.start;\n                    addSliding(newDetails, sliding);\n                }\n            } else {\n                var _this$levelLastLoaded;\n                sliding = this.alignPlaylists(newDetails, track.details, (_this$levelLastLoaded = this.levelLastLoaded) == null ? void 0 : _this$levelLastLoaded.details);\n                if (sliding === 0 && mainSlidingStartFragment) {\n                    // realign with main when there is no overlap with last refresh\n                    sliding = mainSlidingStartFragment.start;\n                    addSliding(newDetails, sliding);\n                }\n            }\n        }\n        track.details = newDetails;\n        this.levelLastLoaded = track;\n        if (!this.startFragRequested && (this.mainDetails || !newDetails.live)) {\n            this.setStartPosition(track.details, sliding);\n        }\n        // trigger handler right now\n        this.tick();\n        // If playlist is misaligned because of bad PDT or drift, delete details to resync with main on reload\n        if (newDetails.live && !this.fragCurrent && this.media && this.state === State.IDLE) {\n            const foundFrag = findFragmentByPTS(null, newDetails.fragments, this.media.currentTime, 0);\n            if (!foundFrag) {\n                this.warn(\"Subtitle playlist not aligned with playback\");\n                track.details = undefined;\n            }\n        }\n    }\n    _handleFragmentLoadComplete(fragLoadedData) {\n        const { frag, payload } = fragLoadedData;\n        const decryptData = frag.decryptdata;\n        const hls = this.hls;\n        if (this.fragContextChanged(frag)) {\n            return;\n        }\n        // check to see if the payload needs to be decrypted\n        if (payload && payload.byteLength > 0 && decryptData != null && decryptData.key && decryptData.iv && decryptData.method === \"AES-128\") {\n            const startTime = performance.now();\n            // decrypt the subtitles\n            this.decrypter.decrypt(new Uint8Array(payload), decryptData.key.buffer, decryptData.iv.buffer).catch((err)=>{\n                hls.trigger(Events.ERROR, {\n                    type: ErrorTypes.MEDIA_ERROR,\n                    details: ErrorDetails.FRAG_DECRYPT_ERROR,\n                    fatal: false,\n                    error: err,\n                    reason: err.message,\n                    frag\n                });\n                throw err;\n            }).then((decryptedData)=>{\n                const endTime = performance.now();\n                hls.trigger(Events.FRAG_DECRYPTED, {\n                    frag,\n                    payload: decryptedData,\n                    stats: {\n                        tstart: startTime,\n                        tdecrypt: endTime\n                    }\n                });\n            }).catch((err)=>{\n                this.warn(`${err.name}: ${err.message}`);\n                this.state = State.IDLE;\n            });\n        }\n    }\n    doTick() {\n        if (!this.media) {\n            this.state = State.IDLE;\n            return;\n        }\n        if (this.state === State.IDLE) {\n            const { currentTrackId, levels } = this;\n            const track = levels == null ? void 0 : levels[currentTrackId];\n            if (!track || !levels.length || !track.details) {\n                return;\n            }\n            const { config } = this;\n            const currentTime = this.getLoadPosition();\n            const bufferedInfo = BufferHelper.bufferedInfo(this.tracksBuffered[this.currentTrackId] || [], currentTime, config.maxBufferHole);\n            const { end: targetBufferTime, len: bufferLen } = bufferedInfo;\n            const mainBufferInfo = this.getFwdBufferInfo(this.media, PlaylistLevelType.MAIN);\n            const trackDetails = track.details;\n            const maxBufLen = this.getMaxBufferLength(mainBufferInfo == null ? void 0 : mainBufferInfo.len) + trackDetails.levelTargetDuration;\n            if (bufferLen > maxBufLen) {\n                return;\n            }\n            const fragments = trackDetails.fragments;\n            const fragLen = fragments.length;\n            const end = trackDetails.edge;\n            let foundFrag = null;\n            const fragPrevious = this.fragPrevious;\n            if (targetBufferTime < end) {\n                const tolerance = config.maxFragLookUpTolerance;\n                const lookupTolerance = targetBufferTime > end - tolerance ? 0 : tolerance;\n                foundFrag = findFragmentByPTS(fragPrevious, fragments, Math.max(fragments[0].start, targetBufferTime), lookupTolerance);\n                if (!foundFrag && fragPrevious && fragPrevious.start < fragments[0].start) {\n                    foundFrag = fragments[0];\n                }\n            } else {\n                foundFrag = fragments[fragLen - 1];\n            }\n            if (!foundFrag) {\n                return;\n            }\n            foundFrag = this.mapToInitFragWhenRequired(foundFrag);\n            if (foundFrag.sn !== \"initSegment\") {\n                // Load earlier fragment in same discontinuity to make up for misaligned playlists and cues that extend beyond end of segment\n                const curSNIdx = foundFrag.sn - trackDetails.startSN;\n                const prevFrag = fragments[curSNIdx - 1];\n                if (prevFrag && prevFrag.cc === foundFrag.cc && this.fragmentTracker.getState(prevFrag) === FragmentState.NOT_LOADED) {\n                    foundFrag = prevFrag;\n                }\n            }\n            if (this.fragmentTracker.getState(foundFrag) === FragmentState.NOT_LOADED) {\n                // only load if fragment is not loaded\n                this.loadFragment(foundFrag, track, targetBufferTime);\n            }\n        }\n    }\n    getMaxBufferLength(mainBufferLength) {\n        const maxConfigBuffer = super.getMaxBufferLength();\n        if (!mainBufferLength) {\n            return maxConfigBuffer;\n        }\n        return Math.max(maxConfigBuffer, mainBufferLength);\n    }\n    loadFragment(frag, level, targetBufferTime) {\n        this.fragCurrent = frag;\n        if (frag.sn === \"initSegment\") {\n            this._loadInitSegment(frag, level);\n        } else {\n            this.startFragRequested = true;\n            super.loadFragment(frag, level, targetBufferTime);\n        }\n    }\n    get mediaBufferTimeRanges() {\n        return new BufferableInstance(this.tracksBuffered[this.currentTrackId] || []);\n    }\n}\nclass BufferableInstance {\n    constructor(timeranges){\n        this.buffered = void 0;\n        const getRange = (name, index, length)=>{\n            index = index >>> 0;\n            if (index > length - 1) {\n                throw new DOMException(`Failed to execute '${name}' on 'TimeRanges': The index provided (${index}) is greater than the maximum bound (${length})`);\n            }\n            return timeranges[index][name];\n        };\n        this.buffered = {\n            get length () {\n                return timeranges.length;\n            },\n            end (index) {\n                return getRange(\"end\", index, timeranges.length);\n            },\n            start (index) {\n                return getRange(\"start\", index, timeranges.length);\n            }\n        };\n    }\n}\nclass SubtitleTrackController extends BasePlaylistController {\n    constructor(hls){\n        super(hls, \"[subtitle-track-controller]\");\n        this.media = null;\n        this.tracks = [];\n        this.groupIds = null;\n        this.tracksInGroup = [];\n        this.trackId = -1;\n        this.currentTrack = null;\n        this.selectDefaultTrack = true;\n        this.queuedDefaultTrack = -1;\n        this.asyncPollTrackChange = ()=>this.pollTrackChange(0);\n        this.useTextTrackPolling = false;\n        this.subtitlePollingInterval = -1;\n        this._subtitleDisplay = true;\n        this.onTextTracksChanged = ()=>{\n            if (!this.useTextTrackPolling) {\n                self.clearInterval(this.subtitlePollingInterval);\n            }\n            // Media is undefined when switching streams via loadSource()\n            if (!this.media || !this.hls.config.renderTextTracksNatively) {\n                return;\n            }\n            let textTrack = null;\n            const tracks = filterSubtitleTracks(this.media.textTracks);\n            for(let i = 0; i < tracks.length; i++){\n                if (tracks[i].mode === \"hidden\") {\n                    // Do not break in case there is a following track with showing.\n                    textTrack = tracks[i];\n                } else if (tracks[i].mode === \"showing\") {\n                    textTrack = tracks[i];\n                    break;\n                }\n            }\n            // Find internal track index for TextTrack\n            const trackId = this.findTrackForTextTrack(textTrack);\n            if (this.subtitleTrack !== trackId) {\n                this.setSubtitleTrack(trackId);\n            }\n        };\n        this.registerListeners();\n    }\n    destroy() {\n        this.unregisterListeners();\n        this.tracks.length = 0;\n        this.tracksInGroup.length = 0;\n        this.currentTrack = null;\n        this.onTextTracksChanged = this.asyncPollTrackChange = null;\n        super.destroy();\n    }\n    get subtitleDisplay() {\n        return this._subtitleDisplay;\n    }\n    set subtitleDisplay(value) {\n        this._subtitleDisplay = value;\n        if (this.trackId > -1) {\n            this.toggleTrackModes();\n        }\n    }\n    registerListeners() {\n        const { hls } = this;\n        hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n        hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);\n        hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n        hls.on(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);\n        hls.on(Events.ERROR, this.onError, this);\n    }\n    unregisterListeners() {\n        const { hls } = this;\n        hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n        hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);\n        hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n        hls.off(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);\n        hls.off(Events.ERROR, this.onError, this);\n    }\n    // Listen for subtitle track change, then extract the current track ID.\n    onMediaAttached(event, data) {\n        this.media = data.media;\n        if (!this.media) {\n            return;\n        }\n        if (this.queuedDefaultTrack > -1) {\n            this.subtitleTrack = this.queuedDefaultTrack;\n            this.queuedDefaultTrack = -1;\n        }\n        this.useTextTrackPolling = !(this.media.textTracks && \"onchange\" in this.media.textTracks);\n        if (this.useTextTrackPolling) {\n            this.pollTrackChange(500);\n        } else {\n            this.media.textTracks.addEventListener(\"change\", this.asyncPollTrackChange);\n        }\n    }\n    pollTrackChange(timeout) {\n        self.clearInterval(this.subtitlePollingInterval);\n        this.subtitlePollingInterval = self.setInterval(this.onTextTracksChanged, timeout);\n    }\n    onMediaDetaching() {\n        if (!this.media) {\n            return;\n        }\n        self.clearInterval(this.subtitlePollingInterval);\n        if (!this.useTextTrackPolling) {\n            this.media.textTracks.removeEventListener(\"change\", this.asyncPollTrackChange);\n        }\n        if (this.trackId > -1) {\n            this.queuedDefaultTrack = this.trackId;\n        }\n        const textTracks = filterSubtitleTracks(this.media.textTracks);\n        // Clear loaded cues on media detachment from tracks\n        textTracks.forEach((track)=>{\n            clearCurrentCues(track);\n        });\n        // Disable all subtitle tracks before detachment so when reattached only tracks in that content are enabled.\n        this.subtitleTrack = -1;\n        this.media = null;\n    }\n    onManifestLoading() {\n        this.tracks = [];\n        this.groupIds = null;\n        this.tracksInGroup = [];\n        this.trackId = -1;\n        this.currentTrack = null;\n        this.selectDefaultTrack = true;\n    }\n    // Fired whenever a new manifest is loaded.\n    onManifestParsed(event, data) {\n        this.tracks = data.subtitleTracks;\n    }\n    onSubtitleTrackLoaded(event, data) {\n        const { id, groupId, details } = data;\n        const trackInActiveGroup = this.tracksInGroup[id];\n        if (!trackInActiveGroup || trackInActiveGroup.groupId !== groupId) {\n            this.warn(`Subtitle track with id:${id} and group:${groupId} not found in active group ${trackInActiveGroup == null ? void 0 : trackInActiveGroup.groupId}`);\n            return;\n        }\n        const curDetails = trackInActiveGroup.details;\n        trackInActiveGroup.details = data.details;\n        this.log(`Subtitle track ${id} \"${trackInActiveGroup.name}\" lang:${trackInActiveGroup.lang} group:${groupId} loaded [${details.startSN}-${details.endSN}]`);\n        if (id === this.trackId) {\n            this.playlistLoaded(id, data, curDetails);\n        }\n    }\n    onLevelLoading(event, data) {\n        this.switchLevel(data.level);\n    }\n    onLevelSwitching(event, data) {\n        this.switchLevel(data.level);\n    }\n    switchLevel(levelIndex) {\n        const levelInfo = this.hls.levels[levelIndex];\n        if (!levelInfo) {\n            return;\n        }\n        const subtitleGroups = levelInfo.subtitleGroups || null;\n        const currentGroups = this.groupIds;\n        let currentTrack = this.currentTrack;\n        if (!subtitleGroups || (currentGroups == null ? void 0 : currentGroups.length) !== (subtitleGroups == null ? void 0 : subtitleGroups.length) || subtitleGroups != null && subtitleGroups.some((groupId)=>(currentGroups == null ? void 0 : currentGroups.indexOf(groupId)) === -1)) {\n            this.groupIds = subtitleGroups;\n            this.trackId = -1;\n            this.currentTrack = null;\n            const subtitleTracks = this.tracks.filter((track)=>!subtitleGroups || subtitleGroups.indexOf(track.groupId) !== -1);\n            if (subtitleTracks.length) {\n                // Disable selectDefaultTrack if there are no default tracks\n                if (this.selectDefaultTrack && !subtitleTracks.some((track)=>track.default)) {\n                    this.selectDefaultTrack = false;\n                }\n                // track.id should match hls.audioTracks index\n                subtitleTracks.forEach((track, i)=>{\n                    track.id = i;\n                });\n            } else if (!currentTrack && !this.tracksInGroup.length) {\n                // Do not dispatch SUBTITLE_TRACKS_UPDATED when there were and are no tracks\n                return;\n            }\n            this.tracksInGroup = subtitleTracks;\n            // Find preferred track\n            const subtitlePreference = this.hls.config.subtitlePreference;\n            if (!currentTrack && subtitlePreference) {\n                this.selectDefaultTrack = false;\n                const groupIndex = findMatchingOption(subtitlePreference, subtitleTracks);\n                if (groupIndex > -1) {\n                    currentTrack = subtitleTracks[groupIndex];\n                } else {\n                    const allIndex = findMatchingOption(subtitlePreference, this.tracks);\n                    currentTrack = this.tracks[allIndex];\n                }\n            }\n            // Select initial track\n            let trackId = this.findTrackId(currentTrack);\n            if (trackId === -1 && currentTrack) {\n                trackId = this.findTrackId(null);\n            }\n            // Dispatch events and load track if needed\n            const subtitleTracksUpdated = {\n                subtitleTracks\n            };\n            this.log(`Updating subtitle tracks, ${subtitleTracks.length} track(s) found in \"${subtitleGroups == null ? void 0 : subtitleGroups.join(\",\")}\" group-id`);\n            this.hls.trigger(Events.SUBTITLE_TRACKS_UPDATED, subtitleTracksUpdated);\n            if (trackId !== -1 && this.trackId === -1) {\n                this.setSubtitleTrack(trackId);\n            }\n        } else if (this.shouldReloadPlaylist(currentTrack)) {\n            // Retry playlist loading if no playlist is or has been loaded yet\n            this.setSubtitleTrack(this.trackId);\n        }\n    }\n    findTrackId(currentTrack) {\n        const tracks = this.tracksInGroup;\n        const selectDefault = this.selectDefaultTrack;\n        for(let i = 0; i < tracks.length; i++){\n            const track = tracks[i];\n            if (selectDefault && !track.default || !selectDefault && !currentTrack) {\n                continue;\n            }\n            if (!currentTrack || matchesOption(track, currentTrack)) {\n                return i;\n            }\n        }\n        if (currentTrack) {\n            for(let i = 0; i < tracks.length; i++){\n                const track = tracks[i];\n                if (mediaAttributesIdentical(currentTrack.attrs, track.attrs, [\n                    \"LANGUAGE\",\n                    \"ASSOC-LANGUAGE\",\n                    \"CHARACTERISTICS\"\n                ])) {\n                    return i;\n                }\n            }\n            for(let i = 0; i < tracks.length; i++){\n                const track = tracks[i];\n                if (mediaAttributesIdentical(currentTrack.attrs, track.attrs, [\n                    \"LANGUAGE\"\n                ])) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n    findTrackForTextTrack(textTrack) {\n        if (textTrack) {\n            const tracks = this.tracksInGroup;\n            for(let i = 0; i < tracks.length; i++){\n                const track = tracks[i];\n                if (subtitleTrackMatchesTextTrack(track, textTrack)) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n    onError(event, data) {\n        if (data.fatal || !data.context) {\n            return;\n        }\n        if (data.context.type === PlaylistContextType.SUBTITLE_TRACK && data.context.id === this.trackId && (!this.groupIds || this.groupIds.indexOf(data.context.groupId) !== -1)) {\n            this.checkRetry(data);\n        }\n    }\n    get allSubtitleTracks() {\n        return this.tracks;\n    }\n    /** get alternate subtitle tracks list from playlist **/ get subtitleTracks() {\n        return this.tracksInGroup;\n    }\n    /** get/set index of the selected subtitle track (based on index in subtitle track lists) **/ get subtitleTrack() {\n        return this.trackId;\n    }\n    set subtitleTrack(newId) {\n        this.selectDefaultTrack = false;\n        this.setSubtitleTrack(newId);\n    }\n    setSubtitleOption(subtitleOption) {\n        this.hls.config.subtitlePreference = subtitleOption;\n        if (subtitleOption) {\n            const allSubtitleTracks = this.allSubtitleTracks;\n            this.selectDefaultTrack = false;\n            if (allSubtitleTracks.length) {\n                // First see if current option matches (no switch op)\n                const currentTrack = this.currentTrack;\n                if (currentTrack && matchesOption(subtitleOption, currentTrack)) {\n                    return currentTrack;\n                }\n                // Find option in current group\n                const groupIndex = findMatchingOption(subtitleOption, this.tracksInGroup);\n                if (groupIndex > -1) {\n                    const track = this.tracksInGroup[groupIndex];\n                    this.setSubtitleTrack(groupIndex);\n                    return track;\n                } else if (currentTrack) {\n                    // If this is not the initial selection return null\n                    // option should have matched one in active group\n                    return null;\n                } else {\n                    // Find the option in all tracks for initial selection\n                    const allIndex = findMatchingOption(subtitleOption, allSubtitleTracks);\n                    if (allIndex > -1) {\n                        return allSubtitleTracks[allIndex];\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    loadPlaylist(hlsUrlParameters) {\n        super.loadPlaylist();\n        const currentTrack = this.currentTrack;\n        if (this.shouldLoadPlaylist(currentTrack) && currentTrack) {\n            const id = currentTrack.id;\n            const groupId = currentTrack.groupId;\n            let url = currentTrack.url;\n            if (hlsUrlParameters) {\n                try {\n                    url = hlsUrlParameters.addDirectives(url);\n                } catch (error) {\n                    this.warn(`Could not construct new URL with HLS Delivery Directives: ${error}`);\n                }\n            }\n            this.log(`Loading subtitle playlist for id ${id}`);\n            this.hls.trigger(Events.SUBTITLE_TRACK_LOADING, {\n                url,\n                id,\n                groupId,\n                deliveryDirectives: hlsUrlParameters || null\n            });\n        }\n    }\n    /**\n   * Disables the old subtitleTrack and sets current mode on the next subtitleTrack.\n   * This operates on the DOM textTracks.\n   * A value of -1 will disable all subtitle tracks.\n   */ toggleTrackModes() {\n        const { media } = this;\n        if (!media) {\n            return;\n        }\n        const textTracks = filterSubtitleTracks(media.textTracks);\n        const currentTrack = this.currentTrack;\n        let nextTrack;\n        if (currentTrack) {\n            nextTrack = textTracks.filter((textTrack)=>subtitleTrackMatchesTextTrack(currentTrack, textTrack))[0];\n            if (!nextTrack) {\n                this.warn(`Unable to find subtitle TextTrack with name \"${currentTrack.name}\" and language \"${currentTrack.lang}\"`);\n            }\n        }\n        [].slice.call(textTracks).forEach((track)=>{\n            if (track.mode !== \"disabled\" && track !== nextTrack) {\n                track.mode = \"disabled\";\n            }\n        });\n        if (nextTrack) {\n            const mode = this.subtitleDisplay ? \"showing\" : \"hidden\";\n            if (nextTrack.mode !== mode) {\n                nextTrack.mode = mode;\n            }\n        }\n    }\n    /**\n   * This method is responsible for validating the subtitle index and periodically reloading if live.\n   * Dispatches the SUBTITLE_TRACK_SWITCH event, which instructs the subtitle-stream-controller to load the selected track.\n   */ setSubtitleTrack(newId) {\n        const tracks = this.tracksInGroup;\n        // setting this.subtitleTrack will trigger internal logic\n        // if media has not been attached yet, it will fail\n        // we keep a reference to the default track id\n        // and we'll set subtitleTrack when onMediaAttached is triggered\n        if (!this.media) {\n            this.queuedDefaultTrack = newId;\n            return;\n        }\n        // exit if track id as already set or invalid\n        if (newId < -1 || newId >= tracks.length || !isFiniteNumber(newId)) {\n            this.warn(`Invalid subtitle track id: ${newId}`);\n            return;\n        }\n        // stopping live reloading timer if any\n        this.clearTimer();\n        this.selectDefaultTrack = false;\n        const lastTrack = this.currentTrack;\n        const track = tracks[newId] || null;\n        this.trackId = newId;\n        this.currentTrack = track;\n        this.toggleTrackModes();\n        if (!track) {\n            // switch to -1\n            this.hls.trigger(Events.SUBTITLE_TRACK_SWITCH, {\n                id: newId\n            });\n            return;\n        }\n        const trackLoaded = !!track.details && !track.details.live;\n        if (newId === this.trackId && track === lastTrack && trackLoaded) {\n            return;\n        }\n        this.log(`Switching to subtitle-track ${newId}` + (track ? ` \"${track.name}\" lang:${track.lang} group:${track.groupId}` : \"\"));\n        const { id, groupId = \"\", name, type, url } = track;\n        this.hls.trigger(Events.SUBTITLE_TRACK_SWITCH, {\n            id,\n            groupId,\n            name,\n            type,\n            url\n        });\n        const hlsUrlParameters = this.switchParams(track.url, lastTrack == null ? void 0 : lastTrack.details);\n        this.loadPlaylist(hlsUrlParameters);\n    }\n}\nclass BufferOperationQueue {\n    constructor(sourceBufferReference){\n        this.buffers = void 0;\n        this.queues = {\n            video: [],\n            audio: [],\n            audiovideo: []\n        };\n        this.buffers = sourceBufferReference;\n    }\n    append(operation, type, pending) {\n        const queue = this.queues[type];\n        queue.push(operation);\n        if (queue.length === 1 && !pending) {\n            this.executeNext(type);\n        }\n    }\n    insertAbort(operation, type) {\n        const queue = this.queues[type];\n        queue.unshift(operation);\n        this.executeNext(type);\n    }\n    appendBlocker(type) {\n        let execute;\n        const promise = new Promise((resolve)=>{\n            execute = resolve;\n        });\n        const operation = {\n            execute,\n            onStart: ()=>{},\n            onComplete: ()=>{},\n            onError: ()=>{}\n        };\n        this.append(operation, type);\n        return promise;\n    }\n    executeNext(type) {\n        const queue = this.queues[type];\n        if (queue.length) {\n            const operation = queue[0];\n            try {\n                // Operations are expected to result in an 'updateend' event being fired. If not, the queue will lock. Operations\n                // which do not end with this event must call _onSBUpdateEnd manually\n                operation.execute();\n            } catch (error) {\n                logger.warn(`[buffer-operation-queue]: Exception executing \"${type}\" SourceBuffer operation: ${error}`);\n                operation.onError(error);\n                // Only shift the current operation off, otherwise the updateend handler will do this for us\n                const sb = this.buffers[type];\n                if (!(sb != null && sb.updating)) {\n                    this.shiftAndExecuteNext(type);\n                }\n            }\n        }\n    }\n    shiftAndExecuteNext(type) {\n        this.queues[type].shift();\n        this.executeNext(type);\n    }\n    current(type) {\n        return this.queues[type][0];\n    }\n}\nconst VIDEO_CODEC_PROFILE_REPLACE = /(avc[1234]|hvc1|hev1|dvh[1e]|vp09|av01)(?:\\.[^.,]+)+/;\nclass BufferController {\n    constructor(hls){\n        // The level details used to determine duration, target-duration and live\n        this.details = null;\n        // cache the self generated object url to detect hijack of video tag\n        this._objectUrl = null;\n        // A queue of buffer operations which require the SourceBuffer to not be updating upon execution\n        this.operationQueue = void 0;\n        // References to event listeners for each SourceBuffer, so that they can be referenced for event removal\n        this.listeners = void 0;\n        this.hls = void 0;\n        // The number of BUFFER_CODEC events received before any sourceBuffers are created\n        this.bufferCodecEventsExpected = 0;\n        // The total number of BUFFER_CODEC events received\n        this._bufferCodecEventsTotal = 0;\n        // A reference to the attached media element\n        this.media = null;\n        // A reference to the active media source\n        this.mediaSource = null;\n        // Last MP3 audio chunk appended\n        this.lastMpegAudioChunk = null;\n        this.appendSource = void 0;\n        // counters\n        this.appendErrors = {\n            audio: 0,\n            video: 0,\n            audiovideo: 0\n        };\n        this.tracks = {};\n        this.pendingTracks = {};\n        this.sourceBuffer = void 0;\n        this.log = void 0;\n        this.warn = void 0;\n        this.error = void 0;\n        this._onEndStreaming = (event)=>{\n            if (!this.hls) {\n                return;\n            }\n            this.hls.pauseBuffering();\n        };\n        this._onStartStreaming = (event)=>{\n            if (!this.hls) {\n                return;\n            }\n            this.hls.resumeBuffering();\n        };\n        // Keep as arrow functions so that we can directly reference these functions directly as event listeners\n        this._onMediaSourceOpen = ()=>{\n            const { media, mediaSource } = this;\n            this.log(\"Media source opened\");\n            if (media) {\n                media.removeEventListener(\"emptied\", this._onMediaEmptied);\n                this.updateMediaElementDuration();\n                this.hls.trigger(Events.MEDIA_ATTACHED, {\n                    media,\n                    mediaSource: mediaSource\n                });\n            }\n            if (mediaSource) {\n                // once received, don't listen anymore to sourceopen event\n                mediaSource.removeEventListener(\"sourceopen\", this._onMediaSourceOpen);\n            }\n            this.checkPendingTracks();\n        };\n        this._onMediaSourceClose = ()=>{\n            this.log(\"Media source closed\");\n        };\n        this._onMediaSourceEnded = ()=>{\n            this.log(\"Media source ended\");\n        };\n        this._onMediaEmptied = ()=>{\n            const { mediaSrc, _objectUrl } = this;\n            if (mediaSrc !== _objectUrl) {\n                logger.error(`Media element src was set while attaching MediaSource (${_objectUrl} > ${mediaSrc})`);\n            }\n        };\n        this.hls = hls;\n        const logPrefix = \"[buffer-controller]\";\n        this.appendSource = hls.config.preferManagedMediaSource;\n        this.log = logger.log.bind(logger, logPrefix);\n        this.warn = logger.warn.bind(logger, logPrefix);\n        this.error = logger.error.bind(logger, logPrefix);\n        this._initSourceBuffer();\n        this.registerListeners();\n    }\n    hasSourceTypes() {\n        return this.getSourceBufferTypes().length > 0 || Object.keys(this.pendingTracks).length > 0;\n    }\n    destroy() {\n        this.unregisterListeners();\n        this.details = null;\n        this.lastMpegAudioChunk = null;\n        // @ts-ignore\n        this.hls = null;\n    }\n    registerListeners() {\n        const { hls } = this;\n        hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n        hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n        hls.on(Events.BUFFER_RESET, this.onBufferReset, this);\n        hls.on(Events.BUFFER_APPENDING, this.onBufferAppending, this);\n        hls.on(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n        hls.on(Events.BUFFER_EOS, this.onBufferEos, this);\n        hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n        hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n        hls.on(Events.FRAG_PARSED, this.onFragParsed, this);\n        hls.on(Events.FRAG_CHANGED, this.onFragChanged, this);\n    }\n    unregisterListeners() {\n        const { hls } = this;\n        hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n        hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n        hls.off(Events.BUFFER_RESET, this.onBufferReset, this);\n        hls.off(Events.BUFFER_APPENDING, this.onBufferAppending, this);\n        hls.off(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n        hls.off(Events.BUFFER_EOS, this.onBufferEos, this);\n        hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n        hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n        hls.off(Events.FRAG_PARSED, this.onFragParsed, this);\n        hls.off(Events.FRAG_CHANGED, this.onFragChanged, this);\n    }\n    _initSourceBuffer() {\n        this.sourceBuffer = {};\n        this.operationQueue = new BufferOperationQueue(this.sourceBuffer);\n        this.listeners = {\n            audio: [],\n            video: [],\n            audiovideo: []\n        };\n        this.appendErrors = {\n            audio: 0,\n            video: 0,\n            audiovideo: 0\n        };\n        this.lastMpegAudioChunk = null;\n    }\n    onManifestLoading() {\n        this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = 0;\n        this.details = null;\n    }\n    onManifestParsed(event, data) {\n        // in case of alt audio 2 BUFFER_CODECS events will be triggered, one per stream controller\n        // sourcebuffers will be created all at once when the expected nb of tracks will be reached\n        // in case alt audio is not used, only one BUFFER_CODEC event will be fired from main stream controller\n        // it will contain the expected nb of source buffers, no need to compute it\n        let codecEvents = 2;\n        if (data.audio && !data.video || !data.altAudio || !true) {\n            codecEvents = 1;\n        }\n        this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = codecEvents;\n        this.log(`${this.bufferCodecEventsExpected} bufferCodec event(s) expected`);\n    }\n    onMediaAttaching(event, data) {\n        const media = this.media = data.media;\n        const MediaSource = getMediaSource(this.appendSource);\n        if (media && MediaSource) {\n            var _ms$constructor;\n            const ms = this.mediaSource = new MediaSource();\n            this.log(`created media source: ${(_ms$constructor = ms.constructor) == null ? void 0 : _ms$constructor.name}`);\n            // MediaSource listeners are arrow functions with a lexical scope, and do not need to be bound\n            ms.addEventListener(\"sourceopen\", this._onMediaSourceOpen);\n            ms.addEventListener(\"sourceended\", this._onMediaSourceEnded);\n            ms.addEventListener(\"sourceclose\", this._onMediaSourceClose);\n            ms.addEventListener(\"startstreaming\", this._onStartStreaming);\n            ms.addEventListener(\"endstreaming\", this._onEndStreaming);\n            // cache the locally generated object url\n            const objectUrl = this._objectUrl = self.URL.createObjectURL(ms);\n            // link video and media Source\n            if (this.appendSource) {\n                try {\n                    media.removeAttribute(\"src\");\n                    // ManagedMediaSource will not open without disableRemotePlayback set to false or source alternatives\n                    const MMS = self.ManagedMediaSource;\n                    media.disableRemotePlayback = media.disableRemotePlayback || MMS && ms instanceof MMS;\n                    removeSourceChildren(media);\n                    addSource(media, objectUrl);\n                    media.load();\n                } catch (error) {\n                    media.src = objectUrl;\n                }\n            } else {\n                media.src = objectUrl;\n            }\n            media.addEventListener(\"emptied\", this._onMediaEmptied);\n        }\n    }\n    onMediaDetaching() {\n        const { media, mediaSource, _objectUrl } = this;\n        if (mediaSource) {\n            this.log(\"media source detaching\");\n            if (mediaSource.readyState === \"open\") {\n                try {\n                    // endOfStream could trigger exception if any sourcebuffer is in updating state\n                    // we don't really care about checking sourcebuffer state here,\n                    // as we are anyway detaching the MediaSource\n                    // let's just avoid this exception to propagate\n                    mediaSource.endOfStream();\n                } catch (err) {\n                    this.warn(`onMediaDetaching: ${err.message} while calling endOfStream`);\n                }\n            }\n            // Clean up the SourceBuffers by invoking onBufferReset\n            this.onBufferReset();\n            mediaSource.removeEventListener(\"sourceopen\", this._onMediaSourceOpen);\n            mediaSource.removeEventListener(\"sourceended\", this._onMediaSourceEnded);\n            mediaSource.removeEventListener(\"sourceclose\", this._onMediaSourceClose);\n            mediaSource.removeEventListener(\"startstreaming\", this._onStartStreaming);\n            mediaSource.removeEventListener(\"endstreaming\", this._onEndStreaming);\n            // Detach properly the MediaSource from the HTMLMediaElement as\n            // suggested in https://github.com/w3c/media-source/issues/53.\n            if (media) {\n                media.removeEventListener(\"emptied\", this._onMediaEmptied);\n                if (_objectUrl) {\n                    self.URL.revokeObjectURL(_objectUrl);\n                }\n                // clean up video tag src only if it's our own url. some external libraries might\n                // hijack the video tag and change its 'src' without destroying the Hls instance first\n                if (this.mediaSrc === _objectUrl) {\n                    media.removeAttribute(\"src\");\n                    if (this.appendSource) {\n                        removeSourceChildren(media);\n                    }\n                    media.load();\n                } else {\n                    this.warn(\"media|source.src was changed by a third party - skip cleanup\");\n                }\n            }\n            this.mediaSource = null;\n            this.media = null;\n            this._objectUrl = null;\n            this.bufferCodecEventsExpected = this._bufferCodecEventsTotal;\n            this.pendingTracks = {};\n            this.tracks = {};\n        }\n        this.hls.trigger(Events.MEDIA_DETACHED, undefined);\n    }\n    onBufferReset() {\n        this.getSourceBufferTypes().forEach((type)=>{\n            this.resetBuffer(type);\n        });\n        this._initSourceBuffer();\n    }\n    resetBuffer(type) {\n        const sb = this.sourceBuffer[type];\n        try {\n            if (sb) {\n                var _this$mediaSource;\n                this.removeBufferListeners(type);\n                // Synchronously remove the SB from the map before the next call in order to prevent an async function from\n                // accessing it\n                this.sourceBuffer[type] = undefined;\n                if ((_this$mediaSource = this.mediaSource) != null && _this$mediaSource.sourceBuffers.length) {\n                    this.mediaSource.removeSourceBuffer(sb);\n                }\n            }\n        } catch (err) {\n            this.warn(`onBufferReset ${type}`, err);\n        }\n    }\n    onBufferCodecs(event, data) {\n        const sourceBufferCount = this.getSourceBufferTypes().length;\n        const trackNames = Object.keys(data);\n        trackNames.forEach((trackName)=>{\n            if (sourceBufferCount) {\n                // check if SourceBuffer codec needs to change\n                const track = this.tracks[trackName];\n                if (track && typeof track.buffer.changeType === \"function\") {\n                    var _trackCodec;\n                    const { id, codec, levelCodec, container, metadata } = data[trackName];\n                    const currentCodecFull = pickMostCompleteCodecName(track.codec, track.levelCodec);\n                    const currentCodec = currentCodecFull == null ? void 0 : currentCodecFull.replace(VIDEO_CODEC_PROFILE_REPLACE, \"$1\");\n                    let trackCodec = pickMostCompleteCodecName(codec, levelCodec);\n                    const nextCodec = (_trackCodec = trackCodec) == null ? void 0 : _trackCodec.replace(VIDEO_CODEC_PROFILE_REPLACE, \"$1\");\n                    if (trackCodec && currentCodec !== nextCodec) {\n                        if (trackName.slice(0, 5) === \"audio\") {\n                            trackCodec = getCodecCompatibleName(trackCodec, this.hls.config.preferManagedMediaSource);\n                        }\n                        const mimeType = `${container};codecs=${trackCodec}`;\n                        this.appendChangeType(trackName, mimeType);\n                        this.log(`switching codec ${currentCodecFull} to ${trackCodec}`);\n                        this.tracks[trackName] = {\n                            buffer: track.buffer,\n                            codec,\n                            container,\n                            levelCodec,\n                            metadata,\n                            id\n                        };\n                    }\n                }\n            } else {\n                // if source buffer(s) not created yet, appended buffer tracks in this.pendingTracks\n                this.pendingTracks[trackName] = data[trackName];\n            }\n        });\n        // if sourcebuffers already created, do nothing ...\n        if (sourceBufferCount) {\n            return;\n        }\n        const bufferCodecEventsExpected = Math.max(this.bufferCodecEventsExpected - 1, 0);\n        if (this.bufferCodecEventsExpected !== bufferCodecEventsExpected) {\n            this.log(`${bufferCodecEventsExpected} bufferCodec event(s) expected ${trackNames.join(\",\")}`);\n            this.bufferCodecEventsExpected = bufferCodecEventsExpected;\n        }\n        if (this.mediaSource && this.mediaSource.readyState === \"open\") {\n            this.checkPendingTracks();\n        }\n    }\n    appendChangeType(type, mimeType) {\n        const { operationQueue } = this;\n        const operation = {\n            execute: ()=>{\n                const sb = this.sourceBuffer[type];\n                if (sb) {\n                    this.log(`changing ${type} sourceBuffer type to ${mimeType}`);\n                    sb.changeType(mimeType);\n                }\n                operationQueue.shiftAndExecuteNext(type);\n            },\n            onStart: ()=>{},\n            onComplete: ()=>{},\n            onError: (error)=>{\n                this.warn(`Failed to change ${type} SourceBuffer type`, error);\n            }\n        };\n        operationQueue.append(operation, type, !!this.pendingTracks[type]);\n    }\n    onBufferAppending(event, eventData) {\n        const { hls, operationQueue, tracks } = this;\n        const { data, type, frag, part, chunkMeta } = eventData;\n        const chunkStats = chunkMeta.buffering[type];\n        const bufferAppendingStart = self.performance.now();\n        chunkStats.start = bufferAppendingStart;\n        const fragBuffering = frag.stats.buffering;\n        const partBuffering = part ? part.stats.buffering : null;\n        if (fragBuffering.start === 0) {\n            fragBuffering.start = bufferAppendingStart;\n        }\n        if (partBuffering && partBuffering.start === 0) {\n            partBuffering.start = bufferAppendingStart;\n        }\n        // TODO: Only update timestampOffset when audio/mpeg fragment or part is not contiguous with previously appended\n        // Adjusting `SourceBuffer.timestampOffset` (desired point in the timeline where the next frames should be appended)\n        // in Chrome browser when we detect MPEG audio container and time delta between level PTS and `SourceBuffer.timestampOffset`\n        // is greater than 100ms (this is enough to handle seek for VOD or level change for LIVE videos).\n        // More info here: https://github.com/video-dev/hls.js/issues/332#issuecomment-257986486\n        const audioTrack = tracks.audio;\n        let checkTimestampOffset = false;\n        if (type === \"audio\" && (audioTrack == null ? void 0 : audioTrack.container) === \"audio/mpeg\") {\n            checkTimestampOffset = !this.lastMpegAudioChunk || chunkMeta.id === 1 || this.lastMpegAudioChunk.sn !== chunkMeta.sn;\n            this.lastMpegAudioChunk = chunkMeta;\n        }\n        const fragStart = frag.start;\n        const operation = {\n            execute: ()=>{\n                chunkStats.executeStart = self.performance.now();\n                if (checkTimestampOffset) {\n                    const sb = this.sourceBuffer[type];\n                    if (sb) {\n                        const delta = fragStart - sb.timestampOffset;\n                        if (Math.abs(delta) >= 0.1) {\n                            this.log(`Updating audio SourceBuffer timestampOffset to ${fragStart} (delta: ${delta}) sn: ${frag.sn})`);\n                            sb.timestampOffset = fragStart;\n                        }\n                    }\n                }\n                this.appendExecutor(data, type);\n            },\n            onStart: ()=>{\n            // logger.debug(`[buffer-controller]: ${type} SourceBuffer updatestart`);\n            },\n            onComplete: ()=>{\n                // logger.debug(`[buffer-controller]: ${type} SourceBuffer updateend`);\n                const end = self.performance.now();\n                chunkStats.executeEnd = chunkStats.end = end;\n                if (fragBuffering.first === 0) {\n                    fragBuffering.first = end;\n                }\n                if (partBuffering && partBuffering.first === 0) {\n                    partBuffering.first = end;\n                }\n                const { sourceBuffer } = this;\n                const timeRanges = {};\n                for(const type in sourceBuffer){\n                    timeRanges[type] = BufferHelper.getBuffered(sourceBuffer[type]);\n                }\n                this.appendErrors[type] = 0;\n                if (type === \"audio\" || type === \"video\") {\n                    this.appendErrors.audiovideo = 0;\n                } else {\n                    this.appendErrors.audio = 0;\n                    this.appendErrors.video = 0;\n                }\n                this.hls.trigger(Events.BUFFER_APPENDED, {\n                    type,\n                    frag,\n                    part,\n                    chunkMeta,\n                    parent: frag.type,\n                    timeRanges\n                });\n            },\n            onError: (error)=>{\n                // in case any error occured while appending, put back segment in segments table\n                const event = {\n                    type: ErrorTypes.MEDIA_ERROR,\n                    parent: frag.type,\n                    details: ErrorDetails.BUFFER_APPEND_ERROR,\n                    sourceBufferName: type,\n                    frag,\n                    part,\n                    chunkMeta,\n                    error,\n                    err: error,\n                    fatal: false\n                };\n                if (error.code === DOMException.QUOTA_EXCEEDED_ERR) {\n                    // QuotaExceededError: http://www.w3.org/TR/html5/infrastructure.html#quotaexceedederror\n                    // let's stop appending any segments, and report BUFFER_FULL_ERROR error\n                    event.details = ErrorDetails.BUFFER_FULL_ERROR;\n                } else {\n                    const appendErrorCount = ++this.appendErrors[type];\n                    event.details = ErrorDetails.BUFFER_APPEND_ERROR;\n                    /* with UHD content, we could get loop of quota exceeded error until\n            browser is able to evict some data from sourcebuffer. Retrying can help recover.\n          */ this.warn(`Failed ${appendErrorCount}/${hls.config.appendErrorMaxRetry} times to append segment in \"${type}\" sourceBuffer`);\n                    if (appendErrorCount >= hls.config.appendErrorMaxRetry) {\n                        event.fatal = true;\n                    }\n                }\n                hls.trigger(Events.ERROR, event);\n            }\n        };\n        operationQueue.append(operation, type, !!this.pendingTracks[type]);\n    }\n    onBufferFlushing(event, data) {\n        const { operationQueue } = this;\n        const flushOperation = (type)=>({\n                execute: this.removeExecutor.bind(this, type, data.startOffset, data.endOffset),\n                onStart: ()=>{\n                // logger.debug(`[buffer-controller]: Started flushing ${data.startOffset} -> ${data.endOffset} for ${type} Source Buffer`);\n                },\n                onComplete: ()=>{\n                    // logger.debug(`[buffer-controller]: Finished flushing ${data.startOffset} -> ${data.endOffset} for ${type} Source Buffer`);\n                    this.hls.trigger(Events.BUFFER_FLUSHED, {\n                        type\n                    });\n                },\n                onError: (error)=>{\n                    this.warn(`Failed to remove from ${type} SourceBuffer`, error);\n                }\n            });\n        if (data.type) {\n            operationQueue.append(flushOperation(data.type), data.type);\n        } else {\n            this.getSourceBufferTypes().forEach((type)=>{\n                operationQueue.append(flushOperation(type), type);\n            });\n        }\n    }\n    onFragParsed(event, data) {\n        const { frag, part } = data;\n        const buffersAppendedTo = [];\n        const elementaryStreams = part ? part.elementaryStreams : frag.elementaryStreams;\n        if (elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO]) {\n            buffersAppendedTo.push(\"audiovideo\");\n        } else {\n            if (elementaryStreams[ElementaryStreamTypes.AUDIO]) {\n                buffersAppendedTo.push(\"audio\");\n            }\n            if (elementaryStreams[ElementaryStreamTypes.VIDEO]) {\n                buffersAppendedTo.push(\"video\");\n            }\n        }\n        const onUnblocked = ()=>{\n            const now = self.performance.now();\n            frag.stats.buffering.end = now;\n            if (part) {\n                part.stats.buffering.end = now;\n            }\n            const stats = part ? part.stats : frag.stats;\n            this.hls.trigger(Events.FRAG_BUFFERED, {\n                frag,\n                part,\n                stats,\n                id: frag.type\n            });\n        };\n        if (buffersAppendedTo.length === 0) {\n            this.warn(`Fragments must have at least one ElementaryStreamType set. type: ${frag.type} level: ${frag.level} sn: ${frag.sn}`);\n        }\n        this.blockBuffers(onUnblocked, buffersAppendedTo);\n    }\n    onFragChanged(event, data) {\n        this.trimBuffers();\n    }\n    // on BUFFER_EOS mark matching sourcebuffer(s) as ended and trigger checkEos()\n    // an undefined data.type will mark all buffers as EOS.\n    onBufferEos(event, data) {\n        const ended = this.getSourceBufferTypes().reduce((acc, type)=>{\n            const sb = this.sourceBuffer[type];\n            if (sb && (!data.type || data.type === type)) {\n                sb.ending = true;\n                if (!sb.ended) {\n                    sb.ended = true;\n                    this.log(`${type} sourceBuffer now EOS`);\n                }\n            }\n            return acc && !!(!sb || sb.ended);\n        }, true);\n        if (ended) {\n            this.log(`Queueing mediaSource.endOfStream()`);\n            this.blockBuffers(()=>{\n                this.getSourceBufferTypes().forEach((type)=>{\n                    const sb = this.sourceBuffer[type];\n                    if (sb) {\n                        sb.ending = false;\n                    }\n                });\n                const { mediaSource } = this;\n                if (!mediaSource || mediaSource.readyState !== \"open\") {\n                    if (mediaSource) {\n                        this.log(`Could not call mediaSource.endOfStream(). mediaSource.readyState: ${mediaSource.readyState}`);\n                    }\n                    return;\n                }\n                this.log(`Calling mediaSource.endOfStream()`);\n                // Allow this to throw and be caught by the enqueueing function\n                mediaSource.endOfStream();\n            });\n        }\n    }\n    onLevelUpdated(event, { details }) {\n        if (!details.fragments.length) {\n            return;\n        }\n        this.details = details;\n        if (this.getSourceBufferTypes().length) {\n            this.blockBuffers(this.updateMediaElementDuration.bind(this));\n        } else {\n            this.updateMediaElementDuration();\n        }\n    }\n    trimBuffers() {\n        const { hls, details, media } = this;\n        if (!media || details === null) {\n            return;\n        }\n        const sourceBufferTypes = this.getSourceBufferTypes();\n        if (!sourceBufferTypes.length) {\n            return;\n        }\n        const config = hls.config;\n        const currentTime = media.currentTime;\n        const targetDuration = details.levelTargetDuration;\n        // Support for deprecated liveBackBufferLength\n        const backBufferLength = details.live && config.liveBackBufferLength !== null ? config.liveBackBufferLength : config.backBufferLength;\n        if (isFiniteNumber(backBufferLength) && backBufferLength > 0) {\n            const maxBackBufferLength = Math.max(backBufferLength, targetDuration);\n            const targetBackBufferPosition = Math.floor(currentTime / targetDuration) * targetDuration - maxBackBufferLength;\n            this.flushBackBuffer(currentTime, targetDuration, targetBackBufferPosition);\n        }\n        if (isFiniteNumber(config.frontBufferFlushThreshold) && config.frontBufferFlushThreshold > 0) {\n            const frontBufferLength = Math.max(config.maxBufferLength, config.frontBufferFlushThreshold);\n            const maxFrontBufferLength = Math.max(frontBufferLength, targetDuration);\n            const targetFrontBufferPosition = Math.floor(currentTime / targetDuration) * targetDuration + maxFrontBufferLength;\n            this.flushFrontBuffer(currentTime, targetDuration, targetFrontBufferPosition);\n        }\n    }\n    flushBackBuffer(currentTime, targetDuration, targetBackBufferPosition) {\n        const { details, sourceBuffer } = this;\n        const sourceBufferTypes = this.getSourceBufferTypes();\n        sourceBufferTypes.forEach((type)=>{\n            const sb = sourceBuffer[type];\n            if (sb) {\n                const buffered = BufferHelper.getBuffered(sb);\n                // when target buffer start exceeds actual buffer start\n                if (buffered.length > 0 && targetBackBufferPosition > buffered.start(0)) {\n                    this.hls.trigger(Events.BACK_BUFFER_REACHED, {\n                        bufferEnd: targetBackBufferPosition\n                    });\n                    // Support for deprecated event:\n                    if (details != null && details.live) {\n                        this.hls.trigger(Events.LIVE_BACK_BUFFER_REACHED, {\n                            bufferEnd: targetBackBufferPosition\n                        });\n                    } else if (sb.ended && buffered.end(buffered.length - 1) - currentTime < targetDuration * 2) {\n                        this.log(`Cannot flush ${type} back buffer while SourceBuffer is in ended state`);\n                        return;\n                    }\n                    this.hls.trigger(Events.BUFFER_FLUSHING, {\n                        startOffset: 0,\n                        endOffset: targetBackBufferPosition,\n                        type\n                    });\n                }\n            }\n        });\n    }\n    flushFrontBuffer(currentTime, targetDuration, targetFrontBufferPosition) {\n        const { sourceBuffer } = this;\n        const sourceBufferTypes = this.getSourceBufferTypes();\n        sourceBufferTypes.forEach((type)=>{\n            const sb = sourceBuffer[type];\n            if (sb) {\n                const buffered = BufferHelper.getBuffered(sb);\n                const numBufferedRanges = buffered.length;\n                // The buffer is either empty or contiguous\n                if (numBufferedRanges < 2) {\n                    return;\n                }\n                const bufferStart = buffered.start(numBufferedRanges - 1);\n                const bufferEnd = buffered.end(numBufferedRanges - 1);\n                // No flush if we can tolerate the current buffer length or the current buffer range we would flush is contiguous with current position\n                if (targetFrontBufferPosition > bufferStart || currentTime >= bufferStart && currentTime <= bufferEnd) {\n                    return;\n                } else if (sb.ended && currentTime - bufferEnd < 2 * targetDuration) {\n                    this.log(`Cannot flush ${type} front buffer while SourceBuffer is in ended state`);\n                    return;\n                }\n                this.hls.trigger(Events.BUFFER_FLUSHING, {\n                    startOffset: bufferStart,\n                    endOffset: Infinity,\n                    type\n                });\n            }\n        });\n    }\n    /**\n   * Update Media Source duration to current level duration or override to Infinity if configuration parameter\n   * 'liveDurationInfinity` is set to `true`\n   * More details: https://github.com/video-dev/hls.js/issues/355\n   */ updateMediaElementDuration() {\n        if (!this.details || !this.media || !this.mediaSource || this.mediaSource.readyState !== \"open\") {\n            return;\n        }\n        const { details, hls, media, mediaSource } = this;\n        const levelDuration = details.fragments[0].start + details.totalduration;\n        const mediaDuration = media.duration;\n        const msDuration = isFiniteNumber(mediaSource.duration) ? mediaSource.duration : 0;\n        if (details.live && hls.config.liveDurationInfinity) {\n            // Override duration to Infinity\n            mediaSource.duration = Infinity;\n            this.updateSeekableRange(details);\n        } else if (levelDuration > msDuration && levelDuration > mediaDuration || !isFiniteNumber(mediaDuration)) {\n            // levelDuration was the last value we set.\n            // not using mediaSource.duration as the browser may tweak this value\n            // only update Media Source duration if its value increase, this is to avoid\n            // flushing already buffered portion when switching between quality level\n            this.log(`Updating Media Source duration to ${levelDuration.toFixed(3)}`);\n            mediaSource.duration = levelDuration;\n        }\n    }\n    updateSeekableRange(levelDetails) {\n        const mediaSource = this.mediaSource;\n        const fragments = levelDetails.fragments;\n        const len = fragments.length;\n        if (len && levelDetails.live && mediaSource != null && mediaSource.setLiveSeekableRange) {\n            const start = Math.max(0, fragments[0].start);\n            const end = Math.max(start, start + levelDetails.totalduration);\n            this.log(`Media Source duration is set to ${mediaSource.duration}. Setting seekable range to ${start}-${end}.`);\n            mediaSource.setLiveSeekableRange(start, end);\n        }\n    }\n    checkPendingTracks() {\n        const { bufferCodecEventsExpected, operationQueue, pendingTracks } = this;\n        // Check if we've received all of the expected bufferCodec events. When none remain, create all the sourceBuffers at once.\n        // This is important because the MSE spec allows implementations to throw QuotaExceededErrors if creating new sourceBuffers after\n        // data has been appended to existing ones.\n        // 2 tracks is the max (one for audio, one for video). If we've reach this max go ahead and create the buffers.\n        const pendingTracksCount = Object.keys(pendingTracks).length;\n        if (pendingTracksCount && (!bufferCodecEventsExpected || pendingTracksCount === 2 || \"audiovideo\" in pendingTracks)) {\n            // ok, let's create them now !\n            this.createSourceBuffers(pendingTracks);\n            this.pendingTracks = {};\n            // append any pending segments now !\n            const buffers = this.getSourceBufferTypes();\n            if (buffers.length) {\n                this.hls.trigger(Events.BUFFER_CREATED, {\n                    tracks: this.tracks\n                });\n                buffers.forEach((type)=>{\n                    operationQueue.executeNext(type);\n                });\n            } else {\n                const error = new Error(\"could not create source buffer for media codec(s)\");\n                this.hls.trigger(Events.ERROR, {\n                    type: ErrorTypes.MEDIA_ERROR,\n                    details: ErrorDetails.BUFFER_INCOMPATIBLE_CODECS_ERROR,\n                    fatal: true,\n                    error,\n                    reason: error.message\n                });\n            }\n        }\n    }\n    createSourceBuffers(tracks) {\n        const { sourceBuffer, mediaSource } = this;\n        if (!mediaSource) {\n            throw Error(\"createSourceBuffers called when mediaSource was null\");\n        }\n        for(const trackName in tracks){\n            if (!sourceBuffer[trackName]) {\n                const track = tracks[trackName];\n                if (!track) {\n                    throw Error(`source buffer exists for track ${trackName}, however track does not`);\n                }\n                // use levelCodec as first priority\n                let codec = track.levelCodec || track.codec;\n                if (codec) {\n                    if (trackName.slice(0, 5) === \"audio\") {\n                        codec = getCodecCompatibleName(codec, this.hls.config.preferManagedMediaSource);\n                    }\n                }\n                const mimeType = `${track.container};codecs=${codec}`;\n                this.log(`creating sourceBuffer(${mimeType})`);\n                try {\n                    const sb = sourceBuffer[trackName] = mediaSource.addSourceBuffer(mimeType);\n                    const sbName = trackName;\n                    this.addBufferListener(sbName, \"updatestart\", this._onSBUpdateStart);\n                    this.addBufferListener(sbName, \"updateend\", this._onSBUpdateEnd);\n                    this.addBufferListener(sbName, \"error\", this._onSBUpdateError);\n                    // ManagedSourceBuffer bufferedchange event\n                    this.addBufferListener(sbName, \"bufferedchange\", (type, event)=>{\n                        // If media was ejected check for a change. Added ranges are redundant with changes on 'updateend' event.\n                        const removedRanges = event.removedRanges;\n                        if (removedRanges != null && removedRanges.length) {\n                            this.hls.trigger(Events.BUFFER_FLUSHED, {\n                                type: trackName\n                            });\n                        }\n                    });\n                    this.tracks[trackName] = {\n                        buffer: sb,\n                        codec: codec,\n                        container: track.container,\n                        levelCodec: track.levelCodec,\n                        metadata: track.metadata,\n                        id: track.id\n                    };\n                } catch (err) {\n                    this.error(`error while trying to add sourceBuffer: ${err.message}`);\n                    this.hls.trigger(Events.ERROR, {\n                        type: ErrorTypes.MEDIA_ERROR,\n                        details: ErrorDetails.BUFFER_ADD_CODEC_ERROR,\n                        fatal: false,\n                        error: err,\n                        sourceBufferName: trackName,\n                        mimeType: mimeType\n                    });\n                }\n            }\n        }\n    }\n    get mediaSrc() {\n        var _this$media;\n        const media = ((_this$media = this.media) == null ? void 0 : _this$media.firstChild) || this.media;\n        return media == null ? void 0 : media.src;\n    }\n    _onSBUpdateStart(type) {\n        const { operationQueue } = this;\n        const operation = operationQueue.current(type);\n        operation.onStart();\n    }\n    _onSBUpdateEnd(type) {\n        var _this$mediaSource2;\n        if (((_this$mediaSource2 = this.mediaSource) == null ? void 0 : _this$mediaSource2.readyState) === \"closed\") {\n            this.resetBuffer(type);\n            return;\n        }\n        const { operationQueue } = this;\n        const operation = operationQueue.current(type);\n        operation.onComplete();\n        operationQueue.shiftAndExecuteNext(type);\n    }\n    _onSBUpdateError(type, event) {\n        var _this$mediaSource3;\n        const error = new Error(`${type} SourceBuffer error. MediaSource readyState: ${(_this$mediaSource3 = this.mediaSource) == null ? void 0 : _this$mediaSource3.readyState}`);\n        this.error(`${error}`, event);\n        // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error\n        // SourceBuffer errors are not necessarily fatal; if so, the HTMLMediaElement will fire an error event\n        this.hls.trigger(Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.BUFFER_APPENDING_ERROR,\n            sourceBufferName: type,\n            error,\n            fatal: false\n        });\n        // updateend is always fired after error, so we'll allow that to shift the current operation off of the queue\n        const operation = this.operationQueue.current(type);\n        if (operation) {\n            operation.onError(error);\n        }\n    }\n    // This method must result in an updateend event; if remove is not called, _onSBUpdateEnd must be called manually\n    removeExecutor(type, startOffset, endOffset) {\n        const { media, mediaSource, operationQueue, sourceBuffer } = this;\n        const sb = sourceBuffer[type];\n        if (!media || !mediaSource || !sb) {\n            this.warn(`Attempting to remove from the ${type} SourceBuffer, but it does not exist`);\n            operationQueue.shiftAndExecuteNext(type);\n            return;\n        }\n        const mediaDuration = isFiniteNumber(media.duration) ? media.duration : Infinity;\n        const msDuration = isFiniteNumber(mediaSource.duration) ? mediaSource.duration : Infinity;\n        const removeStart = Math.max(0, startOffset);\n        const removeEnd = Math.min(endOffset, mediaDuration, msDuration);\n        if (removeEnd > removeStart && (!sb.ending || sb.ended)) {\n            sb.ended = false;\n            this.log(`Removing [${removeStart},${removeEnd}] from the ${type} SourceBuffer`);\n            sb.remove(removeStart, removeEnd);\n        } else {\n            // Cycle the queue\n            operationQueue.shiftAndExecuteNext(type);\n        }\n    }\n    // This method must result in an updateend event; if append is not called, _onSBUpdateEnd must be called manually\n    appendExecutor(data, type) {\n        const sb = this.sourceBuffer[type];\n        if (!sb) {\n            if (!this.pendingTracks[type]) {\n                throw new Error(`Attempting to append to the ${type} SourceBuffer, but it does not exist`);\n            }\n            return;\n        }\n        sb.ended = false;\n        sb.appendBuffer(data);\n    }\n    // Enqueues an operation to each SourceBuffer queue which, upon execution, resolves a promise. When all promises\n    // resolve, the onUnblocked function is executed. Functions calling this method do not need to unblock the queue\n    // upon completion, since we already do it here\n    blockBuffers(onUnblocked, buffers = this.getSourceBufferTypes()) {\n        if (!buffers.length) {\n            this.log(\"Blocking operation requested, but no SourceBuffers exist\");\n            Promise.resolve().then(onUnblocked);\n            return;\n        }\n        const { operationQueue } = this;\n        // logger.debug(`[buffer-controller]: Blocking ${buffers} SourceBuffer`);\n        const blockingOperations = buffers.map((type)=>operationQueue.appendBlocker(type));\n        Promise.all(blockingOperations).then(()=>{\n            // logger.debug(`[buffer-controller]: Blocking operation resolved; unblocking ${buffers} SourceBuffer`);\n            onUnblocked();\n            buffers.forEach((type)=>{\n                const sb = this.sourceBuffer[type];\n                // Only cycle the queue if the SB is not updating. There's a bug in Chrome which sets the SB updating flag to\n                // true when changing the MediaSource duration (https://bugs.chromium.org/p/chromium/issues/detail?id=959359&can=2&q=mediasource%20duration)\n                // While this is a workaround, it's probably useful to have around\n                if (!(sb != null && sb.updating)) {\n                    operationQueue.shiftAndExecuteNext(type);\n                }\n            });\n        });\n    }\n    getSourceBufferTypes() {\n        return Object.keys(this.sourceBuffer);\n    }\n    addBufferListener(type, event, fn) {\n        const buffer = this.sourceBuffer[type];\n        if (!buffer) {\n            return;\n        }\n        const listener = fn.bind(this, type);\n        this.listeners[type].push({\n            event,\n            listener\n        });\n        buffer.addEventListener(event, listener);\n    }\n    removeBufferListeners(type) {\n        const buffer = this.sourceBuffer[type];\n        if (!buffer) {\n            return;\n        }\n        this.listeners[type].forEach((l)=>{\n            buffer.removeEventListener(l.event, l.listener);\n        });\n    }\n}\nfunction removeSourceChildren(node) {\n    const sourceChildren = node.querySelectorAll(\"source\");\n    [].slice.call(sourceChildren).forEach((source)=>{\n        node.removeChild(source);\n    });\n}\nfunction addSource(media, url) {\n    const source = self.document.createElement(\"source\");\n    source.type = \"video/mp4\";\n    source.src = url;\n    media.appendChild(source);\n}\n/**\n *\n * This code was ported from the dash.js project at:\n *   https://github.com/Dash-Industry-Forum/dash.js/blob/development/externals/cea608-parser.js\n *   https://github.com/Dash-Industry-Forum/dash.js/commit/8269b26a761e0853bb21d78780ed945144ecdd4d#diff-71bc295a2d6b6b7093a1d3290d53a4b2\n *\n * The original copyright appears below:\n *\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2015-2016, DASH Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  1. Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  2. Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */ /**\n *  Exceptions from regular ASCII. CodePoints are mapped to UTF-16 codes\n */ const specialCea608CharsCodes = {\n    0x2a: 0xe1,\n    // lowercase a, acute accent\n    0x5c: 0xe9,\n    // lowercase e, acute accent\n    0x5e: 0xed,\n    // lowercase i, acute accent\n    0x5f: 0xf3,\n    // lowercase o, acute accent\n    0x60: 0xfa,\n    // lowercase u, acute accent\n    0x7b: 0xe7,\n    // lowercase c with cedilla\n    0x7c: 0xf7,\n    // division symbol\n    0x7d: 0xd1,\n    // uppercase N tilde\n    0x7e: 0xf1,\n    // lowercase n tilde\n    0x7f: 0x2588,\n    // Full block\n    // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n    // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F\n    // THIS MEANS THAT \\x50 MUST BE ADDED TO THE VALUES\n    0x80: 0xae,\n    // Registered symbol (R)\n    0x81: 0xb0,\n    // degree sign\n    0x82: 0xbd,\n    // 1/2 symbol\n    0x83: 0xbf,\n    // Inverted (open) question mark\n    0x84: 0x2122,\n    // Trademark symbol (TM)\n    0x85: 0xa2,\n    // Cents symbol\n    0x86: 0xa3,\n    // Pounds sterling\n    0x87: 0x266a,\n    // Music 8'th note\n    0x88: 0xe0,\n    // lowercase a, grave accent\n    0x89: 0x20,\n    // transparent space (regular)\n    0x8a: 0xe8,\n    // lowercase e, grave accent\n    0x8b: 0xe2,\n    // lowercase a, circumflex accent\n    0x8c: 0xea,\n    // lowercase e, circumflex accent\n    0x8d: 0xee,\n    // lowercase i, circumflex accent\n    0x8e: 0xf4,\n    // lowercase o, circumflex accent\n    0x8f: 0xfb,\n    // lowercase u, circumflex accent\n    // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n    // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F\n    0x90: 0xc1,\n    // capital letter A with acute\n    0x91: 0xc9,\n    // capital letter E with acute\n    0x92: 0xd3,\n    // capital letter O with acute\n    0x93: 0xda,\n    // capital letter U with acute\n    0x94: 0xdc,\n    // capital letter U with diaresis\n    0x95: 0xfc,\n    // lowercase letter U with diaeresis\n    0x96: 0x2018,\n    // opening single quote\n    0x97: 0xa1,\n    // inverted exclamation mark\n    0x98: 0x2a,\n    // asterisk\n    0x99: 0x2019,\n    // closing single quote\n    0x9a: 0x2501,\n    // box drawings heavy horizontal\n    0x9b: 0xa9,\n    // copyright sign\n    0x9c: 0x2120,\n    // Service mark\n    0x9d: 0x2022,\n    // (round) bullet\n    0x9e: 0x201c,\n    // Left double quotation mark\n    0x9f: 0x201d,\n    // Right double quotation mark\n    0xa0: 0xc0,\n    // uppercase A, grave accent\n    0xa1: 0xc2,\n    // uppercase A, circumflex\n    0xa2: 0xc7,\n    // uppercase C with cedilla\n    0xa3: 0xc8,\n    // uppercase E, grave accent\n    0xa4: 0xca,\n    // uppercase E, circumflex\n    0xa5: 0xcb,\n    // capital letter E with diaresis\n    0xa6: 0xeb,\n    // lowercase letter e with diaresis\n    0xa7: 0xce,\n    // uppercase I, circumflex\n    0xa8: 0xcf,\n    // uppercase I, with diaresis\n    0xa9: 0xef,\n    // lowercase i, with diaresis\n    0xaa: 0xd4,\n    // uppercase O, circumflex\n    0xab: 0xd9,\n    // uppercase U, grave accent\n    0xac: 0xf9,\n    // lowercase u, grave accent\n    0xad: 0xdb,\n    // uppercase U, circumflex\n    0xae: 0xab,\n    // left-pointing double angle quotation mark\n    0xaf: 0xbb,\n    // right-pointing double angle quotation mark\n    // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n    // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F\n    0xb0: 0xc3,\n    // Uppercase A, tilde\n    0xb1: 0xe3,\n    // Lowercase a, tilde\n    0xb2: 0xcd,\n    // Uppercase I, acute accent\n    0xb3: 0xcc,\n    // Uppercase I, grave accent\n    0xb4: 0xec,\n    // Lowercase i, grave accent\n    0xb5: 0xd2,\n    // Uppercase O, grave accent\n    0xb6: 0xf2,\n    // Lowercase o, grave accent\n    0xb7: 0xd5,\n    // Uppercase O, tilde\n    0xb8: 0xf5,\n    // Lowercase o, tilde\n    0xb9: 0x7b,\n    // Open curly brace\n    0xba: 0x7d,\n    // Closing curly brace\n    0xbb: 0x5c,\n    // Backslash\n    0xbc: 0x5e,\n    // Caret\n    0xbd: 0x5f,\n    // Underscore\n    0xbe: 0x7c,\n    // Pipe (vertical line)\n    0xbf: 0x223c,\n    // Tilde operator\n    0xc0: 0xc4,\n    // Uppercase A, umlaut\n    0xc1: 0xe4,\n    // Lowercase A, umlaut\n    0xc2: 0xd6,\n    // Uppercase O, umlaut\n    0xc3: 0xf6,\n    // Lowercase o, umlaut\n    0xc4: 0xdf,\n    // Esszett (sharp S)\n    0xc5: 0xa5,\n    // Yen symbol\n    0xc6: 0xa4,\n    // Generic currency sign\n    0xc7: 0x2503,\n    // Box drawings heavy vertical\n    0xc8: 0xc5,\n    // Uppercase A, ring\n    0xc9: 0xe5,\n    // Lowercase A, ring\n    0xca: 0xd8,\n    // Uppercase O, stroke\n    0xcb: 0xf8,\n    // Lowercase o, strok\n    0xcc: 0x250f,\n    // Box drawings heavy down and right\n    0xcd: 0x2513,\n    // Box drawings heavy down and left\n    0xce: 0x2517,\n    // Box drawings heavy up and right\n    0xcf: 0x251b // Box drawings heavy up and left\n};\n/**\n * Utils\n */ const getCharForByte = function getCharForByte(byte) {\n    let charCode = byte;\n    if (specialCea608CharsCodes.hasOwnProperty(byte)) {\n        charCode = specialCea608CharsCodes[byte];\n    }\n    return String.fromCharCode(charCode);\n};\nconst NR_ROWS = 15;\nconst NR_COLS = 100;\n// Tables to look up row from PAC data\nconst rowsLowCh1 = {\n    0x11: 1,\n    0x12: 3,\n    0x15: 5,\n    0x16: 7,\n    0x17: 9,\n    0x10: 11,\n    0x13: 12,\n    0x14: 14\n};\nconst rowsHighCh1 = {\n    0x11: 2,\n    0x12: 4,\n    0x15: 6,\n    0x16: 8,\n    0x17: 10,\n    0x13: 13,\n    0x14: 15\n};\nconst rowsLowCh2 = {\n    0x19: 1,\n    0x1a: 3,\n    0x1d: 5,\n    0x1e: 7,\n    0x1f: 9,\n    0x18: 11,\n    0x1b: 12,\n    0x1c: 14\n};\nconst rowsHighCh2 = {\n    0x19: 2,\n    0x1a: 4,\n    0x1d: 6,\n    0x1e: 8,\n    0x1f: 10,\n    0x1b: 13,\n    0x1c: 15\n};\nconst backgroundColors = [\n    \"white\",\n    \"green\",\n    \"blue\",\n    \"cyan\",\n    \"red\",\n    \"yellow\",\n    \"magenta\",\n    \"black\",\n    \"transparent\"\n];\nclass CaptionsLogger {\n    constructor(){\n        this.time = null;\n        this.verboseLevel = 0;\n    }\n    log(severity, msg) {\n        if (this.verboseLevel >= severity) {\n            const m = typeof msg === \"function\" ? msg() : msg;\n            logger.log(`${this.time} [${severity}] ${m}`);\n        }\n    }\n}\nconst numArrayToHexArray = function numArrayToHexArray(numArray) {\n    const hexArray = [];\n    for(let j = 0; j < numArray.length; j++){\n        hexArray.push(numArray[j].toString(16));\n    }\n    return hexArray;\n};\nclass PenState {\n    constructor(){\n        this.foreground = \"white\";\n        this.underline = false;\n        this.italics = false;\n        this.background = \"black\";\n        this.flash = false;\n    }\n    reset() {\n        this.foreground = \"white\";\n        this.underline = false;\n        this.italics = false;\n        this.background = \"black\";\n        this.flash = false;\n    }\n    setStyles(styles) {\n        const attribs = [\n            \"foreground\",\n            \"underline\",\n            \"italics\",\n            \"background\",\n            \"flash\"\n        ];\n        for(let i = 0; i < attribs.length; i++){\n            const style = attribs[i];\n            if (styles.hasOwnProperty(style)) {\n                this[style] = styles[style];\n            }\n        }\n    }\n    isDefault() {\n        return this.foreground === \"white\" && !this.underline && !this.italics && this.background === \"black\" && !this.flash;\n    }\n    equals(other) {\n        return this.foreground === other.foreground && this.underline === other.underline && this.italics === other.italics && this.background === other.background && this.flash === other.flash;\n    }\n    copy(newPenState) {\n        this.foreground = newPenState.foreground;\n        this.underline = newPenState.underline;\n        this.italics = newPenState.italics;\n        this.background = newPenState.background;\n        this.flash = newPenState.flash;\n    }\n    toString() {\n        return \"color=\" + this.foreground + \", underline=\" + this.underline + \", italics=\" + this.italics + \", background=\" + this.background + \", flash=\" + this.flash;\n    }\n}\n/**\n * Unicode character with styling and background.\n * @constructor\n */ class StyledUnicodeChar {\n    constructor(){\n        this.uchar = \" \";\n        this.penState = new PenState();\n    }\n    reset() {\n        this.uchar = \" \";\n        this.penState.reset();\n    }\n    setChar(uchar, newPenState) {\n        this.uchar = uchar;\n        this.penState.copy(newPenState);\n    }\n    setPenState(newPenState) {\n        this.penState.copy(newPenState);\n    }\n    equals(other) {\n        return this.uchar === other.uchar && this.penState.equals(other.penState);\n    }\n    copy(newChar) {\n        this.uchar = newChar.uchar;\n        this.penState.copy(newChar.penState);\n    }\n    isEmpty() {\n        return this.uchar === \" \" && this.penState.isDefault();\n    }\n}\n/**\n * CEA-608 row consisting of NR_COLS instances of StyledUnicodeChar.\n * @constructor\n */ class Row {\n    constructor(logger){\n        this.chars = [];\n        this.pos = 0;\n        this.currPenState = new PenState();\n        this.cueStartTime = null;\n        this.logger = void 0;\n        for(let i = 0; i < NR_COLS; i++){\n            this.chars.push(new StyledUnicodeChar());\n        }\n        this.logger = logger;\n    }\n    equals(other) {\n        for(let i = 0; i < NR_COLS; i++){\n            if (!this.chars[i].equals(other.chars[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    copy(other) {\n        for(let i = 0; i < NR_COLS; i++){\n            this.chars[i].copy(other.chars[i]);\n        }\n    }\n    isEmpty() {\n        let empty = true;\n        for(let i = 0; i < NR_COLS; i++){\n            if (!this.chars[i].isEmpty()) {\n                empty = false;\n                break;\n            }\n        }\n        return empty;\n    }\n    /**\n   *  Set the cursor to a valid column.\n   */ setCursor(absPos) {\n        if (this.pos !== absPos) {\n            this.pos = absPos;\n        }\n        if (this.pos < 0) {\n            this.logger.log(3, \"Negative cursor position \" + this.pos);\n            this.pos = 0;\n        } else if (this.pos > NR_COLS) {\n            this.logger.log(3, \"Too large cursor position \" + this.pos);\n            this.pos = NR_COLS;\n        }\n    }\n    /**\n   * Move the cursor relative to current position.\n   */ moveCursor(relPos) {\n        const newPos = this.pos + relPos;\n        if (relPos > 1) {\n            for(let i = this.pos + 1; i < newPos + 1; i++){\n                this.chars[i].setPenState(this.currPenState);\n            }\n        }\n        this.setCursor(newPos);\n    }\n    /**\n   * Backspace, move one step back and clear character.\n   */ backSpace() {\n        this.moveCursor(-1);\n        this.chars[this.pos].setChar(\" \", this.currPenState);\n    }\n    insertChar(byte) {\n        if (byte >= 0x90) {\n            // Extended char\n            this.backSpace();\n        }\n        const char = getCharForByte(byte);\n        if (this.pos >= NR_COLS) {\n            this.logger.log(0, ()=>\"Cannot insert \" + byte.toString(16) + \" (\" + char + \") at position \" + this.pos + \". Skipping it!\");\n            return;\n        }\n        this.chars[this.pos].setChar(char, this.currPenState);\n        this.moveCursor(1);\n    }\n    clearFromPos(startPos) {\n        let i;\n        for(i = startPos; i < NR_COLS; i++){\n            this.chars[i].reset();\n        }\n    }\n    clear() {\n        this.clearFromPos(0);\n        this.pos = 0;\n        this.currPenState.reset();\n    }\n    clearToEndOfRow() {\n        this.clearFromPos(this.pos);\n    }\n    getTextString() {\n        const chars = [];\n        let empty = true;\n        for(let i = 0; i < NR_COLS; i++){\n            const char = this.chars[i].uchar;\n            if (char !== \" \") {\n                empty = false;\n            }\n            chars.push(char);\n        }\n        if (empty) {\n            return \"\";\n        } else {\n            return chars.join(\"\");\n        }\n    }\n    setPenStyles(styles) {\n        this.currPenState.setStyles(styles);\n        const currChar = this.chars[this.pos];\n        currChar.setPenState(this.currPenState);\n    }\n}\n/**\n * Keep a CEA-608 screen of 32x15 styled characters\n * @constructor\n */ class CaptionScreen {\n    constructor(logger){\n        this.rows = [];\n        this.currRow = NR_ROWS - 1;\n        this.nrRollUpRows = null;\n        this.lastOutputScreen = null;\n        this.logger = void 0;\n        for(let i = 0; i < NR_ROWS; i++){\n            this.rows.push(new Row(logger));\n        }\n        this.logger = logger;\n    }\n    reset() {\n        for(let i = 0; i < NR_ROWS; i++){\n            this.rows[i].clear();\n        }\n        this.currRow = NR_ROWS - 1;\n    }\n    equals(other) {\n        let equal = true;\n        for(let i = 0; i < NR_ROWS; i++){\n            if (!this.rows[i].equals(other.rows[i])) {\n                equal = false;\n                break;\n            }\n        }\n        return equal;\n    }\n    copy(other) {\n        for(let i = 0; i < NR_ROWS; i++){\n            this.rows[i].copy(other.rows[i]);\n        }\n    }\n    isEmpty() {\n        let empty = true;\n        for(let i = 0; i < NR_ROWS; i++){\n            if (!this.rows[i].isEmpty()) {\n                empty = false;\n                break;\n            }\n        }\n        return empty;\n    }\n    backSpace() {\n        const row = this.rows[this.currRow];\n        row.backSpace();\n    }\n    clearToEndOfRow() {\n        const row = this.rows[this.currRow];\n        row.clearToEndOfRow();\n    }\n    /**\n   * Insert a character (without styling) in the current row.\n   */ insertChar(char) {\n        const row = this.rows[this.currRow];\n        row.insertChar(char);\n    }\n    setPen(styles) {\n        const row = this.rows[this.currRow];\n        row.setPenStyles(styles);\n    }\n    moveCursor(relPos) {\n        const row = this.rows[this.currRow];\n        row.moveCursor(relPos);\n    }\n    setCursor(absPos) {\n        this.logger.log(2, \"setCursor: \" + absPos);\n        const row = this.rows[this.currRow];\n        row.setCursor(absPos);\n    }\n    setPAC(pacData) {\n        this.logger.log(2, ()=>\"pacData = \" + JSON.stringify(pacData));\n        let newRow = pacData.row - 1;\n        if (this.nrRollUpRows && newRow < this.nrRollUpRows - 1) {\n            newRow = this.nrRollUpRows - 1;\n        }\n        // Make sure this only affects Roll-up Captions by checking this.nrRollUpRows\n        if (this.nrRollUpRows && this.currRow !== newRow) {\n            // clear all rows first\n            for(let i = 0; i < NR_ROWS; i++){\n                this.rows[i].clear();\n            }\n            // Copy this.nrRollUpRows rows from lastOutputScreen and place it in the newRow location\n            // topRowIndex - the start of rows to copy (inclusive index)\n            const topRowIndex = this.currRow + 1 - this.nrRollUpRows;\n            // We only copy if the last position was already shown.\n            // We use the cueStartTime value to check this.\n            const lastOutputScreen = this.lastOutputScreen;\n            if (lastOutputScreen) {\n                const prevLineTime = lastOutputScreen.rows[topRowIndex].cueStartTime;\n                const time = this.logger.time;\n                if (prevLineTime !== null && time !== null && prevLineTime < time) {\n                    for(let i = 0; i < this.nrRollUpRows; i++){\n                        this.rows[newRow - this.nrRollUpRows + i + 1].copy(lastOutputScreen.rows[topRowIndex + i]);\n                    }\n                }\n            }\n        }\n        this.currRow = newRow;\n        const row = this.rows[this.currRow];\n        if (pacData.indent !== null) {\n            const indent = pacData.indent;\n            const prevPos = Math.max(indent - 1, 0);\n            row.setCursor(pacData.indent);\n            pacData.color = row.chars[prevPos].penState.foreground;\n        }\n        const styles = {\n            foreground: pacData.color,\n            underline: pacData.underline,\n            italics: pacData.italics,\n            background: \"black\",\n            flash: false\n        };\n        this.setPen(styles);\n    }\n    /**\n   * Set background/extra foreground, but first do back_space, and then insert space (backwards compatibility).\n   */ setBkgData(bkgData) {\n        this.logger.log(2, ()=>\"bkgData = \" + JSON.stringify(bkgData));\n        this.backSpace();\n        this.setPen(bkgData);\n        this.insertChar(0x20); // Space\n    }\n    setRollUpRows(nrRows) {\n        this.nrRollUpRows = nrRows;\n    }\n    rollUp() {\n        if (this.nrRollUpRows === null) {\n            this.logger.log(3, \"roll_up but nrRollUpRows not set yet\");\n            return; // Not properly setup\n        }\n        this.logger.log(1, ()=>this.getDisplayText());\n        const topRowIndex = this.currRow + 1 - this.nrRollUpRows;\n        const topRow = this.rows.splice(topRowIndex, 1)[0];\n        topRow.clear();\n        this.rows.splice(this.currRow, 0, topRow);\n        this.logger.log(2, \"Rolling up\");\n    // this.logger.log(VerboseLevel.TEXT, this.get_display_text())\n    }\n    /**\n   * Get all non-empty rows with as unicode text.\n   */ getDisplayText(asOneRow) {\n        asOneRow = asOneRow || false;\n        const displayText = [];\n        let text = \"\";\n        let rowNr = -1;\n        for(let i = 0; i < NR_ROWS; i++){\n            const rowText = this.rows[i].getTextString();\n            if (rowText) {\n                rowNr = i + 1;\n                if (asOneRow) {\n                    displayText.push(\"Row \" + rowNr + \": '\" + rowText + \"'\");\n                } else {\n                    displayText.push(rowText.trim());\n                }\n            }\n        }\n        if (displayText.length > 0) {\n            if (asOneRow) {\n                text = \"[\" + displayText.join(\" | \") + \"]\";\n            } else {\n                text = displayText.join(\"\\n\");\n            }\n        }\n        return text;\n    }\n    getTextAndFormat() {\n        return this.rows;\n    }\n}\n// var modes = ['MODE_ROLL-UP', 'MODE_POP-ON', 'MODE_PAINT-ON', 'MODE_TEXT'];\nclass Cea608Channel {\n    constructor(channelNumber, outputFilter, logger){\n        this.chNr = void 0;\n        this.outputFilter = void 0;\n        this.mode = void 0;\n        this.verbose = void 0;\n        this.displayedMemory = void 0;\n        this.nonDisplayedMemory = void 0;\n        this.lastOutputScreen = void 0;\n        this.currRollUpRow = void 0;\n        this.writeScreen = void 0;\n        this.cueStartTime = void 0;\n        this.logger = void 0;\n        this.chNr = channelNumber;\n        this.outputFilter = outputFilter;\n        this.mode = null;\n        this.verbose = 0;\n        this.displayedMemory = new CaptionScreen(logger);\n        this.nonDisplayedMemory = new CaptionScreen(logger);\n        this.lastOutputScreen = new CaptionScreen(logger);\n        this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];\n        this.writeScreen = this.displayedMemory;\n        this.mode = null;\n        this.cueStartTime = null; // Keeps track of where a cue started.\n        this.logger = logger;\n    }\n    reset() {\n        this.mode = null;\n        this.displayedMemory.reset();\n        this.nonDisplayedMemory.reset();\n        this.lastOutputScreen.reset();\n        this.outputFilter.reset();\n        this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];\n        this.writeScreen = this.displayedMemory;\n        this.mode = null;\n        this.cueStartTime = null;\n    }\n    getHandler() {\n        return this.outputFilter;\n    }\n    setHandler(newHandler) {\n        this.outputFilter = newHandler;\n    }\n    setPAC(pacData) {\n        this.writeScreen.setPAC(pacData);\n    }\n    setBkgData(bkgData) {\n        this.writeScreen.setBkgData(bkgData);\n    }\n    setMode(newMode) {\n        if (newMode === this.mode) {\n            return;\n        }\n        this.mode = newMode;\n        this.logger.log(2, ()=>\"MODE=\" + newMode);\n        if (this.mode === \"MODE_POP-ON\") {\n            this.writeScreen = this.nonDisplayedMemory;\n        } else {\n            this.writeScreen = this.displayedMemory;\n            this.writeScreen.reset();\n        }\n        if (this.mode !== \"MODE_ROLL-UP\") {\n            this.displayedMemory.nrRollUpRows = null;\n            this.nonDisplayedMemory.nrRollUpRows = null;\n        }\n        this.mode = newMode;\n    }\n    insertChars(chars) {\n        for(let i = 0; i < chars.length; i++){\n            this.writeScreen.insertChar(chars[i]);\n        }\n        const screen = this.writeScreen === this.displayedMemory ? \"DISP\" : \"NON_DISP\";\n        this.logger.log(2, ()=>screen + \": \" + this.writeScreen.getDisplayText(true));\n        if (this.mode === \"MODE_PAINT-ON\" || this.mode === \"MODE_ROLL-UP\") {\n            this.logger.log(1, ()=>\"DISPLAYED: \" + this.displayedMemory.getDisplayText(true));\n            this.outputDataUpdate();\n        }\n    }\n    ccRCL() {\n        // Resume Caption Loading (switch mode to Pop On)\n        this.logger.log(2, \"RCL - Resume Caption Loading\");\n        this.setMode(\"MODE_POP-ON\");\n    }\n    ccBS() {\n        // BackSpace\n        this.logger.log(2, \"BS - BackSpace\");\n        if (this.mode === \"MODE_TEXT\") {\n            return;\n        }\n        this.writeScreen.backSpace();\n        if (this.writeScreen === this.displayedMemory) {\n            this.outputDataUpdate();\n        }\n    }\n    ccAOF() {\n    // Reserved (formerly Alarm Off)\n    }\n    ccAON() {\n    // Reserved (formerly Alarm On)\n    }\n    ccDER() {\n        // Delete to End of Row\n        this.logger.log(2, \"DER- Delete to End of Row\");\n        this.writeScreen.clearToEndOfRow();\n        this.outputDataUpdate();\n    }\n    ccRU(nrRows) {\n        // Roll-Up Captions-2,3,or 4 Rows\n        this.logger.log(2, \"RU(\" + nrRows + \") - Roll Up\");\n        this.writeScreen = this.displayedMemory;\n        this.setMode(\"MODE_ROLL-UP\");\n        this.writeScreen.setRollUpRows(nrRows);\n    }\n    ccFON() {\n        // Flash On\n        this.logger.log(2, \"FON - Flash On\");\n        this.writeScreen.setPen({\n            flash: true\n        });\n    }\n    ccRDC() {\n        // Resume Direct Captioning (switch mode to PaintOn)\n        this.logger.log(2, \"RDC - Resume Direct Captioning\");\n        this.setMode(\"MODE_PAINT-ON\");\n    }\n    ccTR() {\n        // Text Restart in text mode (not supported, however)\n        this.logger.log(2, \"TR\");\n        this.setMode(\"MODE_TEXT\");\n    }\n    ccRTD() {\n        // Resume Text Display in Text mode (not supported, however)\n        this.logger.log(2, \"RTD\");\n        this.setMode(\"MODE_TEXT\");\n    }\n    ccEDM() {\n        // Erase Displayed Memory\n        this.logger.log(2, \"EDM - Erase Displayed Memory\");\n        this.displayedMemory.reset();\n        this.outputDataUpdate(true);\n    }\n    ccCR() {\n        // Carriage Return\n        this.logger.log(2, \"CR - Carriage Return\");\n        this.writeScreen.rollUp();\n        this.outputDataUpdate(true);\n    }\n    ccENM() {\n        // Erase Non-Displayed Memory\n        this.logger.log(2, \"ENM - Erase Non-displayed Memory\");\n        this.nonDisplayedMemory.reset();\n    }\n    ccEOC() {\n        // End of Caption (Flip Memories)\n        this.logger.log(2, \"EOC - End Of Caption\");\n        if (this.mode === \"MODE_POP-ON\") {\n            const tmp = this.displayedMemory;\n            this.displayedMemory = this.nonDisplayedMemory;\n            this.nonDisplayedMemory = tmp;\n            this.writeScreen = this.nonDisplayedMemory;\n            this.logger.log(1, ()=>\"DISP: \" + this.displayedMemory.getDisplayText());\n        }\n        this.outputDataUpdate(true);\n    }\n    ccTO(nrCols) {\n        // Tab Offset 1,2, or 3 columns\n        this.logger.log(2, \"TO(\" + nrCols + \") - Tab Offset\");\n        this.writeScreen.moveCursor(nrCols);\n    }\n    ccMIDROW(secondByte) {\n        // Parse MIDROW command\n        const styles = {\n            flash: false\n        };\n        styles.underline = secondByte % 2 === 1;\n        styles.italics = secondByte >= 0x2e;\n        if (!styles.italics) {\n            const colorIndex = Math.floor(secondByte / 2) - 0x10;\n            const colors = [\n                \"white\",\n                \"green\",\n                \"blue\",\n                \"cyan\",\n                \"red\",\n                \"yellow\",\n                \"magenta\"\n            ];\n            styles.foreground = colors[colorIndex];\n        } else {\n            styles.foreground = \"white\";\n        }\n        this.logger.log(2, \"MIDROW: \" + JSON.stringify(styles));\n        this.writeScreen.setPen(styles);\n    }\n    outputDataUpdate(dispatch = false) {\n        const time = this.logger.time;\n        if (time === null) {\n            return;\n        }\n        if (this.outputFilter) {\n            if (this.cueStartTime === null && !this.displayedMemory.isEmpty()) {\n                // Start of a new cue\n                this.cueStartTime = time;\n            } else {\n                if (!this.displayedMemory.equals(this.lastOutputScreen)) {\n                    this.outputFilter.newCue(this.cueStartTime, time, this.lastOutputScreen);\n                    if (dispatch && this.outputFilter.dispatchCue) {\n                        this.outputFilter.dispatchCue();\n                    }\n                    this.cueStartTime = this.displayedMemory.isEmpty() ? null : time;\n                }\n            }\n            this.lastOutputScreen.copy(this.displayedMemory);\n        }\n    }\n    cueSplitAtTime(t) {\n        if (this.outputFilter) {\n            if (!this.displayedMemory.isEmpty()) {\n                if (this.outputFilter.newCue) {\n                    this.outputFilter.newCue(this.cueStartTime, t, this.displayedMemory);\n                }\n                this.cueStartTime = t;\n            }\n        }\n    }\n}\n// Will be 1 or 2 when parsing captions\nclass Cea608Parser {\n    constructor(field, out1, out2){\n        this.channels = void 0;\n        this.currentChannel = 0;\n        this.cmdHistory = createCmdHistory();\n        this.logger = void 0;\n        const logger = this.logger = new CaptionsLogger();\n        this.channels = [\n            null,\n            new Cea608Channel(field, out1, logger),\n            new Cea608Channel(field + 1, out2, logger)\n        ];\n    }\n    getHandler(channel) {\n        return this.channels[channel].getHandler();\n    }\n    setHandler(channel, newHandler) {\n        this.channels[channel].setHandler(newHandler);\n    }\n    /**\n   * Add data for time t in forms of list of bytes (unsigned ints). The bytes are treated as pairs.\n   */ addData(time, byteList) {\n        let cmdFound;\n        let a;\n        let b;\n        let charsFound = false;\n        this.logger.time = time;\n        for(let i = 0; i < byteList.length; i += 2){\n            a = byteList[i] & 0x7f;\n            b = byteList[i + 1] & 0x7f;\n            if (a === 0 && b === 0) {\n                continue;\n            } else {\n                this.logger.log(3, \"[\" + numArrayToHexArray([\n                    byteList[i],\n                    byteList[i + 1]\n                ]) + \"] -> (\" + numArrayToHexArray([\n                    a,\n                    b\n                ]) + \")\");\n            }\n            cmdFound = this.parseCmd(a, b);\n            if (!cmdFound) {\n                cmdFound = this.parseMidrow(a, b);\n            }\n            if (!cmdFound) {\n                cmdFound = this.parsePAC(a, b);\n            }\n            if (!cmdFound) {\n                cmdFound = this.parseBackgroundAttributes(a, b);\n            }\n            if (!cmdFound) {\n                charsFound = this.parseChars(a, b);\n                if (charsFound) {\n                    const currChNr = this.currentChannel;\n                    if (currChNr && currChNr > 0) {\n                        const channel = this.channels[currChNr];\n                        channel.insertChars(charsFound);\n                    } else {\n                        this.logger.log(2, \"No channel found yet. TEXT-MODE?\");\n                    }\n                }\n            }\n            if (!cmdFound && !charsFound) {\n                this.logger.log(2, \"Couldn't parse cleaned data \" + numArrayToHexArray([\n                    a,\n                    b\n                ]) + \" orig: \" + numArrayToHexArray([\n                    byteList[i],\n                    byteList[i + 1]\n                ]));\n            }\n        }\n    }\n    /**\n   * Parse Command.\n   * @returns True if a command was found\n   */ parseCmd(a, b) {\n        const { cmdHistory } = this;\n        const cond1 = (a === 0x14 || a === 0x1c || a === 0x15 || a === 0x1d) && b >= 0x20 && b <= 0x2f;\n        const cond2 = (a === 0x17 || a === 0x1f) && b >= 0x21 && b <= 0x23;\n        if (!(cond1 || cond2)) {\n            return false;\n        }\n        if (hasCmdRepeated(a, b, cmdHistory)) {\n            setLastCmd(null, null, cmdHistory);\n            this.logger.log(3, \"Repeated command (\" + numArrayToHexArray([\n                a,\n                b\n            ]) + \") is dropped\");\n            return true;\n        }\n        const chNr = a === 0x14 || a === 0x15 || a === 0x17 ? 1 : 2;\n        const channel = this.channels[chNr];\n        if (a === 0x14 || a === 0x15 || a === 0x1c || a === 0x1d) {\n            if (b === 0x20) {\n                channel.ccRCL();\n            } else if (b === 0x21) {\n                channel.ccBS();\n            } else if (b === 0x22) {\n                channel.ccAOF();\n            } else if (b === 0x23) {\n                channel.ccAON();\n            } else if (b === 0x24) {\n                channel.ccDER();\n            } else if (b === 0x25) {\n                channel.ccRU(2);\n            } else if (b === 0x26) {\n                channel.ccRU(3);\n            } else if (b === 0x27) {\n                channel.ccRU(4);\n            } else if (b === 0x28) {\n                channel.ccFON();\n            } else if (b === 0x29) {\n                channel.ccRDC();\n            } else if (b === 0x2a) {\n                channel.ccTR();\n            } else if (b === 0x2b) {\n                channel.ccRTD();\n            } else if (b === 0x2c) {\n                channel.ccEDM();\n            } else if (b === 0x2d) {\n                channel.ccCR();\n            } else if (b === 0x2e) {\n                channel.ccENM();\n            } else if (b === 0x2f) {\n                channel.ccEOC();\n            }\n        } else {\n            // a == 0x17 || a == 0x1F\n            channel.ccTO(b - 0x20);\n        }\n        setLastCmd(a, b, cmdHistory);\n        this.currentChannel = chNr;\n        return true;\n    }\n    /**\n   * Parse midrow styling command\n   */ parseMidrow(a, b) {\n        let chNr = 0;\n        if ((a === 0x11 || a === 0x19) && b >= 0x20 && b <= 0x2f) {\n            if (a === 0x11) {\n                chNr = 1;\n            } else {\n                chNr = 2;\n            }\n            if (chNr !== this.currentChannel) {\n                this.logger.log(0, \"Mismatch channel in midrow parsing\");\n                return false;\n            }\n            const channel = this.channels[chNr];\n            if (!channel) {\n                return false;\n            }\n            channel.ccMIDROW(b);\n            this.logger.log(3, \"MIDROW (\" + numArrayToHexArray([\n                a,\n                b\n            ]) + \")\");\n            return true;\n        }\n        return false;\n    }\n    /**\n   * Parse Preable Access Codes (Table 53).\n   * @returns {Boolean} Tells if PAC found\n   */ parsePAC(a, b) {\n        let row;\n        const cmdHistory = this.cmdHistory;\n        const case1 = (a >= 0x11 && a <= 0x17 || a >= 0x19 && a <= 0x1f) && b >= 0x40 && b <= 0x7f;\n        const case2 = (a === 0x10 || a === 0x18) && b >= 0x40 && b <= 0x5f;\n        if (!(case1 || case2)) {\n            return false;\n        }\n        if (hasCmdRepeated(a, b, cmdHistory)) {\n            setLastCmd(null, null, cmdHistory);\n            return true; // Repeated commands are dropped (once)\n        }\n        const chNr = a <= 0x17 ? 1 : 2;\n        if (b >= 0x40 && b <= 0x5f) {\n            row = chNr === 1 ? rowsLowCh1[a] : rowsLowCh2[a];\n        } else {\n            // 0x60 <= b <= 0x7F\n            row = chNr === 1 ? rowsHighCh1[a] : rowsHighCh2[a];\n        }\n        const channel = this.channels[chNr];\n        if (!channel) {\n            return false;\n        }\n        channel.setPAC(this.interpretPAC(row, b));\n        setLastCmd(a, b, cmdHistory);\n        this.currentChannel = chNr;\n        return true;\n    }\n    /**\n   * Interpret the second byte of the pac, and return the information.\n   * @returns pacData with style parameters\n   */ interpretPAC(row, byte) {\n        let pacIndex;\n        const pacData = {\n            color: null,\n            italics: false,\n            indent: null,\n            underline: false,\n            row: row\n        };\n        if (byte > 0x5f) {\n            pacIndex = byte - 0x60;\n        } else {\n            pacIndex = byte - 0x40;\n        }\n        pacData.underline = (pacIndex & 1) === 1;\n        if (pacIndex <= 0xd) {\n            pacData.color = [\n                \"white\",\n                \"green\",\n                \"blue\",\n                \"cyan\",\n                \"red\",\n                \"yellow\",\n                \"magenta\",\n                \"white\"\n            ][Math.floor(pacIndex / 2)];\n        } else if (pacIndex <= 0xf) {\n            pacData.italics = true;\n            pacData.color = \"white\";\n        } else {\n            pacData.indent = Math.floor((pacIndex - 0x10) / 2) * 4;\n        }\n        return pacData; // Note that row has zero offset. The spec uses 1.\n    }\n    /**\n   * Parse characters.\n   * @returns An array with 1 to 2 codes corresponding to chars, if found. null otherwise.\n   */ parseChars(a, b) {\n        let channelNr;\n        let charCodes = null;\n        let charCode1 = null;\n        if (a >= 0x19) {\n            channelNr = 2;\n            charCode1 = a - 8;\n        } else {\n            channelNr = 1;\n            charCode1 = a;\n        }\n        if (charCode1 >= 0x11 && charCode1 <= 0x13) {\n            // Special character\n            let oneCode;\n            if (charCode1 === 0x11) {\n                oneCode = b + 0x50;\n            } else if (charCode1 === 0x12) {\n                oneCode = b + 0x70;\n            } else {\n                oneCode = b + 0x90;\n            }\n            this.logger.log(2, \"Special char '\" + getCharForByte(oneCode) + \"' in channel \" + channelNr);\n            charCodes = [\n                oneCode\n            ];\n        } else if (a >= 0x20 && a <= 0x7f) {\n            charCodes = b === 0 ? [\n                a\n            ] : [\n                a,\n                b\n            ];\n        }\n        if (charCodes) {\n            const hexCodes = numArrayToHexArray(charCodes);\n            this.logger.log(3, \"Char codes =  \" + hexCodes.join(\",\"));\n            setLastCmd(a, b, this.cmdHistory);\n        }\n        return charCodes;\n    }\n    /**\n   * Parse extended background attributes as well as new foreground color black.\n   * @returns True if background attributes are found\n   */ parseBackgroundAttributes(a, b) {\n        const case1 = (a === 0x10 || a === 0x18) && b >= 0x20 && b <= 0x2f;\n        const case2 = (a === 0x17 || a === 0x1f) && b >= 0x2d && b <= 0x2f;\n        if (!(case1 || case2)) {\n            return false;\n        }\n        let index;\n        const bkgData = {};\n        if (a === 0x10 || a === 0x18) {\n            index = Math.floor((b - 0x20) / 2);\n            bkgData.background = backgroundColors[index];\n            if (b % 2 === 1) {\n                bkgData.background = bkgData.background + \"_semi\";\n            }\n        } else if (b === 0x2d) {\n            bkgData.background = \"transparent\";\n        } else {\n            bkgData.foreground = \"black\";\n            if (b === 0x2f) {\n                bkgData.underline = true;\n            }\n        }\n        const chNr = a <= 0x17 ? 1 : 2;\n        const channel = this.channels[chNr];\n        channel.setBkgData(bkgData);\n        setLastCmd(a, b, this.cmdHistory);\n        return true;\n    }\n    /**\n   * Reset state of parser and its channels.\n   */ reset() {\n        for(let i = 0; i < Object.keys(this.channels).length; i++){\n            const channel = this.channels[i];\n            if (channel) {\n                channel.reset();\n            }\n        }\n        this.cmdHistory = createCmdHistory();\n    }\n    /**\n   * Trigger the generation of a cue, and the start of a new one if displayScreens are not empty.\n   */ cueSplitAtTime(t) {\n        for(let i = 0; i < this.channels.length; i++){\n            const channel = this.channels[i];\n            if (channel) {\n                channel.cueSplitAtTime(t);\n            }\n        }\n    }\n}\nfunction setLastCmd(a, b, cmdHistory) {\n    cmdHistory.a = a;\n    cmdHistory.b = b;\n}\nfunction hasCmdRepeated(a, b, cmdHistory) {\n    return cmdHistory.a === a && cmdHistory.b === b;\n}\nfunction createCmdHistory() {\n    return {\n        a: null,\n        b: null\n    };\n}\nclass OutputFilter {\n    constructor(timelineController, trackName){\n        this.timelineController = void 0;\n        this.cueRanges = [];\n        this.trackName = void 0;\n        this.startTime = null;\n        this.endTime = null;\n        this.screen = null;\n        this.timelineController = timelineController;\n        this.trackName = trackName;\n    }\n    dispatchCue() {\n        if (this.startTime === null) {\n            return;\n        }\n        this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen, this.cueRanges);\n        this.startTime = null;\n    }\n    newCue(startTime, endTime, screen) {\n        if (this.startTime === null || this.startTime > startTime) {\n            this.startTime = startTime;\n        }\n        this.endTime = endTime;\n        this.screen = screen;\n        this.timelineController.createCaptionsTrack(this.trackName);\n    }\n    reset() {\n        this.cueRanges = [];\n        this.startTime = null;\n    }\n}\n/**\n * Copyright 2013 vtt.js Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ var VTTCue = function() {\n    if (optionalSelf != null && optionalSelf.VTTCue) {\n        return self.VTTCue;\n    }\n    const AllowedDirections = [\n        \"\",\n        \"lr\",\n        \"rl\"\n    ];\n    const AllowedAlignments = [\n        \"start\",\n        \"middle\",\n        \"end\",\n        \"left\",\n        \"right\"\n    ];\n    function isAllowedValue(allowed, value) {\n        if (typeof value !== \"string\") {\n            return false;\n        }\n        // necessary for assuring the generic conforms to the Array interface\n        if (!Array.isArray(allowed)) {\n            return false;\n        }\n        // reset the type so that the next narrowing works well\n        const lcValue = value.toLowerCase();\n        // use the allow list to narrow the type to a specific subset of strings\n        if (~allowed.indexOf(lcValue)) {\n            return lcValue;\n        }\n        return false;\n    }\n    function findDirectionSetting(value) {\n        return isAllowedValue(AllowedDirections, value);\n    }\n    function findAlignSetting(value) {\n        return isAllowedValue(AllowedAlignments, value);\n    }\n    function extend(obj, ...rest) {\n        let i = 1;\n        for(; i < arguments.length; i++){\n            const cobj = arguments[i];\n            for(const p in cobj){\n                obj[p] = cobj[p];\n            }\n        }\n        return obj;\n    }\n    function VTTCue(startTime, endTime, text) {\n        const cue = this;\n        const baseObj = {\n            enumerable: true\n        };\n        /**\n     * Shim implementation specific properties. These properties are not in\n     * the spec.\n     */ // Lets us know when the VTTCue's data has changed in such a way that we need\n        // to recompute its display state. This lets us compute its display state\n        // lazily.\n        cue.hasBeenReset = false;\n        /**\n     * VTTCue and TextTrackCue properties\n     * http://dev.w3.org/html5/webvtt/#vttcue-interface\n     */ let _id = \"\";\n        let _pauseOnExit = false;\n        let _startTime = startTime;\n        let _endTime = endTime;\n        let _text = text;\n        let _region = null;\n        let _vertical = \"\";\n        let _snapToLines = true;\n        let _line = \"auto\";\n        let _lineAlign = \"start\";\n        let _position = 50;\n        let _positionAlign = \"middle\";\n        let _size = 50;\n        let _align = \"middle\";\n        Object.defineProperty(cue, \"id\", extend({}, baseObj, {\n            get: function() {\n                return _id;\n            },\n            set: function(value) {\n                _id = \"\" + value;\n            }\n        }));\n        Object.defineProperty(cue, \"pauseOnExit\", extend({}, baseObj, {\n            get: function() {\n                return _pauseOnExit;\n            },\n            set: function(value) {\n                _pauseOnExit = !!value;\n            }\n        }));\n        Object.defineProperty(cue, \"startTime\", extend({}, baseObj, {\n            get: function() {\n                return _startTime;\n            },\n            set: function(value) {\n                if (typeof value !== \"number\") {\n                    throw new TypeError(\"Start time must be set to a number.\");\n                }\n                _startTime = value;\n                this.hasBeenReset = true;\n            }\n        }));\n        Object.defineProperty(cue, \"endTime\", extend({}, baseObj, {\n            get: function() {\n                return _endTime;\n            },\n            set: function(value) {\n                if (typeof value !== \"number\") {\n                    throw new TypeError(\"End time must be set to a number.\");\n                }\n                _endTime = value;\n                this.hasBeenReset = true;\n            }\n        }));\n        Object.defineProperty(cue, \"text\", extend({}, baseObj, {\n            get: function() {\n                return _text;\n            },\n            set: function(value) {\n                _text = \"\" + value;\n                this.hasBeenReset = true;\n            }\n        }));\n        // todo: implement VTTRegion polyfill?\n        Object.defineProperty(cue, \"region\", extend({}, baseObj, {\n            get: function() {\n                return _region;\n            },\n            set: function(value) {\n                _region = value;\n                this.hasBeenReset = true;\n            }\n        }));\n        Object.defineProperty(cue, \"vertical\", extend({}, baseObj, {\n            get: function() {\n                return _vertical;\n            },\n            set: function(value) {\n                const setting = findDirectionSetting(value);\n                // Have to check for false because the setting an be an empty string.\n                if (setting === false) {\n                    throw new SyntaxError(\"An invalid or illegal string was specified.\");\n                }\n                _vertical = setting;\n                this.hasBeenReset = true;\n            }\n        }));\n        Object.defineProperty(cue, \"snapToLines\", extend({}, baseObj, {\n            get: function() {\n                return _snapToLines;\n            },\n            set: function(value) {\n                _snapToLines = !!value;\n                this.hasBeenReset = true;\n            }\n        }));\n        Object.defineProperty(cue, \"line\", extend({}, baseObj, {\n            get: function() {\n                return _line;\n            },\n            set: function(value) {\n                if (typeof value !== \"number\" && value !== \"auto\") {\n                    throw new SyntaxError(\"An invalid number or illegal string was specified.\");\n                }\n                _line = value;\n                this.hasBeenReset = true;\n            }\n        }));\n        Object.defineProperty(cue, \"lineAlign\", extend({}, baseObj, {\n            get: function() {\n                return _lineAlign;\n            },\n            set: function(value) {\n                const setting = findAlignSetting(value);\n                if (!setting) {\n                    throw new SyntaxError(\"An invalid or illegal string was specified.\");\n                }\n                _lineAlign = setting;\n                this.hasBeenReset = true;\n            }\n        }));\n        Object.defineProperty(cue, \"position\", extend({}, baseObj, {\n            get: function() {\n                return _position;\n            },\n            set: function(value) {\n                if (value < 0 || value > 100) {\n                    throw new Error(\"Position must be between 0 and 100.\");\n                }\n                _position = value;\n                this.hasBeenReset = true;\n            }\n        }));\n        Object.defineProperty(cue, \"positionAlign\", extend({}, baseObj, {\n            get: function() {\n                return _positionAlign;\n            },\n            set: function(value) {\n                const setting = findAlignSetting(value);\n                if (!setting) {\n                    throw new SyntaxError(\"An invalid or illegal string was specified.\");\n                }\n                _positionAlign = setting;\n                this.hasBeenReset = true;\n            }\n        }));\n        Object.defineProperty(cue, \"size\", extend({}, baseObj, {\n            get: function() {\n                return _size;\n            },\n            set: function(value) {\n                if (value < 0 || value > 100) {\n                    throw new Error(\"Size must be between 0 and 100.\");\n                }\n                _size = value;\n                this.hasBeenReset = true;\n            }\n        }));\n        Object.defineProperty(cue, \"align\", extend({}, baseObj, {\n            get: function() {\n                return _align;\n            },\n            set: function(value) {\n                const setting = findAlignSetting(value);\n                if (!setting) {\n                    throw new SyntaxError(\"An invalid or illegal string was specified.\");\n                }\n                _align = setting;\n                this.hasBeenReset = true;\n            }\n        }));\n        /**\n     * Other <track> spec defined properties\n     */ // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state\n        cue.displayState = undefined;\n    }\n    /**\n   * VTTCue methods\n   */ VTTCue.prototype.getCueAsHTML = function() {\n        // Assume WebVTT.convertCueToDOMTree is on the global.\n        const WebVTT = self.WebVTT;\n        return WebVTT.convertCueToDOMTree(self, this.text);\n    };\n    // this is a polyfill hack\n    return VTTCue;\n}();\n/*\n * Source: https://github.com/mozilla/vtt.js/blob/master/dist/vtt.js\n */ class StringDecoder {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    decode(data, options) {\n        if (!data) {\n            return \"\";\n        }\n        if (typeof data !== \"string\") {\n            throw new Error(\"Error - expected string data.\");\n        }\n        return decodeURIComponent(encodeURIComponent(data));\n    }\n}\n// Try to parse input as a time stamp.\nfunction parseTimeStamp(input) {\n    function computeSeconds(h, m, s, f) {\n        return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + parseFloat(f || 0);\n    }\n    const m = input.match(/^(?:(\\d+):)?(\\d{2}):(\\d{2})(\\.\\d+)?/);\n    if (!m) {\n        return null;\n    }\n    if (parseFloat(m[2]) > 59) {\n        // Timestamp takes the form of [hours]:[minutes].[milliseconds]\n        // First position is hours as it's over 59.\n        return computeSeconds(m[2], m[3], 0, m[4]);\n    }\n    // Timestamp takes the form of [hours (optional)]:[minutes]:[seconds].[milliseconds]\n    return computeSeconds(m[1], m[2], m[3], m[4]);\n}\n// A settings object holds key/value pairs and will ignore anything but the first\n// assignment to a specific key.\nclass Settings {\n    constructor(){\n        this.values = Object.create(null);\n    }\n    // Only accept the first assignment to any key.\n    set(k, v) {\n        if (!this.get(k) && v !== \"\") {\n            this.values[k] = v;\n        }\n    }\n    // Return the value for a key, or a default value.\n    // If 'defaultKey' is passed then 'dflt' is assumed to be an object with\n    // a number of possible default values as properties where 'defaultKey' is\n    // the key of the property that will be chosen; otherwise it's assumed to be\n    // a single value.\n    get(k, dflt, defaultKey) {\n        if (defaultKey) {\n            return this.has(k) ? this.values[k] : dflt[defaultKey];\n        }\n        return this.has(k) ? this.values[k] : dflt;\n    }\n    // Check whether we have a value for a key.\n    has(k) {\n        return k in this.values;\n    }\n    // Accept a setting if its one of the given alternatives.\n    alt(k, v, a) {\n        for(let n = 0; n < a.length; ++n){\n            if (v === a[n]) {\n                this.set(k, v);\n                break;\n            }\n        }\n    }\n    // Accept a setting if its a valid (signed) integer.\n    integer(k, v) {\n        if (/^-?\\d+$/.test(v)) {\n            // integer\n            this.set(k, parseInt(v, 10));\n        }\n    }\n    // Accept a setting if its a valid percentage.\n    percent(k, v) {\n        if (/^([\\d]{1,3})(\\.[\\d]*)?%$/.test(v)) {\n            const percent = parseFloat(v);\n            if (percent >= 0 && percent <= 100) {\n                this.set(k, percent);\n                return true;\n            }\n        }\n        return false;\n    }\n}\n// Helper function to parse input into groups separated by 'groupDelim', and\n// interpret each group as a key/value pair separated by 'keyValueDelim'.\nfunction parseOptions(input, callback, keyValueDelim, groupDelim) {\n    const groups = groupDelim ? input.split(groupDelim) : [\n        input\n    ];\n    for(const i in groups){\n        if (typeof groups[i] !== \"string\") {\n            continue;\n        }\n        const kv = groups[i].split(keyValueDelim);\n        if (kv.length !== 2) {\n            continue;\n        }\n        const k = kv[0];\n        const v = kv[1];\n        callback(k, v);\n    }\n}\nconst defaults = new VTTCue(0, 0, \"\");\n// 'middle' was changed to 'center' in the spec: https://github.com/w3c/webvtt/pull/244\n//  Safari doesn't yet support this change, but FF and Chrome do.\nconst center = defaults.align === \"middle\" ? \"middle\" : \"center\";\nfunction parseCue(input, cue, regionList) {\n    // Remember the original input if we need to throw an error.\n    const oInput = input;\n    // 4.1 WebVTT timestamp\n    function consumeTimeStamp() {\n        const ts = parseTimeStamp(input);\n        if (ts === null) {\n            throw new Error(\"Malformed timestamp: \" + oInput);\n        }\n        // Remove time stamp from input.\n        input = input.replace(/^[^\\sa-zA-Z-]+/, \"\");\n        return ts;\n    }\n    // 4.4.2 WebVTT cue settings\n    function consumeCueSettings(input, cue) {\n        const settings = new Settings();\n        parseOptions(input, function(k, v) {\n            let vals;\n            switch(k){\n                case \"region\":\n                    // Find the last region we parsed with the same region id.\n                    for(let i = regionList.length - 1; i >= 0; i--){\n                        if (regionList[i].id === v) {\n                            settings.set(k, regionList[i].region);\n                            break;\n                        }\n                    }\n                    break;\n                case \"vertical\":\n                    settings.alt(k, v, [\n                        \"rl\",\n                        \"lr\"\n                    ]);\n                    break;\n                case \"line\":\n                    vals = v.split(\",\");\n                    settings.integer(k, vals[0]);\n                    if (settings.percent(k, vals[0])) {\n                        settings.set(\"snapToLines\", false);\n                    }\n                    settings.alt(k, vals[0], [\n                        \"auto\"\n                    ]);\n                    if (vals.length === 2) {\n                        settings.alt(\"lineAlign\", vals[1], [\n                            \"start\",\n                            center,\n                            \"end\"\n                        ]);\n                    }\n                    break;\n                case \"position\":\n                    vals = v.split(\",\");\n                    settings.percent(k, vals[0]);\n                    if (vals.length === 2) {\n                        settings.alt(\"positionAlign\", vals[1], [\n                            \"start\",\n                            center,\n                            \"end\",\n                            \"line-left\",\n                            \"line-right\",\n                            \"auto\"\n                        ]);\n                    }\n                    break;\n                case \"size\":\n                    settings.percent(k, v);\n                    break;\n                case \"align\":\n                    settings.alt(k, v, [\n                        \"start\",\n                        center,\n                        \"end\",\n                        \"left\",\n                        \"right\"\n                    ]);\n                    break;\n            }\n        }, /:/, /\\s/);\n        // Apply default values for any missing fields.\n        cue.region = settings.get(\"region\", null);\n        cue.vertical = settings.get(\"vertical\", \"\");\n        let line = settings.get(\"line\", \"auto\");\n        if (line === \"auto\" && defaults.line === -1) {\n            // set numeric line number for Safari\n            line = -1;\n        }\n        cue.line = line;\n        cue.lineAlign = settings.get(\"lineAlign\", \"start\");\n        cue.snapToLines = settings.get(\"snapToLines\", true);\n        cue.size = settings.get(\"size\", 100);\n        cue.align = settings.get(\"align\", center);\n        let position = settings.get(\"position\", \"auto\");\n        if (position === \"auto\" && defaults.position === 50) {\n            // set numeric position for Safari\n            position = cue.align === \"start\" || cue.align === \"left\" ? 0 : cue.align === \"end\" || cue.align === \"right\" ? 100 : 50;\n        }\n        cue.position = position;\n    }\n    function skipWhitespace() {\n        input = input.replace(/^\\s+/, \"\");\n    }\n    // 4.1 WebVTT cue timings.\n    skipWhitespace();\n    cue.startTime = consumeTimeStamp(); // (1) collect cue start time\n    skipWhitespace();\n    if (input.slice(0, 3) !== \"-->\") {\n        // (3) next characters must match '-->'\n        throw new Error(\"Malformed time stamp (time stamps must be separated by '-->'): \" + oInput);\n    }\n    input = input.slice(3);\n    skipWhitespace();\n    cue.endTime = consumeTimeStamp(); // (5) collect cue end time\n    // 4.1 WebVTT cue settings list.\n    skipWhitespace();\n    consumeCueSettings(input, cue);\n}\nfunction fixLineBreaks(input) {\n    return input.replace(/<br(?: \\/)?>/gi, \"\\n\");\n}\nclass VTTParser {\n    constructor(){\n        this.state = \"INITIAL\";\n        this.buffer = \"\";\n        this.decoder = new StringDecoder();\n        this.regionList = [];\n        this.cue = null;\n        this.oncue = void 0;\n        this.onparsingerror = void 0;\n        this.onflush = void 0;\n    }\n    parse(data) {\n        const _this = this;\n        // If there is no data then we won't decode it, but will just try to parse\n        // whatever is in buffer already. This may occur in circumstances, for\n        // example when flush() is called.\n        if (data) {\n            // Try to decode the data that we received.\n            _this.buffer += _this.decoder.decode(data, {\n                stream: true\n            });\n        }\n        function collectNextLine() {\n            let buffer = _this.buffer;\n            let pos = 0;\n            buffer = fixLineBreaks(buffer);\n            while(pos < buffer.length && buffer[pos] !== \"\\r\" && buffer[pos] !== \"\\n\"){\n                ++pos;\n            }\n            const line = buffer.slice(0, pos);\n            // Advance the buffer early in case we fail below.\n            if (buffer[pos] === \"\\r\") {\n                ++pos;\n            }\n            if (buffer[pos] === \"\\n\") {\n                ++pos;\n            }\n            _this.buffer = buffer.slice(pos);\n            return line;\n        }\n        // 3.2 WebVTT metadata header syntax\n        function parseHeader(input) {\n            parseOptions(input, function(k, v) {\n            // switch (k) {\n            // case 'region':\n            // 3.3 WebVTT region metadata header syntax\n            // console.log('parse region', v);\n            // parseRegion(v);\n            // break;\n            // }\n            }, /:/);\n        }\n        // 5.1 WebVTT file parsing.\n        try {\n            let line = \"\";\n            if (_this.state === \"INITIAL\") {\n                // We can't start parsing until we have the first line.\n                if (!/\\r\\n|\\n/.test(_this.buffer)) {\n                    return this;\n                }\n                line = collectNextLine();\n                // strip of UTF-8 BOM if any\n                // https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8\n                const m = line.match(/^()?WEBVTT([ \\t].*)?$/);\n                if (!(m != null && m[0])) {\n                    throw new Error(\"Malformed WebVTT signature.\");\n                }\n                _this.state = \"HEADER\";\n            }\n            let alreadyCollectedLine = false;\n            while(_this.buffer){\n                // We can't parse a line until we have the full line.\n                if (!/\\r\\n|\\n/.test(_this.buffer)) {\n                    return this;\n                }\n                if (!alreadyCollectedLine) {\n                    line = collectNextLine();\n                } else {\n                    alreadyCollectedLine = false;\n                }\n                switch(_this.state){\n                    case \"HEADER\":\n                        // 13-18 - Allow a header (metadata) under the WEBVTT line.\n                        if (/:/.test(line)) {\n                            parseHeader(line);\n                        } else if (!line) {\n                            // An empty line terminates the header and starts the body (cues).\n                            _this.state = \"ID\";\n                        }\n                        continue;\n                    case \"NOTE\":\n                        // Ignore NOTE blocks.\n                        if (!line) {\n                            _this.state = \"ID\";\n                        }\n                        continue;\n                    case \"ID\":\n                        // Check for the start of NOTE blocks.\n                        if (/^NOTE($|[ \\t])/.test(line)) {\n                            _this.state = \"NOTE\";\n                            break;\n                        }\n                        // 19-29 - Allow any number of line terminators, then initialize new cue values.\n                        if (!line) {\n                            continue;\n                        }\n                        _this.cue = new VTTCue(0, 0, \"\");\n                        _this.state = \"CUE\";\n                        // 30-39 - Check if self line contains an optional identifier or timing data.\n                        if (line.indexOf(\"-->\") === -1) {\n                            _this.cue.id = line;\n                            continue;\n                        }\n                    // Process line as start of a cue.\n                    /* falls through */ case \"CUE\":\n                        // 40 - Collect cue timings and settings.\n                        if (!_this.cue) {\n                            _this.state = \"BADCUE\";\n                            continue;\n                        }\n                        try {\n                            parseCue(line, _this.cue, _this.regionList);\n                        } catch (e) {\n                            // In case of an error ignore rest of the cue.\n                            _this.cue = null;\n                            _this.state = \"BADCUE\";\n                            continue;\n                        }\n                        _this.state = \"CUETEXT\";\n                        continue;\n                    case \"CUETEXT\":\n                        {\n                            const hasSubstring = line.indexOf(\"-->\") !== -1;\n                            // 34 - If we have an empty line then report the cue.\n                            // 35 - If we have the special substring '-->' then report the cue,\n                            // but do not collect the line as we need to process the current\n                            // one as a new cue.\n                            if (!line || hasSubstring && (alreadyCollectedLine = true)) {\n                                // We are done parsing self cue.\n                                if (_this.oncue && _this.cue) {\n                                    _this.oncue(_this.cue);\n                                }\n                                _this.cue = null;\n                                _this.state = \"ID\";\n                                continue;\n                            }\n                            if (_this.cue === null) {\n                                continue;\n                            }\n                            if (_this.cue.text) {\n                                _this.cue.text += \"\\n\";\n                            }\n                            _this.cue.text += line;\n                        }\n                        continue;\n                    case \"BADCUE\":\n                        // 54-62 - Collect and discard the remaining cue.\n                        if (!line) {\n                            _this.state = \"ID\";\n                        }\n                }\n            }\n        } catch (e) {\n            // If we are currently parsing a cue, report what we have.\n            if (_this.state === \"CUETEXT\" && _this.cue && _this.oncue) {\n                _this.oncue(_this.cue);\n            }\n            _this.cue = null;\n            // Enter BADWEBVTT state if header was not parsed correctly otherwise\n            // another exception occurred so enter BADCUE state.\n            _this.state = _this.state === \"INITIAL\" ? \"BADWEBVTT\" : \"BADCUE\";\n        }\n        return this;\n    }\n    flush() {\n        const _this = this;\n        try {\n            // Finish decoding the stream.\n            // _this.buffer += _this.decoder.decode();\n            // Synthesize the end of the current cue or region.\n            if (_this.cue || _this.state === \"HEADER\") {\n                _this.buffer += \"\\n\\n\";\n                _this.parse();\n            }\n            // If we've flushed, parsed, and we're still on the INITIAL state then\n            // that means we don't have enough of the stream to parse the first\n            // line.\n            if (_this.state === \"INITIAL\" || _this.state === \"BADWEBVTT\") {\n                throw new Error(\"Malformed WebVTT signature.\");\n            }\n        } catch (e) {\n            if (_this.onparsingerror) {\n                _this.onparsingerror(e);\n            }\n        }\n        if (_this.onflush) {\n            _this.onflush();\n        }\n        return this;\n    }\n}\nconst LINEBREAKS = /\\r\\n|\\n\\r|\\n|\\r/g;\n// String.prototype.startsWith is not supported in IE11\nconst startsWith = function startsWith(inputString, searchString, position = 0) {\n    return inputString.slice(position, position + searchString.length) === searchString;\n};\nconst cueString2millis = function cueString2millis(timeString) {\n    let ts = parseInt(timeString.slice(-3));\n    const secs = parseInt(timeString.slice(-6, -4));\n    const mins = parseInt(timeString.slice(-9, -7));\n    const hours = timeString.length > 9 ? parseInt(timeString.substring(0, timeString.indexOf(\":\"))) : 0;\n    if (!isFiniteNumber(ts) || !isFiniteNumber(secs) || !isFiniteNumber(mins) || !isFiniteNumber(hours)) {\n        throw Error(`Malformed X-TIMESTAMP-MAP: Local:${timeString}`);\n    }\n    ts += 1000 * secs;\n    ts += 60 * 1000 * mins;\n    ts += 60 * 60 * 1000 * hours;\n    return ts;\n};\n// From https://github.com/darkskyapp/string-hash\nconst hash = function hash(text) {\n    let _hash = 5381;\n    let i = text.length;\n    while(i){\n        _hash = _hash * 33 ^ text.charCodeAt(--i);\n    }\n    return (_hash >>> 0).toString();\n};\n// Create a unique hash id for a cue based on start/end times and text.\n// This helps timeline-controller to avoid showing repeated captions.\nfunction generateCueId(startTime, endTime, text) {\n    return hash(startTime.toString()) + hash(endTime.toString()) + hash(text);\n}\nconst calculateOffset = function calculateOffset(vttCCs, cc, presentationTime) {\n    let currCC = vttCCs[cc];\n    let prevCC = vttCCs[currCC.prevCC];\n    // This is the first discontinuity or cues have been processed since the last discontinuity\n    // Offset = current discontinuity time\n    if (!prevCC || !prevCC.new && currCC.new) {\n        vttCCs.ccOffset = vttCCs.presentationOffset = currCC.start;\n        currCC.new = false;\n        return;\n    }\n    // There have been discontinuities since cues were last parsed.\n    // Offset = time elapsed\n    while((_prevCC = prevCC) != null && _prevCC.new){\n        var _prevCC;\n        vttCCs.ccOffset += currCC.start - prevCC.start;\n        currCC.new = false;\n        currCC = prevCC;\n        prevCC = vttCCs[currCC.prevCC];\n    }\n    vttCCs.presentationOffset = presentationTime;\n};\nfunction parseWebVTT(vttByteArray, initPTS, vttCCs, cc, timeOffset, callBack, errorCallBack) {\n    const parser = new VTTParser();\n    // Convert byteArray into string, replacing any somewhat exotic linefeeds with \"\\n\", then split on that character.\n    // Uint8Array.prototype.reduce is not implemented in IE11\n    const vttLines = utf8ArrayToStr(new Uint8Array(vttByteArray)).trim().replace(LINEBREAKS, \"\\n\").split(\"\\n\");\n    const cues = [];\n    const init90kHz = initPTS ? toMpegTsClockFromTimescale(initPTS.baseTime, initPTS.timescale) : 0;\n    let cueTime = \"00:00.000\";\n    let timestampMapMPEGTS = 0;\n    let timestampMapLOCAL = 0;\n    let parsingError;\n    let inHeader = true;\n    parser.oncue = function(cue) {\n        // Adjust cue timing; clamp cues to start no earlier than - and drop cues that don't end after - 0 on timeline.\n        const currCC = vttCCs[cc];\n        let cueOffset = vttCCs.ccOffset;\n        // Calculate subtitle PTS offset\n        const webVttMpegTsMapOffset = (timestampMapMPEGTS - init90kHz) / 90000;\n        // Update offsets for new discontinuities\n        if (currCC != null && currCC.new) {\n            if (timestampMapLOCAL !== undefined) {\n                // When local time is provided, offset = discontinuity start time - local time\n                cueOffset = vttCCs.ccOffset = currCC.start;\n            } else {\n                calculateOffset(vttCCs, cc, webVttMpegTsMapOffset);\n            }\n        }\n        if (webVttMpegTsMapOffset) {\n            if (!initPTS) {\n                parsingError = new Error(\"Missing initPTS for VTT MPEGTS\");\n                return;\n            }\n            // If we have MPEGTS, offset = presentation time + discontinuity offset\n            cueOffset = webVttMpegTsMapOffset - vttCCs.presentationOffset;\n        }\n        const duration = cue.endTime - cue.startTime;\n        const startTime = normalizePts((cue.startTime + cueOffset - timestampMapLOCAL) * 90000, timeOffset * 90000) / 90000;\n        cue.startTime = Math.max(startTime, 0);\n        cue.endTime = Math.max(startTime + duration, 0);\n        //trim trailing webvtt block whitespaces\n        const text = cue.text.trim();\n        // Fix encoding of special characters\n        cue.text = decodeURIComponent(encodeURIComponent(text));\n        // If the cue was not assigned an id from the VTT file (line above the content), create one.\n        if (!cue.id) {\n            cue.id = generateCueId(cue.startTime, cue.endTime, text);\n        }\n        if (cue.endTime > 0) {\n            cues.push(cue);\n        }\n    };\n    parser.onparsingerror = function(error) {\n        parsingError = error;\n    };\n    parser.onflush = function() {\n        if (parsingError) {\n            errorCallBack(parsingError);\n            return;\n        }\n        callBack(cues);\n    };\n    // Go through contents line by line.\n    vttLines.forEach((line)=>{\n        if (inHeader) {\n            // Look for X-TIMESTAMP-MAP in header.\n            if (startsWith(line, \"X-TIMESTAMP-MAP=\")) {\n                // Once found, no more are allowed anyway, so stop searching.\n                inHeader = false;\n                // Extract LOCAL and MPEGTS.\n                line.slice(16).split(\",\").forEach((timestamp)=>{\n                    if (startsWith(timestamp, \"LOCAL:\")) {\n                        cueTime = timestamp.slice(6);\n                    } else if (startsWith(timestamp, \"MPEGTS:\")) {\n                        timestampMapMPEGTS = parseInt(timestamp.slice(7));\n                    }\n                });\n                try {\n                    // Convert cue time to seconds\n                    timestampMapLOCAL = cueString2millis(cueTime) / 1000;\n                } catch (error) {\n                    parsingError = error;\n                }\n                // Return without parsing X-TIMESTAMP-MAP line.\n                return;\n            } else if (line === \"\") {\n                inHeader = false;\n            }\n        }\n        // Parse line by default.\n        parser.parse(line + \"\\n\");\n    });\n    parser.flush();\n}\nconst IMSC1_CODEC = \"stpp.ttml.im1t\";\n// Time format: h:m:s:frames(.subframes)\nconst HMSF_REGEX = /^(\\d{2,}):(\\d{2}):(\\d{2}):(\\d{2})\\.?(\\d+)?$/;\n// Time format: hours, minutes, seconds, milliseconds, frames, ticks\nconst TIME_UNIT_REGEX = /^(\\d*(?:\\.\\d*)?)(h|m|s|ms|f|t)$/;\nconst textAlignToLineAlign = {\n    left: \"start\",\n    center: \"center\",\n    right: \"end\",\n    start: \"start\",\n    end: \"end\"\n};\nfunction parseIMSC1(payload, initPTS, callBack, errorCallBack) {\n    const results = findBox(new Uint8Array(payload), [\n        \"mdat\"\n    ]);\n    if (results.length === 0) {\n        errorCallBack(new Error(\"Could not parse IMSC1 mdat\"));\n        return;\n    }\n    const ttmlList = results.map((mdat)=>utf8ArrayToStr(mdat));\n    const syncTime = toTimescaleFromScale(initPTS.baseTime, 1, initPTS.timescale);\n    try {\n        ttmlList.forEach((ttml)=>callBack(parseTTML(ttml, syncTime)));\n    } catch (error) {\n        errorCallBack(error);\n    }\n}\nfunction parseTTML(ttml, syncTime) {\n    const parser = new DOMParser();\n    const xmlDoc = parser.parseFromString(ttml, \"text/xml\");\n    const tt = xmlDoc.getElementsByTagName(\"tt\")[0];\n    if (!tt) {\n        throw new Error(\"Invalid ttml\");\n    }\n    const defaultRateInfo = {\n        frameRate: 30,\n        subFrameRate: 1,\n        frameRateMultiplier: 0,\n        tickRate: 0\n    };\n    const rateInfo = Object.keys(defaultRateInfo).reduce((result, key)=>{\n        result[key] = tt.getAttribute(`ttp:${key}`) || defaultRateInfo[key];\n        return result;\n    }, {});\n    const trim = tt.getAttribute(\"xml:space\") !== \"preserve\";\n    const styleElements = collectionToDictionary(getElementCollection(tt, \"styling\", \"style\"));\n    const regionElements = collectionToDictionary(getElementCollection(tt, \"layout\", \"region\"));\n    const cueElements = getElementCollection(tt, \"body\", \"[begin]\");\n    return [].map.call(cueElements, (cueElement)=>{\n        const cueText = getTextContent(cueElement, trim);\n        if (!cueText || !cueElement.hasAttribute(\"begin\")) {\n            return null;\n        }\n        const startTime = parseTtmlTime(cueElement.getAttribute(\"begin\"), rateInfo);\n        const duration = parseTtmlTime(cueElement.getAttribute(\"dur\"), rateInfo);\n        let endTime = parseTtmlTime(cueElement.getAttribute(\"end\"), rateInfo);\n        if (startTime === null) {\n            throw timestampParsingError(cueElement);\n        }\n        if (endTime === null) {\n            if (duration === null) {\n                throw timestampParsingError(cueElement);\n            }\n            endTime = startTime + duration;\n        }\n        const cue = new VTTCue(startTime - syncTime, endTime - syncTime, cueText);\n        cue.id = generateCueId(cue.startTime, cue.endTime, cue.text);\n        const region = regionElements[cueElement.getAttribute(\"region\")];\n        const style = styleElements[cueElement.getAttribute(\"style\")];\n        // Apply styles to cue\n        const styles = getTtmlStyles(region, style, styleElements);\n        const { textAlign } = styles;\n        if (textAlign) {\n            // cue.positionAlign not settable in FF~2016\n            const lineAlign = textAlignToLineAlign[textAlign];\n            if (lineAlign) {\n                cue.lineAlign = lineAlign;\n            }\n            cue.align = textAlign;\n        }\n        _extends(cue, styles);\n        return cue;\n    }).filter((cue)=>cue !== null);\n}\nfunction getElementCollection(fromElement, parentName, childName) {\n    const parent = fromElement.getElementsByTagName(parentName)[0];\n    if (parent) {\n        return [].slice.call(parent.querySelectorAll(childName));\n    }\n    return [];\n}\nfunction collectionToDictionary(elementsWithId) {\n    return elementsWithId.reduce((dict, element)=>{\n        const id = element.getAttribute(\"xml:id\");\n        if (id) {\n            dict[id] = element;\n        }\n        return dict;\n    }, {});\n}\nfunction getTextContent(element, trim) {\n    return [].slice.call(element.childNodes).reduce((str, node, i)=>{\n        var _node$childNodes;\n        if (node.nodeName === \"br\" && i) {\n            return str + \"\\n\";\n        }\n        if ((_node$childNodes = node.childNodes) != null && _node$childNodes.length) {\n            return getTextContent(node, trim);\n        } else if (trim) {\n            return str + node.textContent.trim().replace(/\\s+/g, \" \");\n        }\n        return str + node.textContent;\n    }, \"\");\n}\nfunction getTtmlStyles(region, style, styleElements) {\n    const ttsNs = \"http://www.w3.org/ns/ttml#styling\";\n    let regionStyle = null;\n    const styleAttributes = [\n        \"displayAlign\",\n        \"textAlign\",\n        \"color\",\n        \"backgroundColor\",\n        \"fontSize\",\n        \"fontFamily\"\n    ];\n    const regionStyleName = region != null && region.hasAttribute(\"style\") ? region.getAttribute(\"style\") : null;\n    if (regionStyleName && styleElements.hasOwnProperty(regionStyleName)) {\n        regionStyle = styleElements[regionStyleName];\n    }\n    return styleAttributes.reduce((styles, name)=>{\n        const value = getAttributeNS(style, ttsNs, name) || getAttributeNS(region, ttsNs, name) || getAttributeNS(regionStyle, ttsNs, name);\n        if (value) {\n            styles[name] = value;\n        }\n        return styles;\n    }, {});\n}\nfunction getAttributeNS(element, ns, name) {\n    if (!element) {\n        return null;\n    }\n    return element.hasAttributeNS(ns, name) ? element.getAttributeNS(ns, name) : null;\n}\nfunction timestampParsingError(node) {\n    return new Error(`Could not parse ttml timestamp ${node}`);\n}\nfunction parseTtmlTime(timeAttributeValue, rateInfo) {\n    if (!timeAttributeValue) {\n        return null;\n    }\n    let seconds = parseTimeStamp(timeAttributeValue);\n    if (seconds === null) {\n        if (HMSF_REGEX.test(timeAttributeValue)) {\n            seconds = parseHoursMinutesSecondsFrames(timeAttributeValue, rateInfo);\n        } else if (TIME_UNIT_REGEX.test(timeAttributeValue)) {\n            seconds = parseTimeUnits(timeAttributeValue, rateInfo);\n        }\n    }\n    return seconds;\n}\nfunction parseHoursMinutesSecondsFrames(timeAttributeValue, rateInfo) {\n    const m = HMSF_REGEX.exec(timeAttributeValue);\n    const frames = (m[4] | 0) + (m[5] | 0) / rateInfo.subFrameRate;\n    return (m[1] | 0) * 3600 + (m[2] | 0) * 60 + (m[3] | 0) + frames / rateInfo.frameRate;\n}\nfunction parseTimeUnits(timeAttributeValue, rateInfo) {\n    const m = TIME_UNIT_REGEX.exec(timeAttributeValue);\n    const value = Number(m[1]);\n    const unit = m[2];\n    switch(unit){\n        case \"h\":\n            return value * 3600;\n        case \"m\":\n            return value * 60;\n        case \"ms\":\n            return value * 1000;\n        case \"f\":\n            return value / rateInfo.frameRate;\n        case \"t\":\n            return value / rateInfo.tickRate;\n    }\n    return value;\n}\nclass TimelineController {\n    constructor(hls){\n        this.hls = void 0;\n        this.media = null;\n        this.config = void 0;\n        this.enabled = true;\n        this.Cues = void 0;\n        this.textTracks = [];\n        this.tracks = [];\n        this.initPTS = [];\n        this.unparsedVttFrags = [];\n        this.captionsTracks = {};\n        this.nonNativeCaptionsTracks = {};\n        this.cea608Parser1 = void 0;\n        this.cea608Parser2 = void 0;\n        this.lastCc = -1;\n        // Last video (CEA-608) fragment CC\n        this.lastSn = -1;\n        // Last video (CEA-608) fragment MSN\n        this.lastPartIndex = -1;\n        // Last video (CEA-608) fragment Part Index\n        this.prevCC = -1;\n        // Last subtitle fragment CC\n        this.vttCCs = newVTTCCs();\n        this.captionsProperties = void 0;\n        this.hls = hls;\n        this.config = hls.config;\n        this.Cues = hls.config.cueHandler;\n        this.captionsProperties = {\n            textTrack1: {\n                label: this.config.captionsTextTrack1Label,\n                languageCode: this.config.captionsTextTrack1LanguageCode\n            },\n            textTrack2: {\n                label: this.config.captionsTextTrack2Label,\n                languageCode: this.config.captionsTextTrack2LanguageCode\n            },\n            textTrack3: {\n                label: this.config.captionsTextTrack3Label,\n                languageCode: this.config.captionsTextTrack3LanguageCode\n            },\n            textTrack4: {\n                label: this.config.captionsTextTrack4Label,\n                languageCode: this.config.captionsTextTrack4LanguageCode\n            }\n        };\n        hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n        hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n        hls.on(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);\n        hls.on(Events.FRAG_LOADING, this.onFragLoading, this);\n        hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);\n        hls.on(Events.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this);\n        hls.on(Events.FRAG_DECRYPTED, this.onFragDecrypted, this);\n        hls.on(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);\n        hls.on(Events.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this);\n        hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    }\n    destroy() {\n        const { hls } = this;\n        hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n        hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n        hls.off(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);\n        hls.off(Events.FRAG_LOADING, this.onFragLoading, this);\n        hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);\n        hls.off(Events.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this);\n        hls.off(Events.FRAG_DECRYPTED, this.onFragDecrypted, this);\n        hls.off(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);\n        hls.off(Events.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this);\n        hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n        // @ts-ignore\n        this.hls = this.config = null;\n        this.cea608Parser1 = this.cea608Parser2 = undefined;\n    }\n    initCea608Parsers() {\n        if (this.config.enableCEA708Captions && (!this.cea608Parser1 || !this.cea608Parser2)) {\n            const channel1 = new OutputFilter(this, \"textTrack1\");\n            const channel2 = new OutputFilter(this, \"textTrack2\");\n            const channel3 = new OutputFilter(this, \"textTrack3\");\n            const channel4 = new OutputFilter(this, \"textTrack4\");\n            this.cea608Parser1 = new Cea608Parser(1, channel1, channel2);\n            this.cea608Parser2 = new Cea608Parser(3, channel3, channel4);\n        }\n    }\n    addCues(trackName, startTime, endTime, screen, cueRanges) {\n        // skip cues which overlap more than 50% with previously parsed time ranges\n        let merged = false;\n        for(let i = cueRanges.length; i--;){\n            const cueRange = cueRanges[i];\n            const overlap = intersection(cueRange[0], cueRange[1], startTime, endTime);\n            if (overlap >= 0) {\n                cueRange[0] = Math.min(cueRange[0], startTime);\n                cueRange[1] = Math.max(cueRange[1], endTime);\n                merged = true;\n                if (overlap / (endTime - startTime) > 0.5) {\n                    return;\n                }\n            }\n        }\n        if (!merged) {\n            cueRanges.push([\n                startTime,\n                endTime\n            ]);\n        }\n        if (this.config.renderTextTracksNatively) {\n            const track = this.captionsTracks[trackName];\n            this.Cues.newCue(track, startTime, endTime, screen);\n        } else {\n            const cues = this.Cues.newCue(null, startTime, endTime, screen);\n            this.hls.trigger(Events.CUES_PARSED, {\n                type: \"captions\",\n                cues,\n                track: trackName\n            });\n        }\n    }\n    // Triggered when an initial PTS is found; used for synchronisation of WebVTT.\n    onInitPtsFound(event, { frag, id, initPTS, timescale }) {\n        const { unparsedVttFrags } = this;\n        if (id === \"main\") {\n            this.initPTS[frag.cc] = {\n                baseTime: initPTS,\n                timescale\n            };\n        }\n        // Due to asynchronous processing, initial PTS may arrive later than the first VTT fragments are loaded.\n        // Parse any unparsed fragments upon receiving the initial PTS.\n        if (unparsedVttFrags.length) {\n            this.unparsedVttFrags = [];\n            unparsedVttFrags.forEach((frag)=>{\n                this.onFragLoaded(Events.FRAG_LOADED, frag);\n            });\n        }\n    }\n    getExistingTrack(label, language) {\n        const { media } = this;\n        if (media) {\n            for(let i = 0; i < media.textTracks.length; i++){\n                const textTrack = media.textTracks[i];\n                if (canReuseVttTextTrack(textTrack, {\n                    name: label,\n                    lang: language,\n                    attrs: {}\n                })) {\n                    return textTrack;\n                }\n            }\n        }\n        return null;\n    }\n    createCaptionsTrack(trackName) {\n        if (this.config.renderTextTracksNatively) {\n            this.createNativeTrack(trackName);\n        } else {\n            this.createNonNativeTrack(trackName);\n        }\n    }\n    createNativeTrack(trackName) {\n        if (this.captionsTracks[trackName]) {\n            return;\n        }\n        const { captionsProperties, captionsTracks, media } = this;\n        const { label, languageCode } = captionsProperties[trackName];\n        // Enable reuse of existing text track.\n        const existingTrack = this.getExistingTrack(label, languageCode);\n        if (!existingTrack) {\n            const textTrack = this.createTextTrack(\"captions\", label, languageCode);\n            if (textTrack) {\n                // Set a special property on the track so we know it's managed by Hls.js\n                textTrack[trackName] = true;\n                captionsTracks[trackName] = textTrack;\n            }\n        } else {\n            captionsTracks[trackName] = existingTrack;\n            clearCurrentCues(captionsTracks[trackName]);\n            sendAddTrackEvent(captionsTracks[trackName], media);\n        }\n    }\n    createNonNativeTrack(trackName) {\n        if (this.nonNativeCaptionsTracks[trackName]) {\n            return;\n        }\n        // Create a list of a single track for the provider to consume\n        const trackProperties = this.captionsProperties[trackName];\n        if (!trackProperties) {\n            return;\n        }\n        const label = trackProperties.label;\n        const track = {\n            _id: trackName,\n            label,\n            kind: \"captions\",\n            default: trackProperties.media ? !!trackProperties.media.default : false,\n            closedCaptions: trackProperties.media\n        };\n        this.nonNativeCaptionsTracks[trackName] = track;\n        this.hls.trigger(Events.NON_NATIVE_TEXT_TRACKS_FOUND, {\n            tracks: [\n                track\n            ]\n        });\n    }\n    createTextTrack(kind, label, lang) {\n        const media = this.media;\n        if (!media) {\n            return;\n        }\n        return media.addTextTrack(kind, label, lang);\n    }\n    onMediaAttaching(event, data) {\n        this.media = data.media;\n        this._cleanTracks();\n    }\n    onMediaDetaching() {\n        const { captionsTracks } = this;\n        Object.keys(captionsTracks).forEach((trackName)=>{\n            clearCurrentCues(captionsTracks[trackName]);\n            delete captionsTracks[trackName];\n        });\n        this.nonNativeCaptionsTracks = {};\n    }\n    onManifestLoading() {\n        // Detect discontinuity in video fragment (CEA-608) parsing\n        this.lastCc = -1;\n        this.lastSn = -1;\n        this.lastPartIndex = -1;\n        // Detect discontinuity in subtitle manifests\n        this.prevCC = -1;\n        this.vttCCs = newVTTCCs();\n        // Reset tracks\n        this._cleanTracks();\n        this.tracks = [];\n        this.captionsTracks = {};\n        this.nonNativeCaptionsTracks = {};\n        this.textTracks = [];\n        this.unparsedVttFrags = [];\n        this.initPTS = [];\n        if (this.cea608Parser1 && this.cea608Parser2) {\n            this.cea608Parser1.reset();\n            this.cea608Parser2.reset();\n        }\n    }\n    _cleanTracks() {\n        // clear outdated subtitles\n        const { media } = this;\n        if (!media) {\n            return;\n        }\n        const textTracks = media.textTracks;\n        if (textTracks) {\n            for(let i = 0; i < textTracks.length; i++){\n                clearCurrentCues(textTracks[i]);\n            }\n        }\n    }\n    onSubtitleTracksUpdated(event, data) {\n        const tracks = data.subtitleTracks || [];\n        const hasIMSC1 = tracks.some((track)=>track.textCodec === IMSC1_CODEC);\n        if (this.config.enableWebVTT || hasIMSC1 && this.config.enableIMSC1) {\n            const listIsIdentical = subtitleOptionsIdentical(this.tracks, tracks);\n            if (listIsIdentical) {\n                this.tracks = tracks;\n                return;\n            }\n            this.textTracks = [];\n            this.tracks = tracks;\n            if (this.config.renderTextTracksNatively) {\n                const media = this.media;\n                const inUseTracks = media ? filterSubtitleTracks(media.textTracks) : null;\n                this.tracks.forEach((track, index)=>{\n                    // Reuse tracks with the same label and lang, but do not reuse 608/708 tracks\n                    let textTrack;\n                    if (inUseTracks) {\n                        let inUseTrack = null;\n                        for(let i = 0; i < inUseTracks.length; i++){\n                            if (inUseTracks[i] && canReuseVttTextTrack(inUseTracks[i], track)) {\n                                inUseTrack = inUseTracks[i];\n                                inUseTracks[i] = null;\n                                break;\n                            }\n                        }\n                        if (inUseTrack) {\n                            textTrack = inUseTrack;\n                        }\n                    }\n                    if (textTrack) {\n                        clearCurrentCues(textTrack);\n                    } else {\n                        const textTrackKind = captionsOrSubtitlesFromCharacteristics(track);\n                        textTrack = this.createTextTrack(textTrackKind, track.name, track.lang);\n                        if (textTrack) {\n                            textTrack.mode = \"disabled\";\n                        }\n                    }\n                    if (textTrack) {\n                        this.textTracks.push(textTrack);\n                    }\n                });\n                // Warn when video element has captions or subtitle TextTracks carried over from another source\n                if (inUseTracks != null && inUseTracks.length) {\n                    const unusedTextTracks = inUseTracks.filter((t)=>t !== null).map((t)=>t.label);\n                    if (unusedTextTracks.length) {\n                        logger.warn(`Media element contains unused subtitle tracks: ${unusedTextTracks.join(\", \")}. Replace media element for each source to clear TextTracks and captions menu.`);\n                    }\n                }\n            } else if (this.tracks.length) {\n                // Create a list of tracks for the provider to consume\n                const tracksList = this.tracks.map((track)=>{\n                    return {\n                        label: track.name,\n                        kind: track.type.toLowerCase(),\n                        default: track.default,\n                        subtitleTrack: track\n                    };\n                });\n                this.hls.trigger(Events.NON_NATIVE_TEXT_TRACKS_FOUND, {\n                    tracks: tracksList\n                });\n            }\n        }\n    }\n    onManifestLoaded(event, data) {\n        if (this.config.enableCEA708Captions && data.captions) {\n            data.captions.forEach((captionsTrack)=>{\n                const instreamIdMatch = /(?:CC|SERVICE)([1-4])/.exec(captionsTrack.instreamId);\n                if (!instreamIdMatch) {\n                    return;\n                }\n                const trackName = `textTrack${instreamIdMatch[1]}`;\n                const trackProperties = this.captionsProperties[trackName];\n                if (!trackProperties) {\n                    return;\n                }\n                trackProperties.label = captionsTrack.name;\n                if (captionsTrack.lang) {\n                    // optional attribute\n                    trackProperties.languageCode = captionsTrack.lang;\n                }\n                trackProperties.media = captionsTrack;\n            });\n        }\n    }\n    closedCaptionsForLevel(frag) {\n        const level = this.hls.levels[frag.level];\n        return level == null ? void 0 : level.attrs[\"CLOSED-CAPTIONS\"];\n    }\n    onFragLoading(event, data) {\n        this.initCea608Parsers();\n        const { cea608Parser1, cea608Parser2, lastCc, lastSn, lastPartIndex } = this;\n        if (!this.enabled || !cea608Parser1 || !cea608Parser2) {\n            return;\n        }\n        // if this frag isn't contiguous, clear the parser so cues with bad start/end times aren't added to the textTrack\n        if (data.frag.type === PlaylistLevelType.MAIN) {\n            var _data$part$index, _data$part;\n            const { cc, sn } = data.frag;\n            const partIndex = (_data$part$index = data == null ? void 0 : (_data$part = data.part) == null ? void 0 : _data$part.index) != null ? _data$part$index : -1;\n            if (!(sn === lastSn + 1 || sn === lastSn && partIndex === lastPartIndex + 1 || cc === lastCc)) {\n                cea608Parser1.reset();\n                cea608Parser2.reset();\n            }\n            this.lastCc = cc;\n            this.lastSn = sn;\n            this.lastPartIndex = partIndex;\n        }\n    }\n    onFragLoaded(event, data) {\n        const { frag, payload } = data;\n        if (frag.type === PlaylistLevelType.SUBTITLE) {\n            // If fragment is subtitle type, parse as WebVTT.\n            if (payload.byteLength) {\n                const decryptData = frag.decryptdata;\n                // fragment after decryption has a stats object\n                const decrypted = \"stats\" in data;\n                // If the subtitles are not encrypted, parse VTTs now. Otherwise, we need to wait.\n                if (decryptData == null || !decryptData.encrypted || decrypted) {\n                    const trackPlaylistMedia = this.tracks[frag.level];\n                    const vttCCs = this.vttCCs;\n                    if (!vttCCs[frag.cc]) {\n                        vttCCs[frag.cc] = {\n                            start: frag.start,\n                            prevCC: this.prevCC,\n                            new: true\n                        };\n                        this.prevCC = frag.cc;\n                    }\n                    if (trackPlaylistMedia && trackPlaylistMedia.textCodec === IMSC1_CODEC) {\n                        this._parseIMSC1(frag, payload);\n                    } else {\n                        this._parseVTTs(data);\n                    }\n                }\n            } else {\n                // In case there is no payload, finish unsuccessfully.\n                this.hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {\n                    success: false,\n                    frag,\n                    error: new Error(\"Empty subtitle payload\")\n                });\n            }\n        }\n    }\n    _parseIMSC1(frag, payload) {\n        const hls = this.hls;\n        parseIMSC1(payload, this.initPTS[frag.cc], (cues)=>{\n            this._appendCues(cues, frag.level);\n            hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {\n                success: true,\n                frag: frag\n            });\n        }, (error)=>{\n            logger.log(`Failed to parse IMSC1: ${error}`);\n            hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {\n                success: false,\n                frag: frag,\n                error\n            });\n        });\n    }\n    _parseVTTs(data) {\n        var _frag$initSegment;\n        const { frag, payload } = data;\n        // We need an initial synchronisation PTS. Store fragments as long as none has arrived\n        const { initPTS, unparsedVttFrags } = this;\n        const maxAvCC = initPTS.length - 1;\n        if (!initPTS[frag.cc] && maxAvCC === -1) {\n            unparsedVttFrags.push(data);\n            return;\n        }\n        const hls = this.hls;\n        // Parse the WebVTT file contents.\n        const payloadWebVTT = (_frag$initSegment = frag.initSegment) != null && _frag$initSegment.data ? appendUint8Array(frag.initSegment.data, new Uint8Array(payload)) : payload;\n        parseWebVTT(payloadWebVTT, this.initPTS[frag.cc], this.vttCCs, frag.cc, frag.start, (cues)=>{\n            this._appendCues(cues, frag.level);\n            hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {\n                success: true,\n                frag: frag\n            });\n        }, (error)=>{\n            const missingInitPTS = error.message === \"Missing initPTS for VTT MPEGTS\";\n            if (missingInitPTS) {\n                unparsedVttFrags.push(data);\n            } else {\n                this._fallbackToIMSC1(frag, payload);\n            }\n            // Something went wrong while parsing. Trigger event with success false.\n            logger.log(`Failed to parse VTT cue: ${error}`);\n            if (missingInitPTS && maxAvCC > frag.cc) {\n                return;\n            }\n            hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {\n                success: false,\n                frag: frag,\n                error\n            });\n        });\n    }\n    _fallbackToIMSC1(frag, payload) {\n        // If textCodec is unknown, try parsing as IMSC1. Set textCodec based on the result\n        const trackPlaylistMedia = this.tracks[frag.level];\n        if (!trackPlaylistMedia.textCodec) {\n            parseIMSC1(payload, this.initPTS[frag.cc], ()=>{\n                trackPlaylistMedia.textCodec = IMSC1_CODEC;\n                this._parseIMSC1(frag, payload);\n            }, ()=>{\n                trackPlaylistMedia.textCodec = \"wvtt\";\n            });\n        }\n    }\n    _appendCues(cues, fragLevel) {\n        const hls = this.hls;\n        if (this.config.renderTextTracksNatively) {\n            const textTrack = this.textTracks[fragLevel];\n            // WebVTTParser.parse is an async method and if the currently selected text track mode is set to \"disabled\"\n            // before parsing is done then don't try to access currentTrack.cues.getCueById as cues will be null\n            // and trying to access getCueById method of cues will throw an exception\n            // Because we check if the mode is disabled, we can force check `cues` below. They can't be null.\n            if (!textTrack || textTrack.mode === \"disabled\") {\n                return;\n            }\n            cues.forEach((cue)=>addCueToTrack(textTrack, cue));\n        } else {\n            const currentTrack = this.tracks[fragLevel];\n            if (!currentTrack) {\n                return;\n            }\n            const track = currentTrack.default ? \"default\" : \"subtitles\" + fragLevel;\n            hls.trigger(Events.CUES_PARSED, {\n                type: \"subtitles\",\n                cues,\n                track\n            });\n        }\n    }\n    onFragDecrypted(event, data) {\n        const { frag } = data;\n        if (frag.type === PlaylistLevelType.SUBTITLE) {\n            this.onFragLoaded(Events.FRAG_LOADED, data);\n        }\n    }\n    onSubtitleTracksCleared() {\n        this.tracks = [];\n        this.captionsTracks = {};\n    }\n    onFragParsingUserdata(event, data) {\n        this.initCea608Parsers();\n        const { cea608Parser1, cea608Parser2 } = this;\n        if (!this.enabled || !cea608Parser1 || !cea608Parser2) {\n            return;\n        }\n        const { frag, samples } = data;\n        if (frag.type === PlaylistLevelType.MAIN && this.closedCaptionsForLevel(frag) === \"NONE\") {\n            return;\n        }\n        // If the event contains captions (found in the bytes property), push all bytes into the parser immediately\n        // It will create the proper timestamps based on the PTS value\n        for(let i = 0; i < samples.length; i++){\n            const ccBytes = samples[i].bytes;\n            if (ccBytes) {\n                const ccdatas = this.extractCea608Data(ccBytes);\n                cea608Parser1.addData(samples[i].pts, ccdatas[0]);\n                cea608Parser2.addData(samples[i].pts, ccdatas[1]);\n            }\n        }\n    }\n    onBufferFlushing(event, { startOffset, endOffset, endOffsetSubtitles, type }) {\n        const { media } = this;\n        if (!media || media.currentTime < endOffset) {\n            return;\n        }\n        // Clear 608 caption cues from the captions TextTracks when the video back buffer is flushed\n        // Forward cues are never removed because we can loose streamed 608 content from recent fragments\n        if (!type || type === \"video\") {\n            const { captionsTracks } = this;\n            Object.keys(captionsTracks).forEach((trackName)=>removeCuesInRange(captionsTracks[trackName], startOffset, endOffset));\n        }\n        if (this.config.renderTextTracksNatively) {\n            // Clear VTT/IMSC1 subtitle cues from the subtitle TextTracks when the back buffer is flushed\n            if (startOffset === 0 && endOffsetSubtitles !== undefined) {\n                const { textTracks } = this;\n                Object.keys(textTracks).forEach((trackName)=>removeCuesInRange(textTracks[trackName], startOffset, endOffsetSubtitles));\n            }\n        }\n    }\n    extractCea608Data(byteArray) {\n        const actualCCBytes = [\n            [],\n            []\n        ];\n        const count = byteArray[0] & 0x1f;\n        let position = 2;\n        for(let j = 0; j < count; j++){\n            const tmpByte = byteArray[position++];\n            const ccbyte1 = 0x7f & byteArray[position++];\n            const ccbyte2 = 0x7f & byteArray[position++];\n            if (ccbyte1 === 0 && ccbyte2 === 0) {\n                continue;\n            }\n            const ccValid = (0x04 & tmpByte) !== 0; // Support all four channels\n            if (ccValid) {\n                const ccType = 0x03 & tmpByte;\n                if (0x00 /* CEA608 field1*/  === ccType || 0x01 /* CEA608 field2*/  === ccType) {\n                    // Exclude CEA708 CC data.\n                    actualCCBytes[ccType].push(ccbyte1);\n                    actualCCBytes[ccType].push(ccbyte2);\n                }\n            }\n        }\n        return actualCCBytes;\n    }\n}\nfunction captionsOrSubtitlesFromCharacteristics(track) {\n    if (track.characteristics) {\n        if (/transcribes-spoken-dialog/gi.test(track.characteristics) && /describes-music-and-sound/gi.test(track.characteristics)) {\n            return \"captions\";\n        }\n    }\n    return \"subtitles\";\n}\nfunction canReuseVttTextTrack(inUseTrack, manifestTrack) {\n    return !!inUseTrack && inUseTrack.kind === captionsOrSubtitlesFromCharacteristics(manifestTrack) && subtitleTrackMatchesTextTrack(manifestTrack, inUseTrack);\n}\nfunction intersection(x1, x2, y1, y2) {\n    return Math.min(x2, y2) - Math.max(x1, y1);\n}\nfunction newVTTCCs() {\n    return {\n        ccOffset: 0,\n        presentationOffset: 0,\n        0: {\n            start: 0,\n            prevCC: -1,\n            new: true\n        }\n    };\n}\nclass CapLevelController {\n    constructor(hls){\n        this.hls = void 0;\n        this.autoLevelCapping = void 0;\n        this.firstLevel = void 0;\n        this.media = void 0;\n        this.restrictedLevels = void 0;\n        this.timer = void 0;\n        this.clientRect = void 0;\n        this.streamController = void 0;\n        this.hls = hls;\n        this.autoLevelCapping = Number.POSITIVE_INFINITY;\n        this.firstLevel = -1;\n        this.media = null;\n        this.restrictedLevels = [];\n        this.timer = undefined;\n        this.clientRect = null;\n        this.registerListeners();\n    }\n    setStreamController(streamController) {\n        this.streamController = streamController;\n    }\n    destroy() {\n        if (this.hls) {\n            this.unregisterListener();\n        }\n        if (this.timer) {\n            this.stopCapping();\n        }\n        this.media = null;\n        this.clientRect = null;\n        // @ts-ignore\n        this.hls = this.streamController = null;\n    }\n    registerListeners() {\n        const { hls } = this;\n        hls.on(Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);\n        hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n        hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n        hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n        hls.on(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n        hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    }\n    unregisterListener() {\n        const { hls } = this;\n        hls.off(Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);\n        hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n        hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n        hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n        hls.off(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n        hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    }\n    onFpsDropLevelCapping(event, data) {\n        // Don't add a restricted level more than once\n        const level = this.hls.levels[data.droppedLevel];\n        if (this.isLevelAllowed(level)) {\n            this.restrictedLevels.push({\n                bitrate: level.bitrate,\n                height: level.height,\n                width: level.width\n            });\n        }\n    }\n    onMediaAttaching(event, data) {\n        this.media = data.media instanceof HTMLVideoElement ? data.media : null;\n        this.clientRect = null;\n        if (this.timer && this.hls.levels.length) {\n            this.detectPlayerSize();\n        }\n    }\n    onManifestParsed(event, data) {\n        const hls = this.hls;\n        this.restrictedLevels = [];\n        this.firstLevel = data.firstLevel;\n        if (hls.config.capLevelToPlayerSize && data.video) {\n            // Start capping immediately if the manifest has signaled video codecs\n            this.startCapping();\n        }\n    }\n    onLevelsUpdated(event, data) {\n        if (this.timer && isFiniteNumber(this.autoLevelCapping)) {\n            this.detectPlayerSize();\n        }\n    }\n    // Only activate capping when playing a video stream; otherwise, multi-bitrate audio-only streams will be restricted\n    // to the first level\n    onBufferCodecs(event, data) {\n        const hls = this.hls;\n        if (hls.config.capLevelToPlayerSize && data.video) {\n            // If the manifest did not signal a video codec capping has been deferred until we're certain video is present\n            this.startCapping();\n        }\n    }\n    onMediaDetaching() {\n        this.stopCapping();\n    }\n    detectPlayerSize() {\n        if (this.media) {\n            if (this.mediaHeight <= 0 || this.mediaWidth <= 0) {\n                this.clientRect = null;\n                return;\n            }\n            const levels = this.hls.levels;\n            if (levels.length) {\n                const hls = this.hls;\n                const maxLevel = this.getMaxLevel(levels.length - 1);\n                if (maxLevel !== this.autoLevelCapping) {\n                    logger.log(`Setting autoLevelCapping to ${maxLevel}: ${levels[maxLevel].height}p@${levels[maxLevel].bitrate} for media ${this.mediaWidth}x${this.mediaHeight}`);\n                }\n                hls.autoLevelCapping = maxLevel;\n                if (hls.autoLevelCapping > this.autoLevelCapping && this.streamController) {\n                    // if auto level capping has a higher value for the previous one, flush the buffer using nextLevelSwitch\n                    // usually happen when the user go to the fullscreen mode.\n                    this.streamController.nextLevelSwitch();\n                }\n                this.autoLevelCapping = hls.autoLevelCapping;\n            }\n        }\n    }\n    /*\n   * returns level should be the one with the dimensions equal or greater than the media (player) dimensions (so the video will be downscaled)\n   */ getMaxLevel(capLevelIndex) {\n        const levels = this.hls.levels;\n        if (!levels.length) {\n            return -1;\n        }\n        const validLevels = levels.filter((level, index)=>this.isLevelAllowed(level) && index <= capLevelIndex);\n        this.clientRect = null;\n        return CapLevelController.getMaxLevelByMediaSize(validLevels, this.mediaWidth, this.mediaHeight);\n    }\n    startCapping() {\n        if (this.timer) {\n            // Don't reset capping if started twice; this can happen if the manifest signals a video codec\n            return;\n        }\n        this.autoLevelCapping = Number.POSITIVE_INFINITY;\n        self.clearInterval(this.timer);\n        this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1000);\n        this.detectPlayerSize();\n    }\n    stopCapping() {\n        this.restrictedLevels = [];\n        this.firstLevel = -1;\n        this.autoLevelCapping = Number.POSITIVE_INFINITY;\n        if (this.timer) {\n            self.clearInterval(this.timer);\n            this.timer = undefined;\n        }\n    }\n    getDimensions() {\n        if (this.clientRect) {\n            return this.clientRect;\n        }\n        const media = this.media;\n        const boundsRect = {\n            width: 0,\n            height: 0\n        };\n        if (media) {\n            const clientRect = media.getBoundingClientRect();\n            boundsRect.width = clientRect.width;\n            boundsRect.height = clientRect.height;\n            if (!boundsRect.width && !boundsRect.height) {\n                // When the media element has no width or height (equivalent to not being in the DOM),\n                // then use its width and height attributes (media.width, media.height)\n                boundsRect.width = clientRect.right - clientRect.left || media.width || 0;\n                boundsRect.height = clientRect.bottom - clientRect.top || media.height || 0;\n            }\n        }\n        this.clientRect = boundsRect;\n        return boundsRect;\n    }\n    get mediaWidth() {\n        return this.getDimensions().width * this.contentScaleFactor;\n    }\n    get mediaHeight() {\n        return this.getDimensions().height * this.contentScaleFactor;\n    }\n    get contentScaleFactor() {\n        let pixelRatio = 1;\n        if (!this.hls.config.ignoreDevicePixelRatio) {\n            try {\n                pixelRatio = self.devicePixelRatio;\n            } catch (e) {\n            /* no-op */ }\n        }\n        return pixelRatio;\n    }\n    isLevelAllowed(level) {\n        const restrictedLevels = this.restrictedLevels;\n        return !restrictedLevels.some((restrictedLevel)=>{\n            return level.bitrate === restrictedLevel.bitrate && level.width === restrictedLevel.width && level.height === restrictedLevel.height;\n        });\n    }\n    static getMaxLevelByMediaSize(levels, width, height) {\n        if (!(levels != null && levels.length)) {\n            return -1;\n        }\n        // Levels can have the same dimensions but differing bandwidths - since levels are ordered, we can look to the next\n        // to determine whether we've chosen the greatest bandwidth for the media's dimensions\n        const atGreatestBandwidth = (curLevel, nextLevel)=>{\n            if (!nextLevel) {\n                return true;\n            }\n            return curLevel.width !== nextLevel.width || curLevel.height !== nextLevel.height;\n        };\n        // If we run through the loop without breaking, the media's dimensions are greater than every level, so default to\n        // the max level\n        let maxLevelIndex = levels.length - 1;\n        // Prevent changes in aspect-ratio from causing capping to toggle back and forth\n        const squareSize = Math.max(width, height);\n        for(let i = 0; i < levels.length; i += 1){\n            const level = levels[i];\n            if ((level.width >= squareSize || level.height >= squareSize) && atGreatestBandwidth(level, levels[i + 1])) {\n                maxLevelIndex = i;\n                break;\n            }\n        }\n        return maxLevelIndex;\n    }\n}\nclass FPSController {\n    constructor(hls){\n        this.hls = void 0;\n        this.isVideoPlaybackQualityAvailable = false;\n        this.timer = void 0;\n        this.media = null;\n        this.lastTime = void 0;\n        this.lastDroppedFrames = 0;\n        this.lastDecodedFrames = 0;\n        // stream controller must be provided as a dependency!\n        this.streamController = void 0;\n        this.hls = hls;\n        this.registerListeners();\n    }\n    setStreamController(streamController) {\n        this.streamController = streamController;\n    }\n    registerListeners() {\n        this.hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    }\n    unregisterListeners() {\n        this.hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    }\n    destroy() {\n        if (this.timer) {\n            clearInterval(this.timer);\n        }\n        this.unregisterListeners();\n        this.isVideoPlaybackQualityAvailable = false;\n        this.media = null;\n    }\n    onMediaAttaching(event, data) {\n        const config = this.hls.config;\n        if (config.capLevelOnFPSDrop) {\n            const media = data.media instanceof self.HTMLVideoElement ? data.media : null;\n            this.media = media;\n            if (media && typeof media.getVideoPlaybackQuality === \"function\") {\n                this.isVideoPlaybackQualityAvailable = true;\n            }\n            self.clearInterval(this.timer);\n            this.timer = self.setInterval(this.checkFPSInterval.bind(this), config.fpsDroppedMonitoringPeriod);\n        }\n    }\n    checkFPS(video, decodedFrames, droppedFrames) {\n        const currentTime = performance.now();\n        if (decodedFrames) {\n            if (this.lastTime) {\n                const currentPeriod = currentTime - this.lastTime;\n                const currentDropped = droppedFrames - this.lastDroppedFrames;\n                const currentDecoded = decodedFrames - this.lastDecodedFrames;\n                const droppedFPS = 1000 * currentDropped / currentPeriod;\n                const hls = this.hls;\n                hls.trigger(Events.FPS_DROP, {\n                    currentDropped: currentDropped,\n                    currentDecoded: currentDecoded,\n                    totalDroppedFrames: droppedFrames\n                });\n                if (droppedFPS > 0) {\n                    // logger.log('checkFPS : droppedFPS/decodedFPS:' + droppedFPS/(1000 * currentDecoded / currentPeriod));\n                    if (currentDropped > hls.config.fpsDroppedMonitoringThreshold * currentDecoded) {\n                        let currentLevel = hls.currentLevel;\n                        logger.warn(\"drop FPS ratio greater than max allowed value for currentLevel: \" + currentLevel);\n                        if (currentLevel > 0 && (hls.autoLevelCapping === -1 || hls.autoLevelCapping >= currentLevel)) {\n                            currentLevel = currentLevel - 1;\n                            hls.trigger(Events.FPS_DROP_LEVEL_CAPPING, {\n                                level: currentLevel,\n                                droppedLevel: hls.currentLevel\n                            });\n                            hls.autoLevelCapping = currentLevel;\n                            this.streamController.nextLevelSwitch();\n                        }\n                    }\n                }\n            }\n            this.lastTime = currentTime;\n            this.lastDroppedFrames = droppedFrames;\n            this.lastDecodedFrames = decodedFrames;\n        }\n    }\n    checkFPSInterval() {\n        const video = this.media;\n        if (video) {\n            if (this.isVideoPlaybackQualityAvailable) {\n                const videoPlaybackQuality = video.getVideoPlaybackQuality();\n                this.checkFPS(video, videoPlaybackQuality.totalVideoFrames, videoPlaybackQuality.droppedVideoFrames);\n            } else {\n                // HTMLVideoElement doesn't include the webkit types\n                this.checkFPS(video, video.webkitDecodedFrameCount, video.webkitDroppedFrameCount);\n            }\n        }\n    }\n}\nconst LOGGER_PREFIX = \"[eme]\";\n/**\n * Controller to deal with encrypted media extensions (EME)\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API\n *\n * @class\n * @constructor\n */ class EMEController {\n    constructor(hls){\n        this.hls = void 0;\n        this.config = void 0;\n        this.media = null;\n        this.keyFormatPromise = null;\n        this.keySystemAccessPromises = {};\n        this._requestLicenseFailureCount = 0;\n        this.mediaKeySessions = [];\n        this.keyIdToKeySessionPromise = {};\n        this.setMediaKeysQueue = EMEController.CDMCleanupPromise ? [\n            EMEController.CDMCleanupPromise\n        ] : [];\n        this.onMediaEncrypted = this._onMediaEncrypted.bind(this);\n        this.onWaitingForKey = this._onWaitingForKey.bind(this);\n        this.debug = logger.debug.bind(logger, LOGGER_PREFIX);\n        this.log = logger.log.bind(logger, LOGGER_PREFIX);\n        this.warn = logger.warn.bind(logger, LOGGER_PREFIX);\n        this.error = logger.error.bind(logger, LOGGER_PREFIX);\n        this.hls = hls;\n        this.config = hls.config;\n        this.registerListeners();\n    }\n    destroy() {\n        this.unregisterListeners();\n        this.onMediaDetached();\n        // Remove any references that could be held in config options or callbacks\n        const config = this.config;\n        config.requestMediaKeySystemAccessFunc = null;\n        config.licenseXhrSetup = config.licenseResponseCallback = undefined;\n        config.drmSystems = config.drmSystemOptions = {};\n        // @ts-ignore\n        this.hls = this.onMediaEncrypted = this.onWaitingForKey = this.keyIdToKeySessionPromise = null;\n        // @ts-ignore\n        this.config = null;\n    }\n    registerListeners() {\n        this.hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        this.hls.on(Events.MEDIA_DETACHED, this.onMediaDetached, this);\n        this.hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        this.hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    }\n    unregisterListeners() {\n        this.hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        this.hls.off(Events.MEDIA_DETACHED, this.onMediaDetached, this);\n        this.hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        this.hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    }\n    getLicenseServerUrl(keySystem) {\n        const { drmSystems, widevineLicenseUrl } = this.config;\n        const keySystemConfiguration = drmSystems[keySystem];\n        if (keySystemConfiguration) {\n            return keySystemConfiguration.licenseUrl;\n        }\n        // For backward compatibility\n        if (keySystem === KeySystems.WIDEVINE && widevineLicenseUrl) {\n            return widevineLicenseUrl;\n        }\n        throw new Error(`no license server URL configured for key-system \"${keySystem}\"`);\n    }\n    getServerCertificateUrl(keySystem) {\n        const { drmSystems } = this.config;\n        const keySystemConfiguration = drmSystems[keySystem];\n        if (keySystemConfiguration) {\n            return keySystemConfiguration.serverCertificateUrl;\n        } else {\n            this.log(`No Server Certificate in config.drmSystems[\"${keySystem}\"]`);\n        }\n    }\n    attemptKeySystemAccess(keySystemsToAttempt) {\n        const levels = this.hls.levels;\n        const uniqueCodec = (value, i, a)=>!!value && a.indexOf(value) === i;\n        const audioCodecs = levels.map((level)=>level.audioCodec).filter(uniqueCodec);\n        const videoCodecs = levels.map((level)=>level.videoCodec).filter(uniqueCodec);\n        if (audioCodecs.length + videoCodecs.length === 0) {\n            videoCodecs.push(\"avc1.42e01e\");\n        }\n        return new Promise((resolve, reject)=>{\n            const attempt = (keySystems)=>{\n                const keySystem = keySystems.shift();\n                this.getMediaKeysPromise(keySystem, audioCodecs, videoCodecs).then((mediaKeys)=>resolve({\n                        keySystem,\n                        mediaKeys\n                    })).catch((error)=>{\n                    if (keySystems.length) {\n                        attempt(keySystems);\n                    } else if (error instanceof EMEKeyError) {\n                        reject(error);\n                    } else {\n                        reject(new EMEKeyError({\n                            type: ErrorTypes.KEY_SYSTEM_ERROR,\n                            details: ErrorDetails.KEY_SYSTEM_NO_ACCESS,\n                            error,\n                            fatal: true\n                        }, error.message));\n                    }\n                });\n            };\n            attempt(keySystemsToAttempt);\n        });\n    }\n    requestMediaKeySystemAccess(keySystem, supportedConfigurations) {\n        const { requestMediaKeySystemAccessFunc } = this.config;\n        if (!(typeof requestMediaKeySystemAccessFunc === \"function\")) {\n            let errMessage = `Configured requestMediaKeySystemAccess is not a function ${requestMediaKeySystemAccessFunc}`;\n            if (requestMediaKeySystemAccess === null && self.location.protocol === \"http:\") {\n                errMessage = `navigator.requestMediaKeySystemAccess is not available over insecure protocol ${location.protocol}`;\n            }\n            return Promise.reject(new Error(errMessage));\n        }\n        return requestMediaKeySystemAccessFunc(keySystem, supportedConfigurations);\n    }\n    getMediaKeysPromise(keySystem, audioCodecs, videoCodecs) {\n        // This can throw, but is caught in event handler callpath\n        const mediaKeySystemConfigs = getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs, this.config.drmSystemOptions);\n        const keySystemAccessPromises = this.keySystemAccessPromises[keySystem];\n        let keySystemAccess = keySystemAccessPromises == null ? void 0 : keySystemAccessPromises.keySystemAccess;\n        if (!keySystemAccess) {\n            this.log(`Requesting encrypted media \"${keySystem}\" key-system access with config: ${JSON.stringify(mediaKeySystemConfigs)}`);\n            keySystemAccess = this.requestMediaKeySystemAccess(keySystem, mediaKeySystemConfigs);\n            const _keySystemAccessPromises = this.keySystemAccessPromises[keySystem] = {\n                keySystemAccess\n            };\n            keySystemAccess.catch((error)=>{\n                this.log(`Failed to obtain access to key-system \"${keySystem}\": ${error}`);\n            });\n            return keySystemAccess.then((mediaKeySystemAccess)=>{\n                this.log(`Access for key-system \"${mediaKeySystemAccess.keySystem}\" obtained`);\n                const certificateRequest = this.fetchServerCertificate(keySystem);\n                this.log(`Create media-keys for \"${keySystem}\"`);\n                _keySystemAccessPromises.mediaKeys = mediaKeySystemAccess.createMediaKeys().then((mediaKeys)=>{\n                    this.log(`Media-keys created for \"${keySystem}\"`);\n                    return certificateRequest.then((certificate)=>{\n                        if (certificate) {\n                            return this.setMediaKeysServerCertificate(mediaKeys, keySystem, certificate);\n                        }\n                        return mediaKeys;\n                    });\n                });\n                _keySystemAccessPromises.mediaKeys.catch((error)=>{\n                    this.error(`Failed to create media-keys for \"${keySystem}\"}: ${error}`);\n                });\n                return _keySystemAccessPromises.mediaKeys;\n            });\n        }\n        return keySystemAccess.then(()=>keySystemAccessPromises.mediaKeys);\n    }\n    createMediaKeySessionContext({ decryptdata, keySystem, mediaKeys }) {\n        this.log(`Creating key-system session \"${keySystem}\" keyId: ${Hex.hexDump(decryptdata.keyId || [])}`);\n        const mediaKeysSession = mediaKeys.createSession();\n        const mediaKeySessionContext = {\n            decryptdata,\n            keySystem,\n            mediaKeys,\n            mediaKeysSession,\n            keyStatus: \"status-pending\"\n        };\n        this.mediaKeySessions.push(mediaKeySessionContext);\n        return mediaKeySessionContext;\n    }\n    renewKeySession(mediaKeySessionContext) {\n        const decryptdata = mediaKeySessionContext.decryptdata;\n        if (decryptdata.pssh) {\n            const keySessionContext = this.createMediaKeySessionContext(mediaKeySessionContext);\n            const keyId = this.getKeyIdString(decryptdata);\n            const scheme = \"cenc\";\n            this.keyIdToKeySessionPromise[keyId] = this.generateRequestWithPreferredKeySession(keySessionContext, scheme, decryptdata.pssh, \"expired\");\n        } else {\n            this.warn(`Could not renew expired session. Missing pssh initData.`);\n        }\n        this.removeSession(mediaKeySessionContext);\n    }\n    getKeyIdString(decryptdata) {\n        if (!decryptdata) {\n            throw new Error(\"Could not read keyId of undefined decryptdata\");\n        }\n        if (decryptdata.keyId === null) {\n            throw new Error(\"keyId is null\");\n        }\n        return Hex.hexDump(decryptdata.keyId);\n    }\n    updateKeySession(mediaKeySessionContext, data) {\n        var _mediaKeySessionConte;\n        const keySession = mediaKeySessionContext.mediaKeysSession;\n        this.log(`Updating key-session \"${keySession.sessionId}\" for keyID ${Hex.hexDump(((_mediaKeySessionConte = mediaKeySessionContext.decryptdata) == null ? void 0 : _mediaKeySessionConte.keyId) || [])}\n      } (data length: ${data ? data.byteLength : data})`);\n        return keySession.update(data);\n    }\n    selectKeySystemFormat(frag) {\n        const keyFormats = Object.keys(frag.levelkeys || {});\n        if (!this.keyFormatPromise) {\n            this.log(`Selecting key-system from fragment (sn: ${frag.sn} ${frag.type}: ${frag.level}) key formats ${keyFormats.join(\", \")}`);\n            this.keyFormatPromise = this.getKeyFormatPromise(keyFormats);\n        }\n        return this.keyFormatPromise;\n    }\n    getKeyFormatPromise(keyFormats) {\n        return new Promise((resolve, reject)=>{\n            const keySystemsInConfig = getKeySystemsForConfig(this.config);\n            const keySystemsToAttempt = keyFormats.map(keySystemFormatToKeySystemDomain).filter((value)=>!!value && keySystemsInConfig.indexOf(value) !== -1);\n            return this.getKeySystemSelectionPromise(keySystemsToAttempt).then(({ keySystem })=>{\n                const keySystemFormat = keySystemDomainToKeySystemFormat(keySystem);\n                if (keySystemFormat) {\n                    resolve(keySystemFormat);\n                } else {\n                    reject(new Error(`Unable to find format for key-system \"${keySystem}\"`));\n                }\n            }).catch(reject);\n        });\n    }\n    loadKey(data) {\n        const decryptdata = data.keyInfo.decryptdata;\n        const keyId = this.getKeyIdString(decryptdata);\n        const keyDetails = `(keyId: ${keyId} format: \"${decryptdata.keyFormat}\" method: ${decryptdata.method} uri: ${decryptdata.uri})`;\n        this.log(`Starting session for key ${keyDetails}`);\n        let keySessionContextPromise = this.keyIdToKeySessionPromise[keyId];\n        if (!keySessionContextPromise) {\n            keySessionContextPromise = this.keyIdToKeySessionPromise[keyId] = this.getKeySystemForKeyPromise(decryptdata).then(({ keySystem, mediaKeys })=>{\n                this.throwIfDestroyed();\n                this.log(`Handle encrypted media sn: ${data.frag.sn} ${data.frag.type}: ${data.frag.level} using key ${keyDetails}`);\n                return this.attemptSetMediaKeys(keySystem, mediaKeys).then(()=>{\n                    this.throwIfDestroyed();\n                    const keySessionContext = this.createMediaKeySessionContext({\n                        keySystem,\n                        mediaKeys,\n                        decryptdata\n                    });\n                    const scheme = \"cenc\";\n                    return this.generateRequestWithPreferredKeySession(keySessionContext, scheme, decryptdata.pssh, \"playlist-key\");\n                });\n            });\n            keySessionContextPromise.catch((error)=>this.handleError(error));\n        }\n        return keySessionContextPromise;\n    }\n    throwIfDestroyed(message = \"Invalid state\") {\n        if (!this.hls) {\n            throw new Error(\"invalid state\");\n        }\n    }\n    handleError(error) {\n        if (!this.hls) {\n            return;\n        }\n        this.error(error.message);\n        if (error instanceof EMEKeyError) {\n            this.hls.trigger(Events.ERROR, error.data);\n        } else {\n            this.hls.trigger(Events.ERROR, {\n                type: ErrorTypes.KEY_SYSTEM_ERROR,\n                details: ErrorDetails.KEY_SYSTEM_NO_KEYS,\n                error,\n                fatal: true\n            });\n        }\n    }\n    getKeySystemForKeyPromise(decryptdata) {\n        const keyId = this.getKeyIdString(decryptdata);\n        const mediaKeySessionContext = this.keyIdToKeySessionPromise[keyId];\n        if (!mediaKeySessionContext) {\n            const keySystem = keySystemFormatToKeySystemDomain(decryptdata.keyFormat);\n            const keySystemsToAttempt = keySystem ? [\n                keySystem\n            ] : getKeySystemsForConfig(this.config);\n            return this.attemptKeySystemAccess(keySystemsToAttempt);\n        }\n        return mediaKeySessionContext;\n    }\n    getKeySystemSelectionPromise(keySystemsToAttempt) {\n        if (!keySystemsToAttempt.length) {\n            keySystemsToAttempt = getKeySystemsForConfig(this.config);\n        }\n        if (keySystemsToAttempt.length === 0) {\n            throw new EMEKeyError({\n                type: ErrorTypes.KEY_SYSTEM_ERROR,\n                details: ErrorDetails.KEY_SYSTEM_NO_CONFIGURED_LICENSE,\n                fatal: true\n            }, `Missing key-system license configuration options ${JSON.stringify({\n                drmSystems: this.config.drmSystems\n            })}`);\n        }\n        return this.attemptKeySystemAccess(keySystemsToAttempt);\n    }\n    _onMediaEncrypted(event) {\n        const { initDataType, initData } = event;\n        this.debug(`\"${event.type}\" event: init data type: \"${initDataType}\"`);\n        // Ignore event when initData is null\n        if (initData === null) {\n            return;\n        }\n        let keyId;\n        let keySystemDomain;\n        if (initDataType === \"sinf\" && this.config.drmSystems[KeySystems.FAIRPLAY]) {\n            // Match sinf keyId to playlist skd://keyId=\n            const json = bin2str(new Uint8Array(initData));\n            try {\n                const sinf = base64Decode(JSON.parse(json).sinf);\n                const tenc = parseSinf(new Uint8Array(sinf));\n                if (!tenc) {\n                    return;\n                }\n                keyId = tenc.subarray(8, 24);\n                keySystemDomain = KeySystems.FAIRPLAY;\n            } catch (error) {\n                this.warn('Failed to parse sinf \"encrypted\" event message initData');\n                return;\n            }\n        } else {\n            // Support clear-lead key-session creation (otherwise depend on playlist keys)\n            const psshInfo = parsePssh(initData);\n            if (psshInfo === null) {\n                return;\n            }\n            if (psshInfo.version === 0 && psshInfo.systemId === KeySystemIds.WIDEVINE && psshInfo.data) {\n                keyId = psshInfo.data.subarray(8, 24);\n            }\n            keySystemDomain = keySystemIdToKeySystemDomain(psshInfo.systemId);\n        }\n        if (!keySystemDomain || !keyId) {\n            return;\n        }\n        const keyIdHex = Hex.hexDump(keyId);\n        const { keyIdToKeySessionPromise, mediaKeySessions } = this;\n        let keySessionContextPromise = keyIdToKeySessionPromise[keyIdHex];\n        for(let i = 0; i < mediaKeySessions.length; i++){\n            // Match playlist key\n            const keyContext = mediaKeySessions[i];\n            const decryptdata = keyContext.decryptdata;\n            if (decryptdata.pssh || !decryptdata.keyId) {\n                continue;\n            }\n            const oldKeyIdHex = Hex.hexDump(decryptdata.keyId);\n            if (keyIdHex === oldKeyIdHex || decryptdata.uri.replace(/-/g, \"\").indexOf(keyIdHex) !== -1) {\n                keySessionContextPromise = keyIdToKeySessionPromise[oldKeyIdHex];\n                delete keyIdToKeySessionPromise[oldKeyIdHex];\n                decryptdata.pssh = new Uint8Array(initData);\n                decryptdata.keyId = keyId;\n                keySessionContextPromise = keyIdToKeySessionPromise[keyIdHex] = keySessionContextPromise.then(()=>{\n                    return this.generateRequestWithPreferredKeySession(keyContext, initDataType, initData, \"encrypted-event-key-match\");\n                });\n                break;\n            }\n        }\n        if (!keySessionContextPromise) {\n            // Clear-lead key (not encountered in playlist)\n            keySessionContextPromise = keyIdToKeySessionPromise[keyIdHex] = this.getKeySystemSelectionPromise([\n                keySystemDomain\n            ]).then(({ keySystem, mediaKeys })=>{\n                var _keySystemToKeySystem;\n                this.throwIfDestroyed();\n                const decryptdata = new LevelKey(\"ISO-23001-7\", keyIdHex, (_keySystemToKeySystem = keySystemDomainToKeySystemFormat(keySystem)) != null ? _keySystemToKeySystem : \"\");\n                decryptdata.pssh = new Uint8Array(initData);\n                decryptdata.keyId = keyId;\n                return this.attemptSetMediaKeys(keySystem, mediaKeys).then(()=>{\n                    this.throwIfDestroyed();\n                    const keySessionContext = this.createMediaKeySessionContext({\n                        decryptdata,\n                        keySystem,\n                        mediaKeys\n                    });\n                    return this.generateRequestWithPreferredKeySession(keySessionContext, initDataType, initData, \"encrypted-event-no-match\");\n                });\n            });\n        }\n        keySessionContextPromise.catch((error)=>this.handleError(error));\n    }\n    _onWaitingForKey(event) {\n        this.log(`\"${event.type}\" event`);\n    }\n    attemptSetMediaKeys(keySystem, mediaKeys) {\n        const queue = this.setMediaKeysQueue.slice();\n        this.log(`Setting media-keys for \"${keySystem}\"`);\n        // Only one setMediaKeys() can run at one time, and multiple setMediaKeys() operations\n        // can be queued for execution for multiple key sessions.\n        const setMediaKeysPromise = Promise.all(queue).then(()=>{\n            if (!this.media) {\n                throw new Error(\"Attempted to set mediaKeys without media element attached\");\n            }\n            return this.media.setMediaKeys(mediaKeys);\n        });\n        this.setMediaKeysQueue.push(setMediaKeysPromise);\n        return setMediaKeysPromise.then(()=>{\n            this.log(`Media-keys set for \"${keySystem}\"`);\n            queue.push(setMediaKeysPromise);\n            this.setMediaKeysQueue = this.setMediaKeysQueue.filter((p)=>queue.indexOf(p) === -1);\n        });\n    }\n    generateRequestWithPreferredKeySession(context, initDataType, initData, reason) {\n        var _this$config$drmSyste, _this$config$drmSyste2;\n        const generateRequestFilter = (_this$config$drmSyste = this.config.drmSystems) == null ? void 0 : (_this$config$drmSyste2 = _this$config$drmSyste[context.keySystem]) == null ? void 0 : _this$config$drmSyste2.generateRequest;\n        if (generateRequestFilter) {\n            try {\n                const mappedInitData = generateRequestFilter.call(this.hls, initDataType, initData, context);\n                if (!mappedInitData) {\n                    throw new Error(\"Invalid response from configured generateRequest filter\");\n                }\n                initDataType = mappedInitData.initDataType;\n                initData = context.decryptdata.pssh = mappedInitData.initData ? new Uint8Array(mappedInitData.initData) : null;\n            } catch (error) {\n                var _this$hls;\n                this.warn(error.message);\n                if ((_this$hls = this.hls) != null && _this$hls.config.debug) {\n                    throw error;\n                }\n            }\n        }\n        if (initData === null) {\n            this.log(`Skipping key-session request for \"${reason}\" (no initData)`);\n            return Promise.resolve(context);\n        }\n        const keyId = this.getKeyIdString(context.decryptdata);\n        this.log(`Generating key-session request for \"${reason}\": ${keyId} (init data type: ${initDataType} length: ${initData ? initData.byteLength : null})`);\n        const licenseStatus = new EventEmitter();\n        const onmessage = context._onmessage = (event)=>{\n            const keySession = context.mediaKeysSession;\n            if (!keySession) {\n                licenseStatus.emit(\"error\", new Error(\"invalid state\"));\n                return;\n            }\n            const { messageType, message } = event;\n            this.log(`\"${messageType}\" message event for session \"${keySession.sessionId}\" message size: ${message.byteLength}`);\n            if (messageType === \"license-request\" || messageType === \"license-renewal\") {\n                this.renewLicense(context, message).catch((error)=>{\n                    this.handleError(error);\n                    licenseStatus.emit(\"error\", error);\n                });\n            } else if (messageType === \"license-release\") {\n                if (context.keySystem === KeySystems.FAIRPLAY) {\n                    this.updateKeySession(context, strToUtf8array(\"acknowledged\"));\n                    this.removeSession(context);\n                }\n            } else {\n                this.warn(`unhandled media key message type \"${messageType}\"`);\n            }\n        };\n        const onkeystatuseschange = context._onkeystatuseschange = (event)=>{\n            const keySession = context.mediaKeysSession;\n            if (!keySession) {\n                licenseStatus.emit(\"error\", new Error(\"invalid state\"));\n                return;\n            }\n            this.onKeyStatusChange(context);\n            const keyStatus = context.keyStatus;\n            licenseStatus.emit(\"keyStatus\", keyStatus);\n            if (keyStatus === \"expired\") {\n                this.warn(`${context.keySystem} expired for key ${keyId}`);\n                this.renewKeySession(context);\n            }\n        };\n        context.mediaKeysSession.addEventListener(\"message\", onmessage);\n        context.mediaKeysSession.addEventListener(\"keystatuseschange\", onkeystatuseschange);\n        const keyUsablePromise = new Promise((resolve, reject)=>{\n            licenseStatus.on(\"error\", reject);\n            licenseStatus.on(\"keyStatus\", (keyStatus)=>{\n                if (keyStatus.startsWith(\"usable\")) {\n                    resolve();\n                } else if (keyStatus === \"output-restricted\") {\n                    reject(new EMEKeyError({\n                        type: ErrorTypes.KEY_SYSTEM_ERROR,\n                        details: ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED,\n                        fatal: false\n                    }, \"HDCP level output restricted\"));\n                } else if (keyStatus === \"internal-error\") {\n                    reject(new EMEKeyError({\n                        type: ErrorTypes.KEY_SYSTEM_ERROR,\n                        details: ErrorDetails.KEY_SYSTEM_STATUS_INTERNAL_ERROR,\n                        fatal: true\n                    }, `key status changed to \"${keyStatus}\"`));\n                } else if (keyStatus === \"expired\") {\n                    reject(new Error(\"key expired while generating request\"));\n                } else {\n                    this.warn(`unhandled key status change \"${keyStatus}\"`);\n                }\n            });\n        });\n        return context.mediaKeysSession.generateRequest(initDataType, initData).then(()=>{\n            var _context$mediaKeysSes;\n            this.log(`Request generated for key-session \"${(_context$mediaKeysSes = context.mediaKeysSession) == null ? void 0 : _context$mediaKeysSes.sessionId}\" keyId: ${keyId}`);\n        }).catch((error)=>{\n            throw new EMEKeyError({\n                type: ErrorTypes.KEY_SYSTEM_ERROR,\n                details: ErrorDetails.KEY_SYSTEM_NO_SESSION,\n                error,\n                fatal: false\n            }, `Error generating key-session request: ${error}`);\n        }).then(()=>keyUsablePromise).catch((error)=>{\n            licenseStatus.removeAllListeners();\n            this.removeSession(context);\n            throw error;\n        }).then(()=>{\n            licenseStatus.removeAllListeners();\n            return context;\n        });\n    }\n    onKeyStatusChange(mediaKeySessionContext) {\n        mediaKeySessionContext.mediaKeysSession.keyStatuses.forEach((status1, keyId)=>{\n            this.log(`key status change \"${status1}\" for keyStatuses keyId: ${Hex.hexDump(\"buffer\" in keyId ? new Uint8Array(keyId.buffer, keyId.byteOffset, keyId.byteLength) : new Uint8Array(keyId))} session keyId: ${Hex.hexDump(new Uint8Array(mediaKeySessionContext.decryptdata.keyId || []))} uri: ${mediaKeySessionContext.decryptdata.uri}`);\n            mediaKeySessionContext.keyStatus = status1;\n        });\n    }\n    fetchServerCertificate(keySystem) {\n        const config = this.config;\n        const Loader = config.loader;\n        const certLoader = new Loader(config);\n        const url = this.getServerCertificateUrl(keySystem);\n        if (!url) {\n            return Promise.resolve();\n        }\n        this.log(`Fetching server certificate for \"${keySystem}\"`);\n        return new Promise((resolve, reject)=>{\n            const loaderContext = {\n                responseType: \"arraybuffer\",\n                url\n            };\n            const loadPolicy = config.certLoadPolicy.default;\n            const loaderConfig = {\n                loadPolicy,\n                timeout: loadPolicy.maxLoadTimeMs,\n                maxRetry: 0,\n                retryDelay: 0,\n                maxRetryDelay: 0\n            };\n            const loaderCallbacks = {\n                onSuccess: (response, stats, context, networkDetails)=>{\n                    resolve(response.data);\n                },\n                onError: (response, contex, networkDetails, stats)=>{\n                    reject(new EMEKeyError({\n                        type: ErrorTypes.KEY_SYSTEM_ERROR,\n                        details: ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,\n                        fatal: true,\n                        networkDetails,\n                        response: _objectSpread2({\n                            url: loaderContext.url,\n                            data: undefined\n                        }, response)\n                    }, `\"${keySystem}\" certificate request failed (${url}). Status: ${response.code} (${response.text})`));\n                },\n                onTimeout: (stats, context, networkDetails)=>{\n                    reject(new EMEKeyError({\n                        type: ErrorTypes.KEY_SYSTEM_ERROR,\n                        details: ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,\n                        fatal: true,\n                        networkDetails,\n                        response: {\n                            url: loaderContext.url,\n                            data: undefined\n                        }\n                    }, `\"${keySystem}\" certificate request timed out (${url})`));\n                },\n                onAbort: (stats, context, networkDetails)=>{\n                    reject(new Error(\"aborted\"));\n                }\n            };\n            certLoader.load(loaderContext, loaderConfig, loaderCallbacks);\n        });\n    }\n    setMediaKeysServerCertificate(mediaKeys, keySystem, cert) {\n        return new Promise((resolve, reject)=>{\n            mediaKeys.setServerCertificate(cert).then((success)=>{\n                this.log(`setServerCertificate ${success ? \"success\" : \"not supported by CDM\"} (${cert == null ? void 0 : cert.byteLength}) on \"${keySystem}\"`);\n                resolve(mediaKeys);\n            }).catch((error)=>{\n                reject(new EMEKeyError({\n                    type: ErrorTypes.KEY_SYSTEM_ERROR,\n                    details: ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED,\n                    error,\n                    fatal: true\n                }, error.message));\n            });\n        });\n    }\n    renewLicense(context, keyMessage) {\n        return this.requestLicense(context, new Uint8Array(keyMessage)).then((data)=>{\n            return this.updateKeySession(context, new Uint8Array(data)).catch((error)=>{\n                throw new EMEKeyError({\n                    type: ErrorTypes.KEY_SYSTEM_ERROR,\n                    details: ErrorDetails.KEY_SYSTEM_SESSION_UPDATE_FAILED,\n                    error,\n                    fatal: true\n                }, error.message);\n            });\n        });\n    }\n    unpackPlayReadyKeyMessage(xhr, licenseChallenge) {\n        // On Edge, the raw license message is UTF-16-encoded XML.  We need\n        // to unpack the Challenge element (base64-encoded string containing the\n        // actual license request) and any HttpHeader elements (sent as request\n        // headers).\n        // For PlayReady CDMs, we need to dig the Challenge out of the XML.\n        const xmlString = String.fromCharCode.apply(null, new Uint16Array(licenseChallenge.buffer));\n        if (!xmlString.includes(\"PlayReadyKeyMessage\")) {\n            // This does not appear to be a wrapped message as on Edge.  Some\n            // clients do not need this unwrapping, so we will assume this is one of\n            // them.  Note that \"xml\" at this point probably looks like random\n            // garbage, since we interpreted UTF-8 as UTF-16.\n            xhr.setRequestHeader(\"Content-Type\", \"text/xml; charset=utf-8\");\n            return licenseChallenge;\n        }\n        const keyMessageXml = new DOMParser().parseFromString(xmlString, \"application/xml\");\n        // Set request headers.\n        const headers = keyMessageXml.querySelectorAll(\"HttpHeader\");\n        if (headers.length > 0) {\n            let header;\n            for(let i = 0, len = headers.length; i < len; i++){\n                var _header$querySelector, _header$querySelector2;\n                header = headers[i];\n                const name = (_header$querySelector = header.querySelector(\"name\")) == null ? void 0 : _header$querySelector.textContent;\n                const value = (_header$querySelector2 = header.querySelector(\"value\")) == null ? void 0 : _header$querySelector2.textContent;\n                if (name && value) {\n                    xhr.setRequestHeader(name, value);\n                }\n            }\n        }\n        const challengeElement = keyMessageXml.querySelector(\"Challenge\");\n        const challengeText = challengeElement == null ? void 0 : challengeElement.textContent;\n        if (!challengeText) {\n            throw new Error(`Cannot find <Challenge> in key message`);\n        }\n        return strToUtf8array(atob(challengeText));\n    }\n    setupLicenseXHR(xhr, url, keysListItem, licenseChallenge) {\n        const licenseXhrSetup = this.config.licenseXhrSetup;\n        if (!licenseXhrSetup) {\n            xhr.open(\"POST\", url, true);\n            return Promise.resolve({\n                xhr,\n                licenseChallenge\n            });\n        }\n        return Promise.resolve().then(()=>{\n            if (!keysListItem.decryptdata) {\n                throw new Error(\"Key removed\");\n            }\n            return licenseXhrSetup.call(this.hls, xhr, url, keysListItem, licenseChallenge);\n        }).catch((error)=>{\n            if (!keysListItem.decryptdata) {\n                // Key session removed. Cancel license request.\n                throw error;\n            }\n            // let's try to open before running setup\n            xhr.open(\"POST\", url, true);\n            return licenseXhrSetup.call(this.hls, xhr, url, keysListItem, licenseChallenge);\n        }).then((licenseXhrSetupResult)=>{\n            // if licenseXhrSetup did not yet call open, let's do it now\n            if (!xhr.readyState) {\n                xhr.open(\"POST\", url, true);\n            }\n            const finalLicenseChallenge = licenseXhrSetupResult ? licenseXhrSetupResult : licenseChallenge;\n            return {\n                xhr,\n                licenseChallenge: finalLicenseChallenge\n            };\n        });\n    }\n    requestLicense(keySessionContext, licenseChallenge) {\n        const keyLoadPolicy = this.config.keyLoadPolicy.default;\n        return new Promise((resolve, reject)=>{\n            const url = this.getLicenseServerUrl(keySessionContext.keySystem);\n            this.log(`Sending license request to URL: ${url}`);\n            const xhr = new XMLHttpRequest();\n            xhr.responseType = \"arraybuffer\";\n            xhr.onreadystatechange = ()=>{\n                if (!this.hls || !keySessionContext.mediaKeysSession) {\n                    return reject(new Error(\"invalid state\"));\n                }\n                if (xhr.readyState === 4) {\n                    if (xhr.status === 200) {\n                        this._requestLicenseFailureCount = 0;\n                        let data = xhr.response;\n                        this.log(`License received ${data instanceof ArrayBuffer ? data.byteLength : data}`);\n                        const licenseResponseCallback = this.config.licenseResponseCallback;\n                        if (licenseResponseCallback) {\n                            try {\n                                data = licenseResponseCallback.call(this.hls, xhr, url, keySessionContext);\n                            } catch (error) {\n                                this.error(error);\n                            }\n                        }\n                        resolve(data);\n                    } else {\n                        const retryConfig = keyLoadPolicy.errorRetry;\n                        const maxNumRetry = retryConfig ? retryConfig.maxNumRetry : 0;\n                        this._requestLicenseFailureCount++;\n                        if (this._requestLicenseFailureCount > maxNumRetry || xhr.status >= 400 && xhr.status < 500) {\n                            reject(new EMEKeyError({\n                                type: ErrorTypes.KEY_SYSTEM_ERROR,\n                                details: ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,\n                                fatal: true,\n                                networkDetails: xhr,\n                                response: {\n                                    url,\n                                    data: undefined,\n                                    code: xhr.status,\n                                    text: xhr.statusText\n                                }\n                            }, `License Request XHR failed (${url}). Status: ${xhr.status} (${xhr.statusText})`));\n                        } else {\n                            const attemptsLeft = maxNumRetry - this._requestLicenseFailureCount + 1;\n                            this.warn(`Retrying license request, ${attemptsLeft} attempts left`);\n                            this.requestLicense(keySessionContext, licenseChallenge).then(resolve, reject);\n                        }\n                    }\n                }\n            };\n            if (keySessionContext.licenseXhr && keySessionContext.licenseXhr.readyState !== XMLHttpRequest.DONE) {\n                keySessionContext.licenseXhr.abort();\n            }\n            keySessionContext.licenseXhr = xhr;\n            this.setupLicenseXHR(xhr, url, keySessionContext, licenseChallenge).then(({ xhr, licenseChallenge })=>{\n                if (keySessionContext.keySystem == KeySystems.PLAYREADY) {\n                    licenseChallenge = this.unpackPlayReadyKeyMessage(xhr, licenseChallenge);\n                }\n                xhr.send(licenseChallenge);\n            });\n        });\n    }\n    onMediaAttached(event, data) {\n        if (!this.config.emeEnabled) {\n            return;\n        }\n        const media = data.media;\n        // keep reference of media\n        this.media = media;\n        media.addEventListener(\"encrypted\", this.onMediaEncrypted);\n        media.addEventListener(\"waitingforkey\", this.onWaitingForKey);\n    }\n    onMediaDetached() {\n        const media = this.media;\n        const mediaKeysList = this.mediaKeySessions;\n        if (media) {\n            media.removeEventListener(\"encrypted\", this.onMediaEncrypted);\n            media.removeEventListener(\"waitingforkey\", this.onWaitingForKey);\n            this.media = null;\n        }\n        this._requestLicenseFailureCount = 0;\n        this.setMediaKeysQueue = [];\n        this.mediaKeySessions = [];\n        this.keyIdToKeySessionPromise = {};\n        LevelKey.clearKeyUriToKeyIdMap();\n        // Close all sessions and remove media keys from the video element.\n        const keySessionCount = mediaKeysList.length;\n        EMEController.CDMCleanupPromise = Promise.all(mediaKeysList.map((mediaKeySessionContext)=>this.removeSession(mediaKeySessionContext)).concat(media == null ? void 0 : media.setMediaKeys(null).catch((error)=>{\n            this.log(`Could not clear media keys: ${error}`);\n        }))).then(()=>{\n            if (keySessionCount) {\n                this.log(\"finished closing key sessions and clearing media keys\");\n                mediaKeysList.length = 0;\n            }\n        }).catch((error)=>{\n            this.log(`Could not close sessions and clear media keys: ${error}`);\n        });\n    }\n    onManifestLoading() {\n        this.keyFormatPromise = null;\n    }\n    onManifestLoaded(event, { sessionKeys }) {\n        if (!sessionKeys || !this.config.emeEnabled) {\n            return;\n        }\n        if (!this.keyFormatPromise) {\n            const keyFormats = sessionKeys.reduce((formats, sessionKey)=>{\n                if (formats.indexOf(sessionKey.keyFormat) === -1) {\n                    formats.push(sessionKey.keyFormat);\n                }\n                return formats;\n            }, []);\n            this.log(`Selecting key-system from session-keys ${keyFormats.join(\", \")}`);\n            this.keyFormatPromise = this.getKeyFormatPromise(keyFormats);\n        }\n    }\n    removeSession(mediaKeySessionContext) {\n        const { mediaKeysSession, licenseXhr } = mediaKeySessionContext;\n        if (mediaKeysSession) {\n            this.log(`Remove licenses and keys and close session ${mediaKeysSession.sessionId}`);\n            if (mediaKeySessionContext._onmessage) {\n                mediaKeysSession.removeEventListener(\"message\", mediaKeySessionContext._onmessage);\n                mediaKeySessionContext._onmessage = undefined;\n            }\n            if (mediaKeySessionContext._onkeystatuseschange) {\n                mediaKeysSession.removeEventListener(\"keystatuseschange\", mediaKeySessionContext._onkeystatuseschange);\n                mediaKeySessionContext._onkeystatuseschange = undefined;\n            }\n            if (licenseXhr && licenseXhr.readyState !== XMLHttpRequest.DONE) {\n                licenseXhr.abort();\n            }\n            mediaKeySessionContext.mediaKeysSession = mediaKeySessionContext.decryptdata = mediaKeySessionContext.licenseXhr = undefined;\n            const index = this.mediaKeySessions.indexOf(mediaKeySessionContext);\n            if (index > -1) {\n                this.mediaKeySessions.splice(index, 1);\n            }\n            return mediaKeysSession.remove().catch((error)=>{\n                this.log(`Could not remove session: ${error}`);\n            }).then(()=>{\n                return mediaKeysSession.close();\n            }).catch((error)=>{\n                this.log(`Could not close session: ${error}`);\n            });\n        }\n    }\n}\nEMEController.CDMCleanupPromise = void 0;\nclass EMEKeyError extends Error {\n    constructor(data, message){\n        super(message);\n        this.data = void 0;\n        data.error || (data.error = new Error(message));\n        this.data = data;\n        data.err = data.error;\n    }\n}\n/**\n * Common Media Object Type\n *\n * @group CMCD\n * @group CMSD\n *\n * @beta\n */ var CmObjectType;\n(function(CmObjectType) {\n    /**\n   * text file, such as a manifest or playlist\n   */ CmObjectType[\"MANIFEST\"] = \"m\";\n    /**\n   * audio only\n   */ CmObjectType[\"AUDIO\"] = \"a\";\n    /**\n   * video only\n   */ CmObjectType[\"VIDEO\"] = \"v\";\n    /**\n   * muxed audio and video\n   */ CmObjectType[\"MUXED\"] = \"av\";\n    /**\n   * init segment\n   */ CmObjectType[\"INIT\"] = \"i\";\n    /**\n   * caption or subtitle\n   */ CmObjectType[\"CAPTION\"] = \"c\";\n    /**\n   * ISOBMFF timed text track\n   */ CmObjectType[\"TIMED_TEXT\"] = \"tt\";\n    /**\n   * cryptographic key, license or certificate.\n   */ CmObjectType[\"KEY\"] = \"k\";\n    /**\n   * other\n   */ CmObjectType[\"OTHER\"] = \"o\";\n})(CmObjectType || (CmObjectType = {}));\n/**\n * Common Media Streaming Format\n *\n * @group CMCD\n * @group CMSD\n *\n * @beta\n */ var CmStreamingFormat;\n(function(CmStreamingFormat) {\n    /**\n   * MPEG DASH\n   */ CmStreamingFormat[\"DASH\"] = \"d\";\n    /**\n   * HTTP Live Streaming (HLS)\n   */ CmStreamingFormat[\"HLS\"] = \"h\";\n    /**\n   * Smooth Streaming\n   */ CmStreamingFormat[\"SMOOTH\"] = \"s\";\n    /**\n   * Other\n   */ CmStreamingFormat[\"OTHER\"] = \"o\";\n})(CmStreamingFormat || (CmStreamingFormat = {}));\n/**\n * CMCD header fields.\n *\n * @group CMCD\n *\n * @beta\n */ var CmcdHeaderField;\n(function(CmcdHeaderField) {\n    /**\n   * keys whose values vary with the object being requested.\n   */ CmcdHeaderField[\"OBJECT\"] = \"CMCD-Object\";\n    /**\n   * keys whose values vary with each request.\n   */ CmcdHeaderField[\"REQUEST\"] = \"CMCD-Request\";\n    /**\n   * keys whose values are expected to be invariant over the life of the session.\n   */ CmcdHeaderField[\"SESSION\"] = \"CMCD-Session\";\n    /**\n   * keys whose values do not vary with every request or object.\n   */ CmcdHeaderField[\"STATUS\"] = \"CMCD-Status\";\n})(CmcdHeaderField || (CmcdHeaderField = {}));\n/**\n * The map of CMCD header fields to official CMCD keys.\n *\n * @internal\n *\n * @group CMCD\n */ const CmcdHeaderMap = {\n    [CmcdHeaderField.OBJECT]: [\n        \"br\",\n        \"d\",\n        \"ot\",\n        \"tb\"\n    ],\n    [CmcdHeaderField.REQUEST]: [\n        \"bl\",\n        \"dl\",\n        \"mtp\",\n        \"nor\",\n        \"nrr\",\n        \"su\"\n    ],\n    [CmcdHeaderField.SESSION]: [\n        \"cid\",\n        \"pr\",\n        \"sf\",\n        \"sid\",\n        \"st\",\n        \"v\"\n    ],\n    [CmcdHeaderField.STATUS]: [\n        \"bs\",\n        \"rtp\"\n    ]\n};\n/**\n * Structured Field Item\n *\n * @group Structured Field\n *\n * @beta\n */ class SfItem {\n    constructor(value, params){\n        this.value = void 0;\n        this.params = void 0;\n        if (Array.isArray(value)) {\n            value = value.map((v)=>v instanceof SfItem ? v : new SfItem(v));\n        }\n        this.value = value;\n        this.params = params;\n    }\n}\n/**\n * A class to represent structured field tokens when `Symbol` is not available.\n *\n * @group Structured Field\n *\n * @beta\n */ class SfToken {\n    constructor(description){\n        this.description = void 0;\n        this.description = description;\n    }\n}\nconst DICT = \"Dict\";\nfunction format(value) {\n    if (Array.isArray(value)) {\n        return JSON.stringify(value);\n    }\n    if (value instanceof Map) {\n        return \"Map{}\";\n    }\n    if (value instanceof Set) {\n        return \"Set{}\";\n    }\n    if (typeof value === \"object\") {\n        return JSON.stringify(value);\n    }\n    return String(value);\n}\nfunction throwError(action, src, type, cause) {\n    return new Error(`failed to ${action} \"${format(src)}\" as ${type}`, {\n        cause\n    });\n}\nconst BARE_ITEM = \"Bare Item\";\nconst BOOLEAN = \"Boolean\";\nconst BYTES = \"Byte Sequence\";\nconst DECIMAL = \"Decimal\";\nconst INTEGER = \"Integer\";\nfunction isInvalidInt(value) {\n    return value < -999999999999999 || 999999999999999 < value;\n}\nconst STRING_REGEX = /[\\x00-\\x1f\\x7f]+/; // eslint-disable-line no-control-regex\nconst TOKEN = \"Token\";\nconst KEY = \"Key\";\nfunction serializeError(src, type, cause) {\n    return throwError(\"serialize\", src, type, cause);\n}\n// 4.1.9.  Serializing a Boolean\n//\n// Given a Boolean as input_boolean, return an ASCII string suitable for\n// use in a HTTP field value.\n//\n// 1.  If input_boolean is not a boolean, fail serialization.\n//\n// 2.  Let output be an empty string.\n//\n// 3.  Append \"?\" to output.\n//\n// 4.  If input_boolean is true, append \"1\" to output.\n//\n// 5.  If input_boolean is false, append \"0\" to output.\n//\n// 6.  Return output.\nfunction serializeBoolean(value) {\n    if (typeof value !== \"boolean\") {\n        throw serializeError(value, BOOLEAN);\n    }\n    return value ? \"?1\" : \"?0\";\n}\n/**\n * Encodes binary data to base64\n *\n * @param binary - The binary data to encode\n * @returns The base64 encoded string\n *\n * @group Utils\n *\n * @beta\n */ function base64encode(binary) {\n    return btoa(String.fromCharCode(...binary));\n}\n// 4.1.8.  Serializing a Byte Sequence\n//\n// Given a Byte Sequence as input_bytes, return an ASCII string suitable\n// for use in a HTTP field value.\n//\n// 1.  If input_bytes is not a sequence of bytes, fail serialization.\n//\n// 2.  Let output be an empty string.\n//\n// 3.  Append \":\" to output.\n//\n// 4.  Append the result of base64-encoding input_bytes as per\n//     [RFC4648], Section 4, taking account of the requirements below.\n//\n// 5.  Append \":\" to output.\n//\n// 6.  Return output.\n//\n// The encoded data is required to be padded with \"=\", as per [RFC4648],\n// Section 3.2.\n//\n// Likewise, encoded data SHOULD have pad bits set to zero, as per\n// [RFC4648], Section 3.5, unless it is not possible to do so due to\n// implementation constraints.\nfunction serializeByteSequence(value) {\n    if (ArrayBuffer.isView(value) === false) {\n        throw serializeError(value, BYTES);\n    }\n    return `:${base64encode(value)}:`;\n}\n// 4.1.4.  Serializing an Integer\n//\n// Given an Integer as input_integer, return an ASCII string suitable\n// for use in a HTTP field value.\n//\n// 1.  If input_integer is not an integer in the range of\n//     -999,999,999,999,999 to 999,999,999,999,999 inclusive, fail\n//     serialization.\n//\n// 2.  Let output be an empty string.\n//\n// 3.  If input_integer is less than (but not equal to) 0, append \"-\" to\n//     output.\n//\n// 4.  Append input_integer's numeric value represented in base 10 using\n//     only decimal digits to output.\n//\n// 5.  Return output.\nfunction serializeInteger(value) {\n    if (isInvalidInt(value)) {\n        throw serializeError(value, INTEGER);\n    }\n    return value.toString();\n}\n// 4.1.10.  Serializing a Date\n//\n// Given a Date as input_integer, return an ASCII string suitable for\n// use in an HTTP field value.\n// 1.  Let output be \"@\".\n// 2.  Append to output the result of running Serializing an Integer\n//     with input_date (Section 4.1.4).\n// 3.  Return output.\nfunction serializeDate(value) {\n    return `@${serializeInteger(value.getTime() / 1000)}`;\n}\n/**\n * This implements the rounding procedure described in step 2 of the \"Serializing a Decimal\" specification.\n * This rounding style is known as \"even rounding\", \"banker's rounding\", or \"commercial rounding\".\n *\n * @param value - The value to round\n * @param precision - The number of decimal places to round to\n * @returns The rounded value\n *\n * @group Utils\n *\n * @beta\n */ function roundToEven(value, precision) {\n    if (value < 0) {\n        return -roundToEven(-value, precision);\n    }\n    const decimalShift = Math.pow(10, precision);\n    const isEquidistant = Math.abs(value * decimalShift % 1 - 0.5) < Number.EPSILON;\n    if (isEquidistant) {\n        // If the tail of the decimal place is 'equidistant' we round to the nearest even value\n        const flooredValue = Math.floor(value * decimalShift);\n        return (flooredValue % 2 === 0 ? flooredValue : flooredValue + 1) / decimalShift;\n    } else {\n        // Otherwise, proceed as normal\n        return Math.round(value * decimalShift) / decimalShift;\n    }\n}\n// 4.1.5.  Serializing a Decimal\n//\n// Given a decimal number as input_decimal, return an ASCII string\n// suitable for use in a HTTP field value.\n//\n// 1.   If input_decimal is not a decimal number, fail serialization.\n//\n// 2.   If input_decimal has more than three significant digits to the\n//      right of the decimal point, round it to three decimal places,\n//      rounding the final digit to the nearest value, or to the even\n//      value if it is equidistant.\n//\n// 3.   If input_decimal has more than 12 significant digits to the left\n//      of the decimal point after rounding, fail serialization.\n//\n// 4.   Let output be an empty string.\n//\n// 5.   If input_decimal is less than (but not equal to) 0, append \"-\"\n//      to output.\n//\n// 6.   Append input_decimal's integer component represented in base 10\n//      (using only decimal digits) to output; if it is zero, append\n//      \"0\".\n//\n// 7.   Append \".\" to output.\n//\n// 8.   If input_decimal's fractional component is zero, append \"0\" to\n//      output.\n//\n// 9.   Otherwise, append the significant digits of input_decimal's\n//      fractional component represented in base 10 (using only decimal\n//      digits) to output.\n//\n// 10.  Return output.\nfunction serializeDecimal(value) {\n    const roundedValue = roundToEven(value, 3); // round to 3 decimal places\n    if (Math.floor(Math.abs(roundedValue)).toString().length > 12) {\n        throw serializeError(value, DECIMAL);\n    }\n    const stringValue = roundedValue.toString();\n    return stringValue.includes(\".\") ? stringValue : `${stringValue}.0`;\n}\nconst STRING = \"String\";\n// 4.1.6.  Serializing a String\n//\n// Given a String as input_string, return an ASCII string suitable for\n// use in a HTTP field value.\n//\n// 1.  Convert input_string into a sequence of ASCII characters; if\n//     conversion fails, fail serialization.\n//\n// 2.  If input_string contains characters in the range %x00-1f or %x7f\n//     (i.e., not in VCHAR or SP), fail serialization.\n//\n// 3.  Let output be the string DQUOTE.\n//\n// 4.  For each character char in input_string:\n//\n//     1.  If char is \"\\\" or DQUOTE:\n//\n//         1.  Append \"\\\" to output.\n//\n//     2.  Append char to output.\n//\n// 5.  Append DQUOTE to output.\n//\n// 6.  Return output.\nfunction serializeString(value) {\n    if (STRING_REGEX.test(value)) {\n        throw serializeError(value, STRING);\n    }\n    return `\"${value.replace(/\\\\/g, `\\\\\\\\`).replace(/\"/g, `\\\\\"`)}\"`;\n}\nfunction symbolToStr(symbol) {\n    return symbol.description || symbol.toString().slice(7, -1);\n}\nfunction serializeToken(token) {\n    const value = symbolToStr(token);\n    if (/^([a-zA-Z*])([!#$%&'*+\\-.^_`|~\\w:/]*)$/.test(value) === false) {\n        throw serializeError(value, TOKEN);\n    }\n    return value;\n}\n// 4.1.3.1.  Serializing a Bare Item\n//\n// Given an Item as input_item, return an ASCII string suitable for use\n// in a HTTP field value.\n//\n// 1.  If input_item is an Integer, return the result of running\n//     Serializing an Integer (Section 4.1.4) with input_item.\n//\n// 2.  If input_item is a Decimal, return the result of running\n//     Serializing a Decimal (Section 4.1.5) with input_item.\n//\n// 3.  If input_item is a String, return the result of running\n//     Serializing a String (Section 4.1.6) with input_item.\n//\n// 4.  If input_item is a Token, return the result of running\n//     Serializing a Token (Section 4.1.7) with input_item.\n//\n// 5.  If input_item is a Boolean, return the result of running\n//     Serializing a Boolean (Section 4.1.9) with input_item.\n//\n// 6.  If input_item is a Byte Sequence, return the result of running\n//     Serializing a Byte Sequence (Section 4.1.8) with input_item.\n//\n// 7.  If input_item is a Date, return the result of running Serializing\n//     a Date (Section 4.1.10) with input_item.\n//\n// 8.  Otherwise, fail serialization.\nfunction serializeBareItem(value) {\n    switch(typeof value){\n        case \"number\":\n            if (!isFiniteNumber(value)) {\n                throw serializeError(value, BARE_ITEM);\n            }\n            if (Number.isInteger(value)) {\n                return serializeInteger(value);\n            }\n            return serializeDecimal(value);\n        case \"string\":\n            return serializeString(value);\n        case \"symbol\":\n            return serializeToken(value);\n        case \"boolean\":\n            return serializeBoolean(value);\n        case \"object\":\n            if (value instanceof Date) {\n                return serializeDate(value);\n            }\n            if (value instanceof Uint8Array) {\n                return serializeByteSequence(value);\n            }\n            if (value instanceof SfToken) {\n                return serializeToken(value);\n            }\n        default:\n            // fail\n            throw serializeError(value, BARE_ITEM);\n    }\n}\n// 4.1.1.3.  Serializing a Key\n//\n// Given a key as input_key, return an ASCII string suitable for use in\n// a HTTP field value.\n//\n// 1.  Convert input_key into a sequence of ASCII characters; if\n//     conversion fails, fail serialization.\n//\n// 2.  If input_key contains characters not in lcalpha, DIGIT, \"_\", \"-\",\n//     \".\", or \"*\" fail serialization.\n//\n// 3.  If the first character of input_key is not lcalpha or \"*\", fail\n//     serialization.\n//\n// 4.  Let output be an empty string.\n//\n// 5.  Append input_key to output.\n//\n// 6.  Return output.\nfunction serializeKey(value) {\n    if (/^[a-z*][a-z0-9\\-_.*]*$/.test(value) === false) {\n        throw serializeError(value, KEY);\n    }\n    return value;\n}\n// 4.1.1.2.  Serializing Parameters\n//\n// Given an ordered Dictionary as input_parameters (each member having a\n// param_name and a param_value), return an ASCII string suitable for\n// use in a HTTP field value.\n//\n// 1.  Let output be an empty string.\n//\n// 2.  For each param_name with a value of param_value in\n//     input_parameters:\n//\n//     1.  Append \";\" to output.\n//\n//     2.  Append the result of running Serializing a Key\n//         (Section 4.1.1.3) with param_name to output.\n//\n//     3.  If param_value is not Boolean true:\n//\n//         1.  Append \"=\" to output.\n//\n//         2.  Append the result of running Serializing a bare Item\n//             (Section 4.1.3.1) with param_value to output.\n//\n// 3.  Return output.\nfunction serializeParams(params) {\n    if (params == null) {\n        return \"\";\n    }\n    return Object.entries(params).map(([key, value])=>{\n        if (value === true) {\n            return `;${serializeKey(key)}`; // omit true\n        }\n        return `;${serializeKey(key)}=${serializeBareItem(value)}`;\n    }).join(\"\");\n}\n// 4.1.3.  Serializing an Item\n//\n// Given an Item as bare_item and Parameters as item_parameters, return\n// an ASCII string suitable for use in a HTTP field value.\n//\n// 1.  Let output be an empty string.\n//\n// 2.  Append the result of running Serializing a Bare Item\n//     Section 4.1.3.1 with bare_item to output.\n//\n// 3.  Append the result of running Serializing Parameters\n//     Section 4.1.1.2 with item_parameters to output.\n//\n// 4.  Return output.\nfunction serializeItem(value) {\n    if (value instanceof SfItem) {\n        return `${serializeBareItem(value.value)}${serializeParams(value.params)}`;\n    } else {\n        return serializeBareItem(value);\n    }\n}\n// 4.1.1.1.  Serializing an Inner List\n//\n// Given an array of (member_value, parameters) tuples as inner_list,\n// and parameters as list_parameters, return an ASCII string suitable\n// for use in a HTTP field value.\n//\n// 1.  Let output be the string \"(\".\n//\n// 2.  For each (member_value, parameters) of inner_list:\n//\n//     1.  Append the result of running Serializing an Item\n//         (Section 4.1.3) with (member_value, parameters) to output.\n//\n//     2.  If more values remain in inner_list, append a single SP to\n//         output.\n//\n// 3.  Append \")\" to output.\n//\n// 4.  Append the result of running Serializing Parameters\n//     (Section 4.1.1.2) with list_parameters to output.\n//\n// 5.  Return output.\nfunction serializeInnerList(value) {\n    return `(${value.value.map(serializeItem).join(\" \")})${serializeParams(value.params)}`;\n}\n// 4.1.2.  Serializing a Dictionary\n//\n// Given an ordered Dictionary as input_dictionary (each member having a\n// member_name and a tuple value of (member_value, parameters)), return\n// an ASCII string suitable for use in a HTTP field value.\n//\n// 1.  Let output be an empty string.\n//\n// 2.  For each member_name with a value of (member_value, parameters)\n//     in input_dictionary:\n//\n//     1.  Append the result of running Serializing a Key\n//         (Section 4.1.1.3) with member's member_name to output.\n//\n//     2.  If member_value is Boolean true:\n//\n//         1.  Append the result of running Serializing Parameters\n//             (Section 4.1.1.2) with parameters to output.\n//\n//     3.  Otherwise:\n//\n//         1.  Append \"=\" to output.\n//\n//         2.  If member_value is an array, append the result of running\n//             Serializing an Inner List (Section 4.1.1.1) with\n//             (member_value, parameters) to output.\n//\n//         3.  Otherwise, append the result of running Serializing an\n//             Item (Section 4.1.3) with (member_value, parameters) to\n//             output.\n//\n//     4.  If more members remain in input_dictionary:\n//\n//         1.  Append \",\" to output.\n//\n//         2.  Append a single SP to output.\n//\n// 3.  Return output.\nfunction serializeDict(dict, options = {\n    whitespace: true\n}) {\n    if (typeof dict !== \"object\") {\n        throw serializeError(dict, DICT);\n    }\n    const entries = dict instanceof Map ? dict.entries() : Object.entries(dict);\n    const optionalWhiteSpace = options != null && options.whitespace ? \" \" : \"\";\n    return Array.from(entries).map(([key, item])=>{\n        if (item instanceof SfItem === false) {\n            item = new SfItem(item);\n        }\n        let output = serializeKey(key);\n        if (item.value === true) {\n            output += serializeParams(item.params);\n        } else {\n            output += \"=\";\n            if (Array.isArray(item.value)) {\n                output += serializeInnerList(item);\n            } else {\n                output += serializeItem(item);\n            }\n        }\n        return output;\n    }).join(`,${optionalWhiteSpace}`);\n}\n/**\n * Encode an object into a structured field dictionary\n *\n * @param input - The structured field dictionary to encode\n * @returns The structured field string\n *\n * @group Structured Field\n *\n * @beta\n */ function encodeSfDict(value, options) {\n    return serializeDict(value, options);\n}\n/**\n * Checks if the given key is a token field.\n *\n * @param key - The key to check.\n *\n * @returns `true` if the key is a token field.\n *\n * @internal\n *\n * @group CMCD\n */ const isTokenField = (key)=>key === \"ot\" || key === \"sf\" || key === \"st\";\nconst isValid = (value)=>{\n    if (typeof value === \"number\") {\n        return isFiniteNumber(value);\n    }\n    return value != null && value !== \"\" && value !== false;\n};\n/**\n * Constructs a relative path from a URL.\n *\n * @param url - The destination URL\n * @param base - The base URL\n * @returns The relative path\n *\n * @group Utils\n *\n * @beta\n */ function urlToRelativePath(url, base) {\n    const to = new URL(url);\n    const from = new URL(base);\n    if (to.origin !== from.origin) {\n        return url;\n    }\n    const toPath = to.pathname.split(\"/\").slice(1);\n    const fromPath = from.pathname.split(\"/\").slice(1, -1);\n    // remove common parents\n    while(toPath[0] === fromPath[0]){\n        toPath.shift();\n        fromPath.shift();\n    }\n    // add back paths\n    while(fromPath.length){\n        fromPath.shift();\n        toPath.unshift(\"..\");\n    }\n    return toPath.join(\"/\");\n}\n/**\n * Generate a random v4 UUID\n *\n * @returns A random v4 UUID\n *\n * @group Utils\n *\n * @beta\n */ function uuid() {\n    try {\n        return crypto.randomUUID();\n    } catch (error) {\n        try {\n            const url = URL.createObjectURL(new Blob());\n            const uuid = url.toString();\n            URL.revokeObjectURL(url);\n            return uuid.slice(uuid.lastIndexOf(\"/\") + 1);\n        } catch (error) {\n            let dt = new Date().getTime();\n            const uuid = \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c)=>{\n                const r = (dt + Math.random() * 16) % 16 | 0;\n                dt = Math.floor(dt / 16);\n                return (c == \"x\" ? r : r & 0x3 | 0x8).toString(16);\n            });\n            return uuid;\n        }\n    }\n}\nconst toRounded = (value)=>Math.round(value);\nconst toUrlSafe = (value, options)=>{\n    if (options != null && options.baseUrl) {\n        value = urlToRelativePath(value, options.baseUrl);\n    }\n    return encodeURIComponent(value);\n};\nconst toHundred = (value)=>toRounded(value / 100) * 100;\n/**\n * The default formatters for CMCD values.\n *\n * @group CMCD\n *\n * @beta\n */ const CmcdFormatters = {\n    /**\n   * Bitrate (kbps) rounded integer\n   */ br: toRounded,\n    /**\n   * Duration (milliseconds) rounded integer\n   */ d: toRounded,\n    /**\n   * Buffer Length (milliseconds) rounded nearest 100ms\n   */ bl: toHundred,\n    /**\n   * Deadline (milliseconds) rounded nearest 100ms\n   */ dl: toHundred,\n    /**\n   * Measured Throughput (kbps) rounded nearest 100kbps\n   */ mtp: toHundred,\n    /**\n   * Next Object Request URL encoded\n   */ nor: toUrlSafe,\n    /**\n   * Requested maximum throughput (kbps) rounded nearest 100kbps\n   */ rtp: toHundred,\n    /**\n   * Top Bitrate (kbps) rounded integer\n   */ tb: toRounded\n};\n/**\n * Internal CMCD processing function.\n *\n * @param obj - The CMCD object to process.\n * @param map - The mapping function to use.\n * @param options - Options for encoding.\n *\n * @internal\n *\n * @group CMCD\n */ function processCmcd(obj, options) {\n    const results = {};\n    if (obj == null || typeof obj !== \"object\") {\n        return results;\n    }\n    const keys = Object.keys(obj).sort();\n    const formatters = _extends({}, CmcdFormatters, options == null ? void 0 : options.formatters);\n    const filter = options == null ? void 0 : options.filter;\n    keys.forEach((key)=>{\n        if (filter != null && filter(key)) {\n            return;\n        }\n        let value = obj[key];\n        const formatter = formatters[key];\n        if (formatter) {\n            value = formatter(value, options);\n        }\n        // Version should only be reported if not equal to 1.\n        if (key === \"v\" && value === 1) {\n            return;\n        }\n        // Playback rate should only be sent if not equal to 1.\n        if (key == \"pr\" && value === 1) {\n            return;\n        }\n        // ignore invalid values\n        if (!isValid(value)) {\n            return;\n        }\n        if (isTokenField(key) && typeof value === \"string\") {\n            value = new SfToken(value);\n        }\n        results[key] = value;\n    });\n    return results;\n}\n/**\n * Encode a CMCD object to a string.\n *\n * @param cmcd - The CMCD object to encode.\n * @param options - Options for encoding.\n *\n * @returns The encoded CMCD string.\n *\n * @group CMCD\n *\n * @beta\n */ function encodeCmcd(cmcd, options = {}) {\n    if (!cmcd) {\n        return \"\";\n    }\n    return encodeSfDict(processCmcd(cmcd, options), _extends({\n        whitespace: false\n    }, options));\n}\n/**\n * Convert a CMCD data object to request headers\n *\n * @param cmcd - The CMCD data object to convert.\n * @param options - Options for encoding the CMCD object.\n *\n * @returns The CMCD header shards.\n *\n * @group CMCD\n *\n * @beta\n */ function toCmcdHeaders(cmcd, options = {}) {\n    if (!cmcd) {\n        return {};\n    }\n    const entries = Object.entries(cmcd);\n    const headerMap = Object.entries(CmcdHeaderMap).concat(Object.entries((options == null ? void 0 : options.customHeaderMap) || {}));\n    const shards = entries.reduce((acc, entry)=>{\n        var _headerMap$find, _acc$field;\n        const [key, value] = entry;\n        const field = ((_headerMap$find = headerMap.find((entry)=>entry[1].includes(key))) == null ? void 0 : _headerMap$find[0]) || CmcdHeaderField.REQUEST;\n        (_acc$field = acc[field]) != null ? _acc$field : acc[field] = {};\n        acc[field][key] = value;\n        return acc;\n    }, {});\n    return Object.entries(shards).reduce((acc, [field, value])=>{\n        acc[field] = encodeCmcd(value, options);\n        return acc;\n    }, {});\n}\n/**\n * Append CMCD query args to a header object.\n *\n * @param headers - The headers to append to.\n * @param cmcd - The CMCD object to append.\n * @param customHeaderMap - A map of custom CMCD keys to header fields.\n *\n * @returns The headers with the CMCD header shards appended.\n *\n * @group CMCD\n *\n * @beta\n */ function appendCmcdHeaders(headers, cmcd, options) {\n    return _extends(headers, toCmcdHeaders(cmcd, options));\n}\n/**\n * CMCD parameter name.\n *\n * @group CMCD\n *\n * @beta\n */ const CMCD_PARAM = \"CMCD\";\n/**\n * Convert a CMCD data object to a query arg.\n *\n * @param cmcd - The CMCD object to convert.\n * @param options - Options for encoding the CMCD object.\n *\n * @returns The CMCD query arg.\n *\n * @group CMCD\n *\n * @beta\n */ function toCmcdQuery(cmcd, options = {}) {\n    if (!cmcd) {\n        return \"\";\n    }\n    const params = encodeCmcd(cmcd, options);\n    return `${CMCD_PARAM}=${encodeURIComponent(params)}`;\n}\nconst REGEX = /CMCD=[^&#]+/;\n/**\n * Append CMCD query args to a URL.\n *\n * @param url - The URL to append to.\n * @param cmcd - The CMCD object to append.\n * @param options - Options for encoding the CMCD object.\n *\n * @returns The URL with the CMCD query args appended.\n *\n * @group CMCD\n *\n * @beta\n */ function appendCmcdQuery(url, cmcd, options) {\n    // TODO: Replace with URLSearchParams once we drop Safari < 10.1 & Chrome < 49 support.\n    // https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams\n    const query = toCmcdQuery(cmcd, options);\n    if (!query) {\n        return url;\n    }\n    if (REGEX.test(url)) {\n        return url.replace(REGEX, query);\n    }\n    const separator = url.includes(\"?\") ? \"&\" : \"?\";\n    return `${url}${separator}${query}`;\n}\n/**\n * Controller to deal with Common Media Client Data (CMCD)\n * @see https://cdn.cta.tech/cta/media/media/resources/standards/pdfs/cta-5004-final.pdf\n */ class CMCDController {\n    // eslint-disable-line no-restricted-globals\n    constructor(hls){\n        this.hls = void 0;\n        this.config = void 0;\n        this.media = void 0;\n        this.sid = void 0;\n        this.cid = void 0;\n        this.useHeaders = false;\n        this.includeKeys = void 0;\n        this.initialized = false;\n        this.starved = false;\n        this.buffering = true;\n        this.audioBuffer = void 0;\n        // eslint-disable-line no-restricted-globals\n        this.videoBuffer = void 0;\n        this.onWaiting = ()=>{\n            if (this.initialized) {\n                this.starved = true;\n            }\n            this.buffering = true;\n        };\n        this.onPlaying = ()=>{\n            if (!this.initialized) {\n                this.initialized = true;\n            }\n            this.buffering = false;\n        };\n        /**\n     * Apply CMCD data to a manifest request.\n     */ this.applyPlaylistData = (context)=>{\n            try {\n                this.apply(context, {\n                    ot: CmObjectType.MANIFEST,\n                    su: !this.initialized\n                });\n            } catch (error) {\n                logger.warn(\"Could not generate manifest CMCD data.\", error);\n            }\n        };\n        /**\n     * Apply CMCD data to a segment request\n     */ this.applyFragmentData = (context)=>{\n            try {\n                const fragment = context.frag;\n                const level = this.hls.levels[fragment.level];\n                const ot = this.getObjectType(fragment);\n                const data = {\n                    d: fragment.duration * 1000,\n                    ot\n                };\n                if (ot === CmObjectType.VIDEO || ot === CmObjectType.AUDIO || ot == CmObjectType.MUXED) {\n                    data.br = level.bitrate / 1000;\n                    data.tb = this.getTopBandwidth(ot) / 1000;\n                    data.bl = this.getBufferLength(ot);\n                }\n                this.apply(context, data);\n            } catch (error) {\n                logger.warn(\"Could not generate segment CMCD data.\", error);\n            }\n        };\n        this.hls = hls;\n        const config = this.config = hls.config;\n        const { cmcd } = config;\n        if (cmcd != null) {\n            config.pLoader = this.createPlaylistLoader();\n            config.fLoader = this.createFragmentLoader();\n            this.sid = cmcd.sessionId || uuid();\n            this.cid = cmcd.contentId;\n            this.useHeaders = cmcd.useHeaders === true;\n            this.includeKeys = cmcd.includeKeys;\n            this.registerListeners();\n        }\n    }\n    registerListeners() {\n        const hls = this.hls;\n        hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        hls.on(Events.MEDIA_DETACHED, this.onMediaDetached, this);\n        hls.on(Events.BUFFER_CREATED, this.onBufferCreated, this);\n    }\n    unregisterListeners() {\n        const hls = this.hls;\n        hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        hls.off(Events.MEDIA_DETACHED, this.onMediaDetached, this);\n        hls.off(Events.BUFFER_CREATED, this.onBufferCreated, this);\n    }\n    destroy() {\n        this.unregisterListeners();\n        this.onMediaDetached();\n        // @ts-ignore\n        this.hls = this.config = this.audioBuffer = this.videoBuffer = null;\n        // @ts-ignore\n        this.onWaiting = this.onPlaying = null;\n    }\n    onMediaAttached(event, data) {\n        this.media = data.media;\n        this.media.addEventListener(\"waiting\", this.onWaiting);\n        this.media.addEventListener(\"playing\", this.onPlaying);\n    }\n    onMediaDetached() {\n        if (!this.media) {\n            return;\n        }\n        this.media.removeEventListener(\"waiting\", this.onWaiting);\n        this.media.removeEventListener(\"playing\", this.onPlaying);\n        // @ts-ignore\n        this.media = null;\n    }\n    onBufferCreated(event, data) {\n        var _data$tracks$audio, _data$tracks$video;\n        this.audioBuffer = (_data$tracks$audio = data.tracks.audio) == null ? void 0 : _data$tracks$audio.buffer;\n        this.videoBuffer = (_data$tracks$video = data.tracks.video) == null ? void 0 : _data$tracks$video.buffer;\n    }\n    /**\n   * Create baseline CMCD data\n   */ createData() {\n        var _this$media;\n        return {\n            v: 1,\n            sf: CmStreamingFormat.HLS,\n            sid: this.sid,\n            cid: this.cid,\n            pr: (_this$media = this.media) == null ? void 0 : _this$media.playbackRate,\n            mtp: this.hls.bandwidthEstimate / 1000\n        };\n    }\n    /**\n   * Apply CMCD data to a request.\n   */ apply(context, data = {}) {\n        // apply baseline data\n        _extends(data, this.createData());\n        const isVideo = data.ot === CmObjectType.INIT || data.ot === CmObjectType.VIDEO || data.ot === CmObjectType.MUXED;\n        if (this.starved && isVideo) {\n            data.bs = true;\n            data.su = true;\n            this.starved = false;\n        }\n        if (data.su == null) {\n            data.su = this.buffering;\n        }\n        // TODO: Implement rtp, nrr, nor, dl\n        const { includeKeys } = this;\n        if (includeKeys) {\n            data = Object.keys(data).reduce((acc, key)=>{\n                includeKeys.includes(key) && (acc[key] = data[key]);\n                return acc;\n            }, {});\n        }\n        if (this.useHeaders) {\n            if (!context.headers) {\n                context.headers = {};\n            }\n            appendCmcdHeaders(context.headers, data);\n        } else {\n            context.url = appendCmcdQuery(context.url, data);\n        }\n    }\n    /**\n   * The CMCD object type.\n   */ getObjectType(fragment) {\n        const { type } = fragment;\n        if (type === \"subtitle\") {\n            return CmObjectType.TIMED_TEXT;\n        }\n        if (fragment.sn === \"initSegment\") {\n            return CmObjectType.INIT;\n        }\n        if (type === \"audio\") {\n            return CmObjectType.AUDIO;\n        }\n        if (type === \"main\") {\n            if (!this.hls.audioTracks.length) {\n                return CmObjectType.MUXED;\n            }\n            return CmObjectType.VIDEO;\n        }\n        return undefined;\n    }\n    /**\n   * Get the highest bitrate.\n   */ getTopBandwidth(type) {\n        let bitrate = 0;\n        let levels;\n        const hls = this.hls;\n        if (type === CmObjectType.AUDIO) {\n            levels = hls.audioTracks;\n        } else {\n            const max = hls.maxAutoLevel;\n            const len = max > -1 ? max + 1 : hls.levels.length;\n            levels = hls.levels.slice(0, len);\n        }\n        for (const level of levels){\n            if (level.bitrate > bitrate) {\n                bitrate = level.bitrate;\n            }\n        }\n        return bitrate > 0 ? bitrate : NaN;\n    }\n    /**\n   * Get the buffer length for a media type in milliseconds\n   */ getBufferLength(type) {\n        const media = this.hls.media;\n        const buffer = type === CmObjectType.AUDIO ? this.audioBuffer : this.videoBuffer;\n        if (!buffer || !media) {\n            return NaN;\n        }\n        const info = BufferHelper.bufferInfo(buffer, media.currentTime, this.config.maxBufferHole);\n        return info.len * 1000;\n    }\n    /**\n   * Create a playlist loader\n   */ createPlaylistLoader() {\n        const { pLoader } = this.config;\n        const apply = this.applyPlaylistData;\n        const Ctor = pLoader || this.config.loader;\n        return class CmcdPlaylistLoader {\n            constructor(config){\n                this.loader = void 0;\n                this.loader = new Ctor(config);\n            }\n            get stats() {\n                return this.loader.stats;\n            }\n            get context() {\n                return this.loader.context;\n            }\n            destroy() {\n                this.loader.destroy();\n            }\n            abort() {\n                this.loader.abort();\n            }\n            load(context, config, callbacks) {\n                apply(context);\n                this.loader.load(context, config, callbacks);\n            }\n        };\n    }\n    /**\n   * Create a playlist loader\n   */ createFragmentLoader() {\n        const { fLoader } = this.config;\n        const apply = this.applyFragmentData;\n        const Ctor = fLoader || this.config.loader;\n        return class CmcdFragmentLoader {\n            constructor(config){\n                this.loader = void 0;\n                this.loader = new Ctor(config);\n            }\n            get stats() {\n                return this.loader.stats;\n            }\n            get context() {\n                return this.loader.context;\n            }\n            destroy() {\n                this.loader.destroy();\n            }\n            abort() {\n                this.loader.abort();\n            }\n            load(context, config, callbacks) {\n                apply(context);\n                this.loader.load(context, config, callbacks);\n            }\n        };\n    }\n}\nconst PATHWAY_PENALTY_DURATION_MS = 300000;\nclass ContentSteeringController {\n    constructor(hls){\n        this.hls = void 0;\n        this.log = void 0;\n        this.loader = null;\n        this.uri = null;\n        this.pathwayId = \".\";\n        this.pathwayPriority = null;\n        this.timeToLoad = 300;\n        this.reloadTimer = -1;\n        this.updated = 0;\n        this.started = false;\n        this.enabled = true;\n        this.levels = null;\n        this.audioTracks = null;\n        this.subtitleTracks = null;\n        this.penalizedPathways = {};\n        this.hls = hls;\n        this.log = logger.log.bind(logger, `[content-steering]:`);\n        this.registerListeners();\n    }\n    registerListeners() {\n        const hls = this.hls;\n        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n        hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n        hls.on(Events.ERROR, this.onError, this);\n    }\n    unregisterListeners() {\n        const hls = this.hls;\n        if (!hls) {\n            return;\n        }\n        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n        hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n        hls.off(Events.ERROR, this.onError, this);\n    }\n    startLoad() {\n        this.started = true;\n        this.clearTimeout();\n        if (this.enabled && this.uri) {\n            if (this.updated) {\n                const ttl = this.timeToLoad * 1000 - (performance.now() - this.updated);\n                if (ttl > 0) {\n                    this.scheduleRefresh(this.uri, ttl);\n                    return;\n                }\n            }\n            this.loadSteeringManifest(this.uri);\n        }\n    }\n    stopLoad() {\n        this.started = false;\n        if (this.loader) {\n            this.loader.destroy();\n            this.loader = null;\n        }\n        this.clearTimeout();\n    }\n    clearTimeout() {\n        if (this.reloadTimer !== -1) {\n            self.clearTimeout(this.reloadTimer);\n            this.reloadTimer = -1;\n        }\n    }\n    destroy() {\n        this.unregisterListeners();\n        this.stopLoad();\n        // @ts-ignore\n        this.hls = null;\n        this.levels = this.audioTracks = this.subtitleTracks = null;\n    }\n    removeLevel(levelToRemove) {\n        const levels = this.levels;\n        if (levels) {\n            this.levels = levels.filter((level)=>level !== levelToRemove);\n        }\n    }\n    onManifestLoading() {\n        this.stopLoad();\n        this.enabled = true;\n        this.timeToLoad = 300;\n        this.updated = 0;\n        this.uri = null;\n        this.pathwayId = \".\";\n        this.levels = this.audioTracks = this.subtitleTracks = null;\n    }\n    onManifestLoaded(event, data) {\n        const { contentSteering } = data;\n        if (contentSteering === null) {\n            return;\n        }\n        this.pathwayId = contentSteering.pathwayId;\n        this.uri = contentSteering.uri;\n        if (this.started) {\n            this.startLoad();\n        }\n    }\n    onManifestParsed(event, data) {\n        this.audioTracks = data.audioTracks;\n        this.subtitleTracks = data.subtitleTracks;\n    }\n    onError(event, data) {\n        const { errorAction } = data;\n        if ((errorAction == null ? void 0 : errorAction.action) === NetworkErrorAction.SendAlternateToPenaltyBox && errorAction.flags === ErrorActionFlags.MoveAllAlternatesMatchingHost) {\n            const levels = this.levels;\n            let pathwayPriority = this.pathwayPriority;\n            let errorPathway = this.pathwayId;\n            if (data.context) {\n                const { groupId, pathwayId, type } = data.context;\n                if (groupId && levels) {\n                    errorPathway = this.getPathwayForGroupId(groupId, type, errorPathway);\n                } else if (pathwayId) {\n                    errorPathway = pathwayId;\n                }\n            }\n            if (!(errorPathway in this.penalizedPathways)) {\n                this.penalizedPathways[errorPathway] = performance.now();\n            }\n            if (!pathwayPriority && levels) {\n                // If PATHWAY-PRIORITY was not provided, list pathways for error handling\n                pathwayPriority = levels.reduce((pathways, level)=>{\n                    if (pathways.indexOf(level.pathwayId) === -1) {\n                        pathways.push(level.pathwayId);\n                    }\n                    return pathways;\n                }, []);\n            }\n            if (pathwayPriority && pathwayPriority.length > 1) {\n                this.updatePathwayPriority(pathwayPriority);\n                errorAction.resolved = this.pathwayId !== errorPathway;\n            }\n            if (!errorAction.resolved) {\n                logger.warn(`Could not resolve ${data.details} (\"${data.error.message}\") with content-steering for Pathway: ${errorPathway} levels: ${levels ? levels.length : levels} priorities: ${JSON.stringify(pathwayPriority)} penalized: ${JSON.stringify(this.penalizedPathways)}`);\n            }\n        }\n    }\n    filterParsedLevels(levels) {\n        // Filter levels to only include those that are in the initial pathway\n        this.levels = levels;\n        let pathwayLevels = this.getLevelsForPathway(this.pathwayId);\n        if (pathwayLevels.length === 0) {\n            const pathwayId = levels[0].pathwayId;\n            this.log(`No levels found in Pathway ${this.pathwayId}. Setting initial Pathway to \"${pathwayId}\"`);\n            pathwayLevels = this.getLevelsForPathway(pathwayId);\n            this.pathwayId = pathwayId;\n        }\n        if (pathwayLevels.length !== levels.length) {\n            this.log(`Found ${pathwayLevels.length}/${levels.length} levels in Pathway \"${this.pathwayId}\"`);\n            return pathwayLevels;\n        }\n        return levels;\n    }\n    getLevelsForPathway(pathwayId) {\n        if (this.levels === null) {\n            return [];\n        }\n        return this.levels.filter((level)=>pathwayId === level.pathwayId);\n    }\n    updatePathwayPriority(pathwayPriority) {\n        this.pathwayPriority = pathwayPriority;\n        let levels;\n        // Evaluate if we should remove the pathway from the penalized list\n        const penalizedPathways = this.penalizedPathways;\n        const now = performance.now();\n        Object.keys(penalizedPathways).forEach((pathwayId)=>{\n            if (now - penalizedPathways[pathwayId] > PATHWAY_PENALTY_DURATION_MS) {\n                delete penalizedPathways[pathwayId];\n            }\n        });\n        for(let i = 0; i < pathwayPriority.length; i++){\n            const pathwayId = pathwayPriority[i];\n            if (pathwayId in penalizedPathways) {\n                continue;\n            }\n            if (pathwayId === this.pathwayId) {\n                return;\n            }\n            const selectedIndex = this.hls.nextLoadLevel;\n            const selectedLevel = this.hls.levels[selectedIndex];\n            levels = this.getLevelsForPathway(pathwayId);\n            if (levels.length > 0) {\n                this.log(`Setting Pathway to \"${pathwayId}\"`);\n                this.pathwayId = pathwayId;\n                reassignFragmentLevelIndexes(levels);\n                this.hls.trigger(Events.LEVELS_UPDATED, {\n                    levels\n                });\n                // Set LevelController's level to trigger LEVEL_SWITCHING which loads playlist if needed\n                const levelAfterChange = this.hls.levels[selectedIndex];\n                if (selectedLevel && levelAfterChange && this.levels) {\n                    if (levelAfterChange.attrs[\"STABLE-VARIANT-ID\"] !== selectedLevel.attrs[\"STABLE-VARIANT-ID\"] && levelAfterChange.bitrate !== selectedLevel.bitrate) {\n                        this.log(`Unstable Pathways change from bitrate ${selectedLevel.bitrate} to ${levelAfterChange.bitrate}`);\n                    }\n                    this.hls.nextLoadLevel = selectedIndex;\n                }\n                break;\n            }\n        }\n    }\n    getPathwayForGroupId(groupId, type, defaultPathway) {\n        const levels = this.getLevelsForPathway(defaultPathway).concat(this.levels || []);\n        for(let i = 0; i < levels.length; i++){\n            if (type === PlaylistContextType.AUDIO_TRACK && levels[i].hasAudioGroup(groupId) || type === PlaylistContextType.SUBTITLE_TRACK && levels[i].hasSubtitleGroup(groupId)) {\n                return levels[i].pathwayId;\n            }\n        }\n        return defaultPathway;\n    }\n    clonePathways(pathwayClones) {\n        const levels = this.levels;\n        if (!levels) {\n            return;\n        }\n        const audioGroupCloneMap = {};\n        const subtitleGroupCloneMap = {};\n        pathwayClones.forEach((pathwayClone)=>{\n            const { ID: cloneId, \"BASE-ID\": baseId, \"URI-REPLACEMENT\": uriReplacement } = pathwayClone;\n            if (levels.some((level)=>level.pathwayId === cloneId)) {\n                return;\n            }\n            const clonedVariants = this.getLevelsForPathway(baseId).map((baseLevel)=>{\n                const attributes = new AttrList(baseLevel.attrs);\n                attributes[\"PATHWAY-ID\"] = cloneId;\n                const clonedAudioGroupId = attributes.AUDIO && `${attributes.AUDIO}_clone_${cloneId}`;\n                const clonedSubtitleGroupId = attributes.SUBTITLES && `${attributes.SUBTITLES}_clone_${cloneId}`;\n                if (clonedAudioGroupId) {\n                    audioGroupCloneMap[attributes.AUDIO] = clonedAudioGroupId;\n                    attributes.AUDIO = clonedAudioGroupId;\n                }\n                if (clonedSubtitleGroupId) {\n                    subtitleGroupCloneMap[attributes.SUBTITLES] = clonedSubtitleGroupId;\n                    attributes.SUBTITLES = clonedSubtitleGroupId;\n                }\n                const url = performUriReplacement(baseLevel.uri, attributes[\"STABLE-VARIANT-ID\"], \"PER-VARIANT-URIS\", uriReplacement);\n                const clonedLevel = new Level({\n                    attrs: attributes,\n                    audioCodec: baseLevel.audioCodec,\n                    bitrate: baseLevel.bitrate,\n                    height: baseLevel.height,\n                    name: baseLevel.name,\n                    url,\n                    videoCodec: baseLevel.videoCodec,\n                    width: baseLevel.width\n                });\n                if (baseLevel.audioGroups) {\n                    for(let i = 1; i < baseLevel.audioGroups.length; i++){\n                        clonedLevel.addGroupId(\"audio\", `${baseLevel.audioGroups[i]}_clone_${cloneId}`);\n                    }\n                }\n                if (baseLevel.subtitleGroups) {\n                    for(let i = 1; i < baseLevel.subtitleGroups.length; i++){\n                        clonedLevel.addGroupId(\"text\", `${baseLevel.subtitleGroups[i]}_clone_${cloneId}`);\n                    }\n                }\n                return clonedLevel;\n            });\n            levels.push(...clonedVariants);\n            cloneRenditionGroups(this.audioTracks, audioGroupCloneMap, uriReplacement, cloneId);\n            cloneRenditionGroups(this.subtitleTracks, subtitleGroupCloneMap, uriReplacement, cloneId);\n        });\n    }\n    loadSteeringManifest(uri) {\n        const config = this.hls.config;\n        const Loader = config.loader;\n        if (this.loader) {\n            this.loader.destroy();\n        }\n        this.loader = new Loader(config);\n        let url;\n        try {\n            url = new self.URL(uri);\n        } catch (error) {\n            this.enabled = false;\n            this.log(`Failed to parse Steering Manifest URI: ${uri}`);\n            return;\n        }\n        if (url.protocol !== \"data:\") {\n            const throughput = (this.hls.bandwidthEstimate || config.abrEwmaDefaultEstimate) | 0;\n            url.searchParams.set(\"_HLS_pathway\", this.pathwayId);\n            url.searchParams.set(\"_HLS_throughput\", \"\" + throughput);\n        }\n        const context = {\n            responseType: \"json\",\n            url: url.href\n        };\n        const loadPolicy = config.steeringManifestLoadPolicy.default;\n        const legacyRetryCompatibility = loadPolicy.errorRetry || loadPolicy.timeoutRetry || {};\n        const loaderConfig = {\n            loadPolicy,\n            timeout: loadPolicy.maxLoadTimeMs,\n            maxRetry: legacyRetryCompatibility.maxNumRetry || 0,\n            retryDelay: legacyRetryCompatibility.retryDelayMs || 0,\n            maxRetryDelay: legacyRetryCompatibility.maxRetryDelayMs || 0\n        };\n        const callbacks = {\n            onSuccess: (response, stats, context, networkDetails)=>{\n                this.log(`Loaded steering manifest: \"${url}\"`);\n                const steeringData = response.data;\n                if (steeringData.VERSION !== 1) {\n                    this.log(`Steering VERSION ${steeringData.VERSION} not supported!`);\n                    return;\n                }\n                this.updated = performance.now();\n                this.timeToLoad = steeringData.TTL;\n                const { \"RELOAD-URI\": reloadUri, \"PATHWAY-CLONES\": pathwayClones, \"PATHWAY-PRIORITY\": pathwayPriority } = steeringData;\n                if (reloadUri) {\n                    try {\n                        this.uri = new self.URL(reloadUri, url).href;\n                    } catch (error) {\n                        this.enabled = false;\n                        this.log(`Failed to parse Steering Manifest RELOAD-URI: ${reloadUri}`);\n                        return;\n                    }\n                }\n                this.scheduleRefresh(this.uri || context.url);\n                if (pathwayClones) {\n                    this.clonePathways(pathwayClones);\n                }\n                const loadedSteeringData = {\n                    steeringManifest: steeringData,\n                    url: url.toString()\n                };\n                this.hls.trigger(Events.STEERING_MANIFEST_LOADED, loadedSteeringData);\n                if (pathwayPriority) {\n                    this.updatePathwayPriority(pathwayPriority);\n                }\n            },\n            onError: (error, context, networkDetails, stats)=>{\n                this.log(`Error loading steering manifest: ${error.code} ${error.text} (${context.url})`);\n                this.stopLoad();\n                if (error.code === 410) {\n                    this.enabled = false;\n                    this.log(`Steering manifest ${context.url} no longer available`);\n                    return;\n                }\n                let ttl = this.timeToLoad * 1000;\n                if (error.code === 429) {\n                    const loader = this.loader;\n                    if (typeof (loader == null ? void 0 : loader.getResponseHeader) === \"function\") {\n                        const retryAfter = loader.getResponseHeader(\"Retry-After\");\n                        if (retryAfter) {\n                            ttl = parseFloat(retryAfter) * 1000;\n                        }\n                    }\n                    this.log(`Steering manifest ${context.url} rate limited`);\n                    return;\n                }\n                this.scheduleRefresh(this.uri || context.url, ttl);\n            },\n            onTimeout: (stats, context, networkDetails)=>{\n                this.log(`Timeout loading steering manifest (${context.url})`);\n                this.scheduleRefresh(this.uri || context.url);\n            }\n        };\n        this.log(`Requesting steering manifest: ${url}`);\n        this.loader.load(context, loaderConfig, callbacks);\n    }\n    scheduleRefresh(uri, ttlMs = this.timeToLoad * 1000) {\n        this.clearTimeout();\n        this.reloadTimer = self.setTimeout(()=>{\n            var _this$hls;\n            const media = (_this$hls = this.hls) == null ? void 0 : _this$hls.media;\n            if (media && !media.ended) {\n                this.loadSteeringManifest(uri);\n                return;\n            }\n            this.scheduleRefresh(uri, this.timeToLoad * 1000);\n        }, ttlMs);\n    }\n}\nfunction cloneRenditionGroups(tracks, groupCloneMap, uriReplacement, cloneId) {\n    if (!tracks) {\n        return;\n    }\n    Object.keys(groupCloneMap).forEach((audioGroupId)=>{\n        const clonedTracks = tracks.filter((track)=>track.groupId === audioGroupId).map((track)=>{\n            const clonedTrack = _extends({}, track);\n            clonedTrack.details = undefined;\n            clonedTrack.attrs = new AttrList(clonedTrack.attrs);\n            clonedTrack.url = clonedTrack.attrs.URI = performUriReplacement(track.url, track.attrs[\"STABLE-RENDITION-ID\"], \"PER-RENDITION-URIS\", uriReplacement);\n            clonedTrack.groupId = clonedTrack.attrs[\"GROUP-ID\"] = groupCloneMap[audioGroupId];\n            clonedTrack.attrs[\"PATHWAY-ID\"] = cloneId;\n            return clonedTrack;\n        });\n        tracks.push(...clonedTracks);\n    });\n}\nfunction performUriReplacement(uri, stableId, perOptionKey, uriReplacement) {\n    const { HOST: host, PARAMS: params, [perOptionKey]: perOptionUris } = uriReplacement;\n    let perVariantUri;\n    if (stableId) {\n        perVariantUri = perOptionUris == null ? void 0 : perOptionUris[stableId];\n        if (perVariantUri) {\n            uri = perVariantUri;\n        }\n    }\n    const url = new self.URL(uri);\n    if (host && !perVariantUri) {\n        url.host = host;\n    }\n    if (params) {\n        Object.keys(params).sort().forEach((key)=>{\n            if (key) {\n                url.searchParams.set(key, params[key]);\n            }\n        });\n    }\n    return url.href;\n}\nconst AGE_HEADER_LINE_REGEX = /^age:\\s*[\\d.]+\\s*$/im;\nclass XhrLoader {\n    constructor(config){\n        this.xhrSetup = void 0;\n        this.requestTimeout = void 0;\n        this.retryTimeout = void 0;\n        this.retryDelay = void 0;\n        this.config = null;\n        this.callbacks = null;\n        this.context = null;\n        this.loader = null;\n        this.stats = void 0;\n        this.xhrSetup = config ? config.xhrSetup || null : null;\n        this.stats = new LoadStats();\n        this.retryDelay = 0;\n    }\n    destroy() {\n        this.callbacks = null;\n        this.abortInternal();\n        this.loader = null;\n        this.config = null;\n        this.context = null;\n        this.xhrSetup = null;\n        // @ts-ignore\n        this.stats = null;\n    }\n    abortInternal() {\n        const loader = this.loader;\n        self.clearTimeout(this.requestTimeout);\n        self.clearTimeout(this.retryTimeout);\n        if (loader) {\n            loader.onreadystatechange = null;\n            loader.onprogress = null;\n            if (loader.readyState !== 4) {\n                this.stats.aborted = true;\n                loader.abort();\n            }\n        }\n    }\n    abort() {\n        var _this$callbacks;\n        this.abortInternal();\n        if ((_this$callbacks = this.callbacks) != null && _this$callbacks.onAbort) {\n            this.callbacks.onAbort(this.stats, this.context, this.loader);\n        }\n    }\n    load(context, config, callbacks) {\n        if (this.stats.loading.start) {\n            throw new Error(\"Loader can only be used once.\");\n        }\n        this.stats.loading.start = self.performance.now();\n        this.context = context;\n        this.config = config;\n        this.callbacks = callbacks;\n        this.loadInternal();\n    }\n    loadInternal() {\n        const { config, context } = this;\n        if (!config || !context) {\n            return;\n        }\n        const xhr = this.loader = new self.XMLHttpRequest();\n        const stats = this.stats;\n        stats.loading.first = 0;\n        stats.loaded = 0;\n        stats.aborted = false;\n        const xhrSetup = this.xhrSetup;\n        if (xhrSetup) {\n            Promise.resolve().then(()=>{\n                if (this.stats.aborted) return;\n                return xhrSetup(xhr, context.url);\n            }).catch((error)=>{\n                xhr.open(\"GET\", context.url, true);\n                return xhrSetup(xhr, context.url);\n            }).then(()=>{\n                if (this.stats.aborted) return;\n                this.openAndSendXhr(xhr, context, config);\n            }).catch((error)=>{\n                // IE11 throws an exception on xhr.open if attempting to access an HTTP resource over HTTPS\n                this.callbacks.onError({\n                    code: xhr.status,\n                    text: error.message\n                }, context, xhr, stats);\n                return;\n            });\n        } else {\n            this.openAndSendXhr(xhr, context, config);\n        }\n    }\n    openAndSendXhr(xhr, context, config) {\n        if (!xhr.readyState) {\n            xhr.open(\"GET\", context.url, true);\n        }\n        const headers = context.headers;\n        const { maxTimeToFirstByteMs, maxLoadTimeMs } = config.loadPolicy;\n        if (headers) {\n            for(const header in headers){\n                xhr.setRequestHeader(header, headers[header]);\n            }\n        }\n        if (context.rangeEnd) {\n            xhr.setRequestHeader(\"Range\", \"bytes=\" + context.rangeStart + \"-\" + (context.rangeEnd - 1));\n        }\n        xhr.onreadystatechange = this.readystatechange.bind(this);\n        xhr.onprogress = this.loadprogress.bind(this);\n        xhr.responseType = context.responseType;\n        // setup timeout before we perform request\n        self.clearTimeout(this.requestTimeout);\n        config.timeout = maxTimeToFirstByteMs && isFiniteNumber(maxTimeToFirstByteMs) ? maxTimeToFirstByteMs : maxLoadTimeMs;\n        this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.timeout);\n        xhr.send();\n    }\n    readystatechange() {\n        const { context, loader: xhr, stats } = this;\n        if (!context || !xhr) {\n            return;\n        }\n        const readyState = xhr.readyState;\n        const config = this.config;\n        // don't proceed if xhr has been aborted\n        if (stats.aborted) {\n            return;\n        }\n        // >= HEADERS_RECEIVED\n        if (readyState >= 2) {\n            if (stats.loading.first === 0) {\n                stats.loading.first = Math.max(self.performance.now(), stats.loading.start);\n                // readyState >= 2 AND readyState !==4 (readyState = HEADERS_RECEIVED || LOADING) rearm timeout as xhr not finished yet\n                if (config.timeout !== config.loadPolicy.maxLoadTimeMs) {\n                    self.clearTimeout(this.requestTimeout);\n                    config.timeout = config.loadPolicy.maxLoadTimeMs;\n                    this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.loadPolicy.maxLoadTimeMs - (stats.loading.first - stats.loading.start));\n                }\n            }\n            if (readyState === 4) {\n                self.clearTimeout(this.requestTimeout);\n                xhr.onreadystatechange = null;\n                xhr.onprogress = null;\n                const status1 = xhr.status;\n                // http status between 200 to 299 are all successful\n                const useResponse = xhr.responseType !== \"text\";\n                if (status1 >= 200 && status1 < 300 && (useResponse && xhr.response || xhr.responseText !== null)) {\n                    stats.loading.end = Math.max(self.performance.now(), stats.loading.first);\n                    const data = useResponse ? xhr.response : xhr.responseText;\n                    const len = xhr.responseType === \"arraybuffer\" ? data.byteLength : data.length;\n                    stats.loaded = stats.total = len;\n                    stats.bwEstimate = stats.total * 8000 / (stats.loading.end - stats.loading.first);\n                    if (!this.callbacks) {\n                        return;\n                    }\n                    const onProgress = this.callbacks.onProgress;\n                    if (onProgress) {\n                        onProgress(stats, context, data, xhr);\n                    }\n                    if (!this.callbacks) {\n                        return;\n                    }\n                    const response = {\n                        url: xhr.responseURL,\n                        data: data,\n                        code: status1\n                    };\n                    this.callbacks.onSuccess(response, stats, context, xhr);\n                } else {\n                    const retryConfig = config.loadPolicy.errorRetry;\n                    const retryCount = stats.retry;\n                    // if max nb of retries reached or if http status between 400 and 499 (such error cannot be recovered, retrying is useless), return error\n                    const response = {\n                        url: context.url,\n                        data: undefined,\n                        code: status1\n                    };\n                    if (shouldRetry(retryConfig, retryCount, false, response)) {\n                        this.retry(retryConfig);\n                    } else {\n                        logger.error(`${status1} while loading ${context.url}`);\n                        this.callbacks.onError({\n                            code: status1,\n                            text: xhr.statusText\n                        }, context, xhr, stats);\n                    }\n                }\n            }\n        }\n    }\n    loadtimeout() {\n        var _this$config;\n        const retryConfig = (_this$config = this.config) == null ? void 0 : _this$config.loadPolicy.timeoutRetry;\n        const retryCount = this.stats.retry;\n        if (shouldRetry(retryConfig, retryCount, true)) {\n            this.retry(retryConfig);\n        } else {\n            var _this$context;\n            logger.warn(`timeout while loading ${(_this$context = this.context) == null ? void 0 : _this$context.url}`);\n            const callbacks = this.callbacks;\n            if (callbacks) {\n                this.abortInternal();\n                callbacks.onTimeout(this.stats, this.context, this.loader);\n            }\n        }\n    }\n    retry(retryConfig) {\n        const { context, stats } = this;\n        this.retryDelay = getRetryDelay(retryConfig, stats.retry);\n        stats.retry++;\n        logger.warn(`${status ? \"HTTP Status \" + status : \"Timeout\"} while loading ${context == null ? void 0 : context.url}, retrying ${stats.retry}/${retryConfig.maxNumRetry} in ${this.retryDelay}ms`);\n        // abort and reset internal state\n        this.abortInternal();\n        this.loader = null;\n        // schedule retry\n        self.clearTimeout(this.retryTimeout);\n        this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay);\n    }\n    loadprogress(event) {\n        const stats = this.stats;\n        stats.loaded = event.loaded;\n        if (event.lengthComputable) {\n            stats.total = event.total;\n        }\n    }\n    getCacheAge() {\n        let result = null;\n        if (this.loader && AGE_HEADER_LINE_REGEX.test(this.loader.getAllResponseHeaders())) {\n            const ageHeader = this.loader.getResponseHeader(\"age\");\n            result = ageHeader ? parseFloat(ageHeader) : null;\n        }\n        return result;\n    }\n    getResponseHeader(name) {\n        if (this.loader && new RegExp(`^${name}:\\\\s*[\\\\d.]+\\\\s*$`, \"im\").test(this.loader.getAllResponseHeaders())) {\n            return this.loader.getResponseHeader(name);\n        }\n        return null;\n    }\n}\nfunction fetchSupported() {\n    if (// @ts-ignore\n    self.fetch && self.AbortController && self.ReadableStream && self.Request) {\n        try {\n            new self.ReadableStream({}); // eslint-disable-line no-new\n            return true;\n        } catch (e) {\n        /* noop */ }\n    }\n    return false;\n}\nconst BYTERANGE = /(\\d+)-(\\d+)\\/(\\d+)/;\nclass FetchLoader {\n    constructor(config /* HlsConfig */ ){\n        this.fetchSetup = void 0;\n        this.requestTimeout = void 0;\n        this.request = null;\n        this.response = null;\n        this.controller = void 0;\n        this.context = null;\n        this.config = null;\n        this.callbacks = null;\n        this.stats = void 0;\n        this.loader = null;\n        this.fetchSetup = config.fetchSetup || getRequest;\n        this.controller = new self.AbortController();\n        this.stats = new LoadStats();\n    }\n    destroy() {\n        this.loader = this.callbacks = this.context = this.config = this.request = null;\n        this.abortInternal();\n        this.response = null;\n        // @ts-ignore\n        this.fetchSetup = this.controller = this.stats = null;\n    }\n    abortInternal() {\n        if (this.controller && !this.stats.loading.end) {\n            this.stats.aborted = true;\n            this.controller.abort();\n        }\n    }\n    abort() {\n        var _this$callbacks;\n        this.abortInternal();\n        if ((_this$callbacks = this.callbacks) != null && _this$callbacks.onAbort) {\n            this.callbacks.onAbort(this.stats, this.context, this.response);\n        }\n    }\n    load(context, config, callbacks) {\n        const stats = this.stats;\n        if (stats.loading.start) {\n            throw new Error(\"Loader can only be used once.\");\n        }\n        stats.loading.start = self.performance.now();\n        const initParams = getRequestParameters(context, this.controller.signal);\n        const onProgress = callbacks.onProgress;\n        const isArrayBuffer = context.responseType === \"arraybuffer\";\n        const LENGTH = isArrayBuffer ? \"byteLength\" : \"length\";\n        const { maxTimeToFirstByteMs, maxLoadTimeMs } = config.loadPolicy;\n        this.context = context;\n        this.config = config;\n        this.callbacks = callbacks;\n        this.request = this.fetchSetup(context, initParams);\n        self.clearTimeout(this.requestTimeout);\n        config.timeout = maxTimeToFirstByteMs && isFiniteNumber(maxTimeToFirstByteMs) ? maxTimeToFirstByteMs : maxLoadTimeMs;\n        this.requestTimeout = self.setTimeout(()=>{\n            this.abortInternal();\n            callbacks.onTimeout(stats, context, this.response);\n        }, config.timeout);\n        self.fetch(this.request).then((response)=>{\n            this.response = this.loader = response;\n            const first = Math.max(self.performance.now(), stats.loading.start);\n            self.clearTimeout(this.requestTimeout);\n            config.timeout = maxLoadTimeMs;\n            this.requestTimeout = self.setTimeout(()=>{\n                this.abortInternal();\n                callbacks.onTimeout(stats, context, this.response);\n            }, maxLoadTimeMs - (first - stats.loading.start));\n            if (!response.ok) {\n                const { status: status1, statusText } = response;\n                throw new FetchError(statusText || \"fetch, bad network response\", status1, response);\n            }\n            stats.loading.first = first;\n            stats.total = getContentLength(response.headers) || stats.total;\n            if (onProgress && isFiniteNumber(config.highWaterMark)) {\n                return this.loadProgressively(response, stats, context, config.highWaterMark, onProgress);\n            }\n            if (isArrayBuffer) {\n                return response.arrayBuffer();\n            }\n            if (context.responseType === \"json\") {\n                return response.json();\n            }\n            return response.text();\n        }).then((responseData)=>{\n            const response = this.response;\n            if (!response) {\n                throw new Error(\"loader destroyed\");\n            }\n            self.clearTimeout(this.requestTimeout);\n            stats.loading.end = Math.max(self.performance.now(), stats.loading.first);\n            const total = responseData[LENGTH];\n            if (total) {\n                stats.loaded = stats.total = total;\n            }\n            const loaderResponse = {\n                url: response.url,\n                data: responseData,\n                code: response.status\n            };\n            if (onProgress && !isFiniteNumber(config.highWaterMark)) {\n                onProgress(stats, context, responseData, response);\n            }\n            callbacks.onSuccess(loaderResponse, stats, context, response);\n        }).catch((error)=>{\n            self.clearTimeout(this.requestTimeout);\n            if (stats.aborted) {\n                return;\n            }\n            // CORS errors result in an undefined code. Set it to 0 here to align with XHR's behavior\n            // when destroying, 'error' itself can be undefined\n            const code = !error ? 0 : error.code || 0;\n            const text = !error ? null : error.message;\n            callbacks.onError({\n                code,\n                text\n            }, context, error ? error.details : null, stats);\n        });\n    }\n    getCacheAge() {\n        let result = null;\n        if (this.response) {\n            const ageHeader = this.response.headers.get(\"age\");\n            result = ageHeader ? parseFloat(ageHeader) : null;\n        }\n        return result;\n    }\n    getResponseHeader(name) {\n        return this.response ? this.response.headers.get(name) : null;\n    }\n    loadProgressively(response, stats, context, highWaterMark = 0, onProgress) {\n        const chunkCache = new ChunkCache();\n        const reader = response.body.getReader();\n        const pump = ()=>{\n            return reader.read().then((data)=>{\n                if (data.done) {\n                    if (chunkCache.dataLength) {\n                        onProgress(stats, context, chunkCache.flush(), response);\n                    }\n                    return Promise.resolve(new ArrayBuffer(0));\n                }\n                const chunk = data.value;\n                const len = chunk.length;\n                stats.loaded += len;\n                if (len < highWaterMark || chunkCache.dataLength) {\n                    // The current chunk is too small to to be emitted or the cache already has data\n                    // Push it to the cache\n                    chunkCache.push(chunk);\n                    if (chunkCache.dataLength >= highWaterMark) {\n                        // flush in order to join the typed arrays\n                        onProgress(stats, context, chunkCache.flush(), response);\n                    }\n                } else {\n                    // If there's nothing cached already, and the chache is large enough\n                    // just emit the progress event\n                    onProgress(stats, context, chunk, response);\n                }\n                return pump();\n            }).catch(()=>{\n                /* aborted */ return Promise.reject();\n            });\n        };\n        return pump();\n    }\n}\nfunction getRequestParameters(context, signal) {\n    const initParams = {\n        method: \"GET\",\n        mode: \"cors\",\n        credentials: \"same-origin\",\n        signal,\n        headers: new self.Headers(_extends({}, context.headers))\n    };\n    if (context.rangeEnd) {\n        initParams.headers.set(\"Range\", \"bytes=\" + context.rangeStart + \"-\" + String(context.rangeEnd - 1));\n    }\n    return initParams;\n}\nfunction getByteRangeLength(byteRangeHeader) {\n    const result = BYTERANGE.exec(byteRangeHeader);\n    if (result) {\n        return parseInt(result[2]) - parseInt(result[1]) + 1;\n    }\n}\nfunction getContentLength(headers) {\n    const contentRange = headers.get(\"Content-Range\");\n    if (contentRange) {\n        const byteRangeLength = getByteRangeLength(contentRange);\n        if (isFiniteNumber(byteRangeLength)) {\n            return byteRangeLength;\n        }\n    }\n    const contentLength = headers.get(\"Content-Length\");\n    if (contentLength) {\n        return parseInt(contentLength);\n    }\n}\nfunction getRequest(context, initParams) {\n    return new self.Request(context.url, initParams);\n}\nclass FetchError extends Error {\n    constructor(message, code, details){\n        super(message);\n        this.code = void 0;\n        this.details = void 0;\n        this.code = code;\n        this.details = details;\n    }\n}\nconst WHITESPACE_CHAR = /\\s/;\nconst Cues = {\n    newCue (track, startTime, endTime, captionScreen) {\n        const result = [];\n        let row;\n        // the type data states this is VTTCue, but it can potentially be a TextTrackCue on old browsers\n        let cue;\n        let indenting;\n        let indent;\n        let text;\n        const Cue = self.VTTCue || self.TextTrackCue;\n        for(let r = 0; r < captionScreen.rows.length; r++){\n            row = captionScreen.rows[r];\n            indenting = true;\n            indent = 0;\n            text = \"\";\n            if (!row.isEmpty()) {\n                var _track$cues;\n                for(let c = 0; c < row.chars.length; c++){\n                    if (WHITESPACE_CHAR.test(row.chars[c].uchar) && indenting) {\n                        indent++;\n                    } else {\n                        text += row.chars[c].uchar;\n                        indenting = false;\n                    }\n                }\n                // To be used for cleaning-up orphaned roll-up captions\n                row.cueStartTime = startTime;\n                // Give a slight bump to the endTime if it's equal to startTime to avoid a SyntaxError in IE\n                if (startTime === endTime) {\n                    endTime += 0.0001;\n                }\n                if (indent >= 16) {\n                    indent--;\n                } else {\n                    indent++;\n                }\n                const cueText = fixLineBreaks(text.trim());\n                const id = generateCueId(startTime, endTime, cueText);\n                // If this cue already exists in the track do not push it\n                if (!(track != null && (_track$cues = track.cues) != null && _track$cues.getCueById(id))) {\n                    cue = new Cue(startTime, endTime, cueText);\n                    cue.id = id;\n                    cue.line = r + 1;\n                    cue.align = \"left\";\n                    // Clamp the position between 10 and 80 percent (CEA-608 PAC indent code)\n                    // https://dvcs.w3.org/hg/text-tracks/raw-file/default/608toVTT/608toVTT.html#positioning-in-cea-608\n                    // Firefox throws an exception and captions break with out of bounds 0-100 values\n                    cue.position = 10 + Math.min(80, Math.floor(indent * 8 / 32) * 10);\n                    result.push(cue);\n                }\n            }\n        }\n        if (track && result.length) {\n            // Sort bottom cues in reverse order so that they render in line order when overlapping in Chrome\n            result.sort((cueA, cueB)=>{\n                if (cueA.line === \"auto\" || cueB.line === \"auto\") {\n                    return 0;\n                }\n                if (cueA.line > 8 && cueB.line > 8) {\n                    return cueB.line - cueA.line;\n                }\n                return cueA.line - cueB.line;\n            });\n            result.forEach((cue)=>addCueToTrack(track, cue));\n        }\n        return result;\n    }\n};\n/**\n * @deprecated use fragLoadPolicy.default\n */ /**\n * @deprecated use manifestLoadPolicy.default and playlistLoadPolicy.default\n */ const defaultLoadPolicy = {\n    maxTimeToFirstByteMs: 8000,\n    maxLoadTimeMs: 20000,\n    timeoutRetry: null,\n    errorRetry: null\n};\n/**\n * @ignore\n * If possible, keep hlsDefaultConfig shallow\n * It is cloned whenever a new Hls instance is created, by keeping the config\n * shallow the properties are cloned, and we don't end up manipulating the default\n */ const hlsDefaultConfig = _objectSpread2(_objectSpread2({\n    autoStartLoad: true,\n    // used by stream-controller\n    startPosition: -1,\n    // used by stream-controller\n    defaultAudioCodec: undefined,\n    // used by stream-controller\n    debug: false,\n    // used by logger\n    capLevelOnFPSDrop: false,\n    // used by fps-controller\n    capLevelToPlayerSize: false,\n    // used by cap-level-controller\n    ignoreDevicePixelRatio: false,\n    // used by cap-level-controller\n    preferManagedMediaSource: true,\n    initialLiveManifestSize: 1,\n    // used by stream-controller\n    maxBufferLength: 30,\n    // used by stream-controller\n    backBufferLength: Infinity,\n    // used by buffer-controller\n    frontBufferFlushThreshold: Infinity,\n    maxBufferSize: 60 * 1000 * 1000,\n    // used by stream-controller\n    maxBufferHole: 0.1,\n    // used by stream-controller\n    highBufferWatchdogPeriod: 2,\n    // used by stream-controller\n    nudgeOffset: 0.1,\n    // used by stream-controller\n    nudgeMaxRetry: 3,\n    // used by stream-controller\n    maxFragLookUpTolerance: 0.25,\n    // used by stream-controller\n    liveSyncDurationCount: 3,\n    // used by latency-controller\n    liveMaxLatencyDurationCount: Infinity,\n    // used by latency-controller\n    liveSyncDuration: undefined,\n    // used by latency-controller\n    liveMaxLatencyDuration: undefined,\n    // used by latency-controller\n    maxLiveSyncPlaybackRate: 1,\n    // used by latency-controller\n    liveDurationInfinity: false,\n    // used by buffer-controller\n    /**\n   * @deprecated use backBufferLength\n   */ liveBackBufferLength: null,\n    // used by buffer-controller\n    maxMaxBufferLength: 600,\n    // used by stream-controller\n    enableWorker: true,\n    // used by transmuxer\n    workerPath: null,\n    // used by transmuxer\n    enableSoftwareAES: true,\n    // used by decrypter\n    startLevel: undefined,\n    // used by level-controller\n    startFragPrefetch: false,\n    // used by stream-controller\n    fpsDroppedMonitoringPeriod: 5000,\n    // used by fps-controller\n    fpsDroppedMonitoringThreshold: 0.2,\n    // used by fps-controller\n    appendErrorMaxRetry: 3,\n    // used by buffer-controller\n    loader: XhrLoader,\n    // loader: FetchLoader,\n    fLoader: undefined,\n    // used by fragment-loader\n    pLoader: undefined,\n    // used by playlist-loader\n    xhrSetup: undefined,\n    // used by xhr-loader\n    licenseXhrSetup: undefined,\n    // used by eme-controller\n    licenseResponseCallback: undefined,\n    // used by eme-controller\n    abrController: AbrController,\n    bufferController: BufferController,\n    capLevelController: CapLevelController,\n    errorController: ErrorController,\n    fpsController: FPSController,\n    stretchShortVideoTrack: false,\n    // used by mp4-remuxer\n    maxAudioFramesDrift: 1,\n    // used by mp4-remuxer\n    forceKeyFrameOnDiscontinuity: true,\n    // used by ts-demuxer\n    abrEwmaFastLive: 3,\n    // used by abr-controller\n    abrEwmaSlowLive: 9,\n    // used by abr-controller\n    abrEwmaFastVoD: 3,\n    // used by abr-controller\n    abrEwmaSlowVoD: 9,\n    // used by abr-controller\n    abrEwmaDefaultEstimate: 5e5,\n    // 500 kbps  // used by abr-controller\n    abrEwmaDefaultEstimateMax: 5e6,\n    // 5 mbps\n    abrBandWidthFactor: 0.95,\n    // used by abr-controller\n    abrBandWidthUpFactor: 0.7,\n    // used by abr-controller\n    abrMaxWithRealBitrate: false,\n    // used by abr-controller\n    maxStarvationDelay: 4,\n    // used by abr-controller\n    maxLoadingDelay: 4,\n    // used by abr-controller\n    minAutoBitrate: 0,\n    // used by hls\n    emeEnabled: false,\n    // used by eme-controller\n    widevineLicenseUrl: undefined,\n    // used by eme-controller\n    drmSystems: {},\n    // used by eme-controller\n    drmSystemOptions: {},\n    // used by eme-controller\n    requestMediaKeySystemAccessFunc: requestMediaKeySystemAccess,\n    // used by eme-controller\n    testBandwidth: true,\n    progressive: false,\n    lowLatencyMode: true,\n    cmcd: undefined,\n    enableDateRangeMetadataCues: true,\n    enableEmsgMetadataCues: true,\n    enableID3MetadataCues: true,\n    useMediaCapabilities: true,\n    certLoadPolicy: {\n        default: defaultLoadPolicy\n    },\n    keyLoadPolicy: {\n        default: {\n            maxTimeToFirstByteMs: 8000,\n            maxLoadTimeMs: 20000,\n            timeoutRetry: {\n                maxNumRetry: 1,\n                retryDelayMs: 1000,\n                maxRetryDelayMs: 20000,\n                backoff: \"linear\"\n            },\n            errorRetry: {\n                maxNumRetry: 8,\n                retryDelayMs: 1000,\n                maxRetryDelayMs: 20000,\n                backoff: \"linear\"\n            }\n        }\n    },\n    manifestLoadPolicy: {\n        default: {\n            maxTimeToFirstByteMs: Infinity,\n            maxLoadTimeMs: 20000,\n            timeoutRetry: {\n                maxNumRetry: 2,\n                retryDelayMs: 0,\n                maxRetryDelayMs: 0\n            },\n            errorRetry: {\n                maxNumRetry: 1,\n                retryDelayMs: 1000,\n                maxRetryDelayMs: 8000\n            }\n        }\n    },\n    playlistLoadPolicy: {\n        default: {\n            maxTimeToFirstByteMs: 10000,\n            maxLoadTimeMs: 20000,\n            timeoutRetry: {\n                maxNumRetry: 2,\n                retryDelayMs: 0,\n                maxRetryDelayMs: 0\n            },\n            errorRetry: {\n                maxNumRetry: 2,\n                retryDelayMs: 1000,\n                maxRetryDelayMs: 8000\n            }\n        }\n    },\n    fragLoadPolicy: {\n        default: {\n            maxTimeToFirstByteMs: 10000,\n            maxLoadTimeMs: 120000,\n            timeoutRetry: {\n                maxNumRetry: 4,\n                retryDelayMs: 0,\n                maxRetryDelayMs: 0\n            },\n            errorRetry: {\n                maxNumRetry: 6,\n                retryDelayMs: 1000,\n                maxRetryDelayMs: 8000\n            }\n        }\n    },\n    steeringManifestLoadPolicy: {\n        default: {\n            maxTimeToFirstByteMs: 10000,\n            maxLoadTimeMs: 20000,\n            timeoutRetry: {\n                maxNumRetry: 2,\n                retryDelayMs: 0,\n                maxRetryDelayMs: 0\n            },\n            errorRetry: {\n                maxNumRetry: 1,\n                retryDelayMs: 1000,\n                maxRetryDelayMs: 8000\n            }\n        }\n    },\n    // These default settings are deprecated in favor of the above policies\n    // and are maintained for backwards compatibility\n    manifestLoadingTimeOut: 10000,\n    manifestLoadingMaxRetry: 1,\n    manifestLoadingRetryDelay: 1000,\n    manifestLoadingMaxRetryTimeout: 64000,\n    levelLoadingTimeOut: 10000,\n    levelLoadingMaxRetry: 4,\n    levelLoadingRetryDelay: 1000,\n    levelLoadingMaxRetryTimeout: 64000,\n    fragLoadingTimeOut: 20000,\n    fragLoadingMaxRetry: 6,\n    fragLoadingRetryDelay: 1000,\n    fragLoadingMaxRetryTimeout: 64000\n}, timelineConfig()), {}, {\n    subtitleStreamController: SubtitleStreamController,\n    subtitleTrackController: SubtitleTrackController,\n    timelineController: TimelineController,\n    audioStreamController: AudioStreamController,\n    audioTrackController: AudioTrackController,\n    emeController: EMEController,\n    cmcdController: CMCDController,\n    contentSteeringController: ContentSteeringController\n});\nfunction timelineConfig() {\n    return {\n        cueHandler: Cues,\n        // used by timeline-controller\n        enableWebVTT: true,\n        // used by timeline-controller\n        enableIMSC1: true,\n        // used by timeline-controller\n        enableCEA708Captions: true,\n        // used by timeline-controller\n        captionsTextTrack1Label: \"English\",\n        // used by timeline-controller\n        captionsTextTrack1LanguageCode: \"en\",\n        // used by timeline-controller\n        captionsTextTrack2Label: \"Spanish\",\n        // used by timeline-controller\n        captionsTextTrack2LanguageCode: \"es\",\n        // used by timeline-controller\n        captionsTextTrack3Label: \"Unknown CC\",\n        // used by timeline-controller\n        captionsTextTrack3LanguageCode: \"\",\n        // used by timeline-controller\n        captionsTextTrack4Label: \"Unknown CC\",\n        // used by timeline-controller\n        captionsTextTrack4LanguageCode: \"\",\n        // used by timeline-controller\n        renderTextTracksNatively: true\n    };\n}\n/**\n * @ignore\n */ function mergeConfig(defaultConfig, userConfig) {\n    if ((userConfig.liveSyncDurationCount || userConfig.liveMaxLatencyDurationCount) && (userConfig.liveSyncDuration || userConfig.liveMaxLatencyDuration)) {\n        throw new Error(\"Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration\");\n    }\n    if (userConfig.liveMaxLatencyDurationCount !== undefined && (userConfig.liveSyncDurationCount === undefined || userConfig.liveMaxLatencyDurationCount <= userConfig.liveSyncDurationCount)) {\n        throw new Error('Illegal hls.js config: \"liveMaxLatencyDurationCount\" must be greater than \"liveSyncDurationCount\"');\n    }\n    if (userConfig.liveMaxLatencyDuration !== undefined && (userConfig.liveSyncDuration === undefined || userConfig.liveMaxLatencyDuration <= userConfig.liveSyncDuration)) {\n        throw new Error('Illegal hls.js config: \"liveMaxLatencyDuration\" must be greater than \"liveSyncDuration\"');\n    }\n    const defaultsCopy = deepCpy(defaultConfig);\n    // Backwards compatibility with deprecated config values\n    const deprecatedSettingTypes = [\n        \"manifest\",\n        \"level\",\n        \"frag\"\n    ];\n    const deprecatedSettings = [\n        \"TimeOut\",\n        \"MaxRetry\",\n        \"RetryDelay\",\n        \"MaxRetryTimeout\"\n    ];\n    deprecatedSettingTypes.forEach((type)=>{\n        const policyName = `${type === \"level\" ? \"playlist\" : type}LoadPolicy`;\n        const policyNotSet = userConfig[policyName] === undefined;\n        const report = [];\n        deprecatedSettings.forEach((setting)=>{\n            const deprecatedSetting = `${type}Loading${setting}`;\n            const value = userConfig[deprecatedSetting];\n            if (value !== undefined && policyNotSet) {\n                report.push(deprecatedSetting);\n                const settings = defaultsCopy[policyName].default;\n                userConfig[policyName] = {\n                    default: settings\n                };\n                switch(setting){\n                    case \"TimeOut\":\n                        settings.maxLoadTimeMs = value;\n                        settings.maxTimeToFirstByteMs = value;\n                        break;\n                    case \"MaxRetry\":\n                        settings.errorRetry.maxNumRetry = value;\n                        settings.timeoutRetry.maxNumRetry = value;\n                        break;\n                    case \"RetryDelay\":\n                        settings.errorRetry.retryDelayMs = value;\n                        settings.timeoutRetry.retryDelayMs = value;\n                        break;\n                    case \"MaxRetryTimeout\":\n                        settings.errorRetry.maxRetryDelayMs = value;\n                        settings.timeoutRetry.maxRetryDelayMs = value;\n                        break;\n                }\n            }\n        });\n        if (report.length) {\n            logger.warn(`hls.js config: \"${report.join('\", \"')}\" setting(s) are deprecated, use \"${policyName}\": ${JSON.stringify(userConfig[policyName])}`);\n        }\n    });\n    return _objectSpread2(_objectSpread2({}, defaultsCopy), userConfig);\n}\nfunction deepCpy(obj) {\n    if (obj && typeof obj === \"object\") {\n        if (Array.isArray(obj)) {\n            return obj.map(deepCpy);\n        }\n        return Object.keys(obj).reduce((result, key)=>{\n            result[key] = deepCpy(obj[key]);\n            return result;\n        }, {});\n    }\n    return obj;\n}\n/**\n * @ignore\n */ function enableStreamingMode(config) {\n    const currentLoader = config.loader;\n    if (currentLoader !== FetchLoader && currentLoader !== XhrLoader) {\n        // If a developer has configured their own loader, respect that choice\n        logger.log(\"[config]: Custom loader detected, cannot enable progressive streaming\");\n        config.progressive = false;\n    } else {\n        const canStreamProgressively = fetchSupported();\n        if (canStreamProgressively) {\n            config.loader = FetchLoader;\n            config.progressive = true;\n            config.enableSoftwareAES = true;\n            logger.log(\"[config]: Progressive streaming enabled, using FetchLoader\");\n        }\n    }\n}\nlet chromeOrFirefox;\nclass LevelController extends BasePlaylistController {\n    constructor(hls, contentSteeringController){\n        super(hls, \"[level-controller]\");\n        this._levels = [];\n        this._firstLevel = -1;\n        this._maxAutoLevel = -1;\n        this._startLevel = void 0;\n        this.currentLevel = null;\n        this.currentLevelIndex = -1;\n        this.manualLevelIndex = -1;\n        this.steering = void 0;\n        this.onParsedComplete = void 0;\n        this.steering = contentSteeringController;\n        this._registerListeners();\n    }\n    _registerListeners() {\n        const { hls } = this;\n        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n        hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n        hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n        hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n        hls.on(Events.ERROR, this.onError, this);\n    }\n    _unregisterListeners() {\n        const { hls } = this;\n        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n        hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n        hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n        hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n        hls.off(Events.ERROR, this.onError, this);\n    }\n    destroy() {\n        this._unregisterListeners();\n        this.steering = null;\n        this.resetLevels();\n        super.destroy();\n    }\n    stopLoad() {\n        const levels = this._levels;\n        // clean up live level details to force reload them, and reset load errors\n        levels.forEach((level)=>{\n            level.loadError = 0;\n            level.fragmentError = 0;\n        });\n        super.stopLoad();\n    }\n    resetLevels() {\n        this._startLevel = undefined;\n        this.manualLevelIndex = -1;\n        this.currentLevelIndex = -1;\n        this.currentLevel = null;\n        this._levels = [];\n        this._maxAutoLevel = -1;\n    }\n    onManifestLoading(event, data) {\n        this.resetLevels();\n    }\n    onManifestLoaded(event, data) {\n        const preferManagedMediaSource = this.hls.config.preferManagedMediaSource;\n        const levels = [];\n        const redundantSet = {};\n        const generatePathwaySet = {};\n        let resolutionFound = false;\n        let videoCodecFound = false;\n        let audioCodecFound = false;\n        data.levels.forEach((levelParsed)=>{\n            var _audioCodec, _videoCodec;\n            const attributes = levelParsed.attrs;\n            // erase audio codec info if browser does not support mp4a.40.34.\n            // demuxer will autodetect codec and fallback to mpeg/audio\n            let { audioCodec, videoCodec } = levelParsed;\n            if (((_audioCodec = audioCodec) == null ? void 0 : _audioCodec.indexOf(\"mp4a.40.34\")) !== -1) {\n                chromeOrFirefox || (chromeOrFirefox = /chrome|firefox/i.test(navigator.userAgent));\n                if (chromeOrFirefox) {\n                    levelParsed.audioCodec = audioCodec = undefined;\n                }\n            }\n            if (audioCodec) {\n                levelParsed.audioCodec = audioCodec = getCodecCompatibleName(audioCodec, preferManagedMediaSource);\n            }\n            if (((_videoCodec = videoCodec) == null ? void 0 : _videoCodec.indexOf(\"avc1\")) === 0) {\n                videoCodec = levelParsed.videoCodec = convertAVC1ToAVCOTI(videoCodec);\n            }\n            // only keep levels with supported audio/video codecs\n            const { width, height, unknownCodecs } = levelParsed;\n            resolutionFound || (resolutionFound = !!(width && height));\n            videoCodecFound || (videoCodecFound = !!videoCodec);\n            audioCodecFound || (audioCodecFound = !!audioCodec);\n            if (unknownCodecs != null && unknownCodecs.length || audioCodec && !areCodecsMediaSourceSupported(audioCodec, \"audio\", preferManagedMediaSource) || videoCodec && !areCodecsMediaSourceSupported(videoCodec, \"video\", preferManagedMediaSource)) {\n                return;\n            }\n            const { CODECS, \"FRAME-RATE\": FRAMERATE, \"HDCP-LEVEL\": HDCP, \"PATHWAY-ID\": PATHWAY, RESOLUTION, \"VIDEO-RANGE\": VIDEO_RANGE } = attributes;\n            const contentSteeringPrefix = `${PATHWAY || \".\"}-`;\n            const levelKey = `${contentSteeringPrefix}${levelParsed.bitrate}-${RESOLUTION}-${FRAMERATE}-${CODECS}-${VIDEO_RANGE}-${HDCP}`;\n            if (!redundantSet[levelKey]) {\n                const level = new Level(levelParsed);\n                redundantSet[levelKey] = level;\n                generatePathwaySet[levelKey] = 1;\n                levels.push(level);\n            } else if (redundantSet[levelKey].uri !== levelParsed.url && !levelParsed.attrs[\"PATHWAY-ID\"]) {\n                // Assign Pathway IDs to Redundant Streams (default Pathways is \".\". Redundant Streams \"..\", \"...\", and so on.)\n                // Content Steering controller to handles Pathway fallback on error\n                const pathwayCount = generatePathwaySet[levelKey] += 1;\n                levelParsed.attrs[\"PATHWAY-ID\"] = new Array(pathwayCount + 1).join(\".\");\n                const level = new Level(levelParsed);\n                redundantSet[levelKey] = level;\n                levels.push(level);\n            } else {\n                redundantSet[levelKey].addGroupId(\"audio\", attributes.AUDIO);\n                redundantSet[levelKey].addGroupId(\"text\", attributes.SUBTITLES);\n            }\n        });\n        this.filterAndSortMediaOptions(levels, data, resolutionFound, videoCodecFound, audioCodecFound);\n    }\n    filterAndSortMediaOptions(filteredLevels, data, resolutionFound, videoCodecFound, audioCodecFound) {\n        let audioTracks = [];\n        let subtitleTracks = [];\n        let levels = filteredLevels;\n        // remove audio-only and invalid video-range levels if we also have levels with video codecs or RESOLUTION signalled\n        if ((resolutionFound || videoCodecFound) && audioCodecFound) {\n            levels = levels.filter(({ videoCodec, videoRange, width, height })=>(!!videoCodec || !!(width && height)) && isVideoRange(videoRange));\n        }\n        if (levels.length === 0) {\n            // Dispatch error after MANIFEST_LOADED is done propagating\n            Promise.resolve().then(()=>{\n                if (this.hls) {\n                    if (data.levels.length) {\n                        this.warn(`One or more CODECS in variant not supported: ${JSON.stringify(data.levels[0].attrs)}`);\n                    }\n                    const error = new Error(\"no level with compatible codecs found in manifest\");\n                    this.hls.trigger(Events.ERROR, {\n                        type: ErrorTypes.MEDIA_ERROR,\n                        details: ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR,\n                        fatal: true,\n                        url: data.url,\n                        error,\n                        reason: error.message\n                    });\n                }\n            });\n            return;\n        }\n        if (data.audioTracks) {\n            const { preferManagedMediaSource } = this.hls.config;\n            audioTracks = data.audioTracks.filter((track)=>!track.audioCodec || areCodecsMediaSourceSupported(track.audioCodec, \"audio\", preferManagedMediaSource));\n            // Assign ids after filtering as array indices by group-id\n            assignTrackIdsByGroup(audioTracks);\n        }\n        if (data.subtitles) {\n            subtitleTracks = data.subtitles;\n            assignTrackIdsByGroup(subtitleTracks);\n        }\n        // start bitrate is the first bitrate of the manifest\n        const unsortedLevels = levels.slice(0);\n        // sort levels from lowest to highest\n        levels.sort((a, b)=>{\n            if (a.attrs[\"HDCP-LEVEL\"] !== b.attrs[\"HDCP-LEVEL\"]) {\n                return (a.attrs[\"HDCP-LEVEL\"] || \"\") > (b.attrs[\"HDCP-LEVEL\"] || \"\") ? 1 : -1;\n            }\n            // sort on height before bitrate for cap-level-controller\n            if (resolutionFound && a.height !== b.height) {\n                return a.height - b.height;\n            }\n            if (a.frameRate !== b.frameRate) {\n                return a.frameRate - b.frameRate;\n            }\n            if (a.videoRange !== b.videoRange) {\n                return VideoRangeValues.indexOf(a.videoRange) - VideoRangeValues.indexOf(b.videoRange);\n            }\n            if (a.videoCodec !== b.videoCodec) {\n                const valueA = videoCodecPreferenceValue(a.videoCodec);\n                const valueB = videoCodecPreferenceValue(b.videoCodec);\n                if (valueA !== valueB) {\n                    return valueB - valueA;\n                }\n            }\n            if (a.uri === b.uri && a.codecSet !== b.codecSet) {\n                const valueA = codecsSetSelectionPreferenceValue(a.codecSet);\n                const valueB = codecsSetSelectionPreferenceValue(b.codecSet);\n                if (valueA !== valueB) {\n                    return valueB - valueA;\n                }\n            }\n            if (a.averageBitrate !== b.averageBitrate) {\n                return a.averageBitrate - b.averageBitrate;\n            }\n            return 0;\n        });\n        let firstLevelInPlaylist = unsortedLevels[0];\n        if (this.steering) {\n            levels = this.steering.filterParsedLevels(levels);\n            if (levels.length !== unsortedLevels.length) {\n                for(let i = 0; i < unsortedLevels.length; i++){\n                    if (unsortedLevels[i].pathwayId === levels[0].pathwayId) {\n                        firstLevelInPlaylist = unsortedLevels[i];\n                        break;\n                    }\n                }\n            }\n        }\n        this._levels = levels;\n        // find index of first level in sorted levels\n        for(let i = 0; i < levels.length; i++){\n            if (levels[i] === firstLevelInPlaylist) {\n                var _this$hls$userConfig;\n                this._firstLevel = i;\n                const firstLevelBitrate = firstLevelInPlaylist.bitrate;\n                const bandwidthEstimate = this.hls.bandwidthEstimate;\n                this.log(`manifest loaded, ${levels.length} level(s) found, first bitrate: ${firstLevelBitrate}`);\n                // Update default bwe to first variant bitrate as long it has not been configured or set\n                if (((_this$hls$userConfig = this.hls.userConfig) == null ? void 0 : _this$hls$userConfig.abrEwmaDefaultEstimate) === undefined) {\n                    const startingBwEstimate = Math.min(firstLevelBitrate, this.hls.config.abrEwmaDefaultEstimateMax);\n                    if (startingBwEstimate > bandwidthEstimate && bandwidthEstimate === hlsDefaultConfig.abrEwmaDefaultEstimate) {\n                        this.hls.bandwidthEstimate = startingBwEstimate;\n                    }\n                }\n                break;\n            }\n        }\n        // Audio is only alternate if manifest include a URI along with the audio group tag,\n        // and this is not an audio-only stream where levels contain audio-only\n        const audioOnly = audioCodecFound && !videoCodecFound;\n        const edata = {\n            levels,\n            audioTracks,\n            subtitleTracks,\n            sessionData: data.sessionData,\n            sessionKeys: data.sessionKeys,\n            firstLevel: this._firstLevel,\n            stats: data.stats,\n            audio: audioCodecFound,\n            video: videoCodecFound,\n            altAudio: !audioOnly && audioTracks.some((t)=>!!t.url)\n        };\n        this.hls.trigger(Events.MANIFEST_PARSED, edata);\n        // Initiate loading after all controllers have received MANIFEST_PARSED\n        if (this.hls.config.autoStartLoad || this.hls.forceStartLoad) {\n            this.hls.startLoad(this.hls.config.startPosition);\n        }\n    }\n    get levels() {\n        if (this._levels.length === 0) {\n            return null;\n        }\n        return this._levels;\n    }\n    get level() {\n        return this.currentLevelIndex;\n    }\n    set level(newLevel) {\n        const levels = this._levels;\n        if (levels.length === 0) {\n            return;\n        }\n        // check if level idx is valid\n        if (newLevel < 0 || newLevel >= levels.length) {\n            // invalid level id given, trigger error\n            const error = new Error(\"invalid level idx\");\n            const fatal = newLevel < 0;\n            this.hls.trigger(Events.ERROR, {\n                type: ErrorTypes.OTHER_ERROR,\n                details: ErrorDetails.LEVEL_SWITCH_ERROR,\n                level: newLevel,\n                fatal,\n                error,\n                reason: error.message\n            });\n            if (fatal) {\n                return;\n            }\n            newLevel = Math.min(newLevel, levels.length - 1);\n        }\n        const lastLevelIndex = this.currentLevelIndex;\n        const lastLevel = this.currentLevel;\n        const lastPathwayId = lastLevel ? lastLevel.attrs[\"PATHWAY-ID\"] : undefined;\n        const level = levels[newLevel];\n        const pathwayId = level.attrs[\"PATHWAY-ID\"];\n        this.currentLevelIndex = newLevel;\n        this.currentLevel = level;\n        if (lastLevelIndex === newLevel && level.details && lastLevel && lastPathwayId === pathwayId) {\n            return;\n        }\n        this.log(`Switching to level ${newLevel} (${level.height ? level.height + \"p \" : \"\"}${level.videoRange ? level.videoRange + \" \" : \"\"}${level.codecSet ? level.codecSet + \" \" : \"\"}@${level.bitrate})${pathwayId ? \" with Pathway \" + pathwayId : \"\"} from level ${lastLevelIndex}${lastPathwayId ? \" with Pathway \" + lastPathwayId : \"\"}`);\n        const levelSwitchingData = {\n            level: newLevel,\n            attrs: level.attrs,\n            details: level.details,\n            bitrate: level.bitrate,\n            averageBitrate: level.averageBitrate,\n            maxBitrate: level.maxBitrate,\n            realBitrate: level.realBitrate,\n            width: level.width,\n            height: level.height,\n            codecSet: level.codecSet,\n            audioCodec: level.audioCodec,\n            videoCodec: level.videoCodec,\n            audioGroups: level.audioGroups,\n            subtitleGroups: level.subtitleGroups,\n            loaded: level.loaded,\n            loadError: level.loadError,\n            fragmentError: level.fragmentError,\n            name: level.name,\n            id: level.id,\n            uri: level.uri,\n            url: level.url,\n            urlId: 0,\n            audioGroupIds: level.audioGroupIds,\n            textGroupIds: level.textGroupIds\n        };\n        this.hls.trigger(Events.LEVEL_SWITCHING, levelSwitchingData);\n        // check if we need to load playlist for this level\n        const levelDetails = level.details;\n        if (!levelDetails || levelDetails.live) {\n            // level not retrieved yet, or live playlist we need to (re)load it\n            const hlsUrlParameters = this.switchParams(level.uri, lastLevel == null ? void 0 : lastLevel.details);\n            this.loadPlaylist(hlsUrlParameters);\n        }\n    }\n    get manualLevel() {\n        return this.manualLevelIndex;\n    }\n    set manualLevel(newLevel) {\n        this.manualLevelIndex = newLevel;\n        if (this._startLevel === undefined) {\n            this._startLevel = newLevel;\n        }\n        if (newLevel !== -1) {\n            this.level = newLevel;\n        }\n    }\n    get firstLevel() {\n        return this._firstLevel;\n    }\n    set firstLevel(newLevel) {\n        this._firstLevel = newLevel;\n    }\n    get startLevel() {\n        // Setting hls.startLevel (this._startLevel) overrides config.startLevel\n        if (this._startLevel === undefined) {\n            const configStartLevel = this.hls.config.startLevel;\n            if (configStartLevel !== undefined) {\n                return configStartLevel;\n            }\n            return this.hls.firstAutoLevel;\n        }\n        return this._startLevel;\n    }\n    set startLevel(newLevel) {\n        this._startLevel = newLevel;\n    }\n    onError(event, data) {\n        if (data.fatal || !data.context) {\n            return;\n        }\n        if (data.context.type === PlaylistContextType.LEVEL && data.context.level === this.level) {\n            this.checkRetry(data);\n        }\n    }\n    // reset errors on the successful load of a fragment\n    onFragBuffered(event, { frag }) {\n        if (frag !== undefined && frag.type === PlaylistLevelType.MAIN) {\n            const el = frag.elementaryStreams;\n            if (!Object.keys(el).some((type)=>!!el[type])) {\n                return;\n            }\n            const level = this._levels[frag.level];\n            if (level != null && level.loadError) {\n                this.log(`Resetting level error count of ${level.loadError} on frag buffered`);\n                level.loadError = 0;\n            }\n        }\n    }\n    onLevelLoaded(event, data) {\n        var _data$deliveryDirecti2;\n        const { level, details } = data;\n        const curLevel = this._levels[level];\n        if (!curLevel) {\n            var _data$deliveryDirecti;\n            this.warn(`Invalid level index ${level}`);\n            if ((_data$deliveryDirecti = data.deliveryDirectives) != null && _data$deliveryDirecti.skip) {\n                details.deltaUpdateFailed = true;\n            }\n            return;\n        }\n        // only process level loaded events matching with expected level\n        if (level === this.currentLevelIndex) {\n            // reset level load error counter on successful level loaded only if there is no issues with fragments\n            if (curLevel.fragmentError === 0) {\n                curLevel.loadError = 0;\n            }\n            this.playlistLoaded(level, data, curLevel.details);\n        } else if ((_data$deliveryDirecti2 = data.deliveryDirectives) != null && _data$deliveryDirecti2.skip) {\n            // received a delta playlist update that cannot be merged\n            details.deltaUpdateFailed = true;\n        }\n    }\n    loadPlaylist(hlsUrlParameters) {\n        super.loadPlaylist();\n        const currentLevelIndex = this.currentLevelIndex;\n        const currentLevel = this.currentLevel;\n        if (currentLevel && this.shouldLoadPlaylist(currentLevel)) {\n            let url = currentLevel.uri;\n            if (hlsUrlParameters) {\n                try {\n                    url = hlsUrlParameters.addDirectives(url);\n                } catch (error) {\n                    this.warn(`Could not construct new URL with HLS Delivery Directives: ${error}`);\n                }\n            }\n            const pathwayId = currentLevel.attrs[\"PATHWAY-ID\"];\n            this.log(`Loading level index ${currentLevelIndex}${(hlsUrlParameters == null ? void 0 : hlsUrlParameters.msn) !== undefined ? \" at sn \" + hlsUrlParameters.msn + \" part \" + hlsUrlParameters.part : \"\"} with${pathwayId ? \" Pathway \" + pathwayId : \"\"} ${url}`);\n            // console.log('Current audio track group ID:', this.hls.audioTracks[this.hls.audioTrack].groupId);\n            // console.log('New video quality level audio group id:', levelObject.attrs.AUDIO, level);\n            this.clearTimer();\n            this.hls.trigger(Events.LEVEL_LOADING, {\n                url,\n                level: currentLevelIndex,\n                pathwayId: currentLevel.attrs[\"PATHWAY-ID\"],\n                id: 0,\n                // Deprecated Level urlId\n                deliveryDirectives: hlsUrlParameters || null\n            });\n        }\n    }\n    get nextLoadLevel() {\n        if (this.manualLevelIndex !== -1) {\n            return this.manualLevelIndex;\n        } else {\n            return this.hls.nextAutoLevel;\n        }\n    }\n    set nextLoadLevel(nextLevel) {\n        this.level = nextLevel;\n        if (this.manualLevelIndex === -1) {\n            this.hls.nextAutoLevel = nextLevel;\n        }\n    }\n    removeLevel(levelIndex) {\n        var _this$currentLevel;\n        const levels = this._levels.filter((level, index)=>{\n            if (index !== levelIndex) {\n                return true;\n            }\n            if (this.steering) {\n                this.steering.removeLevel(level);\n            }\n            if (level === this.currentLevel) {\n                this.currentLevel = null;\n                this.currentLevelIndex = -1;\n                if (level.details) {\n                    level.details.fragments.forEach((f)=>f.level = -1);\n                }\n            }\n            return false;\n        });\n        reassignFragmentLevelIndexes(levels);\n        this._levels = levels;\n        if (this.currentLevelIndex > -1 && (_this$currentLevel = this.currentLevel) != null && _this$currentLevel.details) {\n            this.currentLevelIndex = this.currentLevel.details.fragments[0].level;\n        }\n        this.hls.trigger(Events.LEVELS_UPDATED, {\n            levels\n        });\n    }\n    onLevelsUpdated(event, { levels }) {\n        this._levels = levels;\n    }\n    checkMaxAutoUpdated() {\n        const { autoLevelCapping, maxAutoLevel, maxHdcpLevel } = this.hls;\n        if (this._maxAutoLevel !== maxAutoLevel) {\n            this._maxAutoLevel = maxAutoLevel;\n            this.hls.trigger(Events.MAX_AUTO_LEVEL_UPDATED, {\n                autoLevelCapping,\n                levels: this.levels,\n                maxAutoLevel,\n                minAutoLevel: this.hls.minAutoLevel,\n                maxHdcpLevel\n            });\n        }\n    }\n}\nfunction assignTrackIdsByGroup(tracks) {\n    const groups = {};\n    tracks.forEach((track)=>{\n        const groupId = track.groupId || \"\";\n        track.id = groups[groupId] = groups[groupId] || 0;\n        groups[groupId]++;\n    });\n}\nclass KeyLoader {\n    constructor(config){\n        this.config = void 0;\n        this.keyUriToKeyInfo = {};\n        this.emeController = null;\n        this.config = config;\n    }\n    abort(type) {\n        for(const uri in this.keyUriToKeyInfo){\n            const loader = this.keyUriToKeyInfo[uri].loader;\n            if (loader) {\n                var _loader$context;\n                if (type && type !== ((_loader$context = loader.context) == null ? void 0 : _loader$context.frag.type)) {\n                    return;\n                }\n                loader.abort();\n            }\n        }\n    }\n    detach() {\n        for(const uri in this.keyUriToKeyInfo){\n            const keyInfo = this.keyUriToKeyInfo[uri];\n            // Remove cached EME keys on detach\n            if (keyInfo.mediaKeySessionContext || keyInfo.decryptdata.isCommonEncryption) {\n                delete this.keyUriToKeyInfo[uri];\n            }\n        }\n    }\n    destroy() {\n        this.detach();\n        for(const uri in this.keyUriToKeyInfo){\n            const loader = this.keyUriToKeyInfo[uri].loader;\n            if (loader) {\n                loader.destroy();\n            }\n        }\n        this.keyUriToKeyInfo = {};\n    }\n    createKeyLoadError(frag, details = ErrorDetails.KEY_LOAD_ERROR, error, networkDetails, response) {\n        return new LoadError({\n            type: ErrorTypes.NETWORK_ERROR,\n            details,\n            fatal: false,\n            frag,\n            response,\n            error,\n            networkDetails\n        });\n    }\n    loadClear(loadingFrag, encryptedFragments) {\n        if (this.emeController && this.config.emeEnabled) {\n            // access key-system with nearest key on start (loaidng frag is unencrypted)\n            const { sn, cc } = loadingFrag;\n            for(let i = 0; i < encryptedFragments.length; i++){\n                const frag = encryptedFragments[i];\n                if (cc <= frag.cc && (sn === \"initSegment\" || frag.sn === \"initSegment\" || sn < frag.sn)) {\n                    this.emeController.selectKeySystemFormat(frag).then((keySystemFormat)=>{\n                        frag.setKeyFormat(keySystemFormat);\n                    });\n                    break;\n                }\n            }\n        }\n    }\n    load(frag) {\n        if (!frag.decryptdata && frag.encrypted && this.emeController) {\n            // Multiple keys, but none selected, resolve in eme-controller\n            return this.emeController.selectKeySystemFormat(frag).then((keySystemFormat)=>{\n                return this.loadInternal(frag, keySystemFormat);\n            });\n        }\n        return this.loadInternal(frag);\n    }\n    loadInternal(frag, keySystemFormat) {\n        var _keyInfo, _keyInfo2;\n        if (keySystemFormat) {\n            frag.setKeyFormat(keySystemFormat);\n        }\n        const decryptdata = frag.decryptdata;\n        if (!decryptdata) {\n            const error = new Error(keySystemFormat ? `Expected frag.decryptdata to be defined after setting format ${keySystemFormat}` : \"Missing decryption data on fragment in onKeyLoading\");\n            return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, error));\n        }\n        const uri = decryptdata.uri;\n        if (!uri) {\n            return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(`Invalid key URI: \"${uri}\"`)));\n        }\n        let keyInfo = this.keyUriToKeyInfo[uri];\n        if ((_keyInfo = keyInfo) != null && _keyInfo.decryptdata.key) {\n            decryptdata.key = keyInfo.decryptdata.key;\n            return Promise.resolve({\n                frag,\n                keyInfo\n            });\n        }\n        // Return key load promise as long as it does not have a mediakey session with an unusable key status\n        if ((_keyInfo2 = keyInfo) != null && _keyInfo2.keyLoadPromise) {\n            var _keyInfo$mediaKeySess;\n            switch((_keyInfo$mediaKeySess = keyInfo.mediaKeySessionContext) == null ? void 0 : _keyInfo$mediaKeySess.keyStatus){\n                case undefined:\n                case \"status-pending\":\n                case \"usable\":\n                case \"usable-in-future\":\n                    return keyInfo.keyLoadPromise.then((keyLoadedData)=>{\n                        // Return the correct fragment with updated decryptdata key and loaded keyInfo\n                        decryptdata.key = keyLoadedData.keyInfo.decryptdata.key;\n                        return {\n                            frag,\n                            keyInfo\n                        };\n                    });\n            }\n        // If we have a key session and status and it is not pending or usable, continue\n        // This will go back to the eme-controller for expired keys to get a new keyLoadPromise\n        }\n        // Load the key or return the loading promise\n        keyInfo = this.keyUriToKeyInfo[uri] = {\n            decryptdata,\n            keyLoadPromise: null,\n            loader: null,\n            mediaKeySessionContext: null\n        };\n        switch(decryptdata.method){\n            case \"ISO-23001-7\":\n            case \"SAMPLE-AES\":\n            case \"SAMPLE-AES-CENC\":\n            case \"SAMPLE-AES-CTR\":\n                if (decryptdata.keyFormat === \"identity\") {\n                    // loadKeyHTTP handles http(s) and data URLs\n                    return this.loadKeyHTTP(keyInfo, frag);\n                }\n                return this.loadKeyEME(keyInfo, frag);\n            case \"AES-128\":\n                return this.loadKeyHTTP(keyInfo, frag);\n            default:\n                return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(`Key supplied with unsupported METHOD: \"${decryptdata.method}\"`)));\n        }\n    }\n    loadKeyEME(keyInfo, frag) {\n        const keyLoadedData = {\n            frag,\n            keyInfo\n        };\n        if (this.emeController && this.config.emeEnabled) {\n            const keySessionContextPromise = this.emeController.loadKey(keyLoadedData);\n            if (keySessionContextPromise) {\n                return (keyInfo.keyLoadPromise = keySessionContextPromise.then((keySessionContext)=>{\n                    keyInfo.mediaKeySessionContext = keySessionContext;\n                    return keyLoadedData;\n                })).catch((error)=>{\n                    // Remove promise for license renewal or retry\n                    keyInfo.keyLoadPromise = null;\n                    throw error;\n                });\n            }\n        }\n        return Promise.resolve(keyLoadedData);\n    }\n    loadKeyHTTP(keyInfo, frag) {\n        const config = this.config;\n        const Loader = config.loader;\n        const keyLoader = new Loader(config);\n        frag.keyLoader = keyInfo.loader = keyLoader;\n        return keyInfo.keyLoadPromise = new Promise((resolve, reject)=>{\n            const loaderContext = {\n                keyInfo,\n                frag,\n                responseType: \"arraybuffer\",\n                url: keyInfo.decryptdata.uri\n            };\n            // maxRetry is 0 so that instead of retrying the same key on the same variant multiple times,\n            // key-loader will trigger an error and rely on stream-controller to handle retry logic.\n            // this will also align retry logic with fragment-loader\n            const loadPolicy = config.keyLoadPolicy.default;\n            const loaderConfig = {\n                loadPolicy,\n                timeout: loadPolicy.maxLoadTimeMs,\n                maxRetry: 0,\n                retryDelay: 0,\n                maxRetryDelay: 0\n            };\n            const loaderCallbacks = {\n                onSuccess: (response, stats, context, networkDetails)=>{\n                    const { frag, keyInfo, url: uri } = context;\n                    if (!frag.decryptdata || keyInfo !== this.keyUriToKeyInfo[uri]) {\n                        return reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(\"after key load, decryptdata unset or changed\"), networkDetails));\n                    }\n                    keyInfo.decryptdata.key = frag.decryptdata.key = new Uint8Array(response.data);\n                    // detach fragment key loader on load success\n                    frag.keyLoader = null;\n                    keyInfo.loader = null;\n                    resolve({\n                        frag,\n                        keyInfo\n                    });\n                },\n                onError: (response, context, networkDetails, stats)=>{\n                    this.resetLoader(context);\n                    reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(`HTTP Error ${response.code} loading key ${response.text}`), networkDetails, _objectSpread2({\n                        url: loaderContext.url,\n                        data: undefined\n                    }, response)));\n                },\n                onTimeout: (stats, context, networkDetails)=>{\n                    this.resetLoader(context);\n                    reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_TIMEOUT, new Error(\"key loading timed out\"), networkDetails));\n                },\n                onAbort: (stats, context, networkDetails)=>{\n                    this.resetLoader(context);\n                    reject(this.createKeyLoadError(frag, ErrorDetails.INTERNAL_ABORTED, new Error(\"key loading aborted\"), networkDetails));\n                }\n            };\n            keyLoader.load(loaderContext, loaderConfig, loaderCallbacks);\n        });\n    }\n    resetLoader(context) {\n        const { frag, keyInfo, url: uri } = context;\n        const loader = keyInfo.loader;\n        if (frag.keyLoader === loader) {\n            frag.keyLoader = null;\n            keyInfo.loader = null;\n        }\n        delete this.keyUriToKeyInfo[uri];\n        if (loader) {\n            loader.destroy();\n        }\n    }\n}\nfunction getSourceBuffer() {\n    return self.SourceBuffer || self.WebKitSourceBuffer;\n}\nfunction isMSESupported() {\n    const mediaSource = getMediaSource();\n    if (!mediaSource) {\n        return false;\n    }\n    // if SourceBuffer is exposed ensure its API is valid\n    // Older browsers do not expose SourceBuffer globally so checking SourceBuffer.prototype is impossible\n    const sourceBuffer = getSourceBuffer();\n    return !sourceBuffer || sourceBuffer.prototype && typeof sourceBuffer.prototype.appendBuffer === \"function\" && typeof sourceBuffer.prototype.remove === \"function\";\n}\nfunction isSupported() {\n    if (!isMSESupported()) {\n        return false;\n    }\n    const mediaSource = getMediaSource();\n    return typeof (mediaSource == null ? void 0 : mediaSource.isTypeSupported) === \"function\" && ([\n        \"avc1.42E01E,mp4a.40.2\",\n        \"av01.0.01M.08\",\n        \"vp09.00.50.08\"\n    ].some((codecsForVideoContainer)=>mediaSource.isTypeSupported(mimeTypeForCodec(codecsForVideoContainer, \"video\"))) || [\n        \"mp4a.40.2\",\n        \"fLaC\"\n    ].some((codecForAudioContainer)=>mediaSource.isTypeSupported(mimeTypeForCodec(codecForAudioContainer, \"audio\"))));\n}\nfunction changeTypeSupported() {\n    var _sourceBuffer$prototy;\n    const sourceBuffer = getSourceBuffer();\n    return typeof (sourceBuffer == null ? void 0 : (_sourceBuffer$prototy = sourceBuffer.prototype) == null ? void 0 : _sourceBuffer$prototy.changeType) === \"function\";\n}\nconst STALL_MINIMUM_DURATION_MS = 250;\nconst MAX_START_GAP_JUMP = 2.0;\nconst SKIP_BUFFER_HOLE_STEP_SECONDS = 0.1;\nconst SKIP_BUFFER_RANGE_START = 0.05;\nclass GapController {\n    constructor(config, media, fragmentTracker, hls){\n        this.config = void 0;\n        this.media = null;\n        this.fragmentTracker = void 0;\n        this.hls = void 0;\n        this.nudgeRetry = 0;\n        this.stallReported = false;\n        this.stalled = null;\n        this.moved = false;\n        this.seeking = false;\n        this.config = config;\n        this.media = media;\n        this.fragmentTracker = fragmentTracker;\n        this.hls = hls;\n    }\n    destroy() {\n        this.media = null;\n        // @ts-ignore\n        this.hls = this.fragmentTracker = null;\n    }\n    /**\n   * Checks if the playhead is stuck within a gap, and if so, attempts to free it.\n   * A gap is an unbuffered range between two buffered ranges (or the start and the first buffered range).\n   *\n   * @param lastCurrentTime - Previously read playhead position\n   */ poll(lastCurrentTime, activeFrag) {\n        const { config, media, stalled } = this;\n        if (media === null) {\n            return;\n        }\n        const { currentTime, seeking } = media;\n        const seeked = this.seeking && !seeking;\n        const beginSeek = !this.seeking && seeking;\n        this.seeking = seeking;\n        // The playhead is moving, no-op\n        if (currentTime !== lastCurrentTime) {\n            this.moved = true;\n            if (!seeking) {\n                this.nudgeRetry = 0;\n            }\n            if (stalled !== null) {\n                // The playhead is now moving, but was previously stalled\n                if (this.stallReported) {\n                    const _stalledDuration = self.performance.now() - stalled;\n                    logger.warn(`playback not stuck anymore @${currentTime}, after ${Math.round(_stalledDuration)}ms`);\n                    this.stallReported = false;\n                }\n                this.stalled = null;\n            }\n            return;\n        }\n        // Clear stalled state when beginning or finishing seeking so that we don't report stalls coming out of a seek\n        if (beginSeek || seeked) {\n            this.stalled = null;\n            return;\n        }\n        // The playhead should not be moving\n        if (media.paused && !seeking || media.ended || media.playbackRate === 0 || !BufferHelper.getBuffered(media).length) {\n            this.nudgeRetry = 0;\n            return;\n        }\n        const bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);\n        const nextStart = bufferInfo.nextStart || 0;\n        if (seeking) {\n            // Waiting for seeking in a buffered range to complete\n            const hasEnoughBuffer = bufferInfo.len > MAX_START_GAP_JUMP;\n            // Next buffered range is too far ahead to jump to while still seeking\n            const noBufferGap = !nextStart || activeFrag && activeFrag.start <= currentTime || nextStart - currentTime > MAX_START_GAP_JUMP && !this.fragmentTracker.getPartialFragment(currentTime);\n            if (hasEnoughBuffer || noBufferGap) {\n                return;\n            }\n            // Reset moved state when seeking to a point in or before a gap\n            this.moved = false;\n        }\n        // Skip start gaps if we haven't played, but the last poll detected the start of a stall\n        // The addition poll gives the browser a chance to jump the gap for us\n        if (!this.moved && this.stalled !== null) {\n            var _level$details;\n            // There is no playable buffer (seeked, waiting for buffer)\n            const isBuffered = bufferInfo.len > 0;\n            if (!isBuffered && !nextStart) {\n                return;\n            }\n            // Jump start gaps within jump threshold\n            const startJump = Math.max(nextStart, bufferInfo.start || 0) - currentTime;\n            // When joining a live stream with audio tracks, account for live playlist window sliding by allowing\n            // a larger jump over start gaps caused by the audio-stream-controller buffering a start fragment\n            // that begins over 1 target duration after the video start position.\n            const level = this.hls.levels ? this.hls.levels[this.hls.currentLevel] : null;\n            const isLive = level == null ? void 0 : (_level$details = level.details) == null ? void 0 : _level$details.live;\n            const maxStartGapJump = isLive ? level.details.targetduration * 2 : MAX_START_GAP_JUMP;\n            const partialOrGap = this.fragmentTracker.getPartialFragment(currentTime);\n            if (startJump > 0 && (startJump <= maxStartGapJump || partialOrGap)) {\n                if (!media.paused) {\n                    this._trySkipBufferHole(partialOrGap);\n                }\n                return;\n            }\n        }\n        // Start tracking stall time\n        const tnow = self.performance.now();\n        if (stalled === null) {\n            this.stalled = tnow;\n            return;\n        }\n        const stalledDuration = tnow - stalled;\n        if (!seeking && stalledDuration >= STALL_MINIMUM_DURATION_MS) {\n            // Report stalling after trying to fix\n            this._reportStall(bufferInfo);\n            if (!this.media) {\n                return;\n            }\n        }\n        const bufferedWithHoles = BufferHelper.bufferInfo(media, currentTime, config.maxBufferHole);\n        this._tryFixBufferStall(bufferedWithHoles, stalledDuration);\n    }\n    /**\n   * Detects and attempts to fix known buffer stalling issues.\n   * @param bufferInfo - The properties of the current buffer.\n   * @param stalledDurationMs - The amount of time Hls.js has been stalling for.\n   * @private\n   */ _tryFixBufferStall(bufferInfo, stalledDurationMs) {\n        const { config, fragmentTracker, media } = this;\n        if (media === null) {\n            return;\n        }\n        const currentTime = media.currentTime;\n        const partial = fragmentTracker.getPartialFragment(currentTime);\n        if (partial) {\n            // Try to skip over the buffer hole caused by a partial fragment\n            // This method isn't limited by the size of the gap between buffered ranges\n            const targetTime = this._trySkipBufferHole(partial);\n            // we return here in this case, meaning\n            // the branch below only executes when we haven't seeked to a new position\n            if (targetTime || !this.media) {\n                return;\n            }\n        }\n        // if we haven't had to skip over a buffer hole of a partial fragment\n        // we may just have to \"nudge\" the playlist as the browser decoding/rendering engine\n        // needs to cross some sort of threshold covering all source-buffers content\n        // to start playing properly.\n        if ((bufferInfo.len > config.maxBufferHole || bufferInfo.nextStart && bufferInfo.nextStart - currentTime < config.maxBufferHole) && stalledDurationMs > config.highBufferWatchdogPeriod * 1000) {\n            logger.warn(\"Trying to nudge playhead over buffer-hole\");\n            // Try to nudge currentTime over a buffer hole if we've been stalling for the configured amount of seconds\n            // We only try to jump the hole if it's under the configured size\n            // Reset stalled so to rearm watchdog timer\n            this.stalled = null;\n            this._tryNudgeBuffer();\n        }\n    }\n    /**\n   * Triggers a BUFFER_STALLED_ERROR event, but only once per stall period.\n   * @param bufferLen - The playhead distance from the end of the current buffer segment.\n   * @private\n   */ _reportStall(bufferInfo) {\n        const { hls, media, stallReported } = this;\n        if (!stallReported && media) {\n            // Report stalled error once\n            this.stallReported = true;\n            const error = new Error(`Playback stalling at @${media.currentTime} due to low buffer (${JSON.stringify(bufferInfo)})`);\n            logger.warn(error.message);\n            hls.trigger(Events.ERROR, {\n                type: ErrorTypes.MEDIA_ERROR,\n                details: ErrorDetails.BUFFER_STALLED_ERROR,\n                fatal: false,\n                error,\n                buffer: bufferInfo.len\n            });\n        }\n    }\n    /**\n   * Attempts to fix buffer stalls by jumping over known gaps caused by partial fragments\n   * @param partial - The partial fragment found at the current time (where playback is stalling).\n   * @private\n   */ _trySkipBufferHole(partial) {\n        const { config, hls, media } = this;\n        if (media === null) {\n            return 0;\n        }\n        // Check if currentTime is between unbuffered regions of partial fragments\n        const currentTime = media.currentTime;\n        const bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);\n        const startTime = currentTime < bufferInfo.start ? bufferInfo.start : bufferInfo.nextStart;\n        if (startTime) {\n            const bufferStarved = bufferInfo.len <= config.maxBufferHole;\n            const waiting = bufferInfo.len > 0 && bufferInfo.len < 1 && media.readyState < 3;\n            const gapLength = startTime - currentTime;\n            if (gapLength > 0 && (bufferStarved || waiting)) {\n                // Only allow large gaps to be skipped if it is a start gap, or all fragments in skip range are partial\n                if (gapLength > config.maxBufferHole) {\n                    const { fragmentTracker } = this;\n                    let startGap = false;\n                    if (currentTime === 0) {\n                        const startFrag = fragmentTracker.getAppendedFrag(0, PlaylistLevelType.MAIN);\n                        if (startFrag && startTime < startFrag.end) {\n                            startGap = true;\n                        }\n                    }\n                    if (!startGap) {\n                        const startProvisioned = partial || fragmentTracker.getAppendedFrag(currentTime, PlaylistLevelType.MAIN);\n                        if (startProvisioned) {\n                            let moreToLoad = false;\n                            let pos = startProvisioned.end;\n                            while(pos < startTime){\n                                const provisioned = fragmentTracker.getPartialFragment(pos);\n                                if (provisioned) {\n                                    pos += provisioned.duration;\n                                } else {\n                                    moreToLoad = true;\n                                    break;\n                                }\n                            }\n                            if (moreToLoad) {\n                                return 0;\n                            }\n                        }\n                    }\n                }\n                const targetTime = Math.max(startTime + SKIP_BUFFER_RANGE_START, currentTime + SKIP_BUFFER_HOLE_STEP_SECONDS);\n                logger.warn(`skipping hole, adjusting currentTime from ${currentTime} to ${targetTime}`);\n                this.moved = true;\n                this.stalled = null;\n                media.currentTime = targetTime;\n                if (partial && !partial.gap) {\n                    const error = new Error(`fragment loaded with buffer holes, seeking from ${currentTime} to ${targetTime}`);\n                    hls.trigger(Events.ERROR, {\n                        type: ErrorTypes.MEDIA_ERROR,\n                        details: ErrorDetails.BUFFER_SEEK_OVER_HOLE,\n                        fatal: false,\n                        error,\n                        reason: error.message,\n                        frag: partial\n                    });\n                }\n                return targetTime;\n            }\n        }\n        return 0;\n    }\n    /**\n   * Attempts to fix buffer stalls by advancing the mediaElement's current time by a small amount.\n   * @private\n   */ _tryNudgeBuffer() {\n        const { config, hls, media, nudgeRetry } = this;\n        if (media === null) {\n            return;\n        }\n        const currentTime = media.currentTime;\n        this.nudgeRetry++;\n        if (nudgeRetry < config.nudgeMaxRetry) {\n            const targetTime = currentTime + (nudgeRetry + 1) * config.nudgeOffset;\n            // playback stalled in buffered area ... let's nudge currentTime to try to overcome this\n            const error = new Error(`Nudging 'currentTime' from ${currentTime} to ${targetTime}`);\n            logger.warn(error.message);\n            media.currentTime = targetTime;\n            hls.trigger(Events.ERROR, {\n                type: ErrorTypes.MEDIA_ERROR,\n                details: ErrorDetails.BUFFER_NUDGE_ON_STALL,\n                error,\n                fatal: false\n            });\n        } else {\n            const error = new Error(`Playhead still not moving while enough data buffered @${currentTime} after ${config.nudgeMaxRetry} nudges`);\n            logger.error(error.message);\n            hls.trigger(Events.ERROR, {\n                type: ErrorTypes.MEDIA_ERROR,\n                details: ErrorDetails.BUFFER_STALLED_ERROR,\n                error,\n                fatal: true\n            });\n        }\n    }\n}\nconst TICK_INTERVAL = 100; // how often to tick in ms\nclass StreamController extends BaseStreamController {\n    constructor(hls, fragmentTracker, keyLoader){\n        super(hls, fragmentTracker, keyLoader, \"[stream-controller]\", PlaylistLevelType.MAIN);\n        this.audioCodecSwap = false;\n        this.gapController = null;\n        this.level = -1;\n        this._forceStartLoad = false;\n        this.altAudio = false;\n        this.audioOnly = false;\n        this.fragPlaying = null;\n        this.onvplaying = null;\n        this.onvseeked = null;\n        this.fragLastKbps = 0;\n        this.couldBacktrack = false;\n        this.backtrackFragment = null;\n        this.audioCodecSwitch = false;\n        this.videoBuffer = null;\n        this._registerListeners();\n    }\n    _registerListeners() {\n        const { hls } = this;\n        hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n        hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);\n        hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n        hls.on(Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);\n        hls.on(Events.ERROR, this.onError, this);\n        hls.on(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n        hls.on(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);\n        hls.on(Events.BUFFER_CREATED, this.onBufferCreated, this);\n        hls.on(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n        hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n        hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    }\n    _unregisterListeners() {\n        const { hls } = this;\n        hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n        hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n        hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n        hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n        hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n        hls.off(Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);\n        hls.off(Events.ERROR, this.onError, this);\n        hls.off(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n        hls.off(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);\n        hls.off(Events.BUFFER_CREATED, this.onBufferCreated, this);\n        hls.off(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n        hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n        hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    }\n    onHandlerDestroying() {\n        this._unregisterListeners();\n        super.onHandlerDestroying();\n    }\n    startLoad(startPosition) {\n        if (this.levels) {\n            const { lastCurrentTime, hls } = this;\n            this.stopLoad();\n            this.setInterval(TICK_INTERVAL);\n            this.level = -1;\n            if (!this.startFragRequested) {\n                // determine load level\n                let startLevel = hls.startLevel;\n                if (startLevel === -1) {\n                    if (hls.config.testBandwidth && this.levels.length > 1) {\n                        // -1 : guess start Level by doing a bitrate test by loading first fragment of lowest quality level\n                        startLevel = 0;\n                        this.bitrateTest = true;\n                    } else {\n                        startLevel = hls.firstAutoLevel;\n                    }\n                }\n                // set new level to playlist loader : this will trigger start level load\n                // hls.nextLoadLevel remains until it is set to a new value or until a new frag is successfully loaded\n                this.level = hls.nextLoadLevel = startLevel;\n                this.loadedmetadata = false;\n            }\n            // if startPosition undefined but lastCurrentTime set, set startPosition to last currentTime\n            if (lastCurrentTime > 0 && startPosition === -1) {\n                this.log(`Override startPosition with lastCurrentTime @${lastCurrentTime.toFixed(3)}`);\n                startPosition = lastCurrentTime;\n            }\n            this.state = State.IDLE;\n            this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;\n            this.tick();\n        } else {\n            this._forceStartLoad = true;\n            this.state = State.STOPPED;\n        }\n    }\n    stopLoad() {\n        this._forceStartLoad = false;\n        super.stopLoad();\n    }\n    doTick() {\n        switch(this.state){\n            case State.WAITING_LEVEL:\n                {\n                    const { levels, level } = this;\n                    const currentLevel = levels == null ? void 0 : levels[level];\n                    const details = currentLevel == null ? void 0 : currentLevel.details;\n                    if (details && (!details.live || this.levelLastLoaded === currentLevel)) {\n                        if (this.waitForCdnTuneIn(details)) {\n                            break;\n                        }\n                        this.state = State.IDLE;\n                        break;\n                    } else if (this.hls.nextLoadLevel !== this.level) {\n                        this.state = State.IDLE;\n                        break;\n                    }\n                    break;\n                }\n            case State.FRAG_LOADING_WAITING_RETRY:\n                {\n                    var _this$media;\n                    const now = self.performance.now();\n                    const retryDate = this.retryDate;\n                    // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading\n                    if (!retryDate || now >= retryDate || (_this$media = this.media) != null && _this$media.seeking) {\n                        const { levels, level } = this;\n                        const currentLevel = levels == null ? void 0 : levels[level];\n                        this.resetStartWhenNotLoaded(currentLevel || null);\n                        this.state = State.IDLE;\n                    }\n                }\n                break;\n        }\n        if (this.state === State.IDLE) {\n            this.doTickIdle();\n        }\n        this.onTickEnd();\n    }\n    onTickEnd() {\n        super.onTickEnd();\n        this.checkBuffer();\n        this.checkFragmentChanged();\n    }\n    doTickIdle() {\n        const { hls, levelLastLoaded, levels, media } = this;\n        const { config, nextLoadLevel: level } = hls;\n        // if start level not parsed yet OR\n        // if video not attached AND start fragment already requested OR start frag prefetch not enabled\n        // exit loop, as we either need more info (level not parsed) or we need media to be attached to load new fragment\n        if (levelLastLoaded === null || !media && (this.startFragRequested || !config.startFragPrefetch)) {\n            return;\n        }\n        // If the \"main\" level is audio-only but we are loading an alternate track in the same group, do not load anything\n        if (this.altAudio && this.audioOnly) {\n            return;\n        }\n        if (!(levels != null && levels[level])) {\n            return;\n        }\n        const levelInfo = levels[level];\n        // if buffer length is less than maxBufLen try to load a new fragment\n        const bufferInfo = this.getMainFwdBufferInfo();\n        if (bufferInfo === null) {\n            return;\n        }\n        const lastDetails = this.getLevelDetails();\n        if (lastDetails && this._streamEnded(bufferInfo, lastDetails)) {\n            const data = {};\n            if (this.altAudio) {\n                data.type = \"video\";\n            }\n            this.hls.trigger(Events.BUFFER_EOS, data);\n            this.state = State.ENDED;\n            return;\n        }\n        // set next load level : this will trigger a playlist load if needed\n        if (hls.loadLevel !== level && hls.manualLevel === -1) {\n            this.log(`Adapting to level ${level} from level ${this.level}`);\n        }\n        this.level = hls.nextLoadLevel = level;\n        const levelDetails = levelInfo.details;\n        // if level info not retrieved yet, switch state and wait for level retrieval\n        // if live playlist, ensure that new playlist has been refreshed to avoid loading/try to load\n        // a useless and outdated fragment (that might even introduce load error if it is already out of the live playlist)\n        if (!levelDetails || this.state === State.WAITING_LEVEL || levelDetails.live && this.levelLastLoaded !== levelInfo) {\n            this.level = level;\n            this.state = State.WAITING_LEVEL;\n            return;\n        }\n        const bufferLen = bufferInfo.len;\n        // compute max Buffer Length that we could get from this load level, based on level bitrate. don't buffer more than 60 MB and more than 30s\n        const maxBufLen = this.getMaxBufferLength(levelInfo.maxBitrate);\n        // Stay idle if we are still with buffer margins\n        if (bufferLen >= maxBufLen) {\n            return;\n        }\n        if (this.backtrackFragment && this.backtrackFragment.start > bufferInfo.end) {\n            this.backtrackFragment = null;\n        }\n        const targetBufferTime = this.backtrackFragment ? this.backtrackFragment.start : bufferInfo.end;\n        let frag = this.getNextFragment(targetBufferTime, levelDetails);\n        // Avoid backtracking by loading an earlier segment in streams with segments that do not start with a key frame (flagged by `couldBacktrack`)\n        if (this.couldBacktrack && !this.fragPrevious && frag && frag.sn !== \"initSegment\" && this.fragmentTracker.getState(frag) !== FragmentState.OK) {\n            var _this$backtrackFragme;\n            const backtrackSn = ((_this$backtrackFragme = this.backtrackFragment) != null ? _this$backtrackFragme : frag).sn;\n            const fragIdx = backtrackSn - levelDetails.startSN;\n            const backtrackFrag = levelDetails.fragments[fragIdx - 1];\n            if (backtrackFrag && frag.cc === backtrackFrag.cc) {\n                frag = backtrackFrag;\n                this.fragmentTracker.removeFragment(backtrackFrag);\n            }\n        } else if (this.backtrackFragment && bufferInfo.len) {\n            this.backtrackFragment = null;\n        }\n        // Avoid loop loading by using nextLoadPosition set for backtracking and skipping consecutive GAP tags\n        if (frag && this.isLoopLoading(frag, targetBufferTime)) {\n            const gapStart = frag.gap;\n            if (!gapStart) {\n                // Cleanup the fragment tracker before trying to find the next unbuffered fragment\n                const type = this.audioOnly && !this.altAudio ? ElementaryStreamTypes.AUDIO : ElementaryStreamTypes.VIDEO;\n                const mediaBuffer = (type === ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;\n                if (mediaBuffer) {\n                    this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.MAIN);\n                }\n            }\n            frag = this.getNextFragmentLoopLoading(frag, levelDetails, bufferInfo, PlaylistLevelType.MAIN, maxBufLen);\n        }\n        if (!frag) {\n            return;\n        }\n        if (frag.initSegment && !frag.initSegment.data && !this.bitrateTest) {\n            frag = frag.initSegment;\n        }\n        this.loadFragment(frag, levelInfo, targetBufferTime);\n    }\n    loadFragment(frag, level, targetBufferTime) {\n        // Check if fragment is not loaded\n        const fragState = this.fragmentTracker.getState(frag);\n        this.fragCurrent = frag;\n        if (fragState === FragmentState.NOT_LOADED || fragState === FragmentState.PARTIAL) {\n            if (frag.sn === \"initSegment\") {\n                this._loadInitSegment(frag, level);\n            } else if (this.bitrateTest) {\n                this.log(`Fragment ${frag.sn} of level ${frag.level} is being downloaded to test bitrate and will not be buffered`);\n                this._loadBitrateTestFrag(frag, level);\n            } else {\n                this.startFragRequested = true;\n                super.loadFragment(frag, level, targetBufferTime);\n            }\n        } else {\n            this.clearTrackerIfNeeded(frag);\n        }\n    }\n    getBufferedFrag(position) {\n        return this.fragmentTracker.getBufferedFrag(position, PlaylistLevelType.MAIN);\n    }\n    followingBufferedFrag(frag) {\n        if (frag) {\n            // try to get range of next fragment (500ms after this range)\n            return this.getBufferedFrag(frag.end + 0.5);\n        }\n        return null;\n    }\n    /*\n    on immediate level switch :\n     - pause playback if playing\n     - cancel any pending load request\n     - and trigger a buffer flush\n  */ immediateLevelSwitch() {\n        this.abortCurrentFrag();\n        this.flushMainBuffer(0, Number.POSITIVE_INFINITY);\n    }\n    /**\n   * try to switch ASAP without breaking video playback:\n   * in order to ensure smooth but quick level switching,\n   * we need to find the next flushable buffer range\n   * we should take into account new segment fetch time\n   */ nextLevelSwitch() {\n        const { levels, media } = this;\n        // ensure that media is defined and that metadata are available (to retrieve currentTime)\n        if (media != null && media.readyState) {\n            let fetchdelay;\n            const fragPlayingCurrent = this.getAppendedFrag(media.currentTime);\n            if (fragPlayingCurrent && fragPlayingCurrent.start > 1) {\n                // flush buffer preceding current fragment (flush until current fragment start offset)\n                // minus 1s to avoid video freezing, that could happen if we flush keyframe of current video ...\n                this.flushMainBuffer(0, fragPlayingCurrent.start - 1);\n            }\n            const levelDetails = this.getLevelDetails();\n            if (levelDetails != null && levelDetails.live) {\n                const bufferInfo = this.getMainFwdBufferInfo();\n                // Do not flush in live stream with low buffer\n                if (!bufferInfo || bufferInfo.len < levelDetails.targetduration * 2) {\n                    return;\n                }\n            }\n            if (!media.paused && levels) {\n                // add a safety delay of 1s\n                const nextLevelId = this.hls.nextLoadLevel;\n                const nextLevel = levels[nextLevelId];\n                const fragLastKbps = this.fragLastKbps;\n                if (fragLastKbps && this.fragCurrent) {\n                    fetchdelay = this.fragCurrent.duration * nextLevel.maxBitrate / (1000 * fragLastKbps) + 1;\n                } else {\n                    fetchdelay = 0;\n                }\n            } else {\n                fetchdelay = 0;\n            }\n            // this.log('fetchdelay:'+fetchdelay);\n            // find buffer range that will be reached once new fragment will be fetched\n            const bufferedFrag = this.getBufferedFrag(media.currentTime + fetchdelay);\n            if (bufferedFrag) {\n                // we can flush buffer range following this one without stalling playback\n                const nextBufferedFrag = this.followingBufferedFrag(bufferedFrag);\n                if (nextBufferedFrag) {\n                    // if we are here, we can also cancel any loading/demuxing in progress, as they are useless\n                    this.abortCurrentFrag();\n                    // start flush position is in next buffered frag. Leave some padding for non-independent segments and smoother playback.\n                    const maxStart = nextBufferedFrag.maxStartPTS ? nextBufferedFrag.maxStartPTS : nextBufferedFrag.start;\n                    const fragDuration = nextBufferedFrag.duration;\n                    const startPts = Math.max(bufferedFrag.end, maxStart + Math.min(Math.max(fragDuration - this.config.maxFragLookUpTolerance, fragDuration * (this.couldBacktrack ? 0.5 : 0.125)), fragDuration * (this.couldBacktrack ? 0.75 : 0.25)));\n                    this.flushMainBuffer(startPts, Number.POSITIVE_INFINITY);\n                }\n            }\n        }\n    }\n    abortCurrentFrag() {\n        const fragCurrent = this.fragCurrent;\n        this.fragCurrent = null;\n        this.backtrackFragment = null;\n        if (fragCurrent) {\n            fragCurrent.abortRequests();\n            this.fragmentTracker.removeFragment(fragCurrent);\n        }\n        switch(this.state){\n            case State.KEY_LOADING:\n            case State.FRAG_LOADING:\n            case State.FRAG_LOADING_WAITING_RETRY:\n            case State.PARSING:\n            case State.PARSED:\n                this.state = State.IDLE;\n                break;\n        }\n        this.nextLoadPosition = this.getLoadPosition();\n    }\n    flushMainBuffer(startOffset, endOffset) {\n        super.flushMainBuffer(startOffset, endOffset, this.altAudio ? \"video\" : null);\n    }\n    onMediaAttached(event, data) {\n        super.onMediaAttached(event, data);\n        const media = data.media;\n        this.onvplaying = this.onMediaPlaying.bind(this);\n        this.onvseeked = this.onMediaSeeked.bind(this);\n        media.addEventListener(\"playing\", this.onvplaying);\n        media.addEventListener(\"seeked\", this.onvseeked);\n        this.gapController = new GapController(this.config, media, this.fragmentTracker, this.hls);\n    }\n    onMediaDetaching() {\n        const { media } = this;\n        if (media && this.onvplaying && this.onvseeked) {\n            media.removeEventListener(\"playing\", this.onvplaying);\n            media.removeEventListener(\"seeked\", this.onvseeked);\n            this.onvplaying = this.onvseeked = null;\n            this.videoBuffer = null;\n        }\n        this.fragPlaying = null;\n        if (this.gapController) {\n            this.gapController.destroy();\n            this.gapController = null;\n        }\n        super.onMediaDetaching();\n    }\n    onMediaPlaying() {\n        // tick to speed up FRAG_CHANGED triggering\n        this.tick();\n    }\n    onMediaSeeked() {\n        const media = this.media;\n        const currentTime = media ? media.currentTime : null;\n        if (isFiniteNumber(currentTime)) {\n            this.log(`Media seeked to ${currentTime.toFixed(3)}`);\n        }\n        // If seeked was issued before buffer was appended do not tick immediately\n        const bufferInfo = this.getMainFwdBufferInfo();\n        if (bufferInfo === null || bufferInfo.len === 0) {\n            this.warn(`Main forward buffer length on \"seeked\" event ${bufferInfo ? bufferInfo.len : \"empty\"})`);\n            return;\n        }\n        // tick to speed up FRAG_CHANGED triggering\n        this.tick();\n    }\n    onManifestLoading() {\n        // reset buffer on manifest loading\n        this.log(\"Trigger BUFFER_RESET\");\n        this.hls.trigger(Events.BUFFER_RESET, undefined);\n        this.fragmentTracker.removeAllFragments();\n        this.couldBacktrack = false;\n        this.startPosition = this.lastCurrentTime = this.fragLastKbps = 0;\n        this.levels = this.fragPlaying = this.backtrackFragment = this.levelLastLoaded = null;\n        this.altAudio = this.audioOnly = this.startFragRequested = false;\n    }\n    onManifestParsed(event, data) {\n        // detect if we have different kind of audio codecs used amongst playlists\n        let aac = false;\n        let heaac = false;\n        data.levels.forEach((level)=>{\n            const codec = level.audioCodec;\n            if (codec) {\n                aac = aac || codec.indexOf(\"mp4a.40.2\") !== -1;\n                heaac = heaac || codec.indexOf(\"mp4a.40.5\") !== -1;\n            }\n        });\n        this.audioCodecSwitch = aac && heaac && !changeTypeSupported();\n        if (this.audioCodecSwitch) {\n            this.log(\"Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC\");\n        }\n        this.levels = data.levels;\n        this.startFragRequested = false;\n    }\n    onLevelLoading(event, data) {\n        const { levels } = this;\n        if (!levels || this.state !== State.IDLE) {\n            return;\n        }\n        const level = levels[data.level];\n        if (!level.details || level.details.live && this.levelLastLoaded !== level || this.waitForCdnTuneIn(level.details)) {\n            this.state = State.WAITING_LEVEL;\n        }\n    }\n    onLevelLoaded(event, data) {\n        var _curLevel$details;\n        const { levels } = this;\n        const newLevelId = data.level;\n        const newDetails = data.details;\n        const duration = newDetails.totalduration;\n        if (!levels) {\n            this.warn(`Levels were reset while loading level ${newLevelId}`);\n            return;\n        }\n        this.log(`Level ${newLevelId} loaded [${newDetails.startSN},${newDetails.endSN}]${newDetails.lastPartSn ? `[part-${newDetails.lastPartSn}-${newDetails.lastPartIndex}]` : \"\"}, cc [${newDetails.startCC}, ${newDetails.endCC}] duration:${duration}`);\n        const curLevel = levels[newLevelId];\n        const fragCurrent = this.fragCurrent;\n        if (fragCurrent && (this.state === State.FRAG_LOADING || this.state === State.FRAG_LOADING_WAITING_RETRY)) {\n            if (fragCurrent.level !== data.level && fragCurrent.loader) {\n                this.abortCurrentFrag();\n            }\n        }\n        let sliding = 0;\n        if (newDetails.live || (_curLevel$details = curLevel.details) != null && _curLevel$details.live) {\n            var _this$levelLastLoaded;\n            this.checkLiveUpdate(newDetails);\n            if (newDetails.deltaUpdateFailed) {\n                return;\n            }\n            sliding = this.alignPlaylists(newDetails, curLevel.details, (_this$levelLastLoaded = this.levelLastLoaded) == null ? void 0 : _this$levelLastLoaded.details);\n        }\n        // override level info\n        curLevel.details = newDetails;\n        this.levelLastLoaded = curLevel;\n        this.hls.trigger(Events.LEVEL_UPDATED, {\n            details: newDetails,\n            level: newLevelId\n        });\n        // only switch back to IDLE state if we were waiting for level to start downloading a new fragment\n        if (this.state === State.WAITING_LEVEL) {\n            if (this.waitForCdnTuneIn(newDetails)) {\n                // Wait for Low-Latency CDN Tune-in\n                return;\n            }\n            this.state = State.IDLE;\n        }\n        if (!this.startFragRequested) {\n            this.setStartPosition(newDetails, sliding);\n        } else if (newDetails.live) {\n            this.synchronizeToLiveEdge(newDetails);\n        }\n        // trigger handler right now\n        this.tick();\n    }\n    _handleFragmentLoadProgress(data) {\n        var _frag$initSegment;\n        const { frag, part, payload } = data;\n        const { levels } = this;\n        if (!levels) {\n            this.warn(`Levels were reset while fragment load was in progress. Fragment ${frag.sn} of level ${frag.level} will not be buffered`);\n            return;\n        }\n        const currentLevel = levels[frag.level];\n        const details = currentLevel.details;\n        if (!details) {\n            this.warn(`Dropping fragment ${frag.sn} of level ${frag.level} after level details were reset`);\n            this.fragmentTracker.removeFragment(frag);\n            return;\n        }\n        const videoCodec = currentLevel.videoCodec;\n        // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)\n        const accurateTimeOffset = details.PTSKnown || !details.live;\n        const initSegmentData = (_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.data;\n        const audioCodec = this._getAudioCodec(currentLevel);\n        // transmux the MPEG-TS data to ISO-BMFF segments\n        // this.log(`Transmuxing ${frag.sn} of [${details.startSN} ,${details.endSN}],level ${frag.level}, cc ${frag.cc}`);\n        const transmuxer = this.transmuxer = this.transmuxer || new TransmuxerInterface(this.hls, PlaylistLevelType.MAIN, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this));\n        const partIndex = part ? part.index : -1;\n        const partial = partIndex !== -1;\n        const chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount, payload.byteLength, partIndex, partial);\n        const initPTS = this.initPTS[frag.cc];\n        transmuxer.push(payload, initSegmentData, audioCodec, videoCodec, frag, part, details.totalduration, accurateTimeOffset, chunkMeta, initPTS);\n    }\n    onAudioTrackSwitching(event, data) {\n        // if any URL found on new audio track, it is an alternate audio track\n        const fromAltAudio = this.altAudio;\n        const altAudio = !!data.url;\n        // if we switch on main audio, ensure that main fragment scheduling is synced with media.buffered\n        // don't do anything if we switch to alt audio: audio stream controller is handling it.\n        // we will just have to change buffer scheduling on audioTrackSwitched\n        if (!altAudio) {\n            if (this.mediaBuffer !== this.media) {\n                this.log(\"Switching on main audio, use media.buffered to schedule main fragment loading\");\n                this.mediaBuffer = this.media;\n                const fragCurrent = this.fragCurrent;\n                // we need to refill audio buffer from main: cancel any frag loading to speed up audio switch\n                if (fragCurrent) {\n                    this.log(\"Switching to main audio track, cancel main fragment load\");\n                    fragCurrent.abortRequests();\n                    this.fragmentTracker.removeFragment(fragCurrent);\n                }\n                // destroy transmuxer to force init segment generation (following audio switch)\n                this.resetTransmuxer();\n                // switch to IDLE state to load new fragment\n                this.resetLoadingState();\n            } else if (this.audioOnly) {\n                // Reset audio transmuxer so when switching back to main audio we're not still appending where we left off\n                this.resetTransmuxer();\n            }\n            const hls = this.hls;\n            // If switching from alt to main audio, flush all audio and trigger track switched\n            if (fromAltAudio) {\n                hls.trigger(Events.BUFFER_FLUSHING, {\n                    startOffset: 0,\n                    endOffset: Number.POSITIVE_INFINITY,\n                    type: null\n                });\n                this.fragmentTracker.removeAllFragments();\n            }\n            hls.trigger(Events.AUDIO_TRACK_SWITCHED, data);\n        }\n    }\n    onAudioTrackSwitched(event, data) {\n        const trackId = data.id;\n        const altAudio = !!this.hls.audioTracks[trackId].url;\n        if (altAudio) {\n            const videoBuffer = this.videoBuffer;\n            // if we switched on alternate audio, ensure that main fragment scheduling is synced with video sourcebuffer buffered\n            if (videoBuffer && this.mediaBuffer !== videoBuffer) {\n                this.log(\"Switching on alternate audio, use video.buffered to schedule main fragment loading\");\n                this.mediaBuffer = videoBuffer;\n            }\n        }\n        this.altAudio = altAudio;\n        this.tick();\n    }\n    onBufferCreated(event, data) {\n        const tracks = data.tracks;\n        let mediaTrack;\n        let name;\n        let alternate = false;\n        for(const type in tracks){\n            const track = tracks[type];\n            if (track.id === \"main\") {\n                name = type;\n                mediaTrack = track;\n                // keep video source buffer reference\n                if (type === \"video\") {\n                    const videoTrack = tracks[type];\n                    if (videoTrack) {\n                        this.videoBuffer = videoTrack.buffer;\n                    }\n                }\n            } else {\n                alternate = true;\n            }\n        }\n        if (alternate && mediaTrack) {\n            this.log(`Alternate track found, use ${name}.buffered to schedule main fragment loading`);\n            this.mediaBuffer = mediaTrack.buffer;\n        } else {\n            this.mediaBuffer = this.media;\n        }\n    }\n    onFragBuffered(event, data) {\n        const { frag, part } = data;\n        if (frag && frag.type !== PlaylistLevelType.MAIN) {\n            return;\n        }\n        if (this.fragContextChanged(frag)) {\n            // If a level switch was requested while a fragment was buffering, it will emit the FRAG_BUFFERED event upon completion\n            // Avoid setting state back to IDLE, since that will interfere with a level switch\n            this.warn(`Fragment ${frag.sn}${part ? \" p: \" + part.index : \"\"} of level ${frag.level} finished buffering, but was aborted. state: ${this.state}`);\n            if (this.state === State.PARSED) {\n                this.state = State.IDLE;\n            }\n            return;\n        }\n        const stats = part ? part.stats : frag.stats;\n        this.fragLastKbps = Math.round(8 * stats.total / (stats.buffering.end - stats.loading.first));\n        if (frag.sn !== \"initSegment\") {\n            this.fragPrevious = frag;\n        }\n        this.fragBufferedComplete(frag, part);\n    }\n    onError(event, data) {\n        var _data$context;\n        if (data.fatal) {\n            this.state = State.ERROR;\n            return;\n        }\n        switch(data.details){\n            case ErrorDetails.FRAG_GAP:\n            case ErrorDetails.FRAG_PARSING_ERROR:\n            case ErrorDetails.FRAG_DECRYPT_ERROR:\n            case ErrorDetails.FRAG_LOAD_ERROR:\n            case ErrorDetails.FRAG_LOAD_TIMEOUT:\n            case ErrorDetails.KEY_LOAD_ERROR:\n            case ErrorDetails.KEY_LOAD_TIMEOUT:\n                this.onFragmentOrKeyLoadError(PlaylistLevelType.MAIN, data);\n                break;\n            case ErrorDetails.LEVEL_LOAD_ERROR:\n            case ErrorDetails.LEVEL_LOAD_TIMEOUT:\n            case ErrorDetails.LEVEL_PARSING_ERROR:\n                // in case of non fatal error while loading level, if level controller is not retrying to load level, switch back to IDLE\n                if (!data.levelRetry && this.state === State.WAITING_LEVEL && ((_data$context = data.context) == null ? void 0 : _data$context.type) === PlaylistContextType.LEVEL) {\n                    this.state = State.IDLE;\n                }\n                break;\n            case ErrorDetails.BUFFER_APPEND_ERROR:\n            case ErrorDetails.BUFFER_FULL_ERROR:\n                if (!data.parent || data.parent !== \"main\") {\n                    return;\n                }\n                if (data.details === ErrorDetails.BUFFER_APPEND_ERROR) {\n                    this.resetLoadingState();\n                    return;\n                }\n                if (this.reduceLengthAndFlushBuffer(data)) {\n                    this.flushMainBuffer(0, Number.POSITIVE_INFINITY);\n                }\n                break;\n            case ErrorDetails.INTERNAL_EXCEPTION:\n                this.recoverWorkerError(data);\n                break;\n        }\n    }\n    // Checks the health of the buffer and attempts to resolve playback stalls.\n    checkBuffer() {\n        const { media, gapController } = this;\n        if (!media || !gapController || !media.readyState) {\n            // Exit early if we don't have media or if the media hasn't buffered anything yet (readyState 0)\n            return;\n        }\n        if (this.loadedmetadata || !BufferHelper.getBuffered(media).length) {\n            // Resolve gaps using the main buffer, whose ranges are the intersections of the A/V sourcebuffers\n            const activeFrag = this.state !== State.IDLE ? this.fragCurrent : null;\n            gapController.poll(this.lastCurrentTime, activeFrag);\n        }\n        this.lastCurrentTime = media.currentTime;\n    }\n    onFragLoadEmergencyAborted() {\n        this.state = State.IDLE;\n        // if loadedmetadata is not set, it means that we are emergency switch down on first frag\n        // in that case, reset startFragRequested flag\n        if (!this.loadedmetadata) {\n            this.startFragRequested = false;\n            this.nextLoadPosition = this.startPosition;\n        }\n        this.tickImmediate();\n    }\n    onBufferFlushed(event, { type }) {\n        if (type !== ElementaryStreamTypes.AUDIO || this.audioOnly && !this.altAudio) {\n            const mediaBuffer = (type === ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;\n            this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.MAIN);\n            this.tick();\n        }\n    }\n    onLevelsUpdated(event, data) {\n        if (this.level > -1 && this.fragCurrent) {\n            this.level = this.fragCurrent.level;\n        }\n        this.levels = data.levels;\n    }\n    swapAudioCodec() {\n        this.audioCodecSwap = !this.audioCodecSwap;\n    }\n    /**\n   * Seeks to the set startPosition if not equal to the mediaElement's current time.\n   */ seekToStartPos() {\n        const { media } = this;\n        if (!media) {\n            return;\n        }\n        const currentTime = media.currentTime;\n        let startPosition = this.startPosition;\n        // only adjust currentTime if different from startPosition or if startPosition not buffered\n        // at that stage, there should be only one buffered range, as we reach that code after first fragment has been buffered\n        if (startPosition >= 0 && currentTime < startPosition) {\n            if (media.seeking) {\n                this.log(`could not seek to ${startPosition}, already seeking at ${currentTime}`);\n                return;\n            }\n            const buffered = BufferHelper.getBuffered(media);\n            const bufferStart = buffered.length ? buffered.start(0) : 0;\n            const delta = bufferStart - startPosition;\n            if (delta > 0 && (delta < this.config.maxBufferHole || delta < this.config.maxFragLookUpTolerance)) {\n                this.log(`adjusting start position by ${delta} to match buffer start`);\n                startPosition += delta;\n                this.startPosition = startPosition;\n            }\n            this.log(`seek to target start position ${startPosition} from current time ${currentTime}`);\n            media.currentTime = startPosition;\n        }\n    }\n    _getAudioCodec(currentLevel) {\n        let audioCodec = this.config.defaultAudioCodec || currentLevel.audioCodec;\n        if (this.audioCodecSwap && audioCodec) {\n            this.log(\"Swapping audio codec\");\n            if (audioCodec.indexOf(\"mp4a.40.5\") !== -1) {\n                audioCodec = \"mp4a.40.2\";\n            } else {\n                audioCodec = \"mp4a.40.5\";\n            }\n        }\n        return audioCodec;\n    }\n    _loadBitrateTestFrag(frag, level) {\n        frag.bitrateTest = true;\n        this._doFragLoad(frag, level).then((data)=>{\n            const { hls } = this;\n            if (!data || this.fragContextChanged(frag)) {\n                return;\n            }\n            level.fragmentError = 0;\n            this.state = State.IDLE;\n            this.startFragRequested = false;\n            this.bitrateTest = false;\n            const stats = frag.stats;\n            // Bitrate tests fragments are neither parsed nor buffered\n            stats.parsing.start = stats.parsing.end = stats.buffering.start = stats.buffering.end = self.performance.now();\n            hls.trigger(Events.FRAG_LOADED, data);\n            frag.bitrateTest = false;\n        });\n    }\n    _handleTransmuxComplete(transmuxResult) {\n        var _id3$samples;\n        const id = \"main\";\n        const { hls } = this;\n        const { remuxResult, chunkMeta } = transmuxResult;\n        const context = this.getCurrentContext(chunkMeta);\n        if (!context) {\n            this.resetWhenMissingContext(chunkMeta);\n            return;\n        }\n        const { frag, part, level } = context;\n        const { video, text, id3, initSegment } = remuxResult;\n        const { details } = level;\n        // The audio-stream-controller handles audio buffering if Hls.js is playing an alternate audio track\n        const audio = this.altAudio ? undefined : remuxResult.audio;\n        // Check if the current fragment has been aborted. We check this by first seeing if we're still playing the current level.\n        // If we are, subsequently check if the currently loading fragment (fragCurrent) has changed.\n        if (this.fragContextChanged(frag)) {\n            this.fragmentTracker.removeFragment(frag);\n            return;\n        }\n        this.state = State.PARSING;\n        if (initSegment) {\n            if (initSegment != null && initSegment.tracks) {\n                const mapFragment = frag.initSegment || frag;\n                this._bufferInitSegment(level, initSegment.tracks, mapFragment, chunkMeta);\n                hls.trigger(Events.FRAG_PARSING_INIT_SEGMENT, {\n                    frag: mapFragment,\n                    id,\n                    tracks: initSegment.tracks\n                });\n            }\n            // This would be nice if Number.isFinite acted as a typeguard, but it doesn't. See: https://github.com/Microsoft/TypeScript/issues/10038\n            const initPTS = initSegment.initPTS;\n            const timescale = initSegment.timescale;\n            if (isFiniteNumber(initPTS)) {\n                this.initPTS[frag.cc] = {\n                    baseTime: initPTS,\n                    timescale\n                };\n                hls.trigger(Events.INIT_PTS_FOUND, {\n                    frag,\n                    id,\n                    initPTS,\n                    timescale\n                });\n            }\n        }\n        // Avoid buffering if backtracking this fragment\n        if (video && details && frag.sn !== \"initSegment\") {\n            const prevFrag = details.fragments[frag.sn - 1 - details.startSN];\n            const isFirstFragment = frag.sn === details.startSN;\n            const isFirstInDiscontinuity = !prevFrag || frag.cc > prevFrag.cc;\n            if (remuxResult.independent !== false) {\n                const { startPTS, endPTS, startDTS, endDTS } = video;\n                if (part) {\n                    part.elementaryStreams[video.type] = {\n                        startPTS,\n                        endPTS,\n                        startDTS,\n                        endDTS\n                    };\n                } else {\n                    if (video.firstKeyFrame && video.independent && chunkMeta.id === 1 && !isFirstInDiscontinuity) {\n                        this.couldBacktrack = true;\n                    }\n                    if (video.dropped && video.independent) {\n                        // Backtrack if dropped frames create a gap after currentTime\n                        const bufferInfo = this.getMainFwdBufferInfo();\n                        const targetBufferTime = (bufferInfo ? bufferInfo.end : this.getLoadPosition()) + this.config.maxBufferHole;\n                        const startTime = video.firstKeyFramePTS ? video.firstKeyFramePTS : startPTS;\n                        if (!isFirstFragment && targetBufferTime < startTime - this.config.maxBufferHole && !isFirstInDiscontinuity) {\n                            this.backtrack(frag);\n                            return;\n                        } else if (isFirstInDiscontinuity) {\n                            // Mark segment with a gap to avoid loop loading\n                            frag.gap = true;\n                        }\n                        // Set video stream start to fragment start so that truncated samples do not distort the timeline, and mark it partial\n                        frag.setElementaryStreamInfo(video.type, frag.start, endPTS, frag.start, endDTS, true);\n                    } else if (isFirstFragment && startPTS > MAX_START_GAP_JUMP) {\n                        // Mark segment with a gap to skip large start gap\n                        frag.gap = true;\n                    }\n                }\n                frag.setElementaryStreamInfo(video.type, startPTS, endPTS, startDTS, endDTS);\n                if (this.backtrackFragment) {\n                    this.backtrackFragment = frag;\n                }\n                this.bufferFragmentData(video, frag, part, chunkMeta, isFirstFragment || isFirstInDiscontinuity);\n            } else if (isFirstFragment || isFirstInDiscontinuity) {\n                // Mark segment with a gap to avoid loop loading\n                frag.gap = true;\n            } else {\n                this.backtrack(frag);\n                return;\n            }\n        }\n        if (audio) {\n            const { startPTS, endPTS, startDTS, endDTS } = audio;\n            if (part) {\n                part.elementaryStreams[ElementaryStreamTypes.AUDIO] = {\n                    startPTS,\n                    endPTS,\n                    startDTS,\n                    endDTS\n                };\n            }\n            frag.setElementaryStreamInfo(ElementaryStreamTypes.AUDIO, startPTS, endPTS, startDTS, endDTS);\n            this.bufferFragmentData(audio, frag, part, chunkMeta);\n        }\n        if (details && id3 != null && (_id3$samples = id3.samples) != null && _id3$samples.length) {\n            const emittedID3 = {\n                id,\n                frag,\n                details,\n                samples: id3.samples\n            };\n            hls.trigger(Events.FRAG_PARSING_METADATA, emittedID3);\n        }\n        if (details && text) {\n            const emittedText = {\n                id,\n                frag,\n                details,\n                samples: text.samples\n            };\n            hls.trigger(Events.FRAG_PARSING_USERDATA, emittedText);\n        }\n    }\n    _bufferInitSegment(currentLevel, tracks, frag, chunkMeta) {\n        if (this.state !== State.PARSING) {\n            return;\n        }\n        this.audioOnly = !!tracks.audio && !tracks.video;\n        // if audio track is expected to come from audio stream controller, discard any coming from main\n        if (this.altAudio && !this.audioOnly) {\n            delete tracks.audio;\n        }\n        // include levelCodec in audio and video tracks\n        const { audio, video, audiovideo } = tracks;\n        if (audio) {\n            let audioCodec = currentLevel.audioCodec;\n            const ua = navigator.userAgent.toLowerCase();\n            if (this.audioCodecSwitch) {\n                if (audioCodec) {\n                    if (audioCodec.indexOf(\"mp4a.40.5\") !== -1) {\n                        audioCodec = \"mp4a.40.2\";\n                    } else {\n                        audioCodec = \"mp4a.40.5\";\n                    }\n                }\n                // In the case that AAC and HE-AAC audio codecs are signalled in manifest,\n                // force HE-AAC, as it seems that most browsers prefers it.\n                // don't force HE-AAC if mono stream, or in Firefox\n                if (audio.metadata.channelCount !== 1 && ua.indexOf(\"firefox\") === -1) {\n                    audioCodec = \"mp4a.40.5\";\n                }\n            }\n            // HE-AAC is broken on Android, always signal audio codec as AAC even if variant manifest states otherwise\n            if (audioCodec && audioCodec.indexOf(\"mp4a.40.5\") !== -1 && ua.indexOf(\"android\") !== -1 && audio.container !== \"audio/mpeg\") {\n                // Exclude mpeg audio\n                audioCodec = \"mp4a.40.2\";\n                this.log(`Android: force audio codec to ${audioCodec}`);\n            }\n            if (currentLevel.audioCodec && currentLevel.audioCodec !== audioCodec) {\n                this.log(`Swapping manifest audio codec \"${currentLevel.audioCodec}\" for \"${audioCodec}\"`);\n            }\n            audio.levelCodec = audioCodec;\n            audio.id = \"main\";\n            this.log(`Init audio buffer, container:${audio.container}, codecs[selected/level/parsed]=[${audioCodec || \"\"}/${currentLevel.audioCodec || \"\"}/${audio.codec}]`);\n        }\n        if (video) {\n            video.levelCodec = currentLevel.videoCodec;\n            video.id = \"main\";\n            this.log(`Init video buffer, container:${video.container}, codecs[level/parsed]=[${currentLevel.videoCodec || \"\"}/${video.codec}]`);\n        }\n        if (audiovideo) {\n            this.log(`Init audiovideo buffer, container:${audiovideo.container}, codecs[level/parsed]=[${currentLevel.codecs}/${audiovideo.codec}]`);\n        }\n        this.hls.trigger(Events.BUFFER_CODECS, tracks);\n        // loop through tracks that are going to be provided to bufferController\n        Object.keys(tracks).forEach((trackName)=>{\n            const track = tracks[trackName];\n            const initSegment = track.initSegment;\n            if (initSegment != null && initSegment.byteLength) {\n                this.hls.trigger(Events.BUFFER_APPENDING, {\n                    type: trackName,\n                    data: initSegment,\n                    frag,\n                    part: null,\n                    chunkMeta,\n                    parent: frag.type\n                });\n            }\n        });\n        // trigger handler right now\n        this.tickImmediate();\n    }\n    getMainFwdBufferInfo() {\n        return this.getFwdBufferInfo(this.mediaBuffer ? this.mediaBuffer : this.media, PlaylistLevelType.MAIN);\n    }\n    backtrack(frag) {\n        this.couldBacktrack = true;\n        // Causes findFragments to backtrack through fragments to find the keyframe\n        this.backtrackFragment = frag;\n        this.resetTransmuxer();\n        this.flushBufferGap(frag);\n        this.fragmentTracker.removeFragment(frag);\n        this.fragPrevious = null;\n        this.nextLoadPosition = frag.start;\n        this.state = State.IDLE;\n    }\n    checkFragmentChanged() {\n        const video = this.media;\n        let fragPlayingCurrent = null;\n        if (video && video.readyState > 1 && video.seeking === false) {\n            const currentTime = video.currentTime;\n            /* if video element is in seeked state, currentTime can only increase.\n        (assuming that playback rate is positive ...)\n        As sometimes currentTime jumps back to zero after a\n        media decode error, check this, to avoid seeking back to\n        wrong position after a media decode error\n      */ if (BufferHelper.isBuffered(video, currentTime)) {\n                fragPlayingCurrent = this.getAppendedFrag(currentTime);\n            } else if (BufferHelper.isBuffered(video, currentTime + 0.1)) {\n                /* ensure that FRAG_CHANGED event is triggered at startup,\n          when first video frame is displayed and playback is paused.\n          add a tolerance of 100ms, in case current position is not buffered,\n          check if current pos+100ms is buffered and use that buffer range\n          for FRAG_CHANGED event reporting */ fragPlayingCurrent = this.getAppendedFrag(currentTime + 0.1);\n            }\n            if (fragPlayingCurrent) {\n                this.backtrackFragment = null;\n                const fragPlaying = this.fragPlaying;\n                const fragCurrentLevel = fragPlayingCurrent.level;\n                if (!fragPlaying || fragPlayingCurrent.sn !== fragPlaying.sn || fragPlaying.level !== fragCurrentLevel) {\n                    this.fragPlaying = fragPlayingCurrent;\n                    this.hls.trigger(Events.FRAG_CHANGED, {\n                        frag: fragPlayingCurrent\n                    });\n                    if (!fragPlaying || fragPlaying.level !== fragCurrentLevel) {\n                        this.hls.trigger(Events.LEVEL_SWITCHED, {\n                            level: fragCurrentLevel\n                        });\n                    }\n                }\n            }\n        }\n    }\n    get nextLevel() {\n        const frag = this.nextBufferedFrag;\n        if (frag) {\n            return frag.level;\n        }\n        return -1;\n    }\n    get currentFrag() {\n        const media = this.media;\n        if (media) {\n            return this.fragPlaying || this.getAppendedFrag(media.currentTime);\n        }\n        return null;\n    }\n    get currentProgramDateTime() {\n        const media = this.media;\n        if (media) {\n            const currentTime = media.currentTime;\n            const frag = this.currentFrag;\n            if (frag && isFiniteNumber(currentTime) && isFiniteNumber(frag.programDateTime)) {\n                const epocMs = frag.programDateTime + (currentTime - frag.start) * 1000;\n                return new Date(epocMs);\n            }\n        }\n        return null;\n    }\n    get currentLevel() {\n        const frag = this.currentFrag;\n        if (frag) {\n            return frag.level;\n        }\n        return -1;\n    }\n    get nextBufferedFrag() {\n        const frag = this.currentFrag;\n        if (frag) {\n            return this.followingBufferedFrag(frag);\n        }\n        return null;\n    }\n    get forceStartLoad() {\n        return this._forceStartLoad;\n    }\n}\n/**\n * The `Hls` class is the core of the HLS.js library used to instantiate player instances.\n * @public\n */ class Hls {\n    /**\n   * Get the video-dev/hls.js package version.\n   */ static get version() {\n        return \"1.5.2\";\n    }\n    /**\n   * Check if the required MediaSource Extensions are available.\n   */ static isMSESupported() {\n        return isMSESupported();\n    }\n    /**\n   * Check if MediaSource Extensions are available and isTypeSupported checks pass for any baseline codecs.\n   */ static isSupported() {\n        return isSupported();\n    }\n    /**\n   * Get the MediaSource global used for MSE playback (ManagedMediaSource, MediaSource, or WebKitMediaSource).\n   */ static getMediaSource() {\n        return getMediaSource();\n    }\n    static get Events() {\n        return Events;\n    }\n    static get ErrorTypes() {\n        return ErrorTypes;\n    }\n    static get ErrorDetails() {\n        return ErrorDetails;\n    }\n    /**\n   * Get the default configuration applied to new instances.\n   */ static get DefaultConfig() {\n        if (!Hls.defaultConfig) {\n            return hlsDefaultConfig;\n        }\n        return Hls.defaultConfig;\n    }\n    /**\n   * Replace the default configuration applied to new instances.\n   */ static set DefaultConfig(defaultConfig) {\n        Hls.defaultConfig = defaultConfig;\n    }\n    /**\n   * Creates an instance of an HLS client that can attach to exactly one `HTMLMediaElement`.\n   * @param userConfig - Configuration options applied over `Hls.DefaultConfig`\n   */ constructor(userConfig = {}){\n        /**\n     * The runtime configuration used by the player. At instantiation this is combination of `hls.userConfig` merged over `Hls.DefaultConfig`.\n     */ this.config = void 0;\n        /**\n     * The configuration object provided on player instantiation.\n     */ this.userConfig = void 0;\n        this.coreComponents = void 0;\n        this.networkControllers = void 0;\n        this.started = false;\n        this._emitter = new EventEmitter();\n        this._autoLevelCapping = -1;\n        this._maxHdcpLevel = null;\n        this.abrController = void 0;\n        this.bufferController = void 0;\n        this.capLevelController = void 0;\n        this.latencyController = void 0;\n        this.levelController = void 0;\n        this.streamController = void 0;\n        this.audioTrackController = void 0;\n        this.subtitleTrackController = void 0;\n        this.emeController = void 0;\n        this.cmcdController = void 0;\n        this._media = null;\n        this.url = null;\n        this.triggeringException = void 0;\n        enableLogs(userConfig.debug || false, \"Hls instance\");\n        const config = this.config = mergeConfig(Hls.DefaultConfig, userConfig);\n        this.userConfig = userConfig;\n        if (config.progressive) {\n            enableStreamingMode(config);\n        }\n        // core controllers and network loaders\n        const { abrController: ConfigAbrController, bufferController: ConfigBufferController, capLevelController: ConfigCapLevelController, errorController: ConfigErrorController, fpsController: ConfigFpsController } = config;\n        const errorController = new ConfigErrorController(this);\n        const abrController = this.abrController = new ConfigAbrController(this);\n        const bufferController = this.bufferController = new ConfigBufferController(this);\n        const capLevelController = this.capLevelController = new ConfigCapLevelController(this);\n        const fpsController = new ConfigFpsController(this);\n        const playListLoader = new PlaylistLoader(this);\n        const id3TrackController = new ID3TrackController(this);\n        const ConfigContentSteeringController = config.contentSteeringController;\n        // ConentSteeringController is defined before LevelController to receive Multivariant Playlist events first\n        const contentSteering = ConfigContentSteeringController ? new ConfigContentSteeringController(this) : null;\n        const levelController = this.levelController = new LevelController(this, contentSteering);\n        // FragmentTracker must be defined before StreamController because the order of event handling is important\n        const fragmentTracker = new FragmentTracker(this);\n        const keyLoader = new KeyLoader(this.config);\n        const streamController = this.streamController = new StreamController(this, fragmentTracker, keyLoader);\n        // Cap level controller uses streamController to flush the buffer\n        capLevelController.setStreamController(streamController);\n        // fpsController uses streamController to switch when frames are being dropped\n        fpsController.setStreamController(streamController);\n        const networkControllers = [\n            playListLoader,\n            levelController,\n            streamController\n        ];\n        if (contentSteering) {\n            networkControllers.splice(1, 0, contentSteering);\n        }\n        this.networkControllers = networkControllers;\n        const coreComponents = [\n            abrController,\n            bufferController,\n            capLevelController,\n            fpsController,\n            id3TrackController,\n            fragmentTracker\n        ];\n        this.audioTrackController = this.createController(config.audioTrackController, networkControllers);\n        const AudioStreamControllerClass = config.audioStreamController;\n        if (AudioStreamControllerClass) {\n            networkControllers.push(new AudioStreamControllerClass(this, fragmentTracker, keyLoader));\n        }\n        // subtitleTrackController must be defined before subtitleStreamController because the order of event handling is important\n        this.subtitleTrackController = this.createController(config.subtitleTrackController, networkControllers);\n        const SubtitleStreamControllerClass = config.subtitleStreamController;\n        if (SubtitleStreamControllerClass) {\n            networkControllers.push(new SubtitleStreamControllerClass(this, fragmentTracker, keyLoader));\n        }\n        this.createController(config.timelineController, coreComponents);\n        keyLoader.emeController = this.emeController = this.createController(config.emeController, coreComponents);\n        this.cmcdController = this.createController(config.cmcdController, coreComponents);\n        this.latencyController = this.createController(LatencyController, coreComponents);\n        this.coreComponents = coreComponents;\n        // Error controller handles errors before and after all other controllers\n        // This listener will be invoked after all other controllers error listeners\n        networkControllers.push(errorController);\n        const onErrorOut = errorController.onErrorOut;\n        if (typeof onErrorOut === \"function\") {\n            this.on(Events.ERROR, onErrorOut, errorController);\n        }\n    }\n    createController(ControllerClass, components) {\n        if (ControllerClass) {\n            const controllerInstance = new ControllerClass(this);\n            if (components) {\n                components.push(controllerInstance);\n            }\n            return controllerInstance;\n        }\n        return null;\n    }\n    // Delegate the EventEmitter through the public API of Hls.js\n    on(event, listener, context = this) {\n        this._emitter.on(event, listener, context);\n    }\n    once(event, listener, context = this) {\n        this._emitter.once(event, listener, context);\n    }\n    removeAllListeners(event) {\n        this._emitter.removeAllListeners(event);\n    }\n    off(event, listener, context = this, once) {\n        this._emitter.off(event, listener, context, once);\n    }\n    listeners(event) {\n        return this._emitter.listeners(event);\n    }\n    emit(event, name, eventObject) {\n        return this._emitter.emit(event, name, eventObject);\n    }\n    trigger(event, eventObject) {\n        if (this.config.debug) {\n            return this.emit(event, event, eventObject);\n        } else {\n            try {\n                return this.emit(event, event, eventObject);\n            } catch (error) {\n                logger.error(\"An internal error happened while handling event \" + event + '. Error message: \"' + error.message + '\". Here is a stacktrace:', error);\n                // Prevent recursion in error event handlers that throw #5497\n                if (!this.triggeringException) {\n                    this.triggeringException = true;\n                    const fatal = event === Events.ERROR;\n                    this.trigger(Events.ERROR, {\n                        type: ErrorTypes.OTHER_ERROR,\n                        details: ErrorDetails.INTERNAL_EXCEPTION,\n                        fatal,\n                        event,\n                        error\n                    });\n                    this.triggeringException = false;\n                }\n            }\n        }\n        return false;\n    }\n    listenerCount(event) {\n        return this._emitter.listenerCount(event);\n    }\n    /**\n   * Dispose of the instance\n   */ destroy() {\n        logger.log(\"destroy\");\n        this.trigger(Events.DESTROYING, undefined);\n        this.detachMedia();\n        this.removeAllListeners();\n        this._autoLevelCapping = -1;\n        this.url = null;\n        this.networkControllers.forEach((component)=>component.destroy());\n        this.networkControllers.length = 0;\n        this.coreComponents.forEach((component)=>component.destroy());\n        this.coreComponents.length = 0;\n        // Remove any references that could be held in config options or callbacks\n        const config = this.config;\n        config.xhrSetup = config.fetchSetup = undefined;\n        // @ts-ignore\n        this.userConfig = null;\n    }\n    /**\n   * Attaches Hls.js to a media element\n   */ attachMedia(media) {\n        logger.log(\"attachMedia\");\n        this._media = media;\n        this.trigger(Events.MEDIA_ATTACHING, {\n            media: media\n        });\n    }\n    /**\n   * Detach Hls.js from the media\n   */ detachMedia() {\n        logger.log(\"detachMedia\");\n        this.trigger(Events.MEDIA_DETACHING, undefined);\n        this._media = null;\n    }\n    /**\n   * Set the source URL. Can be relative or absolute.\n   */ loadSource(url) {\n        this.stopLoad();\n        const media = this.media;\n        const loadedSource = this.url;\n        const loadingSource = this.url = urlToolkitExports.buildAbsoluteURL(self.location.href, url, {\n            alwaysNormalize: true\n        });\n        this._autoLevelCapping = -1;\n        this._maxHdcpLevel = null;\n        logger.log(`loadSource:${loadingSource}`);\n        if (media && loadedSource && (loadedSource !== loadingSource || this.bufferController.hasSourceTypes())) {\n            this.detachMedia();\n            this.attachMedia(media);\n        }\n        // when attaching to a source URL, trigger a playlist load\n        this.trigger(Events.MANIFEST_LOADING, {\n            url: url\n        });\n    }\n    /**\n   * Start loading data from the stream source.\n   * Depending on default config, client starts loading automatically when a source is set.\n   *\n   * @param startPosition - Set the start position to stream from.\n   * Defaults to -1 (None: starts from earliest point)\n   */ startLoad(startPosition = -1) {\n        logger.log(`startLoad(${startPosition})`);\n        this.started = true;\n        this.networkControllers.forEach((controller)=>{\n            controller.startLoad(startPosition);\n        });\n    }\n    /**\n   * Stop loading of any stream data.\n   */ stopLoad() {\n        logger.log(\"stopLoad\");\n        this.started = false;\n        this.networkControllers.forEach((controller)=>{\n            controller.stopLoad();\n        });\n    }\n    /**\n   * Resumes stream controller segment loading if previously started.\n   */ resumeBuffering() {\n        if (this.started) {\n            this.networkControllers.forEach((controller)=>{\n                if (\"fragmentLoader\" in controller) {\n                    controller.startLoad(-1);\n                }\n            });\n        }\n    }\n    /**\n   * Stops stream controller segment loading without changing 'started' state like stopLoad().\n   * This allows for media buffering to be paused without interupting playlist loading.\n   */ pauseBuffering() {\n        this.networkControllers.forEach((controller)=>{\n            if (\"fragmentLoader\" in controller) {\n                controller.stopLoad();\n            }\n        });\n    }\n    /**\n   * Swap through possible audio codecs in the stream (for example to switch from stereo to 5.1)\n   */ swapAudioCodec() {\n        logger.log(\"swapAudioCodec\");\n        this.streamController.swapAudioCodec();\n    }\n    /**\n   * When the media-element fails, this allows to detach and then re-attach it\n   * as one call (convenience method).\n   *\n   * Automatic recovery of media-errors by this process is configurable.\n   */ recoverMediaError() {\n        logger.log(\"recoverMediaError\");\n        const media = this._media;\n        this.detachMedia();\n        if (media) {\n            this.attachMedia(media);\n        }\n    }\n    removeLevel(levelIndex) {\n        this.levelController.removeLevel(levelIndex);\n    }\n    /**\n   * @returns an array of levels (variants) sorted by HDCP-LEVEL, RESOLUTION (height), FRAME-RATE, CODECS, VIDEO-RANGE, and BANDWIDTH\n   */ get levels() {\n        const levels = this.levelController.levels;\n        return levels ? levels : [];\n    }\n    /**\n   * Index of quality level (variant) currently played\n   */ get currentLevel() {\n        return this.streamController.currentLevel;\n    }\n    /**\n   * Set quality level index immediately. This will flush the current buffer to replace the quality asap. That means playback will interrupt at least shortly to re-buffer and re-sync eventually. Set to -1 for automatic level selection.\n   */ set currentLevel(newLevel) {\n        logger.log(`set currentLevel:${newLevel}`);\n        this.levelController.manualLevel = newLevel;\n        this.streamController.immediateLevelSwitch();\n    }\n    /**\n   * Index of next quality level loaded as scheduled by stream controller.\n   */ get nextLevel() {\n        return this.streamController.nextLevel;\n    }\n    /**\n   * Set quality level index for next loaded data.\n   * This will switch the video quality asap, without interrupting playback.\n   * May abort current loading of data, and flush parts of buffer (outside currently played fragment region).\n   * @param newLevel - Pass -1 for automatic level selection\n   */ set nextLevel(newLevel) {\n        logger.log(`set nextLevel:${newLevel}`);\n        this.levelController.manualLevel = newLevel;\n        this.streamController.nextLevelSwitch();\n    }\n    /**\n   * Return the quality level of the currently or last (of none is loaded currently) segment\n   */ get loadLevel() {\n        return this.levelController.level;\n    }\n    /**\n   * Set quality level index for next loaded data in a conservative way.\n   * This will switch the quality without flushing, but interrupt current loading.\n   * Thus the moment when the quality switch will appear in effect will only be after the already existing buffer.\n   * @param newLevel - Pass -1 for automatic level selection\n   */ set loadLevel(newLevel) {\n        logger.log(`set loadLevel:${newLevel}`);\n        this.levelController.manualLevel = newLevel;\n    }\n    /**\n   * get next quality level loaded\n   */ get nextLoadLevel() {\n        return this.levelController.nextLoadLevel;\n    }\n    /**\n   * Set quality level of next loaded segment in a fully \"non-destructive\" way.\n   * Same as `loadLevel` but will wait for next switch (until current loading is done).\n   */ set nextLoadLevel(level) {\n        this.levelController.nextLoadLevel = level;\n    }\n    /**\n   * Return \"first level\": like a default level, if not set,\n   * falls back to index of first level referenced in manifest\n   */ get firstLevel() {\n        return Math.max(this.levelController.firstLevel, this.minAutoLevel);\n    }\n    /**\n   * Sets \"first-level\", see getter.\n   */ set firstLevel(newLevel) {\n        logger.log(`set firstLevel:${newLevel}`);\n        this.levelController.firstLevel = newLevel;\n    }\n    /**\n   * Return the desired start level for the first fragment that will be loaded.\n   * The default value of -1 indicates automatic start level selection.\n   * Setting hls.nextAutoLevel without setting a startLevel will result in\n   * the nextAutoLevel value being used for one fragment load.\n   */ get startLevel() {\n        const startLevel = this.levelController.startLevel;\n        if (startLevel === -1 && this.abrController.forcedAutoLevel > -1) {\n            return this.abrController.forcedAutoLevel;\n        }\n        return startLevel;\n    }\n    /**\n   * set  start level (level of first fragment that will be played back)\n   * if not overrided by user, first level appearing in manifest will be used as start level\n   * if -1 : automatic start level selection, playback will start from level matching download bandwidth\n   * (determined from download of first segment)\n   */ set startLevel(newLevel) {\n        logger.log(`set startLevel:${newLevel}`);\n        // if not in automatic start level detection, ensure startLevel is greater than minAutoLevel\n        if (newLevel !== -1) {\n            newLevel = Math.max(newLevel, this.minAutoLevel);\n        }\n        this.levelController.startLevel = newLevel;\n    }\n    /**\n   * Whether level capping is enabled.\n   * Default value is set via `config.capLevelToPlayerSize`.\n   */ get capLevelToPlayerSize() {\n        return this.config.capLevelToPlayerSize;\n    }\n    /**\n   * Enables or disables level capping. If disabled after previously enabled, `nextLevelSwitch` will be immediately called.\n   */ set capLevelToPlayerSize(shouldStartCapping) {\n        const newCapLevelToPlayerSize = !!shouldStartCapping;\n        if (newCapLevelToPlayerSize !== this.config.capLevelToPlayerSize) {\n            if (newCapLevelToPlayerSize) {\n                this.capLevelController.startCapping(); // If capping occurs, nextLevelSwitch will happen based on size.\n            } else {\n                this.capLevelController.stopCapping();\n                this.autoLevelCapping = -1;\n                this.streamController.nextLevelSwitch(); // Now we're uncapped, get the next level asap.\n            }\n            this.config.capLevelToPlayerSize = newCapLevelToPlayerSize;\n        }\n    }\n    /**\n   * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)\n   */ get autoLevelCapping() {\n        return this._autoLevelCapping;\n    }\n    /**\n   * Returns the current bandwidth estimate in bits per second, when available. Otherwise, `NaN` is returned.\n   */ get bandwidthEstimate() {\n        const { bwEstimator } = this.abrController;\n        if (!bwEstimator) {\n            return NaN;\n        }\n        return bwEstimator.getEstimate();\n    }\n    set bandwidthEstimate(abrEwmaDefaultEstimate) {\n        this.abrController.resetEstimator(abrEwmaDefaultEstimate);\n    }\n    /**\n   * get time to first byte estimate\n   * @type {number}\n   */ get ttfbEstimate() {\n        const { bwEstimator } = this.abrController;\n        if (!bwEstimator) {\n            return NaN;\n        }\n        return bwEstimator.getEstimateTTFB();\n    }\n    /**\n   * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)\n   */ set autoLevelCapping(newLevel) {\n        if (this._autoLevelCapping !== newLevel) {\n            logger.log(`set autoLevelCapping:${newLevel}`);\n            this._autoLevelCapping = newLevel;\n            this.levelController.checkMaxAutoUpdated();\n        }\n    }\n    get maxHdcpLevel() {\n        return this._maxHdcpLevel;\n    }\n    set maxHdcpLevel(value) {\n        if (isHdcpLevel(value) && this._maxHdcpLevel !== value) {\n            this._maxHdcpLevel = value;\n            this.levelController.checkMaxAutoUpdated();\n        }\n    }\n    /**\n   * True when automatic level selection enabled\n   */ get autoLevelEnabled() {\n        return this.levelController.manualLevel === -1;\n    }\n    /**\n   * Level set manually (if any)\n   */ get manualLevel() {\n        return this.levelController.manualLevel;\n    }\n    /**\n   * min level selectable in auto mode according to config.minAutoBitrate\n   */ get minAutoLevel() {\n        const { levels, config: { minAutoBitrate } } = this;\n        if (!levels) return 0;\n        const len = levels.length;\n        for(let i = 0; i < len; i++){\n            if (levels[i].maxBitrate >= minAutoBitrate) {\n                return i;\n            }\n        }\n        return 0;\n    }\n    /**\n   * max level selectable in auto mode according to autoLevelCapping\n   */ get maxAutoLevel() {\n        const { levels, autoLevelCapping, maxHdcpLevel } = this;\n        let maxAutoLevel;\n        if (autoLevelCapping === -1 && levels != null && levels.length) {\n            maxAutoLevel = levels.length - 1;\n        } else {\n            maxAutoLevel = autoLevelCapping;\n        }\n        if (maxHdcpLevel) {\n            for(let i = maxAutoLevel; i--;){\n                const hdcpLevel = levels[i].attrs[\"HDCP-LEVEL\"];\n                if (hdcpLevel && hdcpLevel <= maxHdcpLevel) {\n                    return i;\n                }\n            }\n        }\n        return maxAutoLevel;\n    }\n    get firstAutoLevel() {\n        return this.abrController.firstAutoLevel;\n    }\n    /**\n   * next automatically selected quality level\n   */ get nextAutoLevel() {\n        return this.abrController.nextAutoLevel;\n    }\n    /**\n   * this setter is used to force next auto level.\n   * this is useful to force a switch down in auto mode:\n   * in case of load error on level N, hls.js can set nextAutoLevel to N-1 for example)\n   * forced value is valid for one fragment. upon successful frag loading at forced level,\n   * this value will be resetted to -1 by ABR controller.\n   */ set nextAutoLevel(nextLevel) {\n        this.abrController.nextAutoLevel = nextLevel;\n    }\n    /**\n   * get the datetime value relative to media.currentTime for the active level Program Date Time if present\n   */ get playingDate() {\n        return this.streamController.currentProgramDateTime;\n    }\n    get mainForwardBufferInfo() {\n        return this.streamController.getMainFwdBufferInfo();\n    }\n    /**\n   * Find and select the best matching audio track, making a level switch when a Group change is necessary.\n   * Updates `hls.config.audioPreference`. Returns the selected track, or null when no matching track is found.\n   */ setAudioOption(audioOption) {\n        var _this$audioTrackContr;\n        return (_this$audioTrackContr = this.audioTrackController) == null ? void 0 : _this$audioTrackContr.setAudioOption(audioOption);\n    }\n    /**\n   * Find and select the best matching subtitle track, making a level switch when a Group change is necessary.\n   * Updates `hls.config.subtitlePreference`. Returns the selected track, or null when no matching track is found.\n   */ setSubtitleOption(subtitleOption) {\n        var _this$subtitleTrackCo;\n        (_this$subtitleTrackCo = this.subtitleTrackController) == null ? void 0 : _this$subtitleTrackCo.setSubtitleOption(subtitleOption);\n        return null;\n    }\n    /**\n   * Get the complete list of audio tracks across all media groups\n   */ get allAudioTracks() {\n        const audioTrackController = this.audioTrackController;\n        return audioTrackController ? audioTrackController.allAudioTracks : [];\n    }\n    /**\n   * Get the list of selectable audio tracks\n   */ get audioTracks() {\n        const audioTrackController = this.audioTrackController;\n        return audioTrackController ? audioTrackController.audioTracks : [];\n    }\n    /**\n   * index of the selected audio track (index in audio track lists)\n   */ get audioTrack() {\n        const audioTrackController = this.audioTrackController;\n        return audioTrackController ? audioTrackController.audioTrack : -1;\n    }\n    /**\n   * selects an audio track, based on its index in audio track lists\n   */ set audioTrack(audioTrackId) {\n        const audioTrackController = this.audioTrackController;\n        if (audioTrackController) {\n            audioTrackController.audioTrack = audioTrackId;\n        }\n    }\n    /**\n   * get the complete list of subtitle tracks across all media groups\n   */ get allSubtitleTracks() {\n        const subtitleTrackController = this.subtitleTrackController;\n        return subtitleTrackController ? subtitleTrackController.allSubtitleTracks : [];\n    }\n    /**\n   * get alternate subtitle tracks list from playlist\n   */ get subtitleTracks() {\n        const subtitleTrackController = this.subtitleTrackController;\n        return subtitleTrackController ? subtitleTrackController.subtitleTracks : [];\n    }\n    /**\n   * index of the selected subtitle track (index in subtitle track lists)\n   */ get subtitleTrack() {\n        const subtitleTrackController = this.subtitleTrackController;\n        return subtitleTrackController ? subtitleTrackController.subtitleTrack : -1;\n    }\n    get media() {\n        return this._media;\n    }\n    /**\n   * select an subtitle track, based on its index in subtitle track lists\n   */ set subtitleTrack(subtitleTrackId) {\n        const subtitleTrackController = this.subtitleTrackController;\n        if (subtitleTrackController) {\n            subtitleTrackController.subtitleTrack = subtitleTrackId;\n        }\n    }\n    /**\n   * Whether subtitle display is enabled or not\n   */ get subtitleDisplay() {\n        const subtitleTrackController = this.subtitleTrackController;\n        return subtitleTrackController ? subtitleTrackController.subtitleDisplay : false;\n    }\n    /**\n   * Enable/disable subtitle display rendering\n   */ set subtitleDisplay(value) {\n        const subtitleTrackController = this.subtitleTrackController;\n        if (subtitleTrackController) {\n            subtitleTrackController.subtitleDisplay = value;\n        }\n    }\n    /**\n   * get mode for Low-Latency HLS loading\n   */ get lowLatencyMode() {\n        return this.config.lowLatencyMode;\n    }\n    /**\n   * Enable/disable Low-Latency HLS part playlist and segment loading, and start live streams at playlist PART-HOLD-BACK rather than HOLD-BACK.\n   */ set lowLatencyMode(mode) {\n        this.config.lowLatencyMode = mode;\n    }\n    /**\n   * Position (in seconds) of live sync point (ie edge of live position minus safety delay defined by ```hls.config.liveSyncDuration```)\n   * @returns null prior to loading live Playlist\n   */ get liveSyncPosition() {\n        return this.latencyController.liveSyncPosition;\n    }\n    /**\n   * Estimated position (in seconds) of live edge (ie edge of live playlist plus time sync playlist advanced)\n   * @returns 0 before first playlist is loaded\n   */ get latency() {\n        return this.latencyController.latency;\n    }\n    /**\n   * maximum distance from the edge before the player seeks forward to ```hls.liveSyncPosition```\n   * configured using ```liveMaxLatencyDurationCount``` (multiple of target duration) or ```liveMaxLatencyDuration```\n   * @returns 0 before first playlist is loaded\n   */ get maxLatency() {\n        return this.latencyController.maxLatency;\n    }\n    /**\n   * target distance from the edge as calculated by the latency controller\n   */ get targetLatency() {\n        return this.latencyController.targetLatency;\n    }\n    /**\n   * the rate at which the edge of the current live playlist is advancing or 1 if there is none\n   */ get drift() {\n        return this.latencyController.drift;\n    }\n    /**\n   * set to true when startLoad is called before MANIFEST_PARSED event\n   */ get forceStartLoad() {\n        return this.streamController.forceStartLoad;\n    }\n}\nHls.defaultConfig = void 0;\n //# sourceMappingURL=hls.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaGxzLmpzL2Rpc3QvaGxzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLFNBQVNBLHdCQUF5QkMsQ0FBQztJQUNsQyxPQUFPQSxLQUFLQSxFQUFFQyxVQUFVLElBQUlDLE9BQU9DLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNMLEdBQUcsYUFBYUEsQ0FBQyxDQUFDLFVBQVUsR0FBR0E7QUFDakc7QUFFQSxJQUFJTSxhQUFhO0lBQUNDLFNBQVMsQ0FBQztBQUFDO0FBRTVCLFVBQVVDLE1BQU0sRUFBRUQsT0FBTztJQUN6QiwwQ0FBMEM7SUFFekMsVUFBVUUsSUFBSTtRQUNiLElBQUlDLFlBQ0Y7UUFDRixJQUFJQyxzQkFBc0I7UUFDMUIsSUFBSUMsa0JBQWtCO1FBQ3RCLElBQUlDLHNCQUFzQjtRQUUxQixJQUFJQyxhQUFhO1lBQ2YsMkdBQTJHO1lBQzNHLE1BQU07WUFDTiw4REFBOEQ7WUFDOUQseURBQXlEO1lBQ3pELHdEQUF3RDtZQUN4RCxvREFBb0Q7WUFDcERDLGtCQUFrQixTQUFVQyxPQUFPLEVBQUVDLFdBQVcsRUFBRUMsSUFBSTtnQkFDcERBLE9BQU9BLFFBQVEsQ0FBQztnQkFDaEIsc0NBQXNDO2dCQUN0Q0YsVUFBVUEsUUFBUUcsSUFBSTtnQkFDdEJGLGNBQWNBLFlBQVlFLElBQUk7Z0JBQzlCLElBQUksQ0FBQ0YsYUFBYTtvQkFDaEIsNkRBQTZEO29CQUM3RCx1REFBdUQ7b0JBQ3ZELG1CQUFtQjtvQkFDbkIsSUFBSSxDQUFDQyxLQUFLRSxlQUFlLEVBQUU7d0JBQ3pCLE9BQU9KO29CQUNUO29CQUNBLElBQUlLLHdCQUF3QlAsV0FBV1EsUUFBUSxDQUFDTjtvQkFDaEQsSUFBSSxDQUFDSyx1QkFBdUI7d0JBQzFCLE1BQU0sSUFBSUUsTUFBTTtvQkFDbEI7b0JBQ0FGLHNCQUFzQkcsSUFBSSxHQUFHVixXQUFXVyxhQUFhLENBQ25E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b0IsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmlkeC8uL25vZGVfbW9kdWxlcy9obHMuanMvZGlzdC9obHMubWpzPzQ3MWYiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMgKHgpIHtcblx0cmV0dXJuIHggJiYgeC5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnZGVmYXVsdCcpID8geFsnZGVmYXVsdCddIDogeDtcbn1cblxudmFyIHVybFRvb2xraXQgPSB7ZXhwb3J0czoge319O1xuXG4oZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHQvLyBzZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzE4MDhcblxuXHQoZnVuY3Rpb24gKHJvb3QpIHtcblx0ICB2YXIgVVJMX1JFR0VYID1cblx0ICAgIC9eKD89KCg/OlthLXpBLVowLTkrXFwtLl0rOik/KSlcXDEoPz0oKD86XFwvXFwvW15cXC8/I10qKT8pKVxcMig/PSgoPzooPzpbXj8jXFwvXSpcXC8pKlteOz8jXFwvXSopPykpXFwzKCg/OjtbXj8jXSopPykoXFw/W14jXSopPygjW15dKik/JC87XG5cdCAgdmFyIEZJUlNUX1NFR01FTlRfUkVHRVggPSAvXig/PShbXlxcLz8jXSopKVxcMShbXl0qKSQvO1xuXHQgIHZhciBTTEFTSF9ET1RfUkVHRVggPSAvKD86XFwvfF4pXFwuKD89XFwvKS9nO1xuXHQgIHZhciBTTEFTSF9ET1RfRE9UX1JFR0VYID0gLyg/OlxcL3xeKVxcLlxcLlxcLyg/IVxcLlxcLlxcLylbXlxcL10qKD89XFwvKS9nO1xuXG5cdCAgdmFyIFVSTFRvb2xraXQgPSB7XG5cdCAgICAvLyBJZiBvcHRzLmFsd2F5c05vcm1hbGl6ZSBpcyB0cnVlIHRoZW4gdGhlIHBhdGggd2lsbCBhbHdheXMgYmUgbm9ybWFsaXplZCBldmVuIHdoZW4gaXQgc3RhcnRzIHdpdGggLyBvciAvL1xuXHQgICAgLy8gRS5nXG5cdCAgICAvLyBXaXRoIG9wdHMuYWx3YXlzTm9ybWFsaXplID0gZmFsc2UgKGRlZmF1bHQsIHNwZWMgY29tcGxpYW50KVxuXHQgICAgLy8gaHR0cDovL2EuY29tL2IvY2QgKyAvZS9mLy4uL2cgPT4gaHR0cDovL2EuY29tL2UvZi8uLi9nXG5cdCAgICAvLyBXaXRoIG9wdHMuYWx3YXlzTm9ybWFsaXplID0gdHJ1ZSAobm90IHNwZWMgY29tcGxpYW50KVxuXHQgICAgLy8gaHR0cDovL2EuY29tL2IvY2QgKyAvZS9mLy4uL2cgPT4gaHR0cDovL2EuY29tL2UvZ1xuXHQgICAgYnVpbGRBYnNvbHV0ZVVSTDogZnVuY3Rpb24gKGJhc2VVUkwsIHJlbGF0aXZlVVJMLCBvcHRzKSB7XG5cdCAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXHQgICAgICAvLyByZW1vdmUgYW55IHJlbWFpbmluZyBzcGFjZSBhbmQgQ1JMRlxuXHQgICAgICBiYXNlVVJMID0gYmFzZVVSTC50cmltKCk7XG5cdCAgICAgIHJlbGF0aXZlVVJMID0gcmVsYXRpdmVVUkwudHJpbSgpO1xuXHQgICAgICBpZiAoIXJlbGF0aXZlVVJMKSB7XG5cdCAgICAgICAgLy8gMmEpIElmIHRoZSBlbWJlZGRlZCBVUkwgaXMgZW50aXJlbHkgZW1wdHksIGl0IGluaGVyaXRzIHRoZVxuXHQgICAgICAgIC8vIGVudGlyZSBiYXNlIFVSTCAoaS5lLiwgaXMgc2V0IGVxdWFsIHRvIHRoZSBiYXNlIFVSTClcblx0ICAgICAgICAvLyBhbmQgd2UgYXJlIGRvbmUuXG5cdCAgICAgICAgaWYgKCFvcHRzLmFsd2F5c05vcm1hbGl6ZSkge1xuXHQgICAgICAgICAgcmV0dXJuIGJhc2VVUkw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBiYXNlUGFydHNGb3JOb3JtYWxpc2UgPSBVUkxUb29sa2l0LnBhcnNlVVJMKGJhc2VVUkwpO1xuXHQgICAgICAgIGlmICghYmFzZVBhcnRzRm9yTm9ybWFsaXNlKSB7XG5cdCAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIHRyeWluZyB0byBwYXJzZSBiYXNlIFVSTC4nKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgYmFzZVBhcnRzRm9yTm9ybWFsaXNlLnBhdGggPSBVUkxUb29sa2l0Lm5vcm1hbGl6ZVBhdGgoXG5cdCAgICAgICAgICBiYXNlUGFydHNGb3JOb3JtYWxpc2UucGF0aFxuXHQgICAgICAgICk7XG5cdCAgICAgICAgcmV0dXJuIFVSTFRvb2xraXQuYnVpbGRVUkxGcm9tUGFydHMoYmFzZVBhcnRzRm9yTm9ybWFsaXNlKTtcblx0ICAgICAgfVxuXHQgICAgICB2YXIgcmVsYXRpdmVQYXJ0cyA9IFVSTFRvb2xraXQucGFyc2VVUkwocmVsYXRpdmVVUkwpO1xuXHQgICAgICBpZiAoIXJlbGF0aXZlUGFydHMpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIHRyeWluZyB0byBwYXJzZSByZWxhdGl2ZSBVUkwuJyk7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHJlbGF0aXZlUGFydHMuc2NoZW1lKSB7XG5cdCAgICAgICAgLy8gMmIpIElmIHRoZSBlbWJlZGRlZCBVUkwgc3RhcnRzIHdpdGggYSBzY2hlbWUgbmFtZSwgaXQgaXNcblx0ICAgICAgICAvLyBpbnRlcnByZXRlZCBhcyBhbiBhYnNvbHV0ZSBVUkwgYW5kIHdlIGFyZSBkb25lLlxuXHQgICAgICAgIGlmICghb3B0cy5hbHdheXNOb3JtYWxpemUpIHtcblx0ICAgICAgICAgIHJldHVybiByZWxhdGl2ZVVSTDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmVsYXRpdmVQYXJ0cy5wYXRoID0gVVJMVG9vbGtpdC5ub3JtYWxpemVQYXRoKHJlbGF0aXZlUGFydHMucGF0aCk7XG5cdCAgICAgICAgcmV0dXJuIFVSTFRvb2xraXQuYnVpbGRVUkxGcm9tUGFydHMocmVsYXRpdmVQYXJ0cyk7XG5cdCAgICAgIH1cblx0ICAgICAgdmFyIGJhc2VQYXJ0cyA9IFVSTFRvb2xraXQucGFyc2VVUkwoYmFzZVVSTCk7XG5cdCAgICAgIGlmICghYmFzZVBhcnRzKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciB0cnlpbmcgdG8gcGFyc2UgYmFzZSBVUkwuJyk7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKCFiYXNlUGFydHMubmV0TG9jICYmIGJhc2VQYXJ0cy5wYXRoICYmIGJhc2VQYXJ0cy5wYXRoWzBdICE9PSAnLycpIHtcblx0ICAgICAgICAvLyBJZiBuZXRMb2MgbWlzc2luZyBhbmQgcGF0aCBkb2Vzbid0IHN0YXJ0IHdpdGggJy8nLCBhc3N1bWUgZXZlcnRoaW5nIGJlZm9yZSB0aGUgZmlyc3QgJy8nIGlzIHRoZSBuZXRMb2Ncblx0ICAgICAgICAvLyBUaGlzIGNhdXNlcyAnZXhhbXBsZS5jb20vYScgdG8gYmUgaGFuZGxlZCBhcyAnLy9leGFtcGxlLmNvbS9hJyBpbnN0ZWFkIG9mICcvZXhhbXBsZS5jb20vYSdcblx0ICAgICAgICB2YXIgcGF0aFBhcnRzID0gRklSU1RfU0VHTUVOVF9SRUdFWC5leGVjKGJhc2VQYXJ0cy5wYXRoKTtcblx0ICAgICAgICBiYXNlUGFydHMubmV0TG9jID0gcGF0aFBhcnRzWzFdO1xuXHQgICAgICAgIGJhc2VQYXJ0cy5wYXRoID0gcGF0aFBhcnRzWzJdO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChiYXNlUGFydHMubmV0TG9jICYmICFiYXNlUGFydHMucGF0aCkge1xuXHQgICAgICAgIGJhc2VQYXJ0cy5wYXRoID0gJy8nO1xuXHQgICAgICB9XG5cdCAgICAgIHZhciBidWlsdFBhcnRzID0ge1xuXHQgICAgICAgIC8vIDJjKSBPdGhlcndpc2UsIHRoZSBlbWJlZGRlZCBVUkwgaW5oZXJpdHMgdGhlIHNjaGVtZSBvZlxuXHQgICAgICAgIC8vIHRoZSBiYXNlIFVSTC5cblx0ICAgICAgICBzY2hlbWU6IGJhc2VQYXJ0cy5zY2hlbWUsXG5cdCAgICAgICAgbmV0TG9jOiByZWxhdGl2ZVBhcnRzLm5ldExvYyxcblx0ICAgICAgICBwYXRoOiBudWxsLFxuXHQgICAgICAgIHBhcmFtczogcmVsYXRpdmVQYXJ0cy5wYXJhbXMsXG5cdCAgICAgICAgcXVlcnk6IHJlbGF0aXZlUGFydHMucXVlcnksXG5cdCAgICAgICAgZnJhZ21lbnQ6IHJlbGF0aXZlUGFydHMuZnJhZ21lbnQsXG5cdCAgICAgIH07XG5cdCAgICAgIGlmICghcmVsYXRpdmVQYXJ0cy5uZXRMb2MpIHtcblx0ICAgICAgICAvLyAzKSBJZiB0aGUgZW1iZWRkZWQgVVJMJ3MgPG5ldF9sb2M+IGlzIG5vbi1lbXB0eSwgd2Ugc2tpcCB0b1xuXHQgICAgICAgIC8vIFN0ZXAgNy4gIE90aGVyd2lzZSwgdGhlIGVtYmVkZGVkIFVSTCBpbmhlcml0cyB0aGUgPG5ldF9sb2M+XG5cdCAgICAgICAgLy8gKGlmIGFueSkgb2YgdGhlIGJhc2UgVVJMLlxuXHQgICAgICAgIGJ1aWx0UGFydHMubmV0TG9jID0gYmFzZVBhcnRzLm5ldExvYztcblx0ICAgICAgICAvLyA0KSBJZiB0aGUgZW1iZWRkZWQgVVJMIHBhdGggaXMgcHJlY2VkZWQgYnkgYSBzbGFzaCBcIi9cIiwgdGhlXG5cdCAgICAgICAgLy8gcGF0aCBpcyBub3QgcmVsYXRpdmUgYW5kIHdlIHNraXAgdG8gU3RlcCA3LlxuXHQgICAgICAgIGlmIChyZWxhdGl2ZVBhcnRzLnBhdGhbMF0gIT09ICcvJykge1xuXHQgICAgICAgICAgaWYgKCFyZWxhdGl2ZVBhcnRzLnBhdGgpIHtcblx0ICAgICAgICAgICAgLy8gNSkgSWYgdGhlIGVtYmVkZGVkIFVSTCBwYXRoIGlzIGVtcHR5IChhbmQgbm90IHByZWNlZGVkIGJ5IGFcblx0ICAgICAgICAgICAgLy8gc2xhc2gpLCB0aGVuIHRoZSBlbWJlZGRlZCBVUkwgaW5oZXJpdHMgdGhlIGJhc2UgVVJMIHBhdGhcblx0ICAgICAgICAgICAgYnVpbHRQYXJ0cy5wYXRoID0gYmFzZVBhcnRzLnBhdGg7XG5cdCAgICAgICAgICAgIC8vIDVhKSBpZiB0aGUgZW1iZWRkZWQgVVJMJ3MgPHBhcmFtcz4gaXMgbm9uLWVtcHR5LCB3ZSBza2lwIHRvXG5cdCAgICAgICAgICAgIC8vIHN0ZXAgNzsgb3RoZXJ3aXNlLCBpdCBpbmhlcml0cyB0aGUgPHBhcmFtcz4gb2YgdGhlIGJhc2Vcblx0ICAgICAgICAgICAgLy8gVVJMIChpZiBhbnkpIGFuZFxuXHQgICAgICAgICAgICBpZiAoIXJlbGF0aXZlUGFydHMucGFyYW1zKSB7XG5cdCAgICAgICAgICAgICAgYnVpbHRQYXJ0cy5wYXJhbXMgPSBiYXNlUGFydHMucGFyYW1zO1xuXHQgICAgICAgICAgICAgIC8vIDViKSBpZiB0aGUgZW1iZWRkZWQgVVJMJ3MgPHF1ZXJ5PiBpcyBub24tZW1wdHksIHdlIHNraXAgdG9cblx0ICAgICAgICAgICAgICAvLyBzdGVwIDc7IG90aGVyd2lzZSwgaXQgaW5oZXJpdHMgdGhlIDxxdWVyeT4gb2YgdGhlIGJhc2Vcblx0ICAgICAgICAgICAgICAvLyBVUkwgKGlmIGFueSkgYW5kIHdlIHNraXAgdG8gc3RlcCA3LlxuXHQgICAgICAgICAgICAgIGlmICghcmVsYXRpdmVQYXJ0cy5xdWVyeSkge1xuXHQgICAgICAgICAgICAgICAgYnVpbHRQYXJ0cy5xdWVyeSA9IGJhc2VQYXJ0cy5xdWVyeTtcblx0ICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIC8vIDYpIFRoZSBsYXN0IHNlZ21lbnQgb2YgdGhlIGJhc2UgVVJMJ3MgcGF0aCAoYW55dGhpbmdcblx0ICAgICAgICAgICAgLy8gZm9sbG93aW5nIHRoZSByaWdodG1vc3Qgc2xhc2ggXCIvXCIsIG9yIHRoZSBlbnRpcmUgcGF0aCBpZiBub1xuXHQgICAgICAgICAgICAvLyBzbGFzaCBpcyBwcmVzZW50KSBpcyByZW1vdmVkIGFuZCB0aGUgZW1iZWRkZWQgVVJMJ3MgcGF0aCBpc1xuXHQgICAgICAgICAgICAvLyBhcHBlbmRlZCBpbiBpdHMgcGxhY2UuXG5cdCAgICAgICAgICAgIHZhciBiYXNlVVJMUGF0aCA9IGJhc2VQYXJ0cy5wYXRoO1xuXHQgICAgICAgICAgICB2YXIgbmV3UGF0aCA9XG5cdCAgICAgICAgICAgICAgYmFzZVVSTFBhdGguc3Vic3RyaW5nKDAsIGJhc2VVUkxQYXRoLmxhc3RJbmRleE9mKCcvJykgKyAxKSArXG5cdCAgICAgICAgICAgICAgcmVsYXRpdmVQYXJ0cy5wYXRoO1xuXHQgICAgICAgICAgICBidWlsdFBhcnRzLnBhdGggPSBVUkxUb29sa2l0Lm5vcm1hbGl6ZVBhdGgobmV3UGF0aCk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIGlmIChidWlsdFBhcnRzLnBhdGggPT09IG51bGwpIHtcblx0ICAgICAgICBidWlsdFBhcnRzLnBhdGggPSBvcHRzLmFsd2F5c05vcm1hbGl6ZVxuXHQgICAgICAgICAgPyBVUkxUb29sa2l0Lm5vcm1hbGl6ZVBhdGgocmVsYXRpdmVQYXJ0cy5wYXRoKVxuXHQgICAgICAgICAgOiByZWxhdGl2ZVBhcnRzLnBhdGg7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIFVSTFRvb2xraXQuYnVpbGRVUkxGcm9tUGFydHMoYnVpbHRQYXJ0cyk7XG5cdCAgICB9LFxuXHQgICAgcGFyc2VVUkw6IGZ1bmN0aW9uICh1cmwpIHtcblx0ICAgICAgdmFyIHBhcnRzID0gVVJMX1JFR0VYLmV4ZWModXJsKTtcblx0ICAgICAgaWYgKCFwYXJ0cykge1xuXHQgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiB7XG5cdCAgICAgICAgc2NoZW1lOiBwYXJ0c1sxXSB8fCAnJyxcblx0ICAgICAgICBuZXRMb2M6IHBhcnRzWzJdIHx8ICcnLFxuXHQgICAgICAgIHBhdGg6IHBhcnRzWzNdIHx8ICcnLFxuXHQgICAgICAgIHBhcmFtczogcGFydHNbNF0gfHwgJycsXG5cdCAgICAgICAgcXVlcnk6IHBhcnRzWzVdIHx8ICcnLFxuXHQgICAgICAgIGZyYWdtZW50OiBwYXJ0c1s2XSB8fCAnJyxcblx0ICAgICAgfTtcblx0ICAgIH0sXG5cdCAgICBub3JtYWxpemVQYXRoOiBmdW5jdGlvbiAocGF0aCkge1xuXHQgICAgICAvLyBUaGUgZm9sbG93aW5nIG9wZXJhdGlvbnMgYXJlXG5cdCAgICAgIC8vIHRoZW4gYXBwbGllZCwgaW4gb3JkZXIsIHRvIHRoZSBuZXcgcGF0aDpcblx0ICAgICAgLy8gNmEpIEFsbCBvY2N1cnJlbmNlcyBvZiBcIi4vXCIsIHdoZXJlIFwiLlwiIGlzIGEgY29tcGxldGUgcGF0aFxuXHQgICAgICAvLyBzZWdtZW50LCBhcmUgcmVtb3ZlZC5cblx0ICAgICAgLy8gNmIpIElmIHRoZSBwYXRoIGVuZHMgd2l0aCBcIi5cIiBhcyBhIGNvbXBsZXRlIHBhdGggc2VnbWVudCxcblx0ICAgICAgLy8gdGhhdCBcIi5cIiBpcyByZW1vdmVkLlxuXHQgICAgICBwYXRoID0gcGF0aC5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpLnJlcGxhY2UoU0xBU0hfRE9UX1JFR0VYLCAnJyk7XG5cdCAgICAgIC8vIDZjKSBBbGwgb2NjdXJyZW5jZXMgb2YgXCI8c2VnbWVudD4vLi4vXCIsIHdoZXJlIDxzZWdtZW50PiBpcyBhXG5cdCAgICAgIC8vIGNvbXBsZXRlIHBhdGggc2VnbWVudCBub3QgZXF1YWwgdG8gXCIuLlwiLCBhcmUgcmVtb3ZlZC5cblx0ICAgICAgLy8gUmVtb3ZhbCBvZiB0aGVzZSBwYXRoIHNlZ21lbnRzIGlzIHBlcmZvcm1lZCBpdGVyYXRpdmVseSxcblx0ICAgICAgLy8gcmVtb3ZpbmcgdGhlIGxlZnRtb3N0IG1hdGNoaW5nIHBhdHRlcm4gb24gZWFjaCBpdGVyYXRpb24sXG5cdCAgICAgIC8vIHVudGlsIG5vIG1hdGNoaW5nIHBhdHRlcm4gcmVtYWlucy5cblx0ICAgICAgLy8gNmQpIElmIHRoZSBwYXRoIGVuZHMgd2l0aCBcIjxzZWdtZW50Pi8uLlwiLCB3aGVyZSA8c2VnbWVudD4gaXMgYVxuXHQgICAgICAvLyBjb21wbGV0ZSBwYXRoIHNlZ21lbnQgbm90IGVxdWFsIHRvIFwiLi5cIiwgdGhhdFxuXHQgICAgICAvLyBcIjxzZWdtZW50Pi8uLlwiIGlzIHJlbW92ZWQuXG5cdCAgICAgIHdoaWxlIChcblx0ICAgICAgICBwYXRoLmxlbmd0aCAhPT0gKHBhdGggPSBwYXRoLnJlcGxhY2UoU0xBU0hfRE9UX0RPVF9SRUdFWCwgJycpKS5sZW5ndGhcblx0ICAgICAgKSB7fVxuXHQgICAgICByZXR1cm4gcGF0aC5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpO1xuXHQgICAgfSxcblx0ICAgIGJ1aWxkVVJMRnJvbVBhcnRzOiBmdW5jdGlvbiAocGFydHMpIHtcblx0ICAgICAgcmV0dXJuIChcblx0ICAgICAgICBwYXJ0cy5zY2hlbWUgK1xuXHQgICAgICAgIHBhcnRzLm5ldExvYyArXG5cdCAgICAgICAgcGFydHMucGF0aCArXG5cdCAgICAgICAgcGFydHMucGFyYW1zICtcblx0ICAgICAgICBwYXJ0cy5xdWVyeSArXG5cdCAgICAgICAgcGFydHMuZnJhZ21lbnRcblx0ICAgICAgKTtcblx0ICAgIH0sXG5cdCAgfTtcblxuXHQgIG1vZHVsZS5leHBvcnRzID0gVVJMVG9vbGtpdDtcblx0fSkoKTsgXG59ICh1cmxUb29sa2l0KSk7XG5cbnZhciB1cmxUb29sa2l0RXhwb3J0cyA9IHVybFRvb2xraXQuZXhwb3J0cztcblxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7XG4gIHZhciB0ID0gT2JqZWN0LmtleXMoZSk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO1xuICAgIHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTtcbiAgICB9KSksIHQucHVzaC5hcHBseSh0LCBvKTtcbiAgfVxuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKGUpIHtcbiAgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHtcbiAgICB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307XG4gICAgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTtcbiAgICB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7XG4gIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiB0IHx8ICF0KSByZXR1cm4gdDtcbiAgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmICh2b2lkIDAgIT09IGUpIHtcbiAgICB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgaSkgcmV0dXJuIGk7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7XG59XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7XG4gIHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gXCJzeW1ib2xcIiA9PSB0eXBlb2YgaSA/IGkgOiBTdHJpbmcoaSk7XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuLy8gaHR0cHM6Ly9jYW5pdXNlLmNvbS9tZG4tamF2YXNjcmlwdF9idWlsdGluc19udW1iZXJfaXNmaW5pdGVcbmNvbnN0IGlzRmluaXRlTnVtYmVyID0gTnVtYmVyLmlzRmluaXRlIHx8IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWx1ZSk7XG59O1xuXG4vLyBodHRwczovL2Nhbml1c2UuY29tL21kbi1qYXZhc2NyaXB0X2J1aWx0aW5zX251bWJlcl9pc3NhZmVpbnRlZ2VyXG5jb25zdCBpc1NhZmVJbnRlZ2VyID0gTnVtYmVyLmlzU2FmZUludGVnZXIgfHwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIE1hdGguYWJzKHZhbHVlKSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufTtcbmNvbnN0IE1BWF9TQUZFX0lOVEVHRVIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCA5MDA3MTk5MjU0NzQwOTkxO1xuXG5sZXQgRXZlbnRzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChFdmVudHMpIHtcbiAgRXZlbnRzW1wiTUVESUFfQVRUQUNISU5HXCJdID0gXCJobHNNZWRpYUF0dGFjaGluZ1wiO1xuICBFdmVudHNbXCJNRURJQV9BVFRBQ0hFRFwiXSA9IFwiaGxzTWVkaWFBdHRhY2hlZFwiO1xuICBFdmVudHNbXCJNRURJQV9ERVRBQ0hJTkdcIl0gPSBcImhsc01lZGlhRGV0YWNoaW5nXCI7XG4gIEV2ZW50c1tcIk1FRElBX0RFVEFDSEVEXCJdID0gXCJobHNNZWRpYURldGFjaGVkXCI7XG4gIEV2ZW50c1tcIkJVRkZFUl9SRVNFVFwiXSA9IFwiaGxzQnVmZmVyUmVzZXRcIjtcbiAgRXZlbnRzW1wiQlVGRkVSX0NPREVDU1wiXSA9IFwiaGxzQnVmZmVyQ29kZWNzXCI7XG4gIEV2ZW50c1tcIkJVRkZFUl9DUkVBVEVEXCJdID0gXCJobHNCdWZmZXJDcmVhdGVkXCI7XG4gIEV2ZW50c1tcIkJVRkZFUl9BUFBFTkRJTkdcIl0gPSBcImhsc0J1ZmZlckFwcGVuZGluZ1wiO1xuICBFdmVudHNbXCJCVUZGRVJfQVBQRU5ERURcIl0gPSBcImhsc0J1ZmZlckFwcGVuZGVkXCI7XG4gIEV2ZW50c1tcIkJVRkZFUl9FT1NcIl0gPSBcImhsc0J1ZmZlckVvc1wiO1xuICBFdmVudHNbXCJCVUZGRVJfRkxVU0hJTkdcIl0gPSBcImhsc0J1ZmZlckZsdXNoaW5nXCI7XG4gIEV2ZW50c1tcIkJVRkZFUl9GTFVTSEVEXCJdID0gXCJobHNCdWZmZXJGbHVzaGVkXCI7XG4gIEV2ZW50c1tcIk1BTklGRVNUX0xPQURJTkdcIl0gPSBcImhsc01hbmlmZXN0TG9hZGluZ1wiO1xuICBFdmVudHNbXCJNQU5JRkVTVF9MT0FERURcIl0gPSBcImhsc01hbmlmZXN0TG9hZGVkXCI7XG4gIEV2ZW50c1tcIk1BTklGRVNUX1BBUlNFRFwiXSA9IFwiaGxzTWFuaWZlc3RQYXJzZWRcIjtcbiAgRXZlbnRzW1wiTEVWRUxfU1dJVENISU5HXCJdID0gXCJobHNMZXZlbFN3aXRjaGluZ1wiO1xuICBFdmVudHNbXCJMRVZFTF9TV0lUQ0hFRFwiXSA9IFwiaGxzTGV2ZWxTd2l0Y2hlZFwiO1xuICBFdmVudHNbXCJMRVZFTF9MT0FESU5HXCJdID0gXCJobHNMZXZlbExvYWRpbmdcIjtcbiAgRXZlbnRzW1wiTEVWRUxfTE9BREVEXCJdID0gXCJobHNMZXZlbExvYWRlZFwiO1xuICBFdmVudHNbXCJMRVZFTF9VUERBVEVEXCJdID0gXCJobHNMZXZlbFVwZGF0ZWRcIjtcbiAgRXZlbnRzW1wiTEVWRUxfUFRTX1VQREFURURcIl0gPSBcImhsc0xldmVsUHRzVXBkYXRlZFwiO1xuICBFdmVudHNbXCJMRVZFTFNfVVBEQVRFRFwiXSA9IFwiaGxzTGV2ZWxzVXBkYXRlZFwiO1xuICBFdmVudHNbXCJBVURJT19UUkFDS1NfVVBEQVRFRFwiXSA9IFwiaGxzQXVkaW9UcmFja3NVcGRhdGVkXCI7XG4gIEV2ZW50c1tcIkFVRElPX1RSQUNLX1NXSVRDSElOR1wiXSA9IFwiaGxzQXVkaW9UcmFja1N3aXRjaGluZ1wiO1xuICBFdmVudHNbXCJBVURJT19UUkFDS19TV0lUQ0hFRFwiXSA9IFwiaGxzQXVkaW9UcmFja1N3aXRjaGVkXCI7XG4gIEV2ZW50c1tcIkFVRElPX1RSQUNLX0xPQURJTkdcIl0gPSBcImhsc0F1ZGlvVHJhY2tMb2FkaW5nXCI7XG4gIEV2ZW50c1tcIkFVRElPX1RSQUNLX0xPQURFRFwiXSA9IFwiaGxzQXVkaW9UcmFja0xvYWRlZFwiO1xuICBFdmVudHNbXCJTVUJUSVRMRV9UUkFDS1NfVVBEQVRFRFwiXSA9IFwiaGxzU3VidGl0bGVUcmFja3NVcGRhdGVkXCI7XG4gIEV2ZW50c1tcIlNVQlRJVExFX1RSQUNLU19DTEVBUkVEXCJdID0gXCJobHNTdWJ0aXRsZVRyYWNrc0NsZWFyZWRcIjtcbiAgRXZlbnRzW1wiU1VCVElUTEVfVFJBQ0tfU1dJVENIXCJdID0gXCJobHNTdWJ0aXRsZVRyYWNrU3dpdGNoXCI7XG4gIEV2ZW50c1tcIlNVQlRJVExFX1RSQUNLX0xPQURJTkdcIl0gPSBcImhsc1N1YnRpdGxlVHJhY2tMb2FkaW5nXCI7XG4gIEV2ZW50c1tcIlNVQlRJVExFX1RSQUNLX0xPQURFRFwiXSA9IFwiaGxzU3VidGl0bGVUcmFja0xvYWRlZFwiO1xuICBFdmVudHNbXCJTVUJUSVRMRV9GUkFHX1BST0NFU1NFRFwiXSA9IFwiaGxzU3VidGl0bGVGcmFnUHJvY2Vzc2VkXCI7XG4gIEV2ZW50c1tcIkNVRVNfUEFSU0VEXCJdID0gXCJobHNDdWVzUGFyc2VkXCI7XG4gIEV2ZW50c1tcIk5PTl9OQVRJVkVfVEVYVF9UUkFDS1NfRk9VTkRcIl0gPSBcImhsc05vbk5hdGl2ZVRleHRUcmFja3NGb3VuZFwiO1xuICBFdmVudHNbXCJJTklUX1BUU19GT1VORFwiXSA9IFwiaGxzSW5pdFB0c0ZvdW5kXCI7XG4gIEV2ZW50c1tcIkZSQUdfTE9BRElOR1wiXSA9IFwiaGxzRnJhZ0xvYWRpbmdcIjtcbiAgRXZlbnRzW1wiRlJBR19MT0FEX0VNRVJHRU5DWV9BQk9SVEVEXCJdID0gXCJobHNGcmFnTG9hZEVtZXJnZW5jeUFib3J0ZWRcIjtcbiAgRXZlbnRzW1wiRlJBR19MT0FERURcIl0gPSBcImhsc0ZyYWdMb2FkZWRcIjtcbiAgRXZlbnRzW1wiRlJBR19ERUNSWVBURURcIl0gPSBcImhsc0ZyYWdEZWNyeXB0ZWRcIjtcbiAgRXZlbnRzW1wiRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVFwiXSA9IFwiaGxzRnJhZ1BhcnNpbmdJbml0U2VnbWVudFwiO1xuICBFdmVudHNbXCJGUkFHX1BBUlNJTkdfVVNFUkRBVEFcIl0gPSBcImhsc0ZyYWdQYXJzaW5nVXNlcmRhdGFcIjtcbiAgRXZlbnRzW1wiRlJBR19QQVJTSU5HX01FVEFEQVRBXCJdID0gXCJobHNGcmFnUGFyc2luZ01ldGFkYXRhXCI7XG4gIEV2ZW50c1tcIkZSQUdfUEFSU0VEXCJdID0gXCJobHNGcmFnUGFyc2VkXCI7XG4gIEV2ZW50c1tcIkZSQUdfQlVGRkVSRURcIl0gPSBcImhsc0ZyYWdCdWZmZXJlZFwiO1xuICBFdmVudHNbXCJGUkFHX0NIQU5HRURcIl0gPSBcImhsc0ZyYWdDaGFuZ2VkXCI7XG4gIEV2ZW50c1tcIkZQU19EUk9QXCJdID0gXCJobHNGcHNEcm9wXCI7XG4gIEV2ZW50c1tcIkZQU19EUk9QX0xFVkVMX0NBUFBJTkdcIl0gPSBcImhsc0Zwc0Ryb3BMZXZlbENhcHBpbmdcIjtcbiAgRXZlbnRzW1wiTUFYX0FVVE9fTEVWRUxfVVBEQVRFRFwiXSA9IFwiaGxzTWF4QXV0b0xldmVsVXBkYXRlZFwiO1xuICBFdmVudHNbXCJFUlJPUlwiXSA9IFwiaGxzRXJyb3JcIjtcbiAgRXZlbnRzW1wiREVTVFJPWUlOR1wiXSA9IFwiaGxzRGVzdHJveWluZ1wiO1xuICBFdmVudHNbXCJLRVlfTE9BRElOR1wiXSA9IFwiaGxzS2V5TG9hZGluZ1wiO1xuICBFdmVudHNbXCJLRVlfTE9BREVEXCJdID0gXCJobHNLZXlMb2FkZWRcIjtcbiAgRXZlbnRzW1wiTElWRV9CQUNLX0JVRkZFUl9SRUFDSEVEXCJdID0gXCJobHNMaXZlQmFja0J1ZmZlclJlYWNoZWRcIjtcbiAgRXZlbnRzW1wiQkFDS19CVUZGRVJfUkVBQ0hFRFwiXSA9IFwiaGxzQmFja0J1ZmZlclJlYWNoZWRcIjtcbiAgRXZlbnRzW1wiU1RFRVJJTkdfTUFOSUZFU1RfTE9BREVEXCJdID0gXCJobHNTdGVlcmluZ01hbmlmZXN0TG9hZGVkXCI7XG4gIHJldHVybiBFdmVudHM7XG59KHt9KTtcblxuLyoqXG4gKiBEZWZpbmVzIGVhY2ggRXZlbnQgdHlwZSBhbmQgcGF5bG9hZCBieSBFdmVudCBuYW1lLiBVc2VkIGluIHtAbGluayBobHMuanMjSGxzRXZlbnRFbWl0dGVyfSB0byBzdHJvbmdseSB0eXBlIHRoZSBldmVudCBsaXN0ZW5lciBBUEkuXG4gKi9cblxubGV0IEVycm9yVHlwZXMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKEVycm9yVHlwZXMpIHtcbiAgRXJyb3JUeXBlc1tcIk5FVFdPUktfRVJST1JcIl0gPSBcIm5ldHdvcmtFcnJvclwiO1xuICBFcnJvclR5cGVzW1wiTUVESUFfRVJST1JcIl0gPSBcIm1lZGlhRXJyb3JcIjtcbiAgRXJyb3JUeXBlc1tcIktFWV9TWVNURU1fRVJST1JcIl0gPSBcImtleVN5c3RlbUVycm9yXCI7XG4gIEVycm9yVHlwZXNbXCJNVVhfRVJST1JcIl0gPSBcIm11eEVycm9yXCI7XG4gIEVycm9yVHlwZXNbXCJPVEhFUl9FUlJPUlwiXSA9IFwib3RoZXJFcnJvclwiO1xuICByZXR1cm4gRXJyb3JUeXBlcztcbn0oe30pO1xubGV0IEVycm9yRGV0YWlscyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoRXJyb3JEZXRhaWxzKSB7XG4gIEVycm9yRGV0YWlsc1tcIktFWV9TWVNURU1fTk9fS0VZU1wiXSA9IFwia2V5U3lzdGVtTm9LZXlzXCI7XG4gIEVycm9yRGV0YWlsc1tcIktFWV9TWVNURU1fTk9fQUNDRVNTXCJdID0gXCJrZXlTeXN0ZW1Ob0FjY2Vzc1wiO1xuICBFcnJvckRldGFpbHNbXCJLRVlfU1lTVEVNX05PX1NFU1NJT05cIl0gPSBcImtleVN5c3RlbU5vU2Vzc2lvblwiO1xuICBFcnJvckRldGFpbHNbXCJLRVlfU1lTVEVNX05PX0NPTkZJR1VSRURfTElDRU5TRVwiXSA9IFwia2V5U3lzdGVtTm9Db25maWd1cmVkTGljZW5zZVwiO1xuICBFcnJvckRldGFpbHNbXCJLRVlfU1lTVEVNX0xJQ0VOU0VfUkVRVUVTVF9GQUlMRURcIl0gPSBcImtleVN5c3RlbUxpY2Vuc2VSZXF1ZXN0RmFpbGVkXCI7XG4gIEVycm9yRGV0YWlsc1tcIktFWV9TWVNURU1fU0VSVkVSX0NFUlRJRklDQVRFX1JFUVVFU1RfRkFJTEVEXCJdID0gXCJrZXlTeXN0ZW1TZXJ2ZXJDZXJ0aWZpY2F0ZVJlcXVlc3RGYWlsZWRcIjtcbiAgRXJyb3JEZXRhaWxzW1wiS0VZX1NZU1RFTV9TRVJWRVJfQ0VSVElGSUNBVEVfVVBEQVRFX0ZBSUxFRFwiXSA9IFwia2V5U3lzdGVtU2VydmVyQ2VydGlmaWNhdGVVcGRhdGVGYWlsZWRcIjtcbiAgRXJyb3JEZXRhaWxzW1wiS0VZX1NZU1RFTV9TRVNTSU9OX1VQREFURV9GQUlMRURcIl0gPSBcImtleVN5c3RlbVNlc3Npb25VcGRhdGVGYWlsZWRcIjtcbiAgRXJyb3JEZXRhaWxzW1wiS0VZX1NZU1RFTV9TVEFUVVNfT1VUUFVUX1JFU1RSSUNURURcIl0gPSBcImtleVN5c3RlbVN0YXR1c091dHB1dFJlc3RyaWN0ZWRcIjtcbiAgRXJyb3JEZXRhaWxzW1wiS0VZX1NZU1RFTV9TVEFUVVNfSU5URVJOQUxfRVJST1JcIl0gPSBcImtleVN5c3RlbVN0YXR1c0ludGVybmFsRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiTUFOSUZFU1RfTE9BRF9FUlJPUlwiXSA9IFwibWFuaWZlc3RMb2FkRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiTUFOSUZFU1RfTE9BRF9USU1FT1VUXCJdID0gXCJtYW5pZmVzdExvYWRUaW1lT3V0XCI7XG4gIEVycm9yRGV0YWlsc1tcIk1BTklGRVNUX1BBUlNJTkdfRVJST1JcIl0gPSBcIm1hbmlmZXN0UGFyc2luZ0Vycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIk1BTklGRVNUX0lOQ09NUEFUSUJMRV9DT0RFQ1NfRVJST1JcIl0gPSBcIm1hbmlmZXN0SW5jb21wYXRpYmxlQ29kZWNzRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiTEVWRUxfRU1QVFlfRVJST1JcIl0gPSBcImxldmVsRW1wdHlFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJMRVZFTF9MT0FEX0VSUk9SXCJdID0gXCJsZXZlbExvYWRFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJMRVZFTF9MT0FEX1RJTUVPVVRcIl0gPSBcImxldmVsTG9hZFRpbWVPdXRcIjtcbiAgRXJyb3JEZXRhaWxzW1wiTEVWRUxfUEFSU0lOR19FUlJPUlwiXSA9IFwibGV2ZWxQYXJzaW5nRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiTEVWRUxfU1dJVENIX0VSUk9SXCJdID0gXCJsZXZlbFN3aXRjaEVycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIkFVRElPX1RSQUNLX0xPQURfRVJST1JcIl0gPSBcImF1ZGlvVHJhY2tMb2FkRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiQVVESU9fVFJBQ0tfTE9BRF9USU1FT1VUXCJdID0gXCJhdWRpb1RyYWNrTG9hZFRpbWVPdXRcIjtcbiAgRXJyb3JEZXRhaWxzW1wiU1VCVElUTEVfTE9BRF9FUlJPUlwiXSA9IFwic3VidGl0bGVUcmFja0xvYWRFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJTVUJUSVRMRV9UUkFDS19MT0FEX1RJTUVPVVRcIl0gPSBcInN1YnRpdGxlVHJhY2tMb2FkVGltZU91dFwiO1xuICBFcnJvckRldGFpbHNbXCJGUkFHX0xPQURfRVJST1JcIl0gPSBcImZyYWdMb2FkRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiRlJBR19MT0FEX1RJTUVPVVRcIl0gPSBcImZyYWdMb2FkVGltZU91dFwiO1xuICBFcnJvckRldGFpbHNbXCJGUkFHX0RFQ1JZUFRfRVJST1JcIl0gPSBcImZyYWdEZWNyeXB0RXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiRlJBR19QQVJTSU5HX0VSUk9SXCJdID0gXCJmcmFnUGFyc2luZ0Vycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIkZSQUdfR0FQXCJdID0gXCJmcmFnR2FwXCI7XG4gIEVycm9yRGV0YWlsc1tcIlJFTVVYX0FMTE9DX0VSUk9SXCJdID0gXCJyZW11eEFsbG9jRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiS0VZX0xPQURfRVJST1JcIl0gPSBcImtleUxvYWRFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJLRVlfTE9BRF9USU1FT1VUXCJdID0gXCJrZXlMb2FkVGltZU91dFwiO1xuICBFcnJvckRldGFpbHNbXCJCVUZGRVJfQUREX0NPREVDX0VSUk9SXCJdID0gXCJidWZmZXJBZGRDb2RlY0Vycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIkJVRkZFUl9JTkNPTVBBVElCTEVfQ09ERUNTX0VSUk9SXCJdID0gXCJidWZmZXJJbmNvbXBhdGlibGVDb2RlY3NFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJCVUZGRVJfQVBQRU5EX0VSUk9SXCJdID0gXCJidWZmZXJBcHBlbmRFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJCVUZGRVJfQVBQRU5ESU5HX0VSUk9SXCJdID0gXCJidWZmZXJBcHBlbmRpbmdFcnJvclwiO1xuICBFcnJvckRldGFpbHNbXCJCVUZGRVJfU1RBTExFRF9FUlJPUlwiXSA9IFwiYnVmZmVyU3RhbGxlZEVycm9yXCI7XG4gIEVycm9yRGV0YWlsc1tcIkJVRkZFUl9GVUxMX0VSUk9SXCJdID0gXCJidWZmZXJGdWxsRXJyb3JcIjtcbiAgRXJyb3JEZXRhaWxzW1wiQlVGRkVSX1NFRUtfT1ZFUl9IT0xFXCJdID0gXCJidWZmZXJTZWVrT3ZlckhvbGVcIjtcbiAgRXJyb3JEZXRhaWxzW1wiQlVGRkVSX05VREdFX09OX1NUQUxMXCJdID0gXCJidWZmZXJOdWRnZU9uU3RhbGxcIjtcbiAgRXJyb3JEZXRhaWxzW1wiSU5URVJOQUxfRVhDRVBUSU9OXCJdID0gXCJpbnRlcm5hbEV4Y2VwdGlvblwiO1xuICBFcnJvckRldGFpbHNbXCJJTlRFUk5BTF9BQk9SVEVEXCJdID0gXCJhYm9ydGVkXCI7XG4gIEVycm9yRGV0YWlsc1tcIlVOS05PV05cIl0gPSBcInVua25vd25cIjtcbiAgcmV0dXJuIEVycm9yRGV0YWlscztcbn0oe30pO1xuXG5jb25zdCBub29wID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xuY29uc3QgZmFrZUxvZ2dlciA9IHtcbiAgdHJhY2U6IG5vb3AsXG4gIGRlYnVnOiBub29wLFxuICBsb2c6IG5vb3AsXG4gIHdhcm46IG5vb3AsXG4gIGluZm86IG5vb3AsXG4gIGVycm9yOiBub29wXG59O1xubGV0IGV4cG9ydGVkTG9nZ2VyID0gZmFrZUxvZ2dlcjtcblxuLy8gbGV0IGxhc3RDYWxsVGltZTtcbi8vIGZ1bmN0aW9uIGZvcm1hdE1zZ1dpdGhUaW1lSW5mbyh0eXBlLCBtc2cpIHtcbi8vICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbi8vICAgY29uc3QgZGlmZiA9IGxhc3RDYWxsVGltZSA/ICcrJyArIChub3cgLSBsYXN0Q2FsbFRpbWUpIDogJzAnO1xuLy8gICBsYXN0Q2FsbFRpbWUgPSBub3c7XG4vLyAgIG1zZyA9IChuZXcgRGF0ZShub3cpKS50b0lTT1N0cmluZygpICsgJyB8IFsnICsgIHR5cGUgKyAnXSA+ICcgKyBtc2cgKyAnICggJyArIGRpZmYgKyAnIG1zICknO1xuLy8gICByZXR1cm4gbXNnO1xuLy8gfVxuXG5mdW5jdGlvbiBjb25zb2xlUHJpbnRGbih0eXBlKSB7XG4gIGNvbnN0IGZ1bmMgPSBzZWxmLmNvbnNvbGVbdHlwZV07XG4gIGlmIChmdW5jKSB7XG4gICAgcmV0dXJuIGZ1bmMuYmluZChzZWxmLmNvbnNvbGUsIGBbJHt0eXBlfV0gPmApO1xuICB9XG4gIHJldHVybiBub29wO1xufVxuZnVuY3Rpb24gZXhwb3J0TG9nZ2VyRnVuY3Rpb25zKGRlYnVnQ29uZmlnLCAuLi5mdW5jdGlvbnMpIHtcbiAgZnVuY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBleHBvcnRlZExvZ2dlclt0eXBlXSA9IGRlYnVnQ29uZmlnW3R5cGVdID8gZGVidWdDb25maWdbdHlwZV0uYmluZChkZWJ1Z0NvbmZpZykgOiBjb25zb2xlUHJpbnRGbih0eXBlKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBlbmFibGVMb2dzKGRlYnVnQ29uZmlnLCBpZCkge1xuICAvLyBjaGVjayB0aGF0IGNvbnNvbGUgaXMgYXZhaWxhYmxlXG4gIGlmICh0eXBlb2YgY29uc29sZSA9PT0gJ29iamVjdCcgJiYgZGVidWdDb25maWcgPT09IHRydWUgfHwgdHlwZW9mIGRlYnVnQ29uZmlnID09PSAnb2JqZWN0Jykge1xuICAgIGV4cG9ydExvZ2dlckZ1bmN0aW9ucyhkZWJ1Z0NvbmZpZyxcbiAgICAvLyBSZW1vdmUgb3V0IGZyb20gbGlzdCBoZXJlIHRvIGhhcmQtZGlzYWJsZSBhIGxvZy1sZXZlbFxuICAgIC8vICd0cmFjZScsXG4gICAgJ2RlYnVnJywgJ2xvZycsICdpbmZvJywgJ3dhcm4nLCAnZXJyb3InKTtcbiAgICAvLyBTb21lIGJyb3dzZXJzIGRvbid0IGFsbG93IHRvIHVzZSBiaW5kIG9uIGNvbnNvbGUgb2JqZWN0IGFueXdheVxuICAgIC8vIGZhbGxiYWNrIHRvIGRlZmF1bHQgaWYgbmVlZGVkXG4gICAgdHJ5IHtcbiAgICAgIGV4cG9ydGVkTG9nZ2VyLmxvZyhgRGVidWcgbG9ncyBlbmFibGVkIGZvciBcIiR7aWR9XCIgaW4gaGxzLmpzIHZlcnNpb24gJHtcIjEuNS4yXCJ9YCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXhwb3J0ZWRMb2dnZXIgPSBmYWtlTG9nZ2VyO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBleHBvcnRlZExvZ2dlciA9IGZha2VMb2dnZXI7XG4gIH1cbn1cbmNvbnN0IGxvZ2dlciA9IGV4cG9ydGVkTG9nZ2VyO1xuXG5jb25zdCBERUNJTUFMX1JFU09MVVRJT05fUkVHRVggPSAvXihcXGQrKXgoXFxkKykkLztcbmNvbnN0IEFUVFJfTElTVF9SRUdFWCA9IC8oLis/KT0oXCIuKj9cInwuKj8pKD86LHwkKS9nO1xuXG4vLyBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2thbm9uZ2lsL25vZGUtbTN1OHBhcnNlL2Jsb2IvbWFzdGVyL2F0dHJsaXN0LmpzXG5jbGFzcyBBdHRyTGlzdCB7XG4gIGNvbnN0cnVjdG9yKGF0dHJzKSB7XG4gICAgaWYgKHR5cGVvZiBhdHRycyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGF0dHJzID0gQXR0ckxpc3QucGFyc2VBdHRyTGlzdChhdHRycyk7XG4gICAgfVxuICAgIF9leHRlbmRzKHRoaXMsIGF0dHJzKTtcbiAgfVxuICBnZXQgY2xpZW50QXR0cnMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMpLmZpbHRlcihhdHRyID0+IGF0dHIuc3Vic3RyaW5nKDAsIDIpID09PSAnWC0nKTtcbiAgfVxuICBkZWNpbWFsSW50ZWdlcihhdHRyTmFtZSkge1xuICAgIGNvbnN0IGludFZhbHVlID0gcGFyc2VJbnQodGhpc1thdHRyTmFtZV0sIDEwKTtcbiAgICBpZiAoaW50VmFsdWUgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cbiAgICByZXR1cm4gaW50VmFsdWU7XG4gIH1cbiAgaGV4YWRlY2ltYWxJbnRlZ2VyKGF0dHJOYW1lKSB7XG4gICAgaWYgKHRoaXNbYXR0ck5hbWVdKSB7XG4gICAgICBsZXQgc3RyaW5nVmFsdWUgPSAodGhpc1thdHRyTmFtZV0gfHwgJzB4Jykuc2xpY2UoMik7XG4gICAgICBzdHJpbmdWYWx1ZSA9IChzdHJpbmdWYWx1ZS5sZW5ndGggJiAxID8gJzAnIDogJycpICsgc3RyaW5nVmFsdWU7XG4gICAgICBjb25zdCB2YWx1ZSA9IG5ldyBVaW50OEFycmF5KHN0cmluZ1ZhbHVlLmxlbmd0aCAvIDIpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpbmdWYWx1ZS5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgICAgdmFsdWVbaV0gPSBwYXJzZUludChzdHJpbmdWYWx1ZS5zbGljZShpICogMiwgaSAqIDIgKyAyKSwgMTYpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgaGV4YWRlY2ltYWxJbnRlZ2VyQXNOdW1iZXIoYXR0ck5hbWUpIHtcbiAgICBjb25zdCBpbnRWYWx1ZSA9IHBhcnNlSW50KHRoaXNbYXR0ck5hbWVdLCAxNik7XG4gICAgaWYgKGludFZhbHVlID4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG4gICAgcmV0dXJuIGludFZhbHVlO1xuICB9XG4gIGRlY2ltYWxGbG9hdGluZ1BvaW50KGF0dHJOYW1lKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodGhpc1thdHRyTmFtZV0pO1xuICB9XG4gIG9wdGlvbmFsRmxvYXQoYXR0ck5hbWUsIGRlZmF1bHRWYWx1ZSkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpc1thdHRyTmFtZV07XG4gICAgcmV0dXJuIHZhbHVlID8gcGFyc2VGbG9hdCh2YWx1ZSkgOiBkZWZhdWx0VmFsdWU7XG4gIH1cbiAgZW51bWVyYXRlZFN0cmluZyhhdHRyTmFtZSkge1xuICAgIHJldHVybiB0aGlzW2F0dHJOYW1lXTtcbiAgfVxuICBib29sKGF0dHJOYW1lKSB7XG4gICAgcmV0dXJuIHRoaXNbYXR0ck5hbWVdID09PSAnWUVTJztcbiAgfVxuICBkZWNpbWFsUmVzb2x1dGlvbihhdHRyTmFtZSkge1xuICAgIGNvbnN0IHJlcyA9IERFQ0lNQUxfUkVTT0xVVElPTl9SRUdFWC5leGVjKHRoaXNbYXR0ck5hbWVdKTtcbiAgICBpZiAocmVzID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IHBhcnNlSW50KHJlc1sxXSwgMTApLFxuICAgICAgaGVpZ2h0OiBwYXJzZUludChyZXNbMl0sIDEwKVxuICAgIH07XG4gIH1cbiAgc3RhdGljIHBhcnNlQXR0ckxpc3QoaW5wdXQpIHtcbiAgICBsZXQgbWF0Y2g7XG4gICAgY29uc3QgYXR0cnMgPSB7fTtcbiAgICBjb25zdCBxdW90ZSA9ICdcIic7XG4gICAgQVRUUl9MSVNUX1JFR0VYLmxhc3RJbmRleCA9IDA7XG4gICAgd2hpbGUgKChtYXRjaCA9IEFUVFJfTElTVF9SRUdFWC5leGVjKGlucHV0KSkgIT09IG51bGwpIHtcbiAgICAgIGxldCB2YWx1ZSA9IG1hdGNoWzJdO1xuICAgICAgaWYgKHZhbHVlLmluZGV4T2YocXVvdGUpID09PSAwICYmIHZhbHVlLmxhc3RJbmRleE9mKHF1b3RlKSA9PT0gdmFsdWUubGVuZ3RoIC0gMSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDEsIC0xKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5hbWUgPSBtYXRjaFsxXS50cmltKCk7XG4gICAgICBhdHRyc1tuYW1lXSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gYXR0cnM7XG4gIH1cbn1cblxuLy8gQXZvaWQgZXhwb3J0aW5nIGNvbnN0IGVudW0gc28gdGhhdCB0aGVzZSB2YWx1ZXMgY2FuIGJlIGlubGluZWRcblxuZnVuY3Rpb24gaXNEYXRlUmFuZ2VDdWVBdHRyaWJ1dGUoYXR0ck5hbWUpIHtcbiAgcmV0dXJuIGF0dHJOYW1lICE9PSBcIklEXCIgJiYgYXR0ck5hbWUgIT09IFwiQ0xBU1NcIiAmJiBhdHRyTmFtZSAhPT0gXCJTVEFSVC1EQVRFXCIgJiYgYXR0ck5hbWUgIT09IFwiRFVSQVRJT05cIiAmJiBhdHRyTmFtZSAhPT0gXCJFTkQtREFURVwiICYmIGF0dHJOYW1lICE9PSBcIkVORC1PTi1ORVhUXCI7XG59XG5mdW5jdGlvbiBpc1NDVEUzNUF0dHJpYnV0ZShhdHRyTmFtZSkge1xuICByZXR1cm4gYXR0ck5hbWUgPT09IFwiU0NURTM1LU9VVFwiIHx8IGF0dHJOYW1lID09PSBcIlNDVEUzNS1JTlwiO1xufVxuY2xhc3MgRGF0ZVJhbmdlIHtcbiAgY29uc3RydWN0b3IoZGF0ZVJhbmdlQXR0ciwgZGF0ZVJhbmdlV2l0aFNhbWVJZCkge1xuICAgIHRoaXMuYXR0ciA9IHZvaWQgMDtcbiAgICB0aGlzLl9zdGFydERhdGUgPSB2b2lkIDA7XG4gICAgdGhpcy5fZW5kRGF0ZSA9IHZvaWQgMDtcbiAgICB0aGlzLl9iYWRWYWx1ZUZvclNhbWVJZCA9IHZvaWQgMDtcbiAgICBpZiAoZGF0ZVJhbmdlV2l0aFNhbWVJZCkge1xuICAgICAgY29uc3QgcHJldmlvdXNBdHRyID0gZGF0ZVJhbmdlV2l0aFNhbWVJZC5hdHRyO1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJldmlvdXNBdHRyKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGF0ZVJhbmdlQXR0ciwga2V5KSAmJiBkYXRlUmFuZ2VBdHRyW2tleV0gIT09IHByZXZpb3VzQXR0cltrZXldKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYERBVEVSQU5HRSB0YWcgYXR0cmlidXRlOiBcIiR7a2V5fVwiIGRvZXMgbm90IG1hdGNoIGZvciB0YWdzIHdpdGggSUQ6IFwiJHtkYXRlUmFuZ2VBdHRyLklEfVwiYCk7XG4gICAgICAgICAgdGhpcy5fYmFkVmFsdWVGb3JTYW1lSWQgPSBrZXk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIE1lcmdlIERhdGVSYW5nZSB0YWdzIHdpdGggdGhlIHNhbWUgSURcbiAgICAgIGRhdGVSYW5nZUF0dHIgPSBfZXh0ZW5kcyhuZXcgQXR0ckxpc3Qoe30pLCBwcmV2aW91c0F0dHIsIGRhdGVSYW5nZUF0dHIpO1xuICAgIH1cbiAgICB0aGlzLmF0dHIgPSBkYXRlUmFuZ2VBdHRyO1xuICAgIHRoaXMuX3N0YXJ0RGF0ZSA9IG5ldyBEYXRlKGRhdGVSYW5nZUF0dHJbXCJTVEFSVC1EQVRFXCJdKTtcbiAgICBpZiAoXCJFTkQtREFURVwiIGluIHRoaXMuYXR0cikge1xuICAgICAgY29uc3QgZW5kRGF0ZSA9IG5ldyBEYXRlKHRoaXMuYXR0cltcIkVORC1EQVRFXCJdKTtcbiAgICAgIGlmIChpc0Zpbml0ZU51bWJlcihlbmREYXRlLmdldFRpbWUoKSkpIHtcbiAgICAgICAgdGhpcy5fZW5kRGF0ZSA9IGVuZERhdGU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldCBpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyLklEO1xuICB9XG4gIGdldCBjbGFzcygpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyLkNMQVNTO1xuICB9XG4gIGdldCBzdGFydERhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXJ0RGF0ZTtcbiAgfVxuICBnZXQgZW5kRGF0ZSgpIHtcbiAgICBpZiAodGhpcy5fZW5kRGF0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VuZERhdGU7XG4gICAgfVxuICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy5kdXJhdGlvbjtcbiAgICBpZiAoZHVyYXRpb24gIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLl9zdGFydERhdGUuZ2V0VGltZSgpICsgZHVyYXRpb24gKiAxMDAwKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZ2V0IGR1cmF0aW9uKCkge1xuICAgIGlmIChcIkRVUkFUSU9OXCIgaW4gdGhpcy5hdHRyKSB7XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IHRoaXMuYXR0ci5kZWNpbWFsRmxvYXRpbmdQb2ludChcIkRVUkFUSU9OXCIpO1xuICAgICAgaWYgKGlzRmluaXRlTnVtYmVyKGR1cmF0aW9uKSkge1xuICAgICAgICByZXR1cm4gZHVyYXRpb247XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9lbmREYXRlKSB7XG4gICAgICByZXR1cm4gKHRoaXMuX2VuZERhdGUuZ2V0VGltZSgpIC0gdGhpcy5fc3RhcnREYXRlLmdldFRpbWUoKSkgLyAxMDAwO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBnZXQgcGxhbm5lZER1cmF0aW9uKCkge1xuICAgIGlmIChcIlBMQU5ORUQtRFVSQVRJT05cIiBpbiB0aGlzLmF0dHIpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dHIuZGVjaW1hbEZsb2F0aW5nUG9pbnQoXCJQTEFOTkVELURVUkFUSU9OXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBnZXQgZW5kT25OZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmF0dHIuYm9vbChcIkVORC1PTi1ORVhUXCIpO1xuICB9XG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHJldHVybiAhIXRoaXMuaWQgJiYgIXRoaXMuX2JhZFZhbHVlRm9yU2FtZUlkICYmIGlzRmluaXRlTnVtYmVyKHRoaXMuc3RhcnREYXRlLmdldFRpbWUoKSkgJiYgKHRoaXMuZHVyYXRpb24gPT09IG51bGwgfHwgdGhpcy5kdXJhdGlvbiA+PSAwKSAmJiAoIXRoaXMuZW5kT25OZXh0IHx8ICEhdGhpcy5jbGFzcyk7XG4gIH1cbn1cblxuY2xhc3MgTG9hZFN0YXRzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5hYm9ydGVkID0gZmFsc2U7XG4gICAgdGhpcy5sb2FkZWQgPSAwO1xuICAgIHRoaXMucmV0cnkgPSAwO1xuICAgIHRoaXMudG90YWwgPSAwO1xuICAgIHRoaXMuY2h1bmtDb3VudCA9IDA7XG4gICAgdGhpcy5id0VzdGltYXRlID0gMDtcbiAgICB0aGlzLmxvYWRpbmcgPSB7XG4gICAgICBzdGFydDogMCxcbiAgICAgIGZpcnN0OiAwLFxuICAgICAgZW5kOiAwXG4gICAgfTtcbiAgICB0aGlzLnBhcnNpbmcgPSB7XG4gICAgICBzdGFydDogMCxcbiAgICAgIGVuZDogMFxuICAgIH07XG4gICAgdGhpcy5idWZmZXJpbmcgPSB7XG4gICAgICBzdGFydDogMCxcbiAgICAgIGZpcnN0OiAwLFxuICAgICAgZW5kOiAwXG4gICAgfTtcbiAgfVxufVxuXG52YXIgRWxlbWVudGFyeVN0cmVhbVR5cGVzID0ge1xuICBBVURJTzogXCJhdWRpb1wiLFxuICBWSURFTzogXCJ2aWRlb1wiLFxuICBBVURJT1ZJREVPOiBcImF1ZGlvdmlkZW9cIlxufTtcbmNsYXNzIEJhc2VTZWdtZW50IHtcbiAgY29uc3RydWN0b3IoYmFzZXVybCkge1xuICAgIHRoaXMuX2J5dGVSYW5nZSA9IG51bGw7XG4gICAgdGhpcy5fdXJsID0gbnVsbDtcbiAgICAvLyBiYXNldXJsIGlzIHRoZSBVUkwgdG8gdGhlIHBsYXlsaXN0XG4gICAgdGhpcy5iYXNldXJsID0gdm9pZCAwO1xuICAgIC8vIHJlbHVybCBpcyB0aGUgcG9ydGlvbiBvZiB0aGUgVVJMIHRoYXQgY29tZXMgZnJvbSBpbnNpZGUgdGhlIHBsYXlsaXN0LlxuICAgIHRoaXMucmVsdXJsID0gdm9pZCAwO1xuICAgIC8vIEhvbGRzIHRoZSB0eXBlcyBvZiBkYXRhIHRoaXMgZnJhZ21lbnQgc3VwcG9ydHNcbiAgICB0aGlzLmVsZW1lbnRhcnlTdHJlYW1zID0ge1xuICAgICAgW0VsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJT106IG51bGwsXG4gICAgICBbRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPXTogbnVsbCxcbiAgICAgIFtFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU9WSURFT106IG51bGxcbiAgICB9O1xuICAgIHRoaXMuYmFzZXVybCA9IGJhc2V1cmw7XG4gIH1cblxuICAvLyBzZXRCeXRlUmFuZ2UgY29udmVydHMgYSBFWFQtWC1CWVRFUkFOR0UgYXR0cmlidXRlIGludG8gYSB0d28gZWxlbWVudCBhcnJheVxuICBzZXRCeXRlUmFuZ2UodmFsdWUsIHByZXZpb3VzKSB7XG4gICAgY29uc3QgcGFyYW1zID0gdmFsdWUuc3BsaXQoJ0AnLCAyKTtcbiAgICBsZXQgc3RhcnQ7XG4gICAgaWYgKHBhcmFtcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHN0YXJ0ID0gKHByZXZpb3VzID09IG51bGwgPyB2b2lkIDAgOiBwcmV2aW91cy5ieXRlUmFuZ2VFbmRPZmZzZXQpIHx8IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0ID0gcGFyc2VJbnQocGFyYW1zWzFdKTtcbiAgICB9XG4gICAgdGhpcy5fYnl0ZVJhbmdlID0gW3N0YXJ0LCBwYXJzZUludChwYXJhbXNbMF0pICsgc3RhcnRdO1xuICB9XG4gIGdldCBieXRlUmFuZ2UoKSB7XG4gICAgaWYgKCF0aGlzLl9ieXRlUmFuZ2UpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2J5dGVSYW5nZTtcbiAgfVxuICBnZXQgYnl0ZVJhbmdlU3RhcnRPZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnl0ZVJhbmdlWzBdO1xuICB9XG4gIGdldCBieXRlUmFuZ2VFbmRPZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnl0ZVJhbmdlWzFdO1xuICB9XG4gIGdldCB1cmwoKSB7XG4gICAgaWYgKCF0aGlzLl91cmwgJiYgdGhpcy5iYXNldXJsICYmIHRoaXMucmVsdXJsKSB7XG4gICAgICB0aGlzLl91cmwgPSB1cmxUb29sa2l0RXhwb3J0cy5idWlsZEFic29sdXRlVVJMKHRoaXMuYmFzZXVybCwgdGhpcy5yZWx1cmwsIHtcbiAgICAgICAgYWx3YXlzTm9ybWFsaXplOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3VybCB8fCAnJztcbiAgfVxuICBzZXQgdXJsKHZhbHVlKSB7XG4gICAgdGhpcy5fdXJsID0gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBPYmplY3QgcmVwcmVzZW50aW5nIHBhcnNlZCBkYXRhIGZyb20gYW4gSExTIFNlZ21lbnQuIEZvdW5kIGluIHtAbGluayBobHMuanMjTGV2ZWxEZXRhaWxzLmZyYWdtZW50c30uXG4gKi9cbmNsYXNzIEZyYWdtZW50IGV4dGVuZHMgQmFzZVNlZ21lbnQge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBiYXNldXJsKSB7XG4gICAgc3VwZXIoYmFzZXVybCk7XG4gICAgdGhpcy5fZGVjcnlwdGRhdGEgPSBudWxsO1xuICAgIHRoaXMucmF3UHJvZ3JhbURhdGVUaW1lID0gbnVsbDtcbiAgICB0aGlzLnByb2dyYW1EYXRlVGltZSA9IG51bGw7XG4gICAgdGhpcy50YWdMaXN0ID0gW107XG4gICAgLy8gRVhUSU5GIGhhcyB0byBiZSBwcmVzZW50IGZvciBhIG0zdTggdG8gYmUgY29uc2lkZXJlZCB2YWxpZFxuICAgIHRoaXMuZHVyYXRpb24gPSAwO1xuICAgIC8vIHNuIG5vdGF0ZXMgdGhlIHNlcXVlbmNlIG51bWJlciBmb3IgYSBzZWdtZW50LCBhbmQgaWYgc2V0IHRvIGEgc3RyaW5nIGNhbiBiZSAnaW5pdFNlZ21lbnQnXG4gICAgdGhpcy5zbiA9IDA7XG4gICAgLy8gbGV2ZWxrZXlzIGFyZSB0aGUgRVhULVgtS0VZIHRhZ3MgdGhhdCBhcHBseSB0byB0aGlzIHNlZ21lbnQgZm9yIGRlY3J5cHRpb25cbiAgICAvLyBjb3JlIGRpZmZlcmVuY2UgZnJvbSB0aGUgcHJpdmF0ZSBmaWVsZCBfZGVjcnlwdGRhdGEgaXMgdGhlIGxhY2sgb2YgdGhlIGluaXRpYWxpemVkIElWXG4gICAgLy8gX2RlY3J5cHRkYXRhIHdpbGwgc2V0IHRoZSBJViBmb3IgdGhpcyBzZWdtZW50IGJhc2VkIG9uIHRoZSBzZWdtZW50IG51bWJlciBpbiB0aGUgZnJhZ21lbnRcbiAgICB0aGlzLmxldmVsa2V5cyA9IHZvaWQgMDtcbiAgICAvLyBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGZyYWdtZW50IHR5cGVcbiAgICB0aGlzLnR5cGUgPSB2b2lkIDA7XG4gICAgLy8gQSByZWZlcmVuY2UgdG8gdGhlIGxvYWRlci4gU2V0IHdoaWxlIHRoZSBmcmFnbWVudCBpcyBsb2FkaW5nLCBhbmQgcmVtb3ZlZCBhZnRlcndhcmRzLiBVc2VkIHRvIGFib3J0IGZyYWdtZW50IGxvYWRpbmdcbiAgICB0aGlzLmxvYWRlciA9IG51bGw7XG4gICAgLy8gQSByZWZlcmVuY2UgdG8gdGhlIGtleSBsb2FkZXIuIFNldCB3aGlsZSB0aGUga2V5IGlzIGxvYWRpbmcsIGFuZCByZW1vdmVkIGFmdGVyd2FyZHMuIFVzZWQgdG8gYWJvcnQga2V5IGxvYWRpbmdcbiAgICB0aGlzLmtleUxvYWRlciA9IG51bGw7XG4gICAgLy8gVGhlIGxldmVsL3RyYWNrIGluZGV4IHRvIHdoaWNoIHRoZSBmcmFnbWVudCBiZWxvbmdzXG4gICAgdGhpcy5sZXZlbCA9IC0xO1xuICAgIC8vIFRoZSBjb250aW51aXR5IGNvdW50ZXIgb2YgdGhlIGZyYWdtZW50XG4gICAgdGhpcy5jYyA9IDA7XG4gICAgLy8gVGhlIHN0YXJ0aW5nIFByZXNlbnRhdGlvbiBUaW1lIFN0YW1wIChQVFMpIG9mIHRoZSBmcmFnbWVudC4gU2V0IGFmdGVyIHRyYW5zbXV4IGNvbXBsZXRlLlxuICAgIHRoaXMuc3RhcnRQVFMgPSB2b2lkIDA7XG4gICAgLy8gVGhlIGVuZGluZyBQcmVzZW50YXRpb24gVGltZSBTdGFtcCAoUFRTKSBvZiB0aGUgZnJhZ21lbnQuIFNldCBhZnRlciB0cmFuc211eCBjb21wbGV0ZS5cbiAgICB0aGlzLmVuZFBUUyA9IHZvaWQgMDtcbiAgICAvLyBUaGUgc3RhcnRpbmcgRGVjb2RlIFRpbWUgU3RhbXAgKERUUykgb2YgdGhlIGZyYWdtZW50LiBTZXQgYWZ0ZXIgdHJhbnNtdXggY29tcGxldGUuXG4gICAgdGhpcy5zdGFydERUUyA9IHZvaWQgMDtcbiAgICAvLyBUaGUgZW5kaW5nIERlY29kZSBUaW1lIFN0YW1wIChEVFMpIG9mIHRoZSBmcmFnbWVudC4gU2V0IGFmdGVyIHRyYW5zbXV4IGNvbXBsZXRlLlxuICAgIHRoaXMuZW5kRFRTID0gdm9pZCAwO1xuICAgIC8vIFRoZSBzdGFydCB0aW1lIG9mIHRoZSBmcmFnbWVudCwgYXMgbGlzdGVkIGluIHRoZSBtYW5pZmVzdC4gVXBkYXRlZCBhZnRlciB0cmFuc211eCBjb21wbGV0ZS5cbiAgICB0aGlzLnN0YXJ0ID0gMDtcbiAgICAvLyBTZXQgYnkgYHVwZGF0ZUZyYWdQVFNEVFNgIGluIGxldmVsLWhlbHBlclxuICAgIHRoaXMuZGVsdGFQVFMgPSB2b2lkIDA7XG4gICAgLy8gVGhlIG1heGltdW0gc3RhcnRpbmcgUHJlc2VudGF0aW9uIFRpbWUgU3RhbXAgKGF1ZGlvL3ZpZGVvIFBUUykgb2YgdGhlIGZyYWdtZW50LiBTZXQgYWZ0ZXIgdHJhbnNtdXggY29tcGxldGUuXG4gICAgdGhpcy5tYXhTdGFydFBUUyA9IHZvaWQgMDtcbiAgICAvLyBUaGUgbWluaW11bSBlbmRpbmcgUHJlc2VudGF0aW9uIFRpbWUgU3RhbXAgKGF1ZGlvL3ZpZGVvIFBUUykgb2YgdGhlIGZyYWdtZW50LiBTZXQgYWZ0ZXIgdHJhbnNtdXggY29tcGxldGUuXG4gICAgdGhpcy5taW5FbmRQVFMgPSB2b2lkIDA7XG4gICAgLy8gTG9hZC9wYXJzZSB0aW1pbmcgaW5mb3JtYXRpb25cbiAgICB0aGlzLnN0YXRzID0gbmV3IExvYWRTdGF0cygpO1xuICAgIC8vIEluaXQgU2VnbWVudCBieXRlcyAodW5zZXQgZm9yIG1lZGlhIHNlZ21lbnRzKVxuICAgIHRoaXMuZGF0YSA9IHZvaWQgMDtcbiAgICAvLyBBIGZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBzZWdtZW50IHdhcyBkb3dubG9hZGVkIGluIG9yZGVyIHRvIHRlc3QgYml0cmF0ZSwgYW5kIHdhcyBub3QgYnVmZmVyZWRcbiAgICB0aGlzLmJpdHJhdGVUZXN0ID0gZmFsc2U7XG4gICAgLy8gI0VYVElORiAgc2VnbWVudCB0aXRsZVxuICAgIHRoaXMudGl0bGUgPSBudWxsO1xuICAgIC8vIFRoZSBNZWRpYSBJbml0aWFsaXphdGlvbiBTZWN0aW9uIGZvciB0aGlzIHNlZ21lbnRcbiAgICB0aGlzLmluaXRTZWdtZW50ID0gbnVsbDtcbiAgICAvLyBGcmFnbWVudCBpcyB0aGUgbGFzdCBmcmFnbWVudCBpbiB0aGUgbWVkaWEgcGxheWxpc3RcbiAgICB0aGlzLmVuZExpc3QgPSB2b2lkIDA7XG4gICAgLy8gRnJhZ21lbnQgaXMgbWFya2VkIGJ5IGFuIEVYVC1YLUdBUCB0YWcgaW5kaWNhdGluZyB0aGF0IGl0IGRvZXMgbm90IGNvbnRhaW4gbWVkaWEgZGF0YSBhbmQgc2hvdWxkIG5vdCBiZSBsb2FkZWRcbiAgICB0aGlzLmdhcCA9IHZvaWQgMDtcbiAgICAvLyBEZXByZWNhdGVkXG4gICAgdGhpcy51cmxJZCA9IDA7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgfVxuICBnZXQgZGVjcnlwdGRhdGEoKSB7XG4gICAgY29uc3Qge1xuICAgICAgbGV2ZWxrZXlzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFsZXZlbGtleXMgJiYgIXRoaXMuX2RlY3J5cHRkYXRhKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9kZWNyeXB0ZGF0YSAmJiB0aGlzLmxldmVsa2V5cyAmJiAhdGhpcy5sZXZlbGtleXMuTk9ORSkge1xuICAgICAgY29uc3Qga2V5ID0gdGhpcy5sZXZlbGtleXMuaWRlbnRpdHk7XG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIHRoaXMuX2RlY3J5cHRkYXRhID0ga2V5LmdldERlY3J5cHREYXRhKHRoaXMuc24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qga2V5Rm9ybWF0cyA9IE9iamVjdC5rZXlzKHRoaXMubGV2ZWxrZXlzKTtcbiAgICAgICAgaWYgKGtleUZvcm1hdHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2RlY3J5cHRkYXRhID0gdGhpcy5sZXZlbGtleXNba2V5Rm9ybWF0c1swXV0uZ2V0RGVjcnlwdERhdGEodGhpcy5zbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2RlY3J5cHRkYXRhO1xuICB9XG4gIGdldCBlbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhcnQgKyB0aGlzLmR1cmF0aW9uO1xuICB9XG4gIGdldCBlbmRQcm9ncmFtRGF0ZVRpbWUoKSB7XG4gICAgaWYgKHRoaXMucHJvZ3JhbURhdGVUaW1lID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCFpc0Zpbml0ZU51bWJlcih0aGlzLnByb2dyYW1EYXRlVGltZSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBkdXJhdGlvbiA9ICFpc0Zpbml0ZU51bWJlcih0aGlzLmR1cmF0aW9uKSA/IDAgOiB0aGlzLmR1cmF0aW9uO1xuICAgIHJldHVybiB0aGlzLnByb2dyYW1EYXRlVGltZSArIGR1cmF0aW9uICogMTAwMDtcbiAgfVxuICBnZXQgZW5jcnlwdGVkKCkge1xuICAgIHZhciBfdGhpcyRfZGVjcnlwdGRhdGE7XG4gICAgLy8gQXQgdGhlIG0zdTgtcGFyc2VyIGxldmVsIHdlIG5lZWQgdG8gYWRkIHN1cHBvcnQgZm9yIG1hbmlmZXN0IHNpZ25hbGxlZCBrZXlmb3JtYXRzXG4gICAgLy8gd2hlbiB3ZSB3YW50IHRoZSBmcmFnbWVudCB0byBzdGFydCByZXBvcnRpbmcgdGhhdCBpdCBpcyBlbmNyeXB0ZWQuXG4gICAgLy8gQ3VycmVudGx5LCBrZXlGb3JtYXQgd2lsbCBvbmx5IGJlIHNldCBmb3IgaWRlbnRpdHkga2V5c1xuICAgIGlmICgoX3RoaXMkX2RlY3J5cHRkYXRhID0gdGhpcy5fZGVjcnlwdGRhdGEpICE9IG51bGwgJiYgX3RoaXMkX2RlY3J5cHRkYXRhLmVuY3J5cHRlZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLmxldmVsa2V5cykge1xuICAgICAgY29uc3Qga2V5Rm9ybWF0cyA9IE9iamVjdC5rZXlzKHRoaXMubGV2ZWxrZXlzKTtcbiAgICAgIGNvbnN0IGxlbiA9IGtleUZvcm1hdHMubGVuZ3RoO1xuICAgICAgaWYgKGxlbiA+IDEgfHwgbGVuID09PSAxICYmIHRoaXMubGV2ZWxrZXlzW2tleUZvcm1hdHNbMF1dLmVuY3J5cHRlZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHNldEtleUZvcm1hdChrZXlGb3JtYXQpIHtcbiAgICBpZiAodGhpcy5sZXZlbGtleXMpIHtcbiAgICAgIGNvbnN0IGtleSA9IHRoaXMubGV2ZWxrZXlzW2tleUZvcm1hdF07XG4gICAgICBpZiAoa2V5ICYmICF0aGlzLl9kZWNyeXB0ZGF0YSkge1xuICAgICAgICB0aGlzLl9kZWNyeXB0ZGF0YSA9IGtleS5nZXREZWNyeXB0RGF0YSh0aGlzLnNuKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYWJvcnRSZXF1ZXN0cygpIHtcbiAgICB2YXIgX3RoaXMkbG9hZGVyLCBfdGhpcyRrZXlMb2FkZXI7XG4gICAgKF90aGlzJGxvYWRlciA9IHRoaXMubG9hZGVyKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkbG9hZGVyLmFib3J0KCk7XG4gICAgKF90aGlzJGtleUxvYWRlciA9IHRoaXMua2V5TG9hZGVyKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMka2V5TG9hZGVyLmFib3J0KCk7XG4gIH1cbiAgc2V0RWxlbWVudGFyeVN0cmVhbUluZm8odHlwZSwgc3RhcnRQVFMsIGVuZFBUUywgc3RhcnREVFMsIGVuZERUUywgcGFydGlhbCA9IGZhbHNlKSB7XG4gICAgY29uc3Qge1xuICAgICAgZWxlbWVudGFyeVN0cmVhbXNcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBpbmZvID0gZWxlbWVudGFyeVN0cmVhbXNbdHlwZV07XG4gICAgaWYgKCFpbmZvKSB7XG4gICAgICBlbGVtZW50YXJ5U3RyZWFtc1t0eXBlXSA9IHtcbiAgICAgICAgc3RhcnRQVFMsXG4gICAgICAgIGVuZFBUUyxcbiAgICAgICAgc3RhcnREVFMsXG4gICAgICAgIGVuZERUUyxcbiAgICAgICAgcGFydGlhbFxuICAgICAgfTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW5mby5zdGFydFBUUyA9IE1hdGgubWluKGluZm8uc3RhcnRQVFMsIHN0YXJ0UFRTKTtcbiAgICBpbmZvLmVuZFBUUyA9IE1hdGgubWF4KGluZm8uZW5kUFRTLCBlbmRQVFMpO1xuICAgIGluZm8uc3RhcnREVFMgPSBNYXRoLm1pbihpbmZvLnN0YXJ0RFRTLCBzdGFydERUUyk7XG4gICAgaW5mby5lbmREVFMgPSBNYXRoLm1heChpbmZvLmVuZERUUywgZW5kRFRTKTtcbiAgfVxuICBjbGVhckVsZW1lbnRhcnlTdHJlYW1JbmZvKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGVsZW1lbnRhcnlTdHJlYW1zXG4gICAgfSA9IHRoaXM7XG4gICAgZWxlbWVudGFyeVN0cmVhbXNbRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPXSA9IG51bGw7XG4gICAgZWxlbWVudGFyeVN0cmVhbXNbRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPXSA9IG51bGw7XG4gICAgZWxlbWVudGFyeVN0cmVhbXNbRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPVklERU9dID0gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIE9iamVjdCByZXByZXNlbnRpbmcgcGFyc2VkIGRhdGEgZnJvbSBhbiBITFMgUGFydGlhbCBTZWdtZW50LiBGb3VuZCBpbiB7QGxpbmsgaGxzLmpzI0xldmVsRGV0YWlscy5wYXJ0TGlzdH0uXG4gKi9cbmNsYXNzIFBhcnQgZXh0ZW5kcyBCYXNlU2VnbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcnRBdHRycywgZnJhZywgYmFzZXVybCwgaW5kZXgsIHByZXZpb3VzKSB7XG4gICAgc3VwZXIoYmFzZXVybCk7XG4gICAgdGhpcy5mcmFnT2Zmc2V0ID0gMDtcbiAgICB0aGlzLmR1cmF0aW9uID0gMDtcbiAgICB0aGlzLmdhcCA9IGZhbHNlO1xuICAgIHRoaXMuaW5kZXBlbmRlbnQgPSBmYWxzZTtcbiAgICB0aGlzLnJlbHVybCA9IHZvaWQgMDtcbiAgICB0aGlzLmZyYWdtZW50ID0gdm9pZCAwO1xuICAgIHRoaXMuaW5kZXggPSB2b2lkIDA7XG4gICAgdGhpcy5zdGF0cyA9IG5ldyBMb2FkU3RhdHMoKTtcbiAgICB0aGlzLmR1cmF0aW9uID0gcGFydEF0dHJzLmRlY2ltYWxGbG9hdGluZ1BvaW50KCdEVVJBVElPTicpO1xuICAgIHRoaXMuZ2FwID0gcGFydEF0dHJzLmJvb2woJ0dBUCcpO1xuICAgIHRoaXMuaW5kZXBlbmRlbnQgPSBwYXJ0QXR0cnMuYm9vbCgnSU5ERVBFTkRFTlQnKTtcbiAgICB0aGlzLnJlbHVybCA9IHBhcnRBdHRycy5lbnVtZXJhdGVkU3RyaW5nKCdVUkknKTtcbiAgICB0aGlzLmZyYWdtZW50ID0gZnJhZztcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgY29uc3QgYnl0ZVJhbmdlID0gcGFydEF0dHJzLmVudW1lcmF0ZWRTdHJpbmcoJ0JZVEVSQU5HRScpO1xuICAgIGlmIChieXRlUmFuZ2UpIHtcbiAgICAgIHRoaXMuc2V0Qnl0ZVJhbmdlKGJ5dGVSYW5nZSwgcHJldmlvdXMpO1xuICAgIH1cbiAgICBpZiAocHJldmlvdXMpIHtcbiAgICAgIHRoaXMuZnJhZ09mZnNldCA9IHByZXZpb3VzLmZyYWdPZmZzZXQgKyBwcmV2aW91cy5kdXJhdGlvbjtcbiAgICB9XG4gIH1cbiAgZ2V0IHN0YXJ0KCkge1xuICAgIHJldHVybiB0aGlzLmZyYWdtZW50LnN0YXJ0ICsgdGhpcy5mcmFnT2Zmc2V0O1xuICB9XG4gIGdldCBlbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhcnQgKyB0aGlzLmR1cmF0aW9uO1xuICB9XG4gIGdldCBsb2FkZWQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZWxlbWVudGFyeVN0cmVhbXNcbiAgICB9ID0gdGhpcztcbiAgICByZXR1cm4gISEoZWxlbWVudGFyeVN0cmVhbXMuYXVkaW8gfHwgZWxlbWVudGFyeVN0cmVhbXMudmlkZW8gfHwgZWxlbWVudGFyeVN0cmVhbXMuYXVkaW92aWRlbyk7XG4gIH1cbn1cblxuY29uc3QgREVGQVVMVF9UQVJHRVRfRFVSQVRJT04gPSAxMDtcblxuLyoqXG4gKiBPYmplY3QgcmVwcmVzZW50aW5nIHBhcnNlZCBkYXRhIGZyb20gYW4gSExTIE1lZGlhIFBsYXlsaXN0LiBGb3VuZCBpbiB7QGxpbmsgaGxzLmpzI0xldmVsLmRldGFpbHN9LlxuICovXG5jbGFzcyBMZXZlbERldGFpbHMge1xuICBjb25zdHJ1Y3RvcihiYXNlVXJsKSB7XG4gICAgdGhpcy5QVFNLbm93biA9IGZhbHNlO1xuICAgIHRoaXMuYWxpZ25lZFNsaWRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmF2ZXJhZ2V0YXJnZXRkdXJhdGlvbiA9IHZvaWQgMDtcbiAgICB0aGlzLmVuZENDID0gMDtcbiAgICB0aGlzLmVuZFNOID0gMDtcbiAgICB0aGlzLmZyYWdtZW50cyA9IHZvaWQgMDtcbiAgICB0aGlzLmZyYWdtZW50SGludCA9IHZvaWQgMDtcbiAgICB0aGlzLnBhcnRMaXN0ID0gbnVsbDtcbiAgICB0aGlzLmRhdGVSYW5nZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5saXZlID0gdHJ1ZTtcbiAgICB0aGlzLmFnZUhlYWRlciA9IDA7XG4gICAgdGhpcy5hZHZhbmNlZERhdGVUaW1lID0gdm9pZCAwO1xuICAgIHRoaXMudXBkYXRlZCA9IHRydWU7XG4gICAgdGhpcy5hZHZhbmNlZCA9IHRydWU7XG4gICAgdGhpcy5hdmFpbGFiaWxpdHlEZWxheSA9IHZvaWQgMDtcbiAgICAvLyBNYW5pZmVzdCByZWxvYWQgc3luY2hyb25pemF0aW9uXG4gICAgdGhpcy5taXNzZXMgPSAwO1xuICAgIHRoaXMuc3RhcnRDQyA9IDA7XG4gICAgdGhpcy5zdGFydFNOID0gMDtcbiAgICB0aGlzLnN0YXJ0VGltZU9mZnNldCA9IG51bGw7XG4gICAgdGhpcy50YXJnZXRkdXJhdGlvbiA9IDA7XG4gICAgdGhpcy50b3RhbGR1cmF0aW9uID0gMDtcbiAgICB0aGlzLnR5cGUgPSBudWxsO1xuICAgIHRoaXMudXJsID0gdm9pZCAwO1xuICAgIHRoaXMubTN1OCA9ICcnO1xuICAgIHRoaXMudmVyc2lvbiA9IG51bGw7XG4gICAgdGhpcy5jYW5CbG9ja1JlbG9hZCA9IGZhbHNlO1xuICAgIHRoaXMuY2FuU2tpcFVudGlsID0gMDtcbiAgICB0aGlzLmNhblNraXBEYXRlUmFuZ2VzID0gZmFsc2U7XG4gICAgdGhpcy5za2lwcGVkU2VnbWVudHMgPSAwO1xuICAgIHRoaXMucmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcyA9IHZvaWQgMDtcbiAgICB0aGlzLnBhcnRIb2xkQmFjayA9IDA7XG4gICAgdGhpcy5ob2xkQmFjayA9IDA7XG4gICAgdGhpcy5wYXJ0VGFyZ2V0ID0gMDtcbiAgICB0aGlzLnByZWxvYWRIaW50ID0gdm9pZCAwO1xuICAgIHRoaXMucmVuZGl0aW9uUmVwb3J0cyA9IHZvaWQgMDtcbiAgICB0aGlzLnR1bmVJbkdvYWwgPSAwO1xuICAgIHRoaXMuZGVsdGFVcGRhdGVGYWlsZWQgPSB2b2lkIDA7XG4gICAgdGhpcy5kcmlmdFN0YXJ0VGltZSA9IDA7XG4gICAgdGhpcy5kcmlmdEVuZFRpbWUgPSAwO1xuICAgIHRoaXMuZHJpZnRTdGFydCA9IDA7XG4gICAgdGhpcy5kcmlmdEVuZCA9IDA7XG4gICAgdGhpcy5lbmNyeXB0ZWRGcmFnbWVudHMgPSB2b2lkIDA7XG4gICAgdGhpcy5wbGF5bGlzdFBhcnNpbmdFcnJvciA9IG51bGw7XG4gICAgdGhpcy52YXJpYWJsZUxpc3QgPSBudWxsO1xuICAgIHRoaXMuaGFzVmFyaWFibGVSZWZzID0gZmFsc2U7XG4gICAgdGhpcy5mcmFnbWVudHMgPSBbXTtcbiAgICB0aGlzLmVuY3J5cHRlZEZyYWdtZW50cyA9IFtdO1xuICAgIHRoaXMuZGF0ZVJhbmdlcyA9IHt9O1xuICAgIHRoaXMudXJsID0gYmFzZVVybDtcbiAgfVxuICByZWxvYWRlZChwcmV2aW91cykge1xuICAgIGlmICghcHJldmlvdXMpIHtcbiAgICAgIHRoaXMuYWR2YW5jZWQgPSB0cnVlO1xuICAgICAgdGhpcy51cGRhdGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcGFydFNuRGlmZiA9IHRoaXMubGFzdFBhcnRTbiAtIHByZXZpb3VzLmxhc3RQYXJ0U247XG4gICAgY29uc3QgcGFydEluZGV4RGlmZiA9IHRoaXMubGFzdFBhcnRJbmRleCAtIHByZXZpb3VzLmxhc3RQYXJ0SW5kZXg7XG4gICAgdGhpcy51cGRhdGVkID0gdGhpcy5lbmRTTiAhPT0gcHJldmlvdXMuZW5kU04gfHwgISFwYXJ0SW5kZXhEaWZmIHx8ICEhcGFydFNuRGlmZiB8fCAhdGhpcy5saXZlO1xuICAgIHRoaXMuYWR2YW5jZWQgPSB0aGlzLmVuZFNOID4gcHJldmlvdXMuZW5kU04gfHwgcGFydFNuRGlmZiA+IDAgfHwgcGFydFNuRGlmZiA9PT0gMCAmJiBwYXJ0SW5kZXhEaWZmID4gMDtcbiAgICBpZiAodGhpcy51cGRhdGVkIHx8IHRoaXMuYWR2YW5jZWQpIHtcbiAgICAgIHRoaXMubWlzc2VzID0gTWF0aC5mbG9vcihwcmV2aW91cy5taXNzZXMgKiAwLjYpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1pc3NlcyA9IHByZXZpb3VzLm1pc3NlcyArIDE7XG4gICAgfVxuICAgIHRoaXMuYXZhaWxhYmlsaXR5RGVsYXkgPSBwcmV2aW91cy5hdmFpbGFiaWxpdHlEZWxheTtcbiAgfVxuICBnZXQgaGFzUHJvZ3JhbURhdGVUaW1lKCkge1xuICAgIGlmICh0aGlzLmZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBpc0Zpbml0ZU51bWJlcih0aGlzLmZyYWdtZW50c1t0aGlzLmZyYWdtZW50cy5sZW5ndGggLSAxXS5wcm9ncmFtRGF0ZVRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZ2V0IGxldmVsVGFyZ2V0RHVyYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYXZlcmFnZXRhcmdldGR1cmF0aW9uIHx8IHRoaXMudGFyZ2V0ZHVyYXRpb24gfHwgREVGQVVMVF9UQVJHRVRfRFVSQVRJT047XG4gIH1cbiAgZ2V0IGRyaWZ0KCkge1xuICAgIGNvbnN0IHJ1blRpbWUgPSB0aGlzLmRyaWZ0RW5kVGltZSAtIHRoaXMuZHJpZnRTdGFydFRpbWU7XG4gICAgaWYgKHJ1blRpbWUgPiAwKSB7XG4gICAgICBjb25zdCBydW5EdXJhdGlvbiA9IHRoaXMuZHJpZnRFbmQgLSB0aGlzLmRyaWZ0U3RhcnQ7XG4gICAgICByZXR1cm4gcnVuRHVyYXRpb24gKiAxMDAwIC8gcnVuVGltZTtcbiAgICB9XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgZ2V0IGVkZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFydEVuZCB8fCB0aGlzLmZyYWdtZW50RW5kO1xuICB9XG4gIGdldCBwYXJ0RW5kKCkge1xuICAgIHZhciBfdGhpcyRwYXJ0TGlzdDtcbiAgICBpZiAoKF90aGlzJHBhcnRMaXN0ID0gdGhpcy5wYXJ0TGlzdCkgIT0gbnVsbCAmJiBfdGhpcyRwYXJ0TGlzdC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnRMaXN0W3RoaXMucGFydExpc3QubGVuZ3RoIC0gMV0uZW5kO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mcmFnbWVudEVuZDtcbiAgfVxuICBnZXQgZnJhZ21lbnRFbmQoKSB7XG4gICAgdmFyIF90aGlzJGZyYWdtZW50cztcbiAgICBpZiAoKF90aGlzJGZyYWdtZW50cyA9IHRoaXMuZnJhZ21lbnRzKSAhPSBudWxsICYmIF90aGlzJGZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLmZyYWdtZW50c1t0aGlzLmZyYWdtZW50cy5sZW5ndGggLSAxXS5lbmQ7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG4gIGdldCBhZ2UoKSB7XG4gICAgaWYgKHRoaXMuYWR2YW5jZWREYXRlVGltZSkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KERhdGUubm93KCkgLSB0aGlzLmFkdmFuY2VkRGF0ZVRpbWUsIDApIC8gMTAwMDtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZ2V0IGxhc3RQYXJ0SW5kZXgoKSB7XG4gICAgdmFyIF90aGlzJHBhcnRMaXN0MjtcbiAgICBpZiAoKF90aGlzJHBhcnRMaXN0MiA9IHRoaXMucGFydExpc3QpICE9IG51bGwgJiYgX3RoaXMkcGFydExpc3QyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFydExpc3RbdGhpcy5wYXJ0TGlzdC5sZW5ndGggLSAxXS5pbmRleDtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGdldCBsYXN0UGFydFNuKCkge1xuICAgIHZhciBfdGhpcyRwYXJ0TGlzdDM7XG4gICAgaWYgKChfdGhpcyRwYXJ0TGlzdDMgPSB0aGlzLnBhcnRMaXN0KSAhPSBudWxsICYmIF90aGlzJHBhcnRMaXN0My5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnRMaXN0W3RoaXMucGFydExpc3QubGVuZ3RoIC0gMV0uZnJhZ21lbnQuc247XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmVuZFNOO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NERlY29kZShiYXNlNjRlbmNvZGVkU3RyKSB7XG4gIHJldHVybiBVaW50OEFycmF5LmZyb20oYXRvYihiYXNlNjRlbmNvZGVkU3RyKSwgYyA9PiBjLmNoYXJDb2RlQXQoMCkpO1xufVxuXG5mdW5jdGlvbiBnZXRLZXlJZEJ5dGVzKHN0cikge1xuICBjb25zdCBrZXlJZGJ5dGVzID0gc3RyVG9VdGY4YXJyYXkoc3RyKS5zdWJhcnJheSgwLCAxNik7XG4gIGNvbnN0IHBhZGRlZGtleUlkYnl0ZXMgPSBuZXcgVWludDhBcnJheSgxNik7XG4gIHBhZGRlZGtleUlkYnl0ZXMuc2V0KGtleUlkYnl0ZXMsIDE2IC0ga2V5SWRieXRlcy5sZW5ndGgpO1xuICByZXR1cm4gcGFkZGVka2V5SWRieXRlcztcbn1cbmZ1bmN0aW9uIGNoYW5nZUVuZGlhbm5lc3Moa2V5SWQpIHtcbiAgY29uc3Qgc3dhcCA9IGZ1bmN0aW9uIHN3YXAoYXJyYXksIGZyb20sIHRvKSB7XG4gICAgY29uc3QgY3VyID0gYXJyYXlbZnJvbV07XG4gICAgYXJyYXlbZnJvbV0gPSBhcnJheVt0b107XG4gICAgYXJyYXlbdG9dID0gY3VyO1xuICB9O1xuICBzd2FwKGtleUlkLCAwLCAzKTtcbiAgc3dhcChrZXlJZCwgMSwgMik7XG4gIHN3YXAoa2V5SWQsIDQsIDUpO1xuICBzd2FwKGtleUlkLCA2LCA3KTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnREYXRhVXJpVG9BcnJheUJ5dGVzKHVyaSkge1xuICAvLyBkYXRhOls8bWVkaWEgdHlwZV1bO2F0dHJpYnV0ZT12YWx1ZV1bO2Jhc2U2NF0sPGRhdGE+XG4gIGNvbnN0IGNvbG9uc3BsaXQgPSB1cmkuc3BsaXQoJzonKTtcbiAgbGV0IGtleWRhdGEgPSBudWxsO1xuICBpZiAoY29sb25zcGxpdFswXSA9PT0gJ2RhdGEnICYmIGNvbG9uc3BsaXQubGVuZ3RoID09PSAyKSB7XG4gICAgY29uc3Qgc2VtaWNvbG9uc3BsaXQgPSBjb2xvbnNwbGl0WzFdLnNwbGl0KCc7Jyk7XG4gICAgY29uc3QgY29tbWFzcGxpdCA9IHNlbWljb2xvbnNwbGl0W3NlbWljb2xvbnNwbGl0Lmxlbmd0aCAtIDFdLnNwbGl0KCcsJyk7XG4gICAgaWYgKGNvbW1hc3BsaXQubGVuZ3RoID09PSAyKSB7XG4gICAgICBjb25zdCBpc2Jhc2U2NCA9IGNvbW1hc3BsaXRbMF0gPT09ICdiYXNlNjQnO1xuICAgICAgY29uc3QgZGF0YSA9IGNvbW1hc3BsaXRbMV07XG4gICAgICBpZiAoaXNiYXNlNjQpIHtcbiAgICAgICAgc2VtaWNvbG9uc3BsaXQuc3BsaWNlKC0xLCAxKTsgLy8gcmVtb3ZlIGZyb20gcHJvY2Vzc2luZ1xuICAgICAgICBrZXlkYXRhID0gYmFzZTY0RGVjb2RlKGRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5ZGF0YSA9IGdldEtleUlkQnl0ZXMoZGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBrZXlkYXRhO1xufVxuZnVuY3Rpb24gc3RyVG9VdGY4YXJyYXkoc3RyKSB7XG4gIHJldHVybiBVaW50OEFycmF5LmZyb20odW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpLCBjID0+IGMuY2hhckNvZGVBdCgwKSk7XG59XG5cbi8qKiByZXR1cm5zIGB1bmRlZmluZWRgIGlzIGBzZWxmYCBpcyBtaXNzaW5nLCBlLmcuIGluIG5vZGUgKi9cbmNvbnN0IG9wdGlvbmFsU2VsZiA9IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTmF2aWdhdG9yL3JlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc1xuICovXG52YXIgS2V5U3lzdGVtcyA9IHtcbiAgQ0xFQVJLRVk6IFwib3JnLnczLmNsZWFya2V5XCIsXG4gIEZBSVJQTEFZOiBcImNvbS5hcHBsZS5mcHNcIixcbiAgUExBWVJFQURZOiBcImNvbS5taWNyb3NvZnQucGxheXJlYWR5XCIsXG4gIFdJREVWSU5FOiBcImNvbS53aWRldmluZS5hbHBoYVwiXG59O1xuXG4vLyBQbGF5bGlzdCAjRVhULVgtS0VZIEtFWUZPUk1BVCB2YWx1ZXNcbnZhciBLZXlTeXN0ZW1Gb3JtYXRzID0ge1xuICBDTEVBUktFWTogXCJvcmcudzMuY2xlYXJrZXlcIixcbiAgRkFJUlBMQVk6IFwiY29tLmFwcGxlLnN0cmVhbWluZ2tleWRlbGl2ZXJ5XCIsXG4gIFBMQVlSRUFEWTogXCJjb20ubWljcm9zb2Z0LnBsYXlyZWFkeVwiLFxuICBXSURFVklORTogXCJ1cm46dXVpZDplZGVmOGJhOS03OWQ2LTRhY2UtYTNjOC0yN2RjZDUxZDIxZWRcIlxufTtcbmZ1bmN0aW9uIGtleVN5c3RlbUZvcm1hdFRvS2V5U3lzdGVtRG9tYWluKGZvcm1hdCkge1xuICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgIGNhc2UgS2V5U3lzdGVtRm9ybWF0cy5GQUlSUExBWTpcbiAgICAgIHJldHVybiBLZXlTeXN0ZW1zLkZBSVJQTEFZO1xuICAgIGNhc2UgS2V5U3lzdGVtRm9ybWF0cy5QTEFZUkVBRFk6XG4gICAgICByZXR1cm4gS2V5U3lzdGVtcy5QTEFZUkVBRFk7XG4gICAgY2FzZSBLZXlTeXN0ZW1Gb3JtYXRzLldJREVWSU5FOlxuICAgICAgcmV0dXJuIEtleVN5c3RlbXMuV0lERVZJTkU7XG4gICAgY2FzZSBLZXlTeXN0ZW1Gb3JtYXRzLkNMRUFSS0VZOlxuICAgICAgcmV0dXJuIEtleVN5c3RlbXMuQ0xFQVJLRVk7XG4gIH1cbn1cblxuLy8gU3lzdGVtIElEcyBmb3Igd2hpY2ggd2UgY2FuIGV4dHJhY3QgYSBrZXkgSUQgZnJvbSBcImVuY3J5cHRlZFwiIGV2ZW50IFBTU0hcbnZhciBLZXlTeXN0ZW1JZHMgPSB7XG4gIFdJREVWSU5FOiBcImVkZWY4YmE5NzlkNjRhY2VhM2M4MjdkY2Q1MWQyMWVkXCJcbn07XG5mdW5jdGlvbiBrZXlTeXN0ZW1JZFRvS2V5U3lzdGVtRG9tYWluKHN5c3RlbUlkKSB7XG4gIGlmIChzeXN0ZW1JZCA9PT0gS2V5U3lzdGVtSWRzLldJREVWSU5FKSB7XG4gICAgcmV0dXJuIEtleVN5c3RlbXMuV0lERVZJTkU7XG4gICAgLy8gfSBlbHNlIGlmIChzeXN0ZW1JZCA9PT0gS2V5U3lzdGVtSWRzLlBMQVlSRUFEWSkge1xuICAgIC8vICAgcmV0dXJuIEtleVN5c3RlbXMuUExBWVJFQURZO1xuICAgIC8vIH0gZWxzZSBpZiAoc3lzdGVtSWQgPT09IEtleVN5c3RlbUlkcy5DRU5DIHx8IHN5c3RlbUlkID09PSBLZXlTeXN0ZW1JZHMuQ0xFQVJLRVkpIHtcbiAgICAvLyAgIHJldHVybiBLZXlTeXN0ZW1zLkNMRUFSS0VZO1xuICB9XG59XG5mdW5jdGlvbiBrZXlTeXN0ZW1Eb21haW5Ub0tleVN5c3RlbUZvcm1hdChrZXlTeXN0ZW0pIHtcbiAgc3dpdGNoIChrZXlTeXN0ZW0pIHtcbiAgICBjYXNlIEtleVN5c3RlbXMuRkFJUlBMQVk6XG4gICAgICByZXR1cm4gS2V5U3lzdGVtRm9ybWF0cy5GQUlSUExBWTtcbiAgICBjYXNlIEtleVN5c3RlbXMuUExBWVJFQURZOlxuICAgICAgcmV0dXJuIEtleVN5c3RlbUZvcm1hdHMuUExBWVJFQURZO1xuICAgIGNhc2UgS2V5U3lzdGVtcy5XSURFVklORTpcbiAgICAgIHJldHVybiBLZXlTeXN0ZW1Gb3JtYXRzLldJREVWSU5FO1xuICAgIGNhc2UgS2V5U3lzdGVtcy5DTEVBUktFWTpcbiAgICAgIHJldHVybiBLZXlTeXN0ZW1Gb3JtYXRzLkNMRUFSS0VZO1xuICB9XG59XG5mdW5jdGlvbiBnZXRLZXlTeXN0ZW1zRm9yQ29uZmlnKGNvbmZpZykge1xuICBjb25zdCB7XG4gICAgZHJtU3lzdGVtcyxcbiAgICB3aWRldmluZUxpY2Vuc2VVcmxcbiAgfSA9IGNvbmZpZztcbiAgY29uc3Qga2V5U3lzdGVtc1RvQXR0ZW1wdCA9IGRybVN5c3RlbXMgPyBbS2V5U3lzdGVtcy5GQUlSUExBWSwgS2V5U3lzdGVtcy5XSURFVklORSwgS2V5U3lzdGVtcy5QTEFZUkVBRFksIEtleVN5c3RlbXMuQ0xFQVJLRVldLmZpbHRlcihrZXlTeXN0ZW0gPT4gISFkcm1TeXN0ZW1zW2tleVN5c3RlbV0pIDogW107XG4gIGlmICgha2V5U3lzdGVtc1RvQXR0ZW1wdFtLZXlTeXN0ZW1zLldJREVWSU5FXSAmJiB3aWRldmluZUxpY2Vuc2VVcmwpIHtcbiAgICBrZXlTeXN0ZW1zVG9BdHRlbXB0LnB1c2goS2V5U3lzdGVtcy5XSURFVklORSk7XG4gIH1cbiAgcmV0dXJuIGtleVN5c3RlbXNUb0F0dGVtcHQ7XG59XG5jb25zdCByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MgPSBmdW5jdGlvbiAoX29wdGlvbmFsU2VsZiRuYXZpZ2F0KSB7XG4gIGlmIChvcHRpb25hbFNlbGYgIT0gbnVsbCAmJiAoX29wdGlvbmFsU2VsZiRuYXZpZ2F0ID0gb3B0aW9uYWxTZWxmLm5hdmlnYXRvcikgIT0gbnVsbCAmJiBfb3B0aW9uYWxTZWxmJG5hdmlnYXQucmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzKSB7XG4gICAgcmV0dXJuIHNlbGYubmF2aWdhdG9yLnJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzcy5iaW5kKHNlbGYubmF2aWdhdG9yKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufSgpO1xuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01lZGlhS2V5U3lzdGVtQ29uZmlndXJhdGlvblxuICovXG5mdW5jdGlvbiBnZXRTdXBwb3J0ZWRNZWRpYUtleVN5c3RlbUNvbmZpZ3VyYXRpb25zKGtleVN5c3RlbSwgYXVkaW9Db2RlY3MsIHZpZGVvQ29kZWNzLCBkcm1TeXN0ZW1PcHRpb25zKSB7XG4gIGxldCBpbml0RGF0YVR5cGVzO1xuICBzd2l0Y2ggKGtleVN5c3RlbSkge1xuICAgIGNhc2UgS2V5U3lzdGVtcy5GQUlSUExBWTpcbiAgICAgIGluaXREYXRhVHlwZXMgPSBbJ2NlbmMnLCAnc2luZiddO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBLZXlTeXN0ZW1zLldJREVWSU5FOlxuICAgIGNhc2UgS2V5U3lzdGVtcy5QTEFZUkVBRFk6XG4gICAgICBpbml0RGF0YVR5cGVzID0gWydjZW5jJ107XG4gICAgICBicmVhaztcbiAgICBjYXNlIEtleVN5c3RlbXMuQ0xFQVJLRVk6XG4gICAgICBpbml0RGF0YVR5cGVzID0gWydjZW5jJywgJ2tleWlkcyddO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBrZXktc3lzdGVtOiAke2tleVN5c3RlbX1gKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlTWVkaWFLZXlTeXN0ZW1Db25maWd1cmF0aW9ucyhpbml0RGF0YVR5cGVzLCBhdWRpb0NvZGVjcywgdmlkZW9Db2RlY3MsIGRybVN5c3RlbU9wdGlvbnMpO1xufVxuZnVuY3Rpb24gY3JlYXRlTWVkaWFLZXlTeXN0ZW1Db25maWd1cmF0aW9ucyhpbml0RGF0YVR5cGVzLCBhdWRpb0NvZGVjcywgdmlkZW9Db2RlY3MsIGRybVN5c3RlbU9wdGlvbnMpIHtcbiAgY29uc3QgYmFzZUNvbmZpZyA9IHtcbiAgICBpbml0RGF0YVR5cGVzOiBpbml0RGF0YVR5cGVzLFxuICAgIHBlcnNpc3RlbnRTdGF0ZTogZHJtU3lzdGVtT3B0aW9ucy5wZXJzaXN0ZW50U3RhdGUgfHwgJ29wdGlvbmFsJyxcbiAgICBkaXN0aW5jdGl2ZUlkZW50aWZpZXI6IGRybVN5c3RlbU9wdGlvbnMuZGlzdGluY3RpdmVJZGVudGlmaWVyIHx8ICdvcHRpb25hbCcsXG4gICAgc2Vzc2lvblR5cGVzOiBkcm1TeXN0ZW1PcHRpb25zLnNlc3Npb25UeXBlcyB8fCBbZHJtU3lzdGVtT3B0aW9ucy5zZXNzaW9uVHlwZSB8fCAndGVtcG9yYXJ5J10sXG4gICAgYXVkaW9DYXBhYmlsaXRpZXM6IGF1ZGlvQ29kZWNzLm1hcChjb2RlYyA9PiAoe1xuICAgICAgY29udGVudFR5cGU6IGBhdWRpby9tcDQ7IGNvZGVjcz1cIiR7Y29kZWN9XCJgLFxuICAgICAgcm9idXN0bmVzczogZHJtU3lzdGVtT3B0aW9ucy5hdWRpb1JvYnVzdG5lc3MgfHwgJycsXG4gICAgICBlbmNyeXB0aW9uU2NoZW1lOiBkcm1TeXN0ZW1PcHRpb25zLmF1ZGlvRW5jcnlwdGlvblNjaGVtZSB8fCBudWxsXG4gICAgfSkpLFxuICAgIHZpZGVvQ2FwYWJpbGl0aWVzOiB2aWRlb0NvZGVjcy5tYXAoY29kZWMgPT4gKHtcbiAgICAgIGNvbnRlbnRUeXBlOiBgdmlkZW8vbXA0OyBjb2RlY3M9XCIke2NvZGVjfVwiYCxcbiAgICAgIHJvYnVzdG5lc3M6IGRybVN5c3RlbU9wdGlvbnMudmlkZW9Sb2J1c3RuZXNzIHx8ICcnLFxuICAgICAgZW5jcnlwdGlvblNjaGVtZTogZHJtU3lzdGVtT3B0aW9ucy52aWRlb0VuY3J5cHRpb25TY2hlbWUgfHwgbnVsbFxuICAgIH0pKVxuICB9O1xuICByZXR1cm4gW2Jhc2VDb25maWddO1xufVxuXG5mdW5jdGlvbiBzbGljZVVpbnQ4KGFycmF5LCBzdGFydCwgZW5kKSB7XG4gIC8vIEB0cy1leHBlY3QtZXJyb3IgVGhpcyBwb2x5ZmlsbHMgSUUxMSB1c2FnZSBvZiBVaW50OEFycmF5IHNsaWNlLlxuICAvLyBJdCBhbHdheXMgZXhpc3RzIGluIHRoZSBUeXBlU2NyaXB0IGRlZmluaXRpb24gc28gZmFpbHMsIGJ1dCBpdCBmYWlscyBhdCBydW50aW1lIG9uIElFMTEuXG4gIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5zbGljZSA/IGFycmF5LnNsaWNlKHN0YXJ0LCBlbmQpIDogbmV3IFVpbnQ4QXJyYXkoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyYXksIHN0YXJ0LCBlbmQpKTtcbn1cblxuLy8gYnJlYWtpbmcgdXAgdGhvc2UgdHdvIHR5cGVzIGluIG9yZGVyIHRvIGNsYXJpZnkgd2hhdCBpcyBoYXBwZW5pbmcgaW4gdGhlIGRlY29kaW5nIHBhdGguXG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGFuIElEMyBoZWFkZXIgY2FuIGJlIGZvdW5kIGF0IG9mZnNldCBpbiBkYXRhXG4gKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIHRvIHNlYXJjaFxuICogQHBhcmFtIG9mZnNldCAtIFRoZSBvZmZzZXQgYXQgd2hpY2ggdG8gc3RhcnQgc2VhcmNoaW5nXG4gKi9cbmNvbnN0IGlzSGVhZGVyJDIgPSAoZGF0YSwgb2Zmc2V0KSA9PiB7XG4gIC8qXG4gICAqIGh0dHA6Ly9pZDMub3JnL2lkM3YyLjMuMFxuICAgKiBbMF0gICAgID0gJ0knXG4gICAqIFsxXSAgICAgPSAnRCdcbiAgICogWzJdICAgICA9ICczJ1xuICAgKiBbMyw0XSAgID0ge1ZlcnNpb259XG4gICAqIFs1XSAgICAgPSB7RmxhZ3N9XG4gICAqIFs2LTldICAgPSB7SUQzIFNpemV9XG4gICAqXG4gICAqIEFuIElEM3YyIHRhZyBjYW4gYmUgZGV0ZWN0ZWQgd2l0aCB0aGUgZm9sbG93aW5nIHBhdHRlcm46XG4gICAqICAkNDkgNDQgMzMgeXkgeXkgeHggenogenogenogenpcbiAgICogV2hlcmUgeXkgaXMgbGVzcyB0aGFuICRGRiwgeHggaXMgdGhlICdmbGFncycgYnl0ZSBhbmQgenogaXMgbGVzcyB0aGFuICQ4MFxuICAgKi9cbiAgaWYgKG9mZnNldCArIDEwIDw9IGRhdGEubGVuZ3RoKSB7XG4gICAgLy8gbG9vayBmb3IgJ0lEMycgaWRlbnRpZmllclxuICAgIGlmIChkYXRhW29mZnNldF0gPT09IDB4NDkgJiYgZGF0YVtvZmZzZXQgKyAxXSA9PT0gMHg0NCAmJiBkYXRhW29mZnNldCArIDJdID09PSAweDMzKSB7XG4gICAgICAvLyBjaGVjayB2ZXJzaW9uIGlzIHdpdGhpbiByYW5nZVxuICAgICAgaWYgKGRhdGFbb2Zmc2V0ICsgM10gPCAweGZmICYmIGRhdGFbb2Zmc2V0ICsgNF0gPCAweGZmKSB7XG4gICAgICAgIC8vIGNoZWNrIHNpemUgaXMgd2l0aGluIHJhbmdlXG4gICAgICAgIGlmIChkYXRhW29mZnNldCArIDZdIDwgMHg4MCAmJiBkYXRhW29mZnNldCArIDddIDwgMHg4MCAmJiBkYXRhW29mZnNldCArIDhdIDwgMHg4MCAmJiBkYXRhW29mZnNldCArIDldIDwgMHg4MCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGFuIElEMyBmb290ZXIgY2FuIGJlIGZvdW5kIGF0IG9mZnNldCBpbiBkYXRhXG4gKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIHRvIHNlYXJjaFxuICogQHBhcmFtIG9mZnNldCAtIFRoZSBvZmZzZXQgYXQgd2hpY2ggdG8gc3RhcnQgc2VhcmNoaW5nXG4gKi9cbmNvbnN0IGlzRm9vdGVyID0gKGRhdGEsIG9mZnNldCkgPT4ge1xuICAvKlxuICAgKiBUaGUgZm9vdGVyIGlzIGEgY29weSBvZiB0aGUgaGVhZGVyLCBidXQgd2l0aCBhIGRpZmZlcmVudCBpZGVudGlmaWVyXG4gICAqL1xuICBpZiAob2Zmc2V0ICsgMTAgPD0gZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBsb29rIGZvciAnM0RJJyBpZGVudGlmaWVyXG4gICAgaWYgKGRhdGFbb2Zmc2V0XSA9PT0gMHgzMyAmJiBkYXRhW29mZnNldCArIDFdID09PSAweDQ0ICYmIGRhdGFbb2Zmc2V0ICsgMl0gPT09IDB4NDkpIHtcbiAgICAgIC8vIGNoZWNrIHZlcnNpb24gaXMgd2l0aGluIHJhbmdlXG4gICAgICBpZiAoZGF0YVtvZmZzZXQgKyAzXSA8IDB4ZmYgJiYgZGF0YVtvZmZzZXQgKyA0XSA8IDB4ZmYpIHtcbiAgICAgICAgLy8gY2hlY2sgc2l6ZSBpcyB3aXRoaW4gcmFuZ2VcbiAgICAgICAgaWYgKGRhdGFbb2Zmc2V0ICsgNl0gPCAweDgwICYmIGRhdGFbb2Zmc2V0ICsgN10gPCAweDgwICYmIGRhdGFbb2Zmc2V0ICsgOF0gPCAweDgwICYmIGRhdGFbb2Zmc2V0ICsgOV0gPCAweDgwKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFueSBhZGphY2VudCBJRDMgdGFncyBmb3VuZCBpbiBkYXRhIHN0YXJ0aW5nIGF0IG9mZnNldCwgYXMgb25lIGJsb2NrIG9mIGRhdGFcbiAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgdG8gc2VhcmNoIGluXG4gKiBAcGFyYW0gb2Zmc2V0IC0gVGhlIG9mZnNldCBhdCB3aGljaCB0byBzdGFydCBzZWFyY2hpbmdcbiAqIEByZXR1cm5zIHRoZSBibG9jayBvZiBkYXRhIGNvbnRhaW5pbmcgYW55IElEMyB0YWdzIGZvdW5kXG4gKiBvciAqdW5kZWZpbmVkKiBpZiBubyBoZWFkZXIgaXMgZm91bmQgYXQgdGhlIHN0YXJ0aW5nIG9mZnNldFxuICovXG5jb25zdCBnZXRJRDNEYXRhID0gKGRhdGEsIG9mZnNldCkgPT4ge1xuICBjb25zdCBmcm9udCA9IG9mZnNldDtcbiAgbGV0IGxlbmd0aCA9IDA7XG4gIHdoaWxlIChpc0hlYWRlciQyKGRhdGEsIG9mZnNldCkpIHtcbiAgICAvLyBJRDMgaGVhZGVyIGlzIDEwIGJ5dGVzXG4gICAgbGVuZ3RoICs9IDEwO1xuICAgIGNvbnN0IHNpemUgPSByZWFkU2l6ZShkYXRhLCBvZmZzZXQgKyA2KTtcbiAgICBsZW5ndGggKz0gc2l6ZTtcbiAgICBpZiAoaXNGb290ZXIoZGF0YSwgb2Zmc2V0ICsgMTApKSB7XG4gICAgICAvLyBJRDMgZm9vdGVyIGlzIDEwIGJ5dGVzXG4gICAgICBsZW5ndGggKz0gMTA7XG4gICAgfVxuICAgIG9mZnNldCArPSBsZW5ndGg7XG4gIH1cbiAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gZGF0YS5zdWJhcnJheShmcm9udCwgZnJvbnQgKyBsZW5ndGgpO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuY29uc3QgcmVhZFNpemUgPSAoZGF0YSwgb2Zmc2V0KSA9PiB7XG4gIGxldCBzaXplID0gMDtcbiAgc2l6ZSA9IChkYXRhW29mZnNldF0gJiAweDdmKSA8PCAyMTtcbiAgc2l6ZSB8PSAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4N2YpIDw8IDE0O1xuICBzaXplIHw9IChkYXRhW29mZnNldCArIDJdICYgMHg3ZikgPDwgNztcbiAgc2l6ZSB8PSBkYXRhW29mZnNldCArIDNdICYgMHg3ZjtcbiAgcmV0dXJuIHNpemU7XG59O1xuY29uc3QgY2FuUGFyc2UkMiA9IChkYXRhLCBvZmZzZXQpID0+IHtcbiAgcmV0dXJuIGlzSGVhZGVyJDIoZGF0YSwgb2Zmc2V0KSAmJiByZWFkU2l6ZShkYXRhLCBvZmZzZXQgKyA2KSArIDEwIDw9IGRhdGEubGVuZ3RoIC0gb2Zmc2V0O1xufTtcblxuLyoqXG4gKiBTZWFyY2hlcyBmb3IgdGhlIEVsZW1lbnRhcnkgU3RyZWFtIHRpbWVzdGFtcCBmb3VuZCBpbiB0aGUgSUQzIGRhdGEgY2h1bmtcbiAqIEBwYXJhbSBkYXRhIC0gQmxvY2sgb2YgZGF0YSBjb250YWluaW5nIG9uZSBvciBtb3JlIElEMyB0YWdzXG4gKi9cbmNvbnN0IGdldFRpbWVTdGFtcCA9IGRhdGEgPT4ge1xuICBjb25zdCBmcmFtZXMgPSBnZXRJRDNGcmFtZXMoZGF0YSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZnJhbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZnJhbWUgPSBmcmFtZXNbaV07XG4gICAgaWYgKGlzVGltZVN0YW1wRnJhbWUoZnJhbWUpKSB7XG4gICAgICByZXR1cm4gcmVhZFRpbWVTdGFtcChmcmFtZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgSUQzIGZyYW1lIGlzIGFuIEVsZW1lbnRhcnkgU3RyZWFtIHRpbWVzdGFtcCBmcmFtZVxuICovXG5jb25zdCBpc1RpbWVTdGFtcEZyYW1lID0gZnJhbWUgPT4ge1xuICByZXR1cm4gZnJhbWUgJiYgZnJhbWUua2V5ID09PSAnUFJJVicgJiYgZnJhbWUuaW5mbyA9PT0gJ2NvbS5hcHBsZS5zdHJlYW1pbmcudHJhbnNwb3J0U3RyZWFtVGltZXN0YW1wJztcbn07XG5jb25zdCBnZXRGcmFtZURhdGEgPSBkYXRhID0+IHtcbiAgLypcbiAgRnJhbWUgSUQgICAgICAgJHh4IHh4IHh4IHh4IChmb3VyIGNoYXJhY3RlcnMpXG4gIFNpemUgICAgICAgICAgICR4eCB4eCB4eCB4eFxuICBGbGFncyAgICAgICAgICAkeHggeHhcbiAgKi9cbiAgY29uc3QgdHlwZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZGF0YVswXSwgZGF0YVsxXSwgZGF0YVsyXSwgZGF0YVszXSk7XG4gIGNvbnN0IHNpemUgPSByZWFkU2l6ZShkYXRhLCA0KTtcblxuICAvLyBza2lwIGZyYW1lIGlkLCBzaXplLCBhbmQgZmxhZ3NcbiAgY29uc3Qgb2Zmc2V0ID0gMTA7XG4gIHJldHVybiB7XG4gICAgdHlwZSxcbiAgICBzaXplLFxuICAgIGRhdGE6IGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBzaXplKVxuICB9O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIElEMyBmcmFtZXMgZm91bmQgaW4gYWxsIHRoZSBJRDMgdGFncyBpbiB0aGUgaWQzRGF0YVxuICogQHBhcmFtIGlkM0RhdGEgLSBUaGUgSUQzIGRhdGEgY29udGFpbmluZyBvbmUgb3IgbW9yZSBJRDMgdGFnc1xuICovXG5jb25zdCBnZXRJRDNGcmFtZXMgPSBpZDNEYXRhID0+IHtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGNvbnN0IGZyYW1lcyA9IFtdO1xuICB3aGlsZSAoaXNIZWFkZXIkMihpZDNEYXRhLCBvZmZzZXQpKSB7XG4gICAgY29uc3Qgc2l6ZSA9IHJlYWRTaXplKGlkM0RhdGEsIG9mZnNldCArIDYpO1xuICAgIC8vIHNraXAgcGFzdCBJRDMgaGVhZGVyXG4gICAgb2Zmc2V0ICs9IDEwO1xuICAgIGNvbnN0IGVuZCA9IG9mZnNldCArIHNpemU7XG4gICAgLy8gbG9vcCB0aHJvdWdoIGZyYW1lcyBpbiB0aGUgSUQzIHRhZ1xuICAgIHdoaWxlIChvZmZzZXQgKyA4IDwgZW5kKSB7XG4gICAgICBjb25zdCBmcmFtZURhdGEgPSBnZXRGcmFtZURhdGEoaWQzRGF0YS5zdWJhcnJheShvZmZzZXQpKTtcbiAgICAgIGNvbnN0IGZyYW1lID0gZGVjb2RlRnJhbWUoZnJhbWVEYXRhKTtcbiAgICAgIGlmIChmcmFtZSkge1xuICAgICAgICBmcmFtZXMucHVzaChmcmFtZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHNraXAgZnJhbWUgaGVhZGVyIGFuZCBmcmFtZSBkYXRhXG4gICAgICBvZmZzZXQgKz0gZnJhbWVEYXRhLnNpemUgKyAxMDtcbiAgICB9XG4gICAgaWYgKGlzRm9vdGVyKGlkM0RhdGEsIG9mZnNldCkpIHtcbiAgICAgIG9mZnNldCArPSAxMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZyYW1lcztcbn07XG5jb25zdCBkZWNvZGVGcmFtZSA9IGZyYW1lID0+IHtcbiAgaWYgKGZyYW1lLnR5cGUgPT09ICdQUklWJykge1xuICAgIHJldHVybiBkZWNvZGVQcml2RnJhbWUoZnJhbWUpO1xuICB9IGVsc2UgaWYgKGZyYW1lLnR5cGVbMF0gPT09ICdXJykge1xuICAgIHJldHVybiBkZWNvZGVVUkxGcmFtZShmcmFtZSk7XG4gIH1cbiAgcmV0dXJuIGRlY29kZVRleHRGcmFtZShmcmFtZSk7XG59O1xuY29uc3QgZGVjb2RlUHJpdkZyYW1lID0gZnJhbWUgPT4ge1xuICAvKlxuICBGb3JtYXQ6IDx0ZXh0IHN0cmluZz5cXDA8YmluYXJ5IGRhdGE+XG4gICovXG4gIGlmIChmcmFtZS5zaXplIDwgMikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgY29uc3Qgb3duZXIgPSB1dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhLCB0cnVlKTtcbiAgY29uc3QgcHJpdmF0ZURhdGEgPSBuZXcgVWludDhBcnJheShmcmFtZS5kYXRhLnN1YmFycmF5KG93bmVyLmxlbmd0aCArIDEpKTtcbiAgcmV0dXJuIHtcbiAgICBrZXk6IGZyYW1lLnR5cGUsXG4gICAgaW5mbzogb3duZXIsXG4gICAgZGF0YTogcHJpdmF0ZURhdGEuYnVmZmVyXG4gIH07XG59O1xuY29uc3QgZGVjb2RlVGV4dEZyYW1lID0gZnJhbWUgPT4ge1xuICBpZiAoZnJhbWUuc2l6ZSA8IDIpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChmcmFtZS50eXBlID09PSAnVFhYWCcpIHtcbiAgICAvKlxuICAgIEZvcm1hdDpcbiAgICBbMF0gICA9IHtUZXh0IEVuY29kaW5nfVxuICAgIFsxLT9dID0ge0Rlc2NyaXB0aW9ufVxcMHtWYWx1ZX1cbiAgICAqL1xuICAgIGxldCBpbmRleCA9IDE7XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSB1dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhLnN1YmFycmF5KGluZGV4KSwgdHJ1ZSk7XG4gICAgaW5kZXggKz0gZGVzY3JpcHRpb24ubGVuZ3RoICsgMTtcbiAgICBjb25zdCB2YWx1ZSA9IHV0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEuc3ViYXJyYXkoaW5kZXgpKTtcbiAgICByZXR1cm4ge1xuICAgICAga2V5OiBmcmFtZS50eXBlLFxuICAgICAgaW5mbzogZGVzY3JpcHRpb24sXG4gICAgICBkYXRhOiB2YWx1ZVxuICAgIH07XG4gIH1cbiAgLypcbiAgRm9ybWF0OlxuICBbMF0gICA9IHtUZXh0IEVuY29kaW5nfVxuICBbMS0/XSA9IHtWYWx1ZX1cbiAgKi9cbiAgY29uc3QgdGV4dCA9IHV0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEuc3ViYXJyYXkoMSkpO1xuICByZXR1cm4ge1xuICAgIGtleTogZnJhbWUudHlwZSxcbiAgICBkYXRhOiB0ZXh0XG4gIH07XG59O1xuY29uc3QgZGVjb2RlVVJMRnJhbWUgPSBmcmFtZSA9PiB7XG4gIGlmIChmcmFtZS50eXBlID09PSAnV1hYWCcpIHtcbiAgICAvKlxuICAgIEZvcm1hdDpcbiAgICBbMF0gICA9IHtUZXh0IEVuY29kaW5nfVxuICAgIFsxLT9dID0ge0Rlc2NyaXB0aW9ufVxcMHtVUkx9XG4gICAgKi9cbiAgICBpZiAoZnJhbWUuc2l6ZSA8IDIpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGxldCBpbmRleCA9IDE7XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSB1dGY4QXJyYXlUb1N0cihmcmFtZS5kYXRhLnN1YmFycmF5KGluZGV4KSwgdHJ1ZSk7XG4gICAgaW5kZXggKz0gZGVzY3JpcHRpb24ubGVuZ3RoICsgMTtcbiAgICBjb25zdCB2YWx1ZSA9IHV0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEuc3ViYXJyYXkoaW5kZXgpKTtcbiAgICByZXR1cm4ge1xuICAgICAga2V5OiBmcmFtZS50eXBlLFxuICAgICAgaW5mbzogZGVzY3JpcHRpb24sXG4gICAgICBkYXRhOiB2YWx1ZVxuICAgIH07XG4gIH1cbiAgLypcbiAgRm9ybWF0OlxuICBbMC0/XSA9IHtVUkx9XG4gICovXG4gIGNvbnN0IHVybCA9IHV0ZjhBcnJheVRvU3RyKGZyYW1lLmRhdGEpO1xuICByZXR1cm4ge1xuICAgIGtleTogZnJhbWUudHlwZSxcbiAgICBkYXRhOiB1cmxcbiAgfTtcbn07XG5jb25zdCByZWFkVGltZVN0YW1wID0gdGltZVN0YW1wRnJhbWUgPT4ge1xuICBpZiAodGltZVN0YW1wRnJhbWUuZGF0YS5ieXRlTGVuZ3RoID09PSA4KSB7XG4gICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KHRpbWVTdGFtcEZyYW1lLmRhdGEpO1xuICAgIC8vIHRpbWVzdGFtcCBpcyAzMyBiaXQgZXhwcmVzc2VkIGFzIGEgYmlnLWVuZGlhbiBlaWdodC1vY3RldCBudW1iZXIsXG4gICAgLy8gd2l0aCB0aGUgdXBwZXIgMzEgYml0cyBzZXQgdG8gemVyby5cbiAgICBjb25zdCBwdHMzM0JpdCA9IGRhdGFbM10gJiAweDE7XG4gICAgbGV0IHRpbWVzdGFtcCA9IChkYXRhWzRdIDw8IDIzKSArIChkYXRhWzVdIDw8IDE1KSArIChkYXRhWzZdIDw8IDcpICsgZGF0YVs3XTtcbiAgICB0aW1lc3RhbXAgLz0gNDU7XG4gICAgaWYgKHB0czMzQml0KSB7XG4gICAgICB0aW1lc3RhbXAgKz0gNDc3MjE4NTguODQ7XG4gICAgfSAvLyAyXjMyIC8gOTBcblxuICAgIHJldHVybiBNYXRoLnJvdW5kKHRpbWVzdGFtcCk7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODkzNjk4NC91aW50OGFycmF5LXRvLXN0cmluZy1pbi1qYXZhc2NyaXB0LzIyMzczMTk3XG4vLyBodHRwOi8vd3d3Lm9uaWNvcy5jb20vc3RhZmYvaXovYW11c2UvamF2YXNjcmlwdC9leHBlcnQvdXRmLnR4dFxuLyogdXRmLmpzIC0gVVRGLTggPD0+IFVURi0xNiBjb252ZXJ0aW9uXG4gKlxuICogQ29weXJpZ2h0IChDKSAxOTk5IE1hc2FuYW8gSXp1bW8gPGl6QG9uaWNvcy5jby5qcD5cbiAqIFZlcnNpb246IDEuMFxuICogTGFzdE1vZGlmaWVkOiBEZWMgMjUgMTk5OVxuICogVGhpcyBsaWJyYXJ5IGlzIGZyZWUuICBZb3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0LlxuICovXG5jb25zdCB1dGY4QXJyYXlUb1N0ciA9IChhcnJheSwgZXhpdE9uTnVsbCA9IGZhbHNlKSA9PiB7XG4gIGNvbnN0IGRlY29kZXIgPSBnZXRUZXh0RGVjb2RlcigpO1xuICBpZiAoZGVjb2Rlcikge1xuICAgIGNvbnN0IGRlY29kZWQgPSBkZWNvZGVyLmRlY29kZShhcnJheSk7XG4gICAgaWYgKGV4aXRPbk51bGwpIHtcbiAgICAgIC8vIGdyYWIgdXAgdG8gdGhlIGZpcnN0IG51bGxcbiAgICAgIGNvbnN0IGlkeCA9IGRlY29kZWQuaW5kZXhPZignXFwwJyk7XG4gICAgICByZXR1cm4gaWR4ICE9PSAtMSA/IGRlY29kZWQuc3Vic3RyaW5nKDAsIGlkeCkgOiBkZWNvZGVkO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBhbnkgbnVsbCBjaGFyYWN0ZXJzXG4gICAgcmV0dXJuIGRlY29kZWQucmVwbGFjZSgvXFwwL2csICcnKTtcbiAgfVxuICBjb25zdCBsZW4gPSBhcnJheS5sZW5ndGg7XG4gIGxldCBjO1xuICBsZXQgY2hhcjI7XG4gIGxldCBjaGFyMztcbiAgbGV0IG91dCA9ICcnO1xuICBsZXQgaSA9IDA7XG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgYyA9IGFycmF5W2krK107XG4gICAgaWYgKGMgPT09IDB4MDAgJiYgZXhpdE9uTnVsbCkge1xuICAgICAgcmV0dXJuIG91dDtcbiAgICB9IGVsc2UgaWYgKGMgPT09IDB4MDAgfHwgYyA9PT0gMHgwMykge1xuICAgICAgLy8gSWYgdGhlIGNoYXJhY3RlciBpcyAzIChFTkRfT0ZfVEVYVCkgb3IgMCAoTlVMTCkgdGhlbiBza2lwIGl0XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgc3dpdGNoIChjID4+IDQpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgIGNhc2UgMTpcbiAgICAgIGNhc2UgMjpcbiAgICAgIGNhc2UgMzpcbiAgICAgIGNhc2UgNDpcbiAgICAgIGNhc2UgNTpcbiAgICAgIGNhc2UgNjpcbiAgICAgIGNhc2UgNzpcbiAgICAgICAgLy8gMHh4eHh4eHhcbiAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMjpcbiAgICAgIGNhc2UgMTM6XG4gICAgICAgIC8vIDExMHggeHh4eCAgIDEweHggeHh4eFxuICAgICAgICBjaGFyMiA9IGFycmF5W2krK107XG4gICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjICYgMHgxZikgPDwgNiB8IGNoYXIyICYgMHgzZik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxNDpcbiAgICAgICAgLy8gMTExMCB4eHh4ICAxMHh4IHh4eHggIDEweHggeHh4eFxuICAgICAgICBjaGFyMiA9IGFycmF5W2krK107XG4gICAgICAgIGNoYXIzID0gYXJyYXlbaSsrXTtcbiAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMgJiAweDBmKSA8PCAxMiB8IChjaGFyMiAmIDB4M2YpIDw8IDYgfCAoY2hhcjMgJiAweDNmKSA8PCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59O1xubGV0IGRlY29kZXI7XG5mdW5jdGlvbiBnZXRUZXh0RGVjb2RlcigpIHtcbiAgLy8gT24gUGxheSBTdGF0aW9uIDQsIFRleHREZWNvZGVyIGlzIGRlZmluZWQgYnV0IHBhcnRpYWxseSBpbXBsZW1lbnRlZC5cbiAgLy8gTWFudWFsIGRlY29kaW5nIG9wdGlvbiBpcyBwcmVmZXJhYmxlXG4gIGlmIChuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKCdQbGF5U3RhdGlvbiA0JykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFkZWNvZGVyICYmIHR5cGVvZiBzZWxmLlRleHREZWNvZGVyICE9PSAndW5kZWZpbmVkJykge1xuICAgIGRlY29kZXIgPSBuZXcgc2VsZi5UZXh0RGVjb2RlcigndXRmLTgnKTtcbiAgfVxuICByZXR1cm4gZGVjb2Rlcjtcbn1cblxuLyoqXG4gKiAgaGV4IGR1bXAgaGVscGVyIGNsYXNzXG4gKi9cblxuY29uc3QgSGV4ID0ge1xuICBoZXhEdW1wOiBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICBsZXQgc3RyID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGggPSBhcnJheVtpXS50b1N0cmluZygxNik7XG4gICAgICBpZiAoaC5sZW5ndGggPCAyKSB7XG4gICAgICAgIGggPSAnMCcgKyBoO1xuICAgICAgfVxuICAgICAgc3RyICs9IGg7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH1cbn07XG5cbmNvbnN0IFVJTlQzMl9NQVgkMSA9IE1hdGgucG93KDIsIDMyKSAtIDE7XG5jb25zdCBwdXNoID0gW10ucHVzaDtcblxuLy8gV2UgYXJlIHVzaW5nIGZpeGVkIHRyYWNrIElEcyBmb3IgZHJpdmluZyB0aGUgTVA0IHJlbXV4ZXJcbi8vIGluc3RlYWQgb2YgZm9sbG93aW5nIHRoZSBUUyBQSURzLlxuLy8gVGhlcmUgaXMgbm8gcmVhc29uIG5vdCB0byBkbyB0aGlzIGFuZCBzb21lIGJyb3dzZXJzL1NvdXJjZUJ1ZmZlci1kZW11eGVyc1xuLy8gbWF5IG5vdCBsaWtlIGlmIHRoZXJlIGFyZSBUcmFja0lEIFwic3dpdGNoZXNcIlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy8xMzMxXG4vLyBIZXJlIHdlIGFyZSBtYXBwaW5nIG91ciBpbnRlcm5hbCB0cmFjayB0eXBlcyB0byBjb25zdGFudCBNUDQgdHJhY2sgSURzXG4vLyBXaXRoIE1TRSBjdXJyZW50bHkgb25lIGNhbiBvbmx5IGhhdmUgb25lIHRyYWNrIG9mIGVhY2gsIGFuZCB3ZSBhcmUgbXV4aW5nXG4vLyB3aGF0ZXZlciB2aWRlby9hdWRpbyByZW5kaXRpb24gaW4gdGhlbS5cbmNvbnN0IFJlbXV4ZXJUcmFja0lkQ29uZmlnID0ge1xuICB2aWRlbzogMSxcbiAgYXVkaW86IDIsXG4gIGlkMzogMyxcbiAgdGV4dDogNFxufTtcbmZ1bmN0aW9uIGJpbjJzdHIoZGF0YSkge1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBkYXRhKTtcbn1cbmZ1bmN0aW9uIHJlYWRVaW50MTYoYnVmZmVyLCBvZmZzZXQpIHtcbiAgY29uc3QgdmFsID0gYnVmZmVyW29mZnNldF0gPDwgOCB8IGJ1ZmZlcltvZmZzZXQgKyAxXTtcbiAgcmV0dXJuIHZhbCA8IDAgPyA2NTUzNiArIHZhbCA6IHZhbDtcbn1cbmZ1bmN0aW9uIHJlYWRVaW50MzIoYnVmZmVyLCBvZmZzZXQpIHtcbiAgY29uc3QgdmFsID0gcmVhZFNpbnQzMihidWZmZXIsIG9mZnNldCk7XG4gIHJldHVybiB2YWwgPCAwID8gNDI5NDk2NzI5NiArIHZhbCA6IHZhbDtcbn1cbmZ1bmN0aW9uIHJlYWRTaW50MzIoYnVmZmVyLCBvZmZzZXQpIHtcbiAgcmV0dXJuIGJ1ZmZlcltvZmZzZXRdIDw8IDI0IHwgYnVmZmVyW29mZnNldCArIDFdIDw8IDE2IHwgYnVmZmVyW29mZnNldCArIDJdIDw8IDggfCBidWZmZXJbb2Zmc2V0ICsgM107XG59XG5mdW5jdGlvbiB3cml0ZVVpbnQzMihidWZmZXIsIG9mZnNldCwgdmFsdWUpIHtcbiAgYnVmZmVyW29mZnNldF0gPSB2YWx1ZSA+PiAyNDtcbiAgYnVmZmVyW29mZnNldCArIDFdID0gdmFsdWUgPj4gMTYgJiAweGZmO1xuICBidWZmZXJbb2Zmc2V0ICsgMl0gPSB2YWx1ZSA+PiA4ICYgMHhmZjtcbiAgYnVmZmVyW29mZnNldCArIDNdID0gdmFsdWUgJiAweGZmO1xufVxuXG4vLyBGaW5kIFwibW9vZlwiIGJveFxuZnVuY3Rpb24gaGFzTW9vZkRhdGEoZGF0YSkge1xuICBjb25zdCBlbmQgPSBkYXRhLmJ5dGVMZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZW5kOykge1xuICAgIGNvbnN0IHNpemUgPSByZWFkVWludDMyKGRhdGEsIGkpO1xuICAgIGlmIChzaXplID4gOCAmJiBkYXRhW2kgKyA0XSA9PT0gMHg2ZCAmJiBkYXRhW2kgKyA1XSA9PT0gMHg2ZiAmJiBkYXRhW2kgKyA2XSA9PT0gMHg2ZiAmJiBkYXRhW2kgKyA3XSA9PT0gMHg2Nikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGkgPSBzaXplID4gMSA/IGkgKyBzaXplIDogZW5kO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gRmluZCB0aGUgZGF0YSBmb3IgYSBib3ggc3BlY2lmaWVkIGJ5IGl0cyBwYXRoXG5mdW5jdGlvbiBmaW5kQm94KGRhdGEsIHBhdGgpIHtcbiAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICBpZiAoIXBhdGgubGVuZ3RoKSB7XG4gICAgLy8gc2hvcnQtY2lyY3VpdCB0aGUgc2VhcmNoIGZvciBlbXB0eSBwYXRoc1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG4gIGNvbnN0IGVuZCA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmQ7KSB7XG4gICAgY29uc3Qgc2l6ZSA9IHJlYWRVaW50MzIoZGF0YSwgaSk7XG4gICAgY29uc3QgdHlwZSA9IGJpbjJzdHIoZGF0YS5zdWJhcnJheShpICsgNCwgaSArIDgpKTtcbiAgICBjb25zdCBlbmRib3ggPSBzaXplID4gMSA/IGkgKyBzaXplIDogZW5kO1xuICAgIGlmICh0eXBlID09PSBwYXRoWzBdKSB7XG4gICAgICBpZiAocGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgZW5kIG9mIHRoZSBwYXRoIGFuZCB3ZSd2ZSBmb3VuZCB0aGUgYm94IHdlIHdlcmVcbiAgICAgICAgLy8gbG9va2luZyBmb3JcbiAgICAgICAgcmVzdWx0cy5wdXNoKGRhdGEuc3ViYXJyYXkoaSArIDgsIGVuZGJveCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciB0aGUgbmV4dCBib3ggYWxvbmcgdGhlIHBhdGhcbiAgICAgICAgY29uc3Qgc3VicmVzdWx0cyA9IGZpbmRCb3goZGF0YS5zdWJhcnJheShpICsgOCwgZW5kYm94KSwgcGF0aC5zbGljZSgxKSk7XG4gICAgICAgIGlmIChzdWJyZXN1bHRzLmxlbmd0aCkge1xuICAgICAgICAgIHB1c2guYXBwbHkocmVzdWx0cywgc3VicmVzdWx0cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaSA9IGVuZGJveDtcbiAgfVxuXG4gIC8vIHdlJ3ZlIGZpbmlzaGVkIHNlYXJjaGluZyBhbGwgb2YgZGF0YVxuICByZXR1cm4gcmVzdWx0cztcbn1cbmZ1bmN0aW9uIHBhcnNlU2VnbWVudEluZGV4KHNpZHgpIHtcbiAgY29uc3QgcmVmZXJlbmNlcyA9IFtdO1xuICBjb25zdCB2ZXJzaW9uID0gc2lkeFswXTtcblxuICAvLyBzZXQgaW5pdGlhbCBvZmZzZXQsIHdlIHNraXAgdGhlIHJlZmVyZW5jZSBJRCAobm90IG5lZWRlZClcbiAgbGV0IGluZGV4ID0gODtcbiAgY29uc3QgdGltZXNjYWxlID0gcmVhZFVpbnQzMihzaWR4LCBpbmRleCk7XG4gIGluZGV4ICs9IDQ7XG5cbiAgLy8gVE9ETzogcGFyc2UgZWFybGllc3RQcmVzZW50YXRpb25UaW1lIGFuZCBmaXJzdE9mZnNldFxuICAvLyB1c3VhbGx5IHplcm8gaW4gb3VyIGNhc2VcbiAgY29uc3QgZWFybGllc3RQcmVzZW50YXRpb25UaW1lID0gMDtcbiAgY29uc3QgZmlyc3RPZmZzZXQgPSAwO1xuICBpZiAodmVyc2lvbiA9PT0gMCkge1xuICAgIGluZGV4ICs9IDg7XG4gIH0gZWxzZSB7XG4gICAgaW5kZXggKz0gMTY7XG4gIH1cblxuICAvLyBza2lwIHJlc2VydmVkXG4gIGluZGV4ICs9IDI7XG4gIGxldCBzdGFydEJ5dGUgPSBzaWR4Lmxlbmd0aCArIGZpcnN0T2Zmc2V0O1xuICBjb25zdCByZWZlcmVuY2VzQ291bnQgPSByZWFkVWludDE2KHNpZHgsIGluZGV4KTtcbiAgaW5kZXggKz0gMjtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWZlcmVuY2VzQ291bnQ7IGkrKykge1xuICAgIGxldCByZWZlcmVuY2VJbmRleCA9IGluZGV4O1xuICAgIGNvbnN0IHJlZmVyZW5jZUluZm8gPSByZWFkVWludDMyKHNpZHgsIHJlZmVyZW5jZUluZGV4KTtcbiAgICByZWZlcmVuY2VJbmRleCArPSA0O1xuICAgIGNvbnN0IHJlZmVyZW5jZVNpemUgPSByZWZlcmVuY2VJbmZvICYgMHg3ZmZmZmZmZjtcbiAgICBjb25zdCByZWZlcmVuY2VUeXBlID0gKHJlZmVyZW5jZUluZm8gJiAweDgwMDAwMDAwKSA+Pj4gMzE7XG4gICAgaWYgKHJlZmVyZW5jZVR5cGUgPT09IDEpIHtcbiAgICAgIGxvZ2dlci53YXJuKCdTSURYIGhhcyBoaWVyYXJjaGljYWwgcmVmZXJlbmNlcyAobm90IHN1cHBvcnRlZCknKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzdWJzZWdtZW50RHVyYXRpb24gPSByZWFkVWludDMyKHNpZHgsIHJlZmVyZW5jZUluZGV4KTtcbiAgICByZWZlcmVuY2VJbmRleCArPSA0O1xuICAgIHJlZmVyZW5jZXMucHVzaCh7XG4gICAgICByZWZlcmVuY2VTaXplLFxuICAgICAgc3Vic2VnbWVudER1cmF0aW9uLFxuICAgICAgLy8gdW5zY2FsZWRcbiAgICAgIGluZm86IHtcbiAgICAgICAgZHVyYXRpb246IHN1YnNlZ21lbnREdXJhdGlvbiAvIHRpbWVzY2FsZSxcbiAgICAgICAgc3RhcnQ6IHN0YXJ0Qnl0ZSxcbiAgICAgICAgZW5kOiBzdGFydEJ5dGUgKyByZWZlcmVuY2VTaXplIC0gMVxuICAgICAgfVxuICAgIH0pO1xuICAgIHN0YXJ0Qnl0ZSArPSByZWZlcmVuY2VTaXplO1xuXG4gICAgLy8gU2tpcHBpbmcgMSBiaXQgZm9yIHxzdGFydHNXaXRoU2FwfCwgMyBiaXRzIGZvciB8c2FwVHlwZXwsIGFuZCAyOCBiaXRzXG4gICAgLy8gZm9yIHxzYXBEZWx0YXwuXG4gICAgcmVmZXJlbmNlSW5kZXggKz0gNDtcblxuICAgIC8vIHNraXAgdG8gbmV4dCByZWZcbiAgICBpbmRleCA9IHJlZmVyZW5jZUluZGV4O1xuICB9XG4gIHJldHVybiB7XG4gICAgZWFybGllc3RQcmVzZW50YXRpb25UaW1lLFxuICAgIHRpbWVzY2FsZSxcbiAgICB2ZXJzaW9uLFxuICAgIHJlZmVyZW5jZXNDb3VudCxcbiAgICByZWZlcmVuY2VzXG4gIH07XG59XG5cbi8qKlxuICogUGFyc2VzIGFuIE1QNCBpbml0aWFsaXphdGlvbiBzZWdtZW50IGFuZCBleHRyYWN0cyBzdHJlYW0gdHlwZSBhbmRcbiAqIHRpbWVzY2FsZSB2YWx1ZXMgZm9yIGFueSBkZWNsYXJlZCB0cmFja3MuIFRpbWVzY2FsZSB2YWx1ZXMgaW5kaWNhdGUgdGhlXG4gKiBudW1iZXIgb2YgY2xvY2sgdGlja3MgcGVyIHNlY29uZCB0byBhc3N1bWUgZm9yIHRpbWUtYmFzZWQgdmFsdWVzXG4gKiBlbHNld2hlcmUgaW4gdGhlIE1QNC5cbiAqXG4gKiBUbyBkZXRlcm1pbmUgdGhlIHN0YXJ0IHRpbWUgb2YgYW4gTVA0LCB5b3UgbmVlZCB0d28gcGllY2VzIG9mXG4gKiBpbmZvcm1hdGlvbjogdGhlIHRpbWVzY2FsZSB1bml0IGFuZCB0aGUgZWFybGllc3QgYmFzZSBtZWRpYSBkZWNvZGVcbiAqIHRpbWUuIE11bHRpcGxlIHRpbWVzY2FsZXMgY2FuIGJlIHNwZWNpZmllZCB3aXRoaW4gYW4gTVA0IGJ1dCB0aGVcbiAqIGJhc2UgbWVkaWEgZGVjb2RlIHRpbWUgaXMgYWx3YXlzIGV4cHJlc3NlZCBpbiB0aGUgdGltZXNjYWxlIGZyb21cbiAqIHRoZSBtZWRpYSBoZWFkZXIgYm94IGZvciB0aGUgdHJhY2s6XG4gKiBgYGBcbiAqIG1vb3YgPiB0cmFrID4gbWRpYSA+IG1kaGQudGltZXNjYWxlXG4gKiBtb292ID4gdHJhayA+IG1kaWEgPiBoZGxyXG4gKiBgYGBcbiAqIEBwYXJhbSBpbml0U2VnbWVudCB0aGUgYnl0ZXMgb2YgdGhlIGluaXQgc2VnbWVudFxuICogQHJldHVybnMgYSBoYXNoIG9mIHRyYWNrIHR5cGUgdG8gdGltZXNjYWxlIHZhbHVlcyBvciBudWxsIGlmXG4gKiB0aGUgaW5pdCBzZWdtZW50IGlzIG1hbGZvcm1lZC5cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZUluaXRTZWdtZW50KGluaXRTZWdtZW50KSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCB0cmFrcyA9IGZpbmRCb3goaW5pdFNlZ21lbnQsIFsnbW9vdicsICd0cmFrJ10pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYWtzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdHJhayA9IHRyYWtzW2ldO1xuICAgIGNvbnN0IHRraGQgPSBmaW5kQm94KHRyYWssIFsndGtoZCddKVswXTtcbiAgICBpZiAodGtoZCkge1xuICAgICAgbGV0IHZlcnNpb24gPSB0a2hkWzBdO1xuICAgICAgY29uc3QgdHJhY2tJZCA9IHJlYWRVaW50MzIodGtoZCwgdmVyc2lvbiA9PT0gMCA/IDEyIDogMjApO1xuICAgICAgY29uc3QgbWRoZCA9IGZpbmRCb3godHJhaywgWydtZGlhJywgJ21kaGQnXSlbMF07XG4gICAgICBpZiAobWRoZCkge1xuICAgICAgICB2ZXJzaW9uID0gbWRoZFswXTtcbiAgICAgICAgY29uc3QgdGltZXNjYWxlID0gcmVhZFVpbnQzMihtZGhkLCB2ZXJzaW9uID09PSAwID8gMTIgOiAyMCk7XG4gICAgICAgIGNvbnN0IGhkbHIgPSBmaW5kQm94KHRyYWssIFsnbWRpYScsICdoZGxyJ10pWzBdO1xuICAgICAgICBpZiAoaGRscikge1xuICAgICAgICAgIGNvbnN0IGhkbHJUeXBlID0gYmluMnN0cihoZGxyLnN1YmFycmF5KDgsIDEyKSk7XG4gICAgICAgICAgY29uc3QgdHlwZSA9IHtcbiAgICAgICAgICAgIHNvdW46IEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5BVURJTyxcbiAgICAgICAgICAgIHZpZGU6IEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFT1xuICAgICAgICAgIH1baGRsclR5cGVdO1xuICAgICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICAvLyBQYXJzZSBjb2RlYyBkZXRhaWxzXG4gICAgICAgICAgICBjb25zdCBzdHNkID0gZmluZEJveCh0cmFrLCBbJ21kaWEnLCAnbWluZicsICdzdGJsJywgJ3N0c2QnXSlbMF07XG4gICAgICAgICAgICBjb25zdCBzdHNkRGF0YSA9IHBhcnNlU3RzZChzdHNkKTtcbiAgICAgICAgICAgIHJlc3VsdFt0cmFja0lkXSA9IHtcbiAgICAgICAgICAgICAgdGltZXNjYWxlLFxuICAgICAgICAgICAgICB0eXBlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVzdWx0W3R5cGVdID0gX29iamVjdFNwcmVhZDIoe1xuICAgICAgICAgICAgICB0aW1lc2NhbGUsXG4gICAgICAgICAgICAgIGlkOiB0cmFja0lkXG4gICAgICAgICAgICB9LCBzdHNkRGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IHRyZXggPSBmaW5kQm94KGluaXRTZWdtZW50LCBbJ21vb3YnLCAnbXZleCcsICd0cmV4J10pO1xuICB0cmV4LmZvckVhY2godHJleCA9PiB7XG4gICAgY29uc3QgdHJhY2tJZCA9IHJlYWRVaW50MzIodHJleCwgNCk7XG4gICAgY29uc3QgdHJhY2sgPSByZXN1bHRbdHJhY2tJZF07XG4gICAgaWYgKHRyYWNrKSB7XG4gICAgICB0cmFjay5kZWZhdWx0ID0ge1xuICAgICAgICBkdXJhdGlvbjogcmVhZFVpbnQzMih0cmV4LCAxMiksXG4gICAgICAgIGZsYWdzOiByZWFkVWludDMyKHRyZXgsIDIwKVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGFyc2VTdHNkKHN0c2QpIHtcbiAgY29uc3Qgc2FtcGxlRW50cmllcyA9IHN0c2Quc3ViYXJyYXkoOCk7XG4gIGNvbnN0IHNhbXBsZUVudHJpZXNFbmQgPSBzYW1wbGVFbnRyaWVzLnN1YmFycmF5KDggKyA3OCk7XG4gIGNvbnN0IGZvdXJDQyA9IGJpbjJzdHIoc2FtcGxlRW50cmllcy5zdWJhcnJheSg0LCA4KSk7XG4gIGxldCBjb2RlYyA9IGZvdXJDQztcbiAgY29uc3QgZW5jcnlwdGVkID0gZm91ckNDID09PSAnZW5jYScgfHwgZm91ckNDID09PSAnZW5jdic7XG4gIGlmIChlbmNyeXB0ZWQpIHtcbiAgICBjb25zdCBlbmNCb3ggPSBmaW5kQm94KHNhbXBsZUVudHJpZXMsIFtmb3VyQ0NdKVswXTtcbiAgICBjb25zdCBlbmNCb3hDaGlsZHJlbiA9IGVuY0JveC5zdWJhcnJheShmb3VyQ0MgPT09ICdlbmNhJyA/IDI4IDogNzgpO1xuICAgIGNvbnN0IHNpbmZzID0gZmluZEJveChlbmNCb3hDaGlsZHJlbiwgWydzaW5mJ10pO1xuICAgIHNpbmZzLmZvckVhY2goc2luZiA9PiB7XG4gICAgICBjb25zdCBzY2htID0gZmluZEJveChzaW5mLCBbJ3NjaG0nXSlbMF07XG4gICAgICBpZiAoc2NobSkge1xuICAgICAgICBjb25zdCBzY2hlbWUgPSBiaW4yc3RyKHNjaG0uc3ViYXJyYXkoNCwgOCkpO1xuICAgICAgICBpZiAoc2NoZW1lID09PSAnY2JjcycgfHwgc2NoZW1lID09PSAnY2VuYycpIHtcbiAgICAgICAgICBjb25zdCBmcm1hID0gZmluZEJveChzaW5mLCBbJ2ZybWEnXSlbMF07XG4gICAgICAgICAgaWYgKGZybWEpIHtcbiAgICAgICAgICAgIC8vIGZvciBlbmNyeXB0ZWQgY29udGVudCBjb2RlYyBmb3VyQ0Mgd2lsbCBiZSBpbiBmcm1hXG4gICAgICAgICAgICBjb2RlYyA9IGJpbjJzdHIoZnJtYSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc3dpdGNoIChjb2RlYykge1xuICAgIGNhc2UgJ2F2YzEnOlxuICAgIGNhc2UgJ2F2YzInOlxuICAgIGNhc2UgJ2F2YzMnOlxuICAgIGNhc2UgJ2F2YzQnOlxuICAgICAge1xuICAgICAgICAvLyBleHRyYWN0IHByb2ZpbGUgKyBjb21wYXRpYmlsaXR5ICsgbGV2ZWwgb3V0IG9mIGF2Y0MgYm94XG4gICAgICAgIGNvbnN0IGF2Y0NCb3ggPSBmaW5kQm94KHNhbXBsZUVudHJpZXNFbmQsIFsnYXZjQyddKVswXTtcbiAgICAgICAgY29kZWMgKz0gJy4nICsgdG9IZXgoYXZjQ0JveFsxXSkgKyB0b0hleChhdmNDQm94WzJdKSArIHRvSGV4KGF2Y0NCb3hbM10pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlICdtcDRhJzpcbiAgICAgIHtcbiAgICAgICAgY29uc3QgY29kZWNCb3ggPSBmaW5kQm94KHNhbXBsZUVudHJpZXMsIFtmb3VyQ0NdKVswXTtcbiAgICAgICAgY29uc3QgZXNkc0JveCA9IGZpbmRCb3goY29kZWNCb3guc3ViYXJyYXkoMjgpLCBbJ2VzZHMnXSlbMF07XG4gICAgICAgIGlmIChlc2RzQm94ICYmIGVzZHNCb3gubGVuZ3RoID4gMTIpIHtcbiAgICAgICAgICBsZXQgaSA9IDQ7XG4gICAgICAgICAgLy8gRVMgRGVzY3JpcHRvciB0YWdcbiAgICAgICAgICBpZiAoZXNkc0JveFtpKytdICE9PSAweDAzKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaSA9IHNraXBCRVJJbnRlZ2VyKGVzZHNCb3gsIGkpO1xuICAgICAgICAgIGkgKz0gMjsgLy8gc2tpcCBlc19pZDtcbiAgICAgICAgICBjb25zdCBmbGFncyA9IGVzZHNCb3hbaSsrXTtcbiAgICAgICAgICBpZiAoZmxhZ3MgJiAweDgwKSB7XG4gICAgICAgICAgICBpICs9IDI7IC8vIHNraXAgZGVwZW5kZW5jeSBlc19pZFxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZmxhZ3MgJiAweDQwKSB7XG4gICAgICAgICAgICBpICs9IGVzZHNCb3hbaSsrXTsgLy8gc2tpcCBVUkxcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gRGVjb2RlciBjb25maWcgZGVzY3JpcHRvclxuICAgICAgICAgIGlmIChlc2RzQm94W2krK10gIT09IDB4MDQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpID0gc2tpcEJFUkludGVnZXIoZXNkc0JveCwgaSk7XG4gICAgICAgICAgY29uc3Qgb2JqZWN0VHlwZSA9IGVzZHNCb3hbaSsrXTtcbiAgICAgICAgICBpZiAob2JqZWN0VHlwZSA9PT0gMHg0MCkge1xuICAgICAgICAgICAgY29kZWMgKz0gJy4nICsgdG9IZXgob2JqZWN0VHlwZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpICs9IDEyO1xuICAgICAgICAgIC8vIERlY29kZXIgc3BlY2lmaWMgaW5mb1xuICAgICAgICAgIGlmIChlc2RzQm94W2krK10gIT09IDB4MDUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpID0gc2tpcEJFUkludGVnZXIoZXNkc0JveCwgaSk7XG4gICAgICAgICAgY29uc3QgZmlyc3RCeXRlID0gZXNkc0JveFtpKytdO1xuICAgICAgICAgIGxldCBhdWRpb09iamVjdFR5cGUgPSAoZmlyc3RCeXRlICYgMHhmOCkgPj4gMztcbiAgICAgICAgICBpZiAoYXVkaW9PYmplY3RUeXBlID09PSAzMSkge1xuICAgICAgICAgICAgYXVkaW9PYmplY3RUeXBlICs9IDEgKyAoKGZpcnN0Qnl0ZSAmIDB4NykgPDwgMykgKyAoKGVzZHNCb3hbaV0gJiAweGUwKSA+PiA1KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29kZWMgKz0gJy4nICsgYXVkaW9PYmplY3RUeXBlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgJ2h2YzEnOlxuICAgIGNhc2UgJ2hldjEnOlxuICAgICAge1xuICAgICAgICBjb25zdCBodmNDQm94ID0gZmluZEJveChzYW1wbGVFbnRyaWVzRW5kLCBbJ2h2Y0MnXSlbMF07XG4gICAgICAgIGNvbnN0IHByb2ZpbGVCeXRlID0gaHZjQ0JveFsxXTtcbiAgICAgICAgY29uc3QgcHJvZmlsZVNwYWNlID0gWycnLCAnQScsICdCJywgJ0MnXVtwcm9maWxlQnl0ZSA+PiA2XTtcbiAgICAgICAgY29uc3QgZ2VuZXJhbFByb2ZpbGVJZGMgPSBwcm9maWxlQnl0ZSAmIDB4MWY7XG4gICAgICAgIGNvbnN0IHByb2ZpbGVDb21wYXQgPSByZWFkVWludDMyKGh2Y0NCb3gsIDIpO1xuICAgICAgICBjb25zdCB0aWVyRmxhZyA9IChwcm9maWxlQnl0ZSAmIDB4MjApID4+IDUgPyAnSCcgOiAnTCc7XG4gICAgICAgIGNvbnN0IGxldmVsSURDID0gaHZjQ0JveFsxMl07XG4gICAgICAgIGNvbnN0IGNvbnN0cmFpbnRJbmRpY2F0b3IgPSBodmNDQm94LnN1YmFycmF5KDYsIDEyKTtcbiAgICAgICAgY29kZWMgKz0gJy4nICsgcHJvZmlsZVNwYWNlICsgZ2VuZXJhbFByb2ZpbGVJZGM7XG4gICAgICAgIGNvZGVjICs9ICcuJyArIHByb2ZpbGVDb21wYXQudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGNvZGVjICs9ICcuJyArIHRpZXJGbGFnICsgbGV2ZWxJREM7XG4gICAgICAgIGxldCBjb25zdHJhaW50U3RyaW5nID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSBjb25zdHJhaW50SW5kaWNhdG9yLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgIGNvbnN0IGJ5dGUgPSBjb25zdHJhaW50SW5kaWNhdG9yW2ldO1xuICAgICAgICAgIGlmIChieXRlIHx8IGNvbnN0cmFpbnRTdHJpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZWRCeXRlID0gYnl0ZS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIGNvbnN0cmFpbnRTdHJpbmcgPSAnLicgKyBlbmNvZGVkQnl0ZSArIGNvbnN0cmFpbnRTdHJpbmc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvZGVjICs9IGNvbnN0cmFpbnRTdHJpbmc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgJ2R2aDEnOlxuICAgIGNhc2UgJ2R2aGUnOlxuICAgICAge1xuICAgICAgICBjb25zdCBkdmNDQm94ID0gZmluZEJveChzYW1wbGVFbnRyaWVzRW5kLCBbJ2R2Y0MnXSlbMF07XG4gICAgICAgIGNvbnN0IHByb2ZpbGUgPSBkdmNDQm94WzJdID4+IDEgJiAweDdmO1xuICAgICAgICBjb25zdCBsZXZlbCA9IGR2Y0NCb3hbMl0gPDwgNSAmIDB4MjAgfCBkdmNDQm94WzNdID4+IDMgJiAweDFmO1xuICAgICAgICBjb2RlYyArPSAnLicgKyBhZGRMZWFkaW5nWmVybyhwcm9maWxlKSArICcuJyArIGFkZExlYWRpbmdaZXJvKGxldmVsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgY2FzZSAndnAwOSc6XG4gICAgICB7XG4gICAgICAgIGNvbnN0IHZwY0NCb3ggPSBmaW5kQm94KHNhbXBsZUVudHJpZXNFbmQsIFsndnBjQyddKVswXTtcbiAgICAgICAgY29uc3QgcHJvZmlsZSA9IHZwY0NCb3hbNF07XG4gICAgICAgIGNvbnN0IGxldmVsID0gdnBjQ0JveFs1XTtcbiAgICAgICAgY29uc3QgYml0RGVwdGggPSB2cGNDQm94WzZdID4+IDQgJiAweDBmO1xuICAgICAgICBjb2RlYyArPSAnLicgKyBhZGRMZWFkaW5nWmVybyhwcm9maWxlKSArICcuJyArIGFkZExlYWRpbmdaZXJvKGxldmVsKSArICcuJyArIGFkZExlYWRpbmdaZXJvKGJpdERlcHRoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgY2FzZSAnYXYwMSc6XG4gICAgICB7XG4gICAgICAgIGNvbnN0IGF2MUNCb3ggPSBmaW5kQm94KHNhbXBsZUVudHJpZXNFbmQsIFsnYXYxQyddKVswXTtcbiAgICAgICAgY29uc3QgcHJvZmlsZSA9IGF2MUNCb3hbMV0gPj4+IDU7XG4gICAgICAgIGNvbnN0IGxldmVsID0gYXYxQ0JveFsxXSAmIDB4MWY7XG4gICAgICAgIGNvbnN0IHRpZXJGbGFnID0gYXYxQ0JveFsyXSA+Pj4gNyA/ICdIJyA6ICdNJztcbiAgICAgICAgY29uc3QgaGlnaEJpdERlcHRoID0gKGF2MUNCb3hbMl0gJiAweDQwKSA+PiA2O1xuICAgICAgICBjb25zdCB0d2VsdmVCaXQgPSAoYXYxQ0JveFsyXSAmIDB4MjApID4+IDU7XG4gICAgICAgIGNvbnN0IGJpdERlcHRoID0gcHJvZmlsZSA9PT0gMiAmJiBoaWdoQml0RGVwdGggPyB0d2VsdmVCaXQgPyAxMiA6IDEwIDogaGlnaEJpdERlcHRoID8gMTAgOiA4O1xuICAgICAgICBjb25zdCBtb25vY2hyb21lID0gKGF2MUNCb3hbMl0gJiAweDEwKSA+PiA0O1xuICAgICAgICBjb25zdCBjaHJvbWFTdWJzYW1wbGluZ1ggPSAoYXYxQ0JveFsyXSAmIDB4MDgpID4+IDM7XG4gICAgICAgIGNvbnN0IGNocm9tYVN1YnNhbXBsaW5nWSA9IChhdjFDQm94WzJdICYgMHgwNCkgPj4gMjtcbiAgICAgICAgY29uc3QgY2hyb21hU2FtcGxlUG9zaXRpb24gPSBhdjFDQm94WzJdICYgMHgwMztcbiAgICAgICAgLy8gVE9ETzogcGFyc2UgY29sb3JfZGVzY3JpcHRpb25fcHJlc2VudF9mbGFnXG4gICAgICAgIC8vIGRlZmF1bHQgaXQgdG8gQlQuNzA5L2xpbWl0ZWQgcmFuZ2UgZm9yIG5vd1xuICAgICAgICAvLyBtb3JlIGluZm8gaHR0cHM6Ly9hb21lZGlhY29kZWMuZ2l0aHViLmlvL2F2MS1pc29ibWZmLyNhdjFjb2RlY2NvbmZpZ3VyYXRpb25ib3gtc3ludGF4XG4gICAgICAgIGNvbnN0IGNvbG9yUHJpbWFyaWVzID0gMTtcbiAgICAgICAgY29uc3QgdHJhbnNmZXJDaGFyYWN0ZXJpc3RpY3MgPSAxO1xuICAgICAgICBjb25zdCBtYXRyaXhDb2VmZmljaWVudHMgPSAxO1xuICAgICAgICBjb25zdCB2aWRlb0Z1bGxSYW5nZUZsYWcgPSAwO1xuICAgICAgICBjb2RlYyArPSAnLicgKyBwcm9maWxlICsgJy4nICsgYWRkTGVhZGluZ1plcm8obGV2ZWwpICsgdGllckZsYWcgKyAnLicgKyBhZGRMZWFkaW5nWmVybyhiaXREZXB0aCkgKyAnLicgKyBtb25vY2hyb21lICsgJy4nICsgY2hyb21hU3Vic2FtcGxpbmdYICsgY2hyb21hU3Vic2FtcGxpbmdZICsgY2hyb21hU2FtcGxlUG9zaXRpb24gKyAnLicgKyBhZGRMZWFkaW5nWmVybyhjb2xvclByaW1hcmllcykgKyAnLicgKyBhZGRMZWFkaW5nWmVybyh0cmFuc2ZlckNoYXJhY3RlcmlzdGljcykgKyAnLicgKyBhZGRMZWFkaW5nWmVybyhtYXRyaXhDb2VmZmljaWVudHMpICsgJy4nICsgdmlkZW9GdWxsUmFuZ2VGbGFnO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGNvZGVjLFxuICAgIGVuY3J5cHRlZFxuICB9O1xufVxuZnVuY3Rpb24gc2tpcEJFUkludGVnZXIoYnl0ZXMsIGkpIHtcbiAgY29uc3QgbGltaXQgPSBpICsgNTtcbiAgd2hpbGUgKGJ5dGVzW2krK10gJiAweDgwICYmIGkgPCBsaW1pdCkge31cbiAgcmV0dXJuIGk7XG59XG5mdW5jdGlvbiB0b0hleCh4KSB7XG4gIHJldHVybiAoJzAnICsgeC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSkuc2xpY2UoLTIpO1xufVxuZnVuY3Rpb24gYWRkTGVhZGluZ1plcm8obnVtKSB7XG4gIHJldHVybiAobnVtIDwgMTAgPyAnMCcgOiAnJykgKyBudW07XG59XG5mdW5jdGlvbiBwYXRjaEVuY3lwdGlvbkRhdGEoaW5pdFNlZ21lbnQsIGRlY3J5cHRkYXRhKSB7XG4gIGlmICghaW5pdFNlZ21lbnQgfHwgIWRlY3J5cHRkYXRhKSB7XG4gICAgcmV0dXJuIGluaXRTZWdtZW50O1xuICB9XG4gIGNvbnN0IGtleUlkID0gZGVjcnlwdGRhdGEua2V5SWQ7XG4gIGlmIChrZXlJZCAmJiBkZWNyeXB0ZGF0YS5pc0NvbW1vbkVuY3J5cHRpb24pIHtcbiAgICBjb25zdCB0cmFrcyA9IGZpbmRCb3goaW5pdFNlZ21lbnQsIFsnbW9vdicsICd0cmFrJ10pO1xuICAgIHRyYWtzLmZvckVhY2godHJhayA9PiB7XG4gICAgICBjb25zdCBzdHNkID0gZmluZEJveCh0cmFrLCBbJ21kaWEnLCAnbWluZicsICdzdGJsJywgJ3N0c2QnXSlbMF07XG5cbiAgICAgIC8vIHNraXAgdGhlIHNhbXBsZSBlbnRyeSBjb3VudFxuICAgICAgY29uc3Qgc2FtcGxlRW50cmllcyA9IHN0c2Quc3ViYXJyYXkoOCk7XG4gICAgICBsZXQgZW5jQm94ZXMgPSBmaW5kQm94KHNhbXBsZUVudHJpZXMsIFsnZW5jYSddKTtcbiAgICAgIGNvbnN0IGlzQXVkaW8gPSBlbmNCb3hlcy5sZW5ndGggPiAwO1xuICAgICAgaWYgKCFpc0F1ZGlvKSB7XG4gICAgICAgIGVuY0JveGVzID0gZmluZEJveChzYW1wbGVFbnRyaWVzLCBbJ2VuY3YnXSk7XG4gICAgICB9XG4gICAgICBlbmNCb3hlcy5mb3JFYWNoKGVuYyA9PiB7XG4gICAgICAgIGNvbnN0IGVuY0JveENoaWxkcmVuID0gaXNBdWRpbyA/IGVuYy5zdWJhcnJheSgyOCkgOiBlbmMuc3ViYXJyYXkoNzgpO1xuICAgICAgICBjb25zdCBzaW5mQm94ZXMgPSBmaW5kQm94KGVuY0JveENoaWxkcmVuLCBbJ3NpbmYnXSk7XG4gICAgICAgIHNpbmZCb3hlcy5mb3JFYWNoKHNpbmYgPT4ge1xuICAgICAgICAgIGNvbnN0IHRlbmMgPSBwYXJzZVNpbmYoc2luZik7XG4gICAgICAgICAgaWYgKHRlbmMpIHtcbiAgICAgICAgICAgIC8vIExvb2sgZm9yIGRlZmF1bHQga2V5IGlkIChrZXlJRCBvZmZzZXQgaXMgYWx3YXlzIDggd2l0aGluIHRoZSB0ZW5jIGJveCk6XG4gICAgICAgICAgICBjb25zdCB0ZW5jS2V5SWQgPSB0ZW5jLnN1YmFycmF5KDgsIDI0KTtcbiAgICAgICAgICAgIGlmICghdGVuY0tleUlkLnNvbWUoYiA9PiBiICE9PSAwKSkge1xuICAgICAgICAgICAgICBsb2dnZXIubG9nKGBbZW1lXSBQYXRjaGluZyBrZXlJZCBpbiAnZW5jJHtpc0F1ZGlvID8gJ2EnIDogJ3YnfT5zaW5mPj50ZW5jJyBib3g6ICR7SGV4LmhleER1bXAodGVuY0tleUlkKX0gLT4gJHtIZXguaGV4RHVtcChrZXlJZCl9YCk7XG4gICAgICAgICAgICAgIHRlbmMuc2V0KGtleUlkLCA4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGluaXRTZWdtZW50O1xufVxuZnVuY3Rpb24gcGFyc2VTaW5mKHNpbmYpIHtcbiAgY29uc3Qgc2NobSA9IGZpbmRCb3goc2luZiwgWydzY2htJ10pWzBdO1xuICBpZiAoc2NobSkge1xuICAgIGNvbnN0IHNjaGVtZSA9IGJpbjJzdHIoc2NobS5zdWJhcnJheSg0LCA4KSk7XG4gICAgaWYgKHNjaGVtZSA9PT0gJ2NiY3MnIHx8IHNjaGVtZSA9PT0gJ2NlbmMnKSB7XG4gICAgICByZXR1cm4gZmluZEJveChzaW5mLCBbJ3NjaGknLCAndGVuYyddKVswXTtcbiAgICB9XG4gIH1cbiAgbG9nZ2VyLmVycm9yKGBbZW1lXSBtaXNzaW5nICdzY2htJyBib3hgKTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIHRoZSBiYXNlIG1lZGlhIGRlY29kZSBzdGFydCB0aW1lLCBpbiBzZWNvbmRzLCBmb3IgYW4gTVA0XG4gKiBmcmFnbWVudC4gSWYgbXVsdGlwbGUgZnJhZ21lbnRzIGFyZSBzcGVjaWZpZWQsIHRoZSBlYXJsaWVzdCB0aW1lIGlzXG4gKiByZXR1cm5lZC5cbiAqXG4gKiBUaGUgYmFzZSBtZWRpYSBkZWNvZGUgdGltZSBjYW4gYmUgcGFyc2VkIGZyb20gdHJhY2sgZnJhZ21lbnRcbiAqIG1ldGFkYXRhOlxuICogYGBgXG4gKiBtb29mID4gdHJhZiA+IHRmZHQuYmFzZU1lZGlhRGVjb2RlVGltZVxuICogYGBgXG4gKiBJdCByZXF1aXJlcyB0aGUgdGltZXNjYWxlIHZhbHVlIGZyb20gdGhlIG1kaGQgdG8gaW50ZXJwcmV0LlxuICpcbiAqIEBwYXJhbSBpbml0RGF0YSAtIGEgaGFzaCBvZiB0cmFjayB0eXBlIHRvIHRpbWVzY2FsZSB2YWx1ZXNcbiAqIEBwYXJhbSBmbXA0IC0gdGhlIGJ5dGVzIG9mIHRoZSBtcDQgZnJhZ21lbnRcbiAqIEByZXR1cm5zIHRoZSBlYXJsaWVzdCBiYXNlIG1lZGlhIGRlY29kZSBzdGFydCB0aW1lIGZvciB0aGVcbiAqIGZyYWdtZW50LCBpbiBzZWNvbmRzXG4gKi9cbmZ1bmN0aW9uIGdldFN0YXJ0RFRTKGluaXREYXRhLCBmbXA0KSB7XG4gIC8vIHdlIG5lZWQgaW5mbyBmcm9tIHR3byBjaGlsZHJlbiBvZiBlYWNoIHRyYWNrIGZyYWdtZW50IGJveFxuICByZXR1cm4gZmluZEJveChmbXA0LCBbJ21vb2YnLCAndHJhZiddKS5yZWR1Y2UoKHJlc3VsdCwgdHJhZikgPT4ge1xuICAgIGNvbnN0IHRmZHQgPSBmaW5kQm94KHRyYWYsIFsndGZkdCddKVswXTtcbiAgICBjb25zdCB2ZXJzaW9uID0gdGZkdFswXTtcbiAgICBjb25zdCBzdGFydCA9IGZpbmRCb3godHJhZiwgWyd0ZmhkJ10pLnJlZHVjZSgocmVzdWx0LCB0ZmhkKSA9PiB7XG4gICAgICAvLyBnZXQgdGhlIHRyYWNrIGlkIGZyb20gdGhlIHRmaGRcbiAgICAgIGNvbnN0IGlkID0gcmVhZFVpbnQzMih0ZmhkLCA0KTtcbiAgICAgIGNvbnN0IHRyYWNrID0gaW5pdERhdGFbaWRdO1xuICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgIGxldCBiYXNlVGltZSA9IHJlYWRVaW50MzIodGZkdCwgNCk7XG4gICAgICAgIGlmICh2ZXJzaW9uID09PSAxKSB7XG4gICAgICAgICAgLy8gSWYgdmFsdWUgaXMgdG9vIGxhcmdlLCBhc3N1bWUgc2lnbmVkIDY0LWJpdC4gTmVnYXRpdmUgdHJhY2sgZnJhZ21lbnQgZGVjb2RlIHRpbWVzIGFyZSBpbnZhbGlkLCBidXQgdGhleSBleGlzdCBpbiB0aGUgd2lsZC5cbiAgICAgICAgICAvLyBUaGlzIHByZXZlbnRzIGxhcmdlIHZhbHVlcyBmcm9tIGJlaW5nIHVzZWQgZm9yIGluaXRQVFMsIHdoaWNoIGNhbiBjYXVzZSBwbGF5bGlzdCBzeW5jIGlzc3Vlcy5cbiAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvNTMwM1xuICAgICAgICAgIGlmIChiYXNlVGltZSA9PT0gVUlOVDMyX01BWCQxKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihgW21wNC1kZW11eGVyXTogSWdub3JpbmcgYXNzdW1lZCBpbnZhbGlkIHNpZ25lZCA2NC1iaXQgdHJhY2sgZnJhZ21lbnQgZGVjb2RlIHRpbWVgKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJhc2VUaW1lICo9IFVJTlQzMl9NQVgkMSArIDE7XG4gICAgICAgICAgYmFzZVRpbWUgKz0gcmVhZFVpbnQzMih0ZmR0LCA4KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhc3N1bWUgYSA5MGtIeiBjbG9jayBpZiBubyB0aW1lc2NhbGUgd2FzIHNwZWNpZmllZFxuICAgICAgICBjb25zdCBzY2FsZSA9IHRyYWNrLnRpbWVzY2FsZSB8fCA5MGUzO1xuICAgICAgICAvLyBjb252ZXJ0IGJhc2UgdGltZSB0byBzZWNvbmRzXG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IGJhc2VUaW1lIC8gc2NhbGU7XG4gICAgICAgIGlmIChpc0Zpbml0ZU51bWJlcihzdGFydFRpbWUpICYmIChyZXN1bHQgPT09IG51bGwgfHwgc3RhcnRUaW1lIDwgcmVzdWx0KSkge1xuICAgICAgICAgIHJldHVybiBzdGFydFRpbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwgbnVsbCk7XG4gICAgaWYgKHN0YXJ0ICE9PSBudWxsICYmIGlzRmluaXRlTnVtYmVyKHN0YXJ0KSAmJiAocmVzdWx0ID09PSBudWxsIHx8IHN0YXJ0IDwgcmVzdWx0KSkge1xuICAgICAgcmV0dXJuIHN0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LCBudWxsKTtcbn1cblxuLypcbiAgRm9yIFJlZmVyZW5jZTpcbiAgYWxpZ25lZCg4KSBjbGFzcyBUcmFja0ZyYWdtZW50SGVhZGVyQm94XG4gICAgICAgICAgIGV4dGVuZHMgRnVsbEJveCjigJh0Zmhk4oCZLCAwLCB0Zl9mbGFncyl7XG4gICAgIHVuc2lnbmVkIGludCgzMikgIHRyYWNrX0lEO1xuICAgICAvLyBhbGwgdGhlIGZvbGxvd2luZyBhcmUgb3B0aW9uYWwgZmllbGRzXG4gICAgIHVuc2lnbmVkIGludCg2NCkgIGJhc2VfZGF0YV9vZmZzZXQ7XG4gICAgIHVuc2lnbmVkIGludCgzMikgIHNhbXBsZV9kZXNjcmlwdGlvbl9pbmRleDtcbiAgICAgdW5zaWduZWQgaW50KDMyKSAgZGVmYXVsdF9zYW1wbGVfZHVyYXRpb247XG4gICAgIHVuc2lnbmVkIGludCgzMikgIGRlZmF1bHRfc2FtcGxlX3NpemU7XG4gICAgIHVuc2lnbmVkIGludCgzMikgIGRlZmF1bHRfc2FtcGxlX2ZsYWdzXG4gIH1cbiAqL1xuZnVuY3Rpb24gZ2V0RHVyYXRpb24oZGF0YSwgaW5pdERhdGEpIHtcbiAgbGV0IHJhd0R1cmF0aW9uID0gMDtcbiAgbGV0IHZpZGVvRHVyYXRpb24gPSAwO1xuICBsZXQgYXVkaW9EdXJhdGlvbiA9IDA7XG4gIGNvbnN0IHRyYWZzID0gZmluZEJveChkYXRhLCBbJ21vb2YnLCAndHJhZiddKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFmcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRyYWYgPSB0cmFmc1tpXTtcbiAgICAvLyBUaGVyZSBpcyBvbmx5IG9uZSB0ZmhkICYgdHJ1biBwZXIgdHJhZlxuICAgIC8vIFRoaXMgaXMgdHJ1ZSBmb3IgQ01BRiBzdHlsZSBjb250ZW50LCBhbmQgd2Ugc2hvdWxkIHBlcmhhcHMgY2hlY2sgdGhlIGZ0eXBcbiAgICAvLyBhbmQgb25seSBsb29rIGZvciBhIHNpbmdsZSB0cnVuIHRoZW4sIGJ1dCBmb3IgSVNPQk1GRiB3ZSBzaG91bGQgY2hlY2tcbiAgICAvLyBmb3IgbXVsdGlwbGUgdHJhY2sgcnVucy5cbiAgICBjb25zdCB0ZmhkID0gZmluZEJveCh0cmFmLCBbJ3RmaGQnXSlbMF07XG4gICAgLy8gZ2V0IHRoZSB0cmFjayBpZCBmcm9tIHRoZSB0ZmhkXG4gICAgY29uc3QgaWQgPSByZWFkVWludDMyKHRmaGQsIDQpO1xuICAgIGNvbnN0IHRyYWNrID0gaW5pdERhdGFbaWRdO1xuICAgIGlmICghdHJhY2spIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB0cmFja0RlZmF1bHQgPSB0cmFjay5kZWZhdWx0O1xuICAgIGNvbnN0IHRmaGRGbGFncyA9IHJlYWRVaW50MzIodGZoZCwgMCkgfCAodHJhY2tEZWZhdWx0ID09IG51bGwgPyB2b2lkIDAgOiB0cmFja0RlZmF1bHQuZmxhZ3MpO1xuICAgIGxldCBzYW1wbGVEdXJhdGlvbiA9IHRyYWNrRGVmYXVsdCA9PSBudWxsID8gdm9pZCAwIDogdHJhY2tEZWZhdWx0LmR1cmF0aW9uO1xuICAgIGlmICh0ZmhkRmxhZ3MgJiAweDAwMDAwOCkge1xuICAgICAgLy8gMHgwMDAwMDggaW5kaWNhdGVzIHRoZSBwcmVzZW5jZSBvZiB0aGUgZGVmYXVsdF9zYW1wbGVfZHVyYXRpb24gZmllbGRcbiAgICAgIGlmICh0ZmhkRmxhZ3MgJiAweDAwMDAwMikge1xuICAgICAgICAvLyAweDAwMDAwMiBpbmRpY2F0ZXMgdGhlIHByZXNlbmNlIG9mIHRoZSBzYW1wbGVfZGVzY3JpcHRpb25faW5kZXggZmllbGQsIHdoaWNoIHByZWNlZGVzIGRlZmF1bHRfc2FtcGxlX2R1cmF0aW9uXG4gICAgICAgIC8vIElmIHByZXNlbnQsIHRoZSBkZWZhdWx0X3NhbXBsZV9kdXJhdGlvbiBleGlzdHMgYXQgYnl0ZSBvZmZzZXQgMTJcbiAgICAgICAgc2FtcGxlRHVyYXRpb24gPSByZWFkVWludDMyKHRmaGQsIDEyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSwgdGhlIGR1cmF0aW9uIGlzIGF0IGJ5dGUgb2Zmc2V0IDhcbiAgICAgICAgc2FtcGxlRHVyYXRpb24gPSByZWFkVWludDMyKHRmaGQsIDgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBhc3N1bWUgYSA5MGtIeiBjbG9jayBpZiBubyB0aW1lc2NhbGUgd2FzIHNwZWNpZmllZFxuICAgIGNvbnN0IHRpbWVzY2FsZSA9IHRyYWNrLnRpbWVzY2FsZSB8fCA5MGUzO1xuICAgIGNvbnN0IHRydW5zID0gZmluZEJveCh0cmFmLCBbJ3RydW4nXSk7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCB0cnVucy5sZW5ndGg7IGorKykge1xuICAgICAgcmF3RHVyYXRpb24gPSBjb21wdXRlUmF3RHVyYXRpb25Gcm9tU2FtcGxlcyh0cnVuc1tqXSk7XG4gICAgICBpZiAoIXJhd0R1cmF0aW9uICYmIHNhbXBsZUR1cmF0aW9uKSB7XG4gICAgICAgIGNvbnN0IHNhbXBsZUNvdW50ID0gcmVhZFVpbnQzMih0cnVuc1tqXSwgNCk7XG4gICAgICAgIHJhd0R1cmF0aW9uID0gc2FtcGxlRHVyYXRpb24gKiBzYW1wbGVDb3VudDtcbiAgICAgIH1cbiAgICAgIGlmICh0cmFjay50eXBlID09PSBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU8pIHtcbiAgICAgICAgdmlkZW9EdXJhdGlvbiArPSByYXdEdXJhdGlvbiAvIHRpbWVzY2FsZTtcbiAgICAgIH0gZWxzZSBpZiAodHJhY2sudHlwZSA9PT0gRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPKSB7XG4gICAgICAgIGF1ZGlvRHVyYXRpb24gKz0gcmF3RHVyYXRpb24gLyB0aW1lc2NhbGU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh2aWRlb0R1cmF0aW9uID09PSAwICYmIGF1ZGlvRHVyYXRpb24gPT09IDApIHtcbiAgICAvLyBJZiBkdXJhdGlvbiBzYW1wbGVzIGFyZSBub3QgYXZhaWxhYmxlIGluIHRoZSB0cmFmIHVzZSBzaWR4IHN1YnNlZ21lbnRfZHVyYXRpb25cbiAgICBsZXQgc2lkeER1cmF0aW9uID0gMDtcbiAgICBjb25zdCBzaWR4cyA9IGZpbmRCb3goZGF0YSwgWydzaWR4J10pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2lkeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHNpZHggPSBwYXJzZVNlZ21lbnRJbmRleChzaWR4c1tpXSk7XG4gICAgICBpZiAoc2lkeCAhPSBudWxsICYmIHNpZHgucmVmZXJlbmNlcykge1xuICAgICAgICBzaWR4RHVyYXRpb24gKz0gc2lkeC5yZWZlcmVuY2VzLnJlZHVjZSgoZHVyLCByZWYpID0+IGR1ciArIHJlZi5pbmZvLmR1cmF0aW9uIHx8IDAsIDApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2lkeER1cmF0aW9uO1xuICB9XG4gIGlmICh2aWRlb0R1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHZpZGVvRHVyYXRpb247XG4gIH1cbiAgcmV0dXJuIGF1ZGlvRHVyYXRpb247XG59XG5cbi8qXG4gIEZvciBSZWZlcmVuY2U6XG4gIGFsaWduZWQoOCkgY2xhc3MgVHJhY2tSdW5Cb3hcbiAgICAgICAgICAgZXh0ZW5kcyBGdWxsQm94KOKAmHRydW7igJksIHZlcnNpb24sIHRyX2ZsYWdzKSB7XG4gICAgIHVuc2lnbmVkIGludCgzMikgIHNhbXBsZV9jb3VudDtcbiAgICAgLy8gdGhlIGZvbGxvd2luZyBhcmUgb3B0aW9uYWwgZmllbGRzXG4gICAgIHNpZ25lZCBpbnQoMzIpIGRhdGFfb2Zmc2V0O1xuICAgICB1bnNpZ25lZCBpbnQoMzIpICBmaXJzdF9zYW1wbGVfZmxhZ3M7XG4gICAgIC8vIGFsbCBmaWVsZHMgaW4gdGhlIGZvbGxvd2luZyBhcnJheSBhcmUgb3B0aW9uYWxcbiAgICAge1xuICAgICAgICB1bnNpZ25lZCBpbnQoMzIpICBzYW1wbGVfZHVyYXRpb247XG4gICAgICAgIHVuc2lnbmVkIGludCgzMikgIHNhbXBsZV9zaXplO1xuICAgICAgICB1bnNpZ25lZCBpbnQoMzIpICBzYW1wbGVfZmxhZ3NcbiAgICAgICAgaWYgKHZlcnNpb24gPT0gMClcbiAgICAgICAgICAgeyB1bnNpZ25lZCBpbnQoMzIpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgeyBzaWduZWQgaW50KDMyKVxuICAgICB9WyBzYW1wbGVfY291bnQgXVxuICB9XG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVSYXdEdXJhdGlvbkZyb21TYW1wbGVzKHRydW4pIHtcbiAgY29uc3QgZmxhZ3MgPSByZWFkVWludDMyKHRydW4sIDApO1xuICAvLyBGbGFncyBhcmUgYXQgb2Zmc2V0IDAsIG5vbi1vcHRpb25hbCBzYW1wbGVfY291bnQgaXMgYXQgb2Zmc2V0IDQuIFRoZXJlZm9yZSB3ZSBzdGFydCA4IGJ5dGVzIGluLlxuICAvLyBFYWNoIGZpZWxkIGlzIGFuIGludDMyLCB3aGljaCBpcyA0IGJ5dGVzXG4gIGxldCBvZmZzZXQgPSA4O1xuICAvLyBkYXRhLW9mZnNldC1wcmVzZW50IGZsYWdcbiAgaWYgKGZsYWdzICYgMHgwMDAwMDEpIHtcbiAgICBvZmZzZXQgKz0gNDtcbiAgfVxuICAvLyBmaXJzdC1zYW1wbGUtZmxhZ3MtcHJlc2VudCBmbGFnXG4gIGlmIChmbGFncyAmIDB4MDAwMDA0KSB7XG4gICAgb2Zmc2V0ICs9IDQ7XG4gIH1cbiAgbGV0IGR1cmF0aW9uID0gMDtcbiAgY29uc3Qgc2FtcGxlQ291bnQgPSByZWFkVWludDMyKHRydW4sIDQpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNhbXBsZUNvdW50OyBpKyspIHtcbiAgICAvLyBzYW1wbGUtZHVyYXRpb24tcHJlc2VudCBmbGFnXG4gICAgaWYgKGZsYWdzICYgMHgwMDAxMDApIHtcbiAgICAgIGNvbnN0IHNhbXBsZUR1cmF0aW9uID0gcmVhZFVpbnQzMih0cnVuLCBvZmZzZXQpO1xuICAgICAgZHVyYXRpb24gKz0gc2FtcGxlRHVyYXRpb247XG4gICAgICBvZmZzZXQgKz0gNDtcbiAgICB9XG4gICAgLy8gc2FtcGxlLXNpemUtcHJlc2VudCBmbGFnXG4gICAgaWYgKGZsYWdzICYgMHgwMDAyMDApIHtcbiAgICAgIG9mZnNldCArPSA0O1xuICAgIH1cbiAgICAvLyBzYW1wbGUtZmxhZ3MtcHJlc2VudCBmbGFnXG4gICAgaWYgKGZsYWdzICYgMHgwMDA0MDApIHtcbiAgICAgIG9mZnNldCArPSA0O1xuICAgIH1cbiAgICAvLyBzYW1wbGUtY29tcG9zaXRpb24tdGltZS1vZmZzZXRzLXByZXNlbnQgZmxhZ1xuICAgIGlmIChmbGFncyAmIDB4MDAwODAwKSB7XG4gICAgICBvZmZzZXQgKz0gNDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGR1cmF0aW9uO1xufVxuZnVuY3Rpb24gb2Zmc2V0U3RhcnREVFMoaW5pdERhdGEsIGZtcDQsIHRpbWVPZmZzZXQpIHtcbiAgZmluZEJveChmbXA0LCBbJ21vb2YnLCAndHJhZiddKS5mb3JFYWNoKHRyYWYgPT4ge1xuICAgIGZpbmRCb3godHJhZiwgWyd0ZmhkJ10pLmZvckVhY2godGZoZCA9PiB7XG4gICAgICAvLyBnZXQgdGhlIHRyYWNrIGlkIGZyb20gdGhlIHRmaGRcbiAgICAgIGNvbnN0IGlkID0gcmVhZFVpbnQzMih0ZmhkLCA0KTtcbiAgICAgIGNvbnN0IHRyYWNrID0gaW5pdERhdGFbaWRdO1xuICAgICAgaWYgKCF0cmFjaykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBhc3N1bWUgYSA5MGtIeiBjbG9jayBpZiBubyB0aW1lc2NhbGUgd2FzIHNwZWNpZmllZFxuICAgICAgY29uc3QgdGltZXNjYWxlID0gdHJhY2sudGltZXNjYWxlIHx8IDkwZTM7XG4gICAgICAvLyBnZXQgdGhlIGJhc2UgbWVkaWEgZGVjb2RlIHRpbWUgZnJvbSB0aGUgdGZkdFxuICAgICAgZmluZEJveCh0cmFmLCBbJ3RmZHQnXSkuZm9yRWFjaCh0ZmR0ID0+IHtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IHRmZHRbMF07XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRpbWVPZmZzZXQgKiB0aW1lc2NhbGU7XG4gICAgICAgIGlmIChvZmZzZXQpIHtcbiAgICAgICAgICBsZXQgYmFzZU1lZGlhRGVjb2RlVGltZSA9IHJlYWRVaW50MzIodGZkdCwgNCk7XG4gICAgICAgICAgaWYgKHZlcnNpb24gPT09IDApIHtcbiAgICAgICAgICAgIGJhc2VNZWRpYURlY29kZVRpbWUgLT0gb2Zmc2V0O1xuICAgICAgICAgICAgYmFzZU1lZGlhRGVjb2RlVGltZSA9IE1hdGgubWF4KGJhc2VNZWRpYURlY29kZVRpbWUsIDApO1xuICAgICAgICAgICAgd3JpdGVVaW50MzIodGZkdCwgNCwgYmFzZU1lZGlhRGVjb2RlVGltZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJhc2VNZWRpYURlY29kZVRpbWUgKj0gTWF0aC5wb3coMiwgMzIpO1xuICAgICAgICAgICAgYmFzZU1lZGlhRGVjb2RlVGltZSArPSByZWFkVWludDMyKHRmZHQsIDgpO1xuICAgICAgICAgICAgYmFzZU1lZGlhRGVjb2RlVGltZSAtPSBvZmZzZXQ7XG4gICAgICAgICAgICBiYXNlTWVkaWFEZWNvZGVUaW1lID0gTWF0aC5tYXgoYmFzZU1lZGlhRGVjb2RlVGltZSwgMCk7XG4gICAgICAgICAgICBjb25zdCB1cHBlciA9IE1hdGguZmxvb3IoYmFzZU1lZGlhRGVjb2RlVGltZSAvIChVSU5UMzJfTUFYJDEgKyAxKSk7XG4gICAgICAgICAgICBjb25zdCBsb3dlciA9IE1hdGguZmxvb3IoYmFzZU1lZGlhRGVjb2RlVGltZSAlIChVSU5UMzJfTUFYJDEgKyAxKSk7XG4gICAgICAgICAgICB3cml0ZVVpbnQzMih0ZmR0LCA0LCB1cHBlcik7XG4gICAgICAgICAgICB3cml0ZVVpbnQzMih0ZmR0LCA4LCBsb3dlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8vIFRPRE86IENoZWNrIGlmIHRoZSBsYXN0IG1vb2YrbWRhdCBwYWlyIGlzIHBhcnQgb2YgdGhlIHZhbGlkIHJhbmdlXG5mdW5jdGlvbiBzZWdtZW50VmFsaWRSYW5nZShkYXRhKSB7XG4gIGNvbnN0IHNlZ21lbnRlZFJhbmdlID0ge1xuICAgIHZhbGlkOiBudWxsLFxuICAgIHJlbWFpbmRlcjogbnVsbFxuICB9O1xuICBjb25zdCBtb29mcyA9IGZpbmRCb3goZGF0YSwgWydtb29mJ10pO1xuICBpZiAobW9vZnMubGVuZ3RoIDwgMikge1xuICAgIHNlZ21lbnRlZFJhbmdlLnJlbWFpbmRlciA9IGRhdGE7XG4gICAgcmV0dXJuIHNlZ21lbnRlZFJhbmdlO1xuICB9XG4gIGNvbnN0IGxhc3QgPSBtb29mc1ttb29mcy5sZW5ndGggLSAxXTtcbiAgLy8gT2Zmc2V0IGJ5IDggYnl0ZXM7IGZpbmRCb3ggb2Zmc2V0cyB0aGUgc3RhcnQgYnkgYXMgbXVjaFxuICBzZWdtZW50ZWRSYW5nZS52YWxpZCA9IHNsaWNlVWludDgoZGF0YSwgMCwgbGFzdC5ieXRlT2Zmc2V0IC0gOCk7XG4gIHNlZ21lbnRlZFJhbmdlLnJlbWFpbmRlciA9IHNsaWNlVWludDgoZGF0YSwgbGFzdC5ieXRlT2Zmc2V0IC0gOCk7XG4gIHJldHVybiBzZWdtZW50ZWRSYW5nZTtcbn1cbmZ1bmN0aW9uIGFwcGVuZFVpbnQ4QXJyYXkoZGF0YTEsIGRhdGEyKSB7XG4gIGNvbnN0IHRlbXAgPSBuZXcgVWludDhBcnJheShkYXRhMS5sZW5ndGggKyBkYXRhMi5sZW5ndGgpO1xuICB0ZW1wLnNldChkYXRhMSk7XG4gIHRlbXAuc2V0KGRhdGEyLCBkYXRhMS5sZW5ndGgpO1xuICByZXR1cm4gdGVtcDtcbn1cbmZ1bmN0aW9uIHBhcnNlU2FtcGxlcyh0aW1lT2Zmc2V0LCB0cmFjaykge1xuICBjb25zdCBzZWlTYW1wbGVzID0gW107XG4gIGNvbnN0IHZpZGVvRGF0YSA9IHRyYWNrLnNhbXBsZXM7XG4gIGNvbnN0IHRpbWVzY2FsZSA9IHRyYWNrLnRpbWVzY2FsZTtcbiAgY29uc3QgdHJhY2tJZCA9IHRyYWNrLmlkO1xuICBsZXQgaXNIRVZDRmxhdm9yID0gZmFsc2U7XG4gIGNvbnN0IG1vb2ZzID0gZmluZEJveCh2aWRlb0RhdGEsIFsnbW9vZiddKTtcbiAgbW9vZnMubWFwKG1vb2YgPT4ge1xuICAgIGNvbnN0IG1vb2ZPZmZzZXQgPSBtb29mLmJ5dGVPZmZzZXQgLSA4O1xuICAgIGNvbnN0IHRyYWZzID0gZmluZEJveChtb29mLCBbJ3RyYWYnXSk7XG4gICAgdHJhZnMubWFwKHRyYWYgPT4ge1xuICAgICAgLy8gZ2V0IHRoZSBiYXNlIG1lZGlhIGRlY29kZSB0aW1lIGZyb20gdGhlIHRmZHRcbiAgICAgIGNvbnN0IGJhc2VUaW1lID0gZmluZEJveCh0cmFmLCBbJ3RmZHQnXSkubWFwKHRmZHQgPT4ge1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gdGZkdFswXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHJlYWRVaW50MzIodGZkdCwgNCk7XG4gICAgICAgIGlmICh2ZXJzaW9uID09PSAxKSB7XG4gICAgICAgICAgcmVzdWx0ICo9IE1hdGgucG93KDIsIDMyKTtcbiAgICAgICAgICByZXN1bHQgKz0gcmVhZFVpbnQzMih0ZmR0LCA4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0IC8gdGltZXNjYWxlO1xuICAgICAgfSlbMF07XG4gICAgICBpZiAoYmFzZVRpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aW1lT2Zmc2V0ID0gYmFzZVRpbWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmluZEJveCh0cmFmLCBbJ3RmaGQnXSkubWFwKHRmaGQgPT4ge1xuICAgICAgICBjb25zdCBpZCA9IHJlYWRVaW50MzIodGZoZCwgNCk7XG4gICAgICAgIGNvbnN0IHRmaGRGbGFncyA9IHJlYWRVaW50MzIodGZoZCwgMCkgJiAweGZmZmZmZjtcbiAgICAgICAgY29uc3QgYmFzZURhdGFPZmZzZXRQcmVzZW50ID0gKHRmaGRGbGFncyAmIDB4MDAwMDAxKSAhPT0gMDtcbiAgICAgICAgY29uc3Qgc2FtcGxlRGVzY3JpcHRpb25JbmRleFByZXNlbnQgPSAodGZoZEZsYWdzICYgMHgwMDAwMDIpICE9PSAwO1xuICAgICAgICBjb25zdCBkZWZhdWx0U2FtcGxlRHVyYXRpb25QcmVzZW50ID0gKHRmaGRGbGFncyAmIDB4MDAwMDA4KSAhPT0gMDtcbiAgICAgICAgbGV0IGRlZmF1bHRTYW1wbGVEdXJhdGlvbiA9IDA7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRTYW1wbGVTaXplUHJlc2VudCA9ICh0ZmhkRmxhZ3MgJiAweDAwMDAxMCkgIT09IDA7XG4gICAgICAgIGxldCBkZWZhdWx0U2FtcGxlU2l6ZSA9IDA7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRTYW1wbGVGbGFnc1ByZXNlbnQgPSAodGZoZEZsYWdzICYgMHgwMDAwMjApICE9PSAwO1xuICAgICAgICBsZXQgdGZoZE9mZnNldCA9IDg7XG4gICAgICAgIGlmIChpZCA9PT0gdHJhY2tJZCkge1xuICAgICAgICAgIGlmIChiYXNlRGF0YU9mZnNldFByZXNlbnQpIHtcbiAgICAgICAgICAgIHRmaGRPZmZzZXQgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNhbXBsZURlc2NyaXB0aW9uSW5kZXhQcmVzZW50KSB7XG4gICAgICAgICAgICB0ZmhkT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkZWZhdWx0U2FtcGxlRHVyYXRpb25QcmVzZW50KSB7XG4gICAgICAgICAgICBkZWZhdWx0U2FtcGxlRHVyYXRpb24gPSByZWFkVWludDMyKHRmaGQsIHRmaGRPZmZzZXQpO1xuICAgICAgICAgICAgdGZoZE9mZnNldCArPSA0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGVmYXVsdFNhbXBsZVNpemVQcmVzZW50KSB7XG4gICAgICAgICAgICBkZWZhdWx0U2FtcGxlU2l6ZSA9IHJlYWRVaW50MzIodGZoZCwgdGZoZE9mZnNldCk7XG4gICAgICAgICAgICB0ZmhkT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkZWZhdWx0U2FtcGxlRmxhZ3NQcmVzZW50KSB7XG4gICAgICAgICAgICB0ZmhkT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0cmFjay50eXBlID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgICBpc0hFVkNGbGF2b3IgPSBpc0hFVkModHJhY2suY29kZWMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmaW5kQm94KHRyYWYsIFsndHJ1biddKS5tYXAodHJ1biA9PiB7XG4gICAgICAgICAgICBjb25zdCB2ZXJzaW9uID0gdHJ1blswXTtcbiAgICAgICAgICAgIGNvbnN0IGZsYWdzID0gcmVhZFVpbnQzMih0cnVuLCAwKSAmIDB4ZmZmZmZmO1xuICAgICAgICAgICAgY29uc3QgZGF0YU9mZnNldFByZXNlbnQgPSAoZmxhZ3MgJiAweDAwMDAwMSkgIT09IDA7XG4gICAgICAgICAgICBsZXQgZGF0YU9mZnNldCA9IDA7XG4gICAgICAgICAgICBjb25zdCBmaXJzdFNhbXBsZUZsYWdzUHJlc2VudCA9IChmbGFncyAmIDB4MDAwMDA0KSAhPT0gMDtcbiAgICAgICAgICAgIGNvbnN0IHNhbXBsZUR1cmF0aW9uUHJlc2VudCA9IChmbGFncyAmIDB4MDAwMTAwKSAhPT0gMDtcbiAgICAgICAgICAgIGxldCBzYW1wbGVEdXJhdGlvbiA9IDA7XG4gICAgICAgICAgICBjb25zdCBzYW1wbGVTaXplUHJlc2VudCA9IChmbGFncyAmIDB4MDAwMjAwKSAhPT0gMDtcbiAgICAgICAgICAgIGxldCBzYW1wbGVTaXplID0gMDtcbiAgICAgICAgICAgIGNvbnN0IHNhbXBsZUZsYWdzUHJlc2VudCA9IChmbGFncyAmIDB4MDAwNDAwKSAhPT0gMDtcbiAgICAgICAgICAgIGNvbnN0IHNhbXBsZUNvbXBvc2l0aW9uT2Zmc2V0c1ByZXNlbnQgPSAoZmxhZ3MgJiAweDAwMDgwMCkgIT09IDA7XG4gICAgICAgICAgICBsZXQgY29tcG9zaXRpb25PZmZzZXQgPSAwO1xuICAgICAgICAgICAgY29uc3Qgc2FtcGxlQ291bnQgPSByZWFkVWludDMyKHRydW4sIDQpO1xuICAgICAgICAgICAgbGV0IHRydW5PZmZzZXQgPSA4OyAvLyBwYXN0IHZlcnNpb24sIGZsYWdzLCBhbmQgc2FtcGxlIGNvdW50XG5cbiAgICAgICAgICAgIGlmIChkYXRhT2Zmc2V0UHJlc2VudCkge1xuICAgICAgICAgICAgICBkYXRhT2Zmc2V0ID0gcmVhZFVpbnQzMih0cnVuLCB0cnVuT2Zmc2V0KTtcbiAgICAgICAgICAgICAgdHJ1bk9mZnNldCArPSA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpcnN0U2FtcGxlRmxhZ3NQcmVzZW50KSB7XG4gICAgICAgICAgICAgIHRydW5PZmZzZXQgKz0gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzYW1wbGVPZmZzZXQgPSBkYXRhT2Zmc2V0ICsgbW9vZk9mZnNldDtcbiAgICAgICAgICAgIGZvciAobGV0IGl4ID0gMDsgaXggPCBzYW1wbGVDb3VudDsgaXgrKykge1xuICAgICAgICAgICAgICBpZiAoc2FtcGxlRHVyYXRpb25QcmVzZW50KSB7XG4gICAgICAgICAgICAgICAgc2FtcGxlRHVyYXRpb24gPSByZWFkVWludDMyKHRydW4sIHRydW5PZmZzZXQpO1xuICAgICAgICAgICAgICAgIHRydW5PZmZzZXQgKz0gNDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzYW1wbGVEdXJhdGlvbiA9IGRlZmF1bHRTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoc2FtcGxlU2l6ZVByZXNlbnQpIHtcbiAgICAgICAgICAgICAgICBzYW1wbGVTaXplID0gcmVhZFVpbnQzMih0cnVuLCB0cnVuT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB0cnVuT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2FtcGxlU2l6ZSA9IGRlZmF1bHRTYW1wbGVTaXplO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzYW1wbGVGbGFnc1ByZXNlbnQpIHtcbiAgICAgICAgICAgICAgICB0cnVuT2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHNhbXBsZUNvbXBvc2l0aW9uT2Zmc2V0c1ByZXNlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAodmVyc2lvbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgY29tcG9zaXRpb25PZmZzZXQgPSByZWFkVWludDMyKHRydW4sIHRydW5PZmZzZXQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjb21wb3NpdGlvbk9mZnNldCA9IHJlYWRTaW50MzIodHJ1biwgdHJ1bk9mZnNldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRydW5PZmZzZXQgKz0gNDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodHJhY2sudHlwZSA9PT0gRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5hbHVUb3RhbFNpemUgPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlIChuYWx1VG90YWxTaXplIDwgc2FtcGxlU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgbmFsdVNpemUgPSByZWFkVWludDMyKHZpZGVvRGF0YSwgc2FtcGxlT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgIHNhbXBsZU9mZnNldCArPSA0O1xuICAgICAgICAgICAgICAgICAgaWYgKGlzU0VJTWVzc2FnZShpc0hFVkNGbGF2b3IsIHZpZGVvRGF0YVtzYW1wbGVPZmZzZXRdKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gdmlkZW9EYXRhLnN1YmFycmF5KHNhbXBsZU9mZnNldCwgc2FtcGxlT2Zmc2V0ICsgbmFsdVNpemUpO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZVNFSU1lc3NhZ2VGcm9tTkFMdShkYXRhLCBpc0hFVkNGbGF2b3IgPyAyIDogMSwgdGltZU9mZnNldCArIGNvbXBvc2l0aW9uT2Zmc2V0IC8gdGltZXNjYWxlLCBzZWlTYW1wbGVzKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHNhbXBsZU9mZnNldCArPSBuYWx1U2l6ZTtcbiAgICAgICAgICAgICAgICAgIG5hbHVUb3RhbFNpemUgKz0gbmFsdVNpemUgKyA0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aW1lT2Zmc2V0ICs9IHNhbXBsZUR1cmF0aW9uIC8gdGltZXNjYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBzZWlTYW1wbGVzO1xufVxuZnVuY3Rpb24gaXNIRVZDKGNvZGVjKSB7XG4gIGlmICghY29kZWMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgZGVsaW1pdCA9IGNvZGVjLmluZGV4T2YoJy4nKTtcbiAgY29uc3QgYmFzZUNvZGVjID0gZGVsaW1pdCA8IDAgPyBjb2RlYyA6IGNvZGVjLnN1YnN0cmluZygwLCBkZWxpbWl0KTtcbiAgcmV0dXJuIGJhc2VDb2RlYyA9PT0gJ2h2YzEnIHx8IGJhc2VDb2RlYyA9PT0gJ2hldjEnIHx8XG4gIC8vIERvbGJ5IFZpc2lvblxuICBiYXNlQ29kZWMgPT09ICdkdmgxJyB8fCBiYXNlQ29kZWMgPT09ICdkdmhlJztcbn1cbmZ1bmN0aW9uIGlzU0VJTWVzc2FnZShpc0hFVkNGbGF2b3IsIG5hbHVIZWFkZXIpIHtcbiAgaWYgKGlzSEVWQ0ZsYXZvcikge1xuICAgIGNvbnN0IG5hbHVUeXBlID0gbmFsdUhlYWRlciA+PiAxICYgMHgzZjtcbiAgICByZXR1cm4gbmFsdVR5cGUgPT09IDM5IHx8IG5hbHVUeXBlID09PSA0MDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBuYWx1VHlwZSA9IG5hbHVIZWFkZXIgJiAweDFmO1xuICAgIHJldHVybiBuYWx1VHlwZSA9PT0gNjtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VTRUlNZXNzYWdlRnJvbU5BTHUodW5lc2NhcGVkRGF0YSwgaGVhZGVyU2l6ZSwgcHRzLCBzYW1wbGVzKSB7XG4gIGNvbnN0IGRhdGEgPSBkaXNjYXJkRVBCKHVuZXNjYXBlZERhdGEpO1xuICBsZXQgc2VpUHRyID0gMDtcbiAgLy8gc2tpcCBuYWwgaGVhZGVyXG4gIHNlaVB0ciArPSBoZWFkZXJTaXplO1xuICBsZXQgcGF5bG9hZFR5cGUgPSAwO1xuICBsZXQgcGF5bG9hZFNpemUgPSAwO1xuICBsZXQgYiA9IDA7XG4gIHdoaWxlIChzZWlQdHIgPCBkYXRhLmxlbmd0aCkge1xuICAgIHBheWxvYWRUeXBlID0gMDtcbiAgICBkbyB7XG4gICAgICBpZiAoc2VpUHRyID49IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgYiA9IGRhdGFbc2VpUHRyKytdO1xuICAgICAgcGF5bG9hZFR5cGUgKz0gYjtcbiAgICB9IHdoaWxlIChiID09PSAweGZmKTtcblxuICAgIC8vIFBhcnNlIHBheWxvYWQgc2l6ZS5cbiAgICBwYXlsb2FkU2l6ZSA9IDA7XG4gICAgZG8ge1xuICAgICAgaWYgKHNlaVB0ciA+PSBkYXRhLmxlbmd0aCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGIgPSBkYXRhW3NlaVB0cisrXTtcbiAgICAgIHBheWxvYWRTaXplICs9IGI7XG4gICAgfSB3aGlsZSAoYiA9PT0gMHhmZik7XG4gICAgY29uc3QgbGVmdE92ZXIgPSBkYXRhLmxlbmd0aCAtIHNlaVB0cjtcbiAgICAvLyBDcmVhdGUgYSB2YXJpYWJsZSB0byBwcm9jZXNzIHRoZSBwYXlsb2FkXG4gICAgbGV0IHBheVB0ciA9IHNlaVB0cjtcblxuICAgIC8vIEluY3JlbWVudCB0aGUgc2VpUHRyIHRvIHRoZSBlbmQgb2YgdGhlIHBheWxvYWRcbiAgICBpZiAocGF5bG9hZFNpemUgPCBsZWZ0T3Zlcikge1xuICAgICAgc2VpUHRyICs9IHBheWxvYWRTaXplO1xuICAgIH0gZWxzZSBpZiAocGF5bG9hZFNpemUgPiBsZWZ0T3Zlcikge1xuICAgICAgLy8gU29tZSB0eXBlIG9mIGNvcnJ1cHRpb24gaGFzIGhhcHBlbmVkP1xuICAgICAgbG9nZ2VyLmVycm9yKGBNYWxmb3JtZWQgU0VJIHBheWxvYWQuICR7cGF5bG9hZFNpemV9IGlzIHRvbyBzbWFsbCwgb25seSAke2xlZnRPdmVyfSBieXRlcyBsZWZ0IHRvIHBhcnNlLmApO1xuICAgICAgLy8gV2UgbWlnaHQgYmUgYWJsZSB0byBwYXJzZSBzb21lIGRhdGEsIGJ1dCBsZXQncyBiZSBzYWZlIGFuZCBpZ25vcmUgaXQuXG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKHBheWxvYWRUeXBlID09PSA0KSB7XG4gICAgICBjb25zdCBjb3VudHJ5Q29kZSA9IGRhdGFbcGF5UHRyKytdO1xuICAgICAgaWYgKGNvdW50cnlDb2RlID09PSAxODEpIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXJDb2RlID0gcmVhZFVpbnQxNihkYXRhLCBwYXlQdHIpO1xuICAgICAgICBwYXlQdHIgKz0gMjtcbiAgICAgICAgaWYgKHByb3ZpZGVyQ29kZSA9PT0gNDkpIHtcbiAgICAgICAgICBjb25zdCB1c2VyU3RydWN0dXJlID0gcmVhZFVpbnQzMihkYXRhLCBwYXlQdHIpO1xuICAgICAgICAgIHBheVB0ciArPSA0O1xuICAgICAgICAgIGlmICh1c2VyU3RydWN0dXJlID09PSAweDQ3NDEzOTM0KSB7XG4gICAgICAgICAgICBjb25zdCB1c2VyRGF0YVR5cGUgPSBkYXRhW3BheVB0cisrXTtcblxuICAgICAgICAgICAgLy8gUmF3IENFQS02MDggYnl0ZXMgd3JhcHBlZCBpbiBDRUEtNzA4IHBhY2tldFxuICAgICAgICAgICAgaWYgKHVzZXJEYXRhVHlwZSA9PT0gMykge1xuICAgICAgICAgICAgICBjb25zdCBmaXJzdEJ5dGUgPSBkYXRhW3BheVB0cisrXTtcbiAgICAgICAgICAgICAgY29uc3QgdG90YWxDQ3MgPSAweDFmICYgZmlyc3RCeXRlO1xuICAgICAgICAgICAgICBjb25zdCBlbmFibGVkID0gMHg0MCAmIGZpcnN0Qnl0ZTtcbiAgICAgICAgICAgICAgY29uc3QgdG90YWxCeXRlcyA9IGVuYWJsZWQgPyAyICsgdG90YWxDQ3MgKiAzIDogMDtcbiAgICAgICAgICAgICAgY29uc3QgYnl0ZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodG90YWxCeXRlcyk7XG4gICAgICAgICAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgYnl0ZUFycmF5WzBdID0gZmlyc3RCeXRlO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdG90YWxCeXRlczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICBieXRlQXJyYXlbaV0gPSBkYXRhW3BheVB0cisrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc2FtcGxlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiB1c2VyRGF0YVR5cGUsXG4gICAgICAgICAgICAgICAgcGF5bG9hZFR5cGUsXG4gICAgICAgICAgICAgICAgcHRzLFxuICAgICAgICAgICAgICAgIGJ5dGVzOiBieXRlQXJyYXlcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwYXlsb2FkVHlwZSA9PT0gNSkge1xuICAgICAgaWYgKHBheWxvYWRTaXplID4gMTYpIHtcbiAgICAgICAgY29uc3QgdXVpZFN0ckFycmF5ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgICAgIGNvbnN0IF9iID0gZGF0YVtwYXlQdHIrK10udG9TdHJpbmcoMTYpO1xuICAgICAgICAgIHV1aWRTdHJBcnJheS5wdXNoKF9iLmxlbmd0aCA9PSAxID8gJzAnICsgX2IgOiBfYik7XG4gICAgICAgICAgaWYgKGkgPT09IDMgfHwgaSA9PT0gNSB8fCBpID09PSA3IHx8IGkgPT09IDkpIHtcbiAgICAgICAgICAgIHV1aWRTdHJBcnJheS5wdXNoKCctJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHBheWxvYWRTaXplIC0gMTY7XG4gICAgICAgIGNvbnN0IHVzZXJEYXRhQnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdXNlckRhdGFCeXRlc1tpXSA9IGRhdGFbcGF5UHRyKytdO1xuICAgICAgICB9XG4gICAgICAgIHNhbXBsZXMucHVzaCh7XG4gICAgICAgICAgcGF5bG9hZFR5cGUsXG4gICAgICAgICAgcHRzLFxuICAgICAgICAgIHV1aWQ6IHV1aWRTdHJBcnJheS5qb2luKCcnKSxcbiAgICAgICAgICB1c2VyRGF0YTogdXRmOEFycmF5VG9TdHIodXNlckRhdGFCeXRlcyksXG4gICAgICAgICAgdXNlckRhdGFCeXRlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiByZW1vdmUgRW11bGF0aW9uIFByZXZlbnRpb24gYnl0ZXMgZnJvbSBhIFJCU1BcbiAqL1xuZnVuY3Rpb24gZGlzY2FyZEVQQihkYXRhKSB7XG4gIGNvbnN0IGxlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgY29uc3QgRVBCUG9zaXRpb25zID0gW107XG4gIGxldCBpID0gMTtcblxuICAvLyBGaW5kIGFsbCBgRW11bGF0aW9uIFByZXZlbnRpb24gQnl0ZXNgXG4gIHdoaWxlIChpIDwgbGVuZ3RoIC0gMikge1xuICAgIGlmIChkYXRhW2ldID09PSAwICYmIGRhdGFbaSArIDFdID09PSAwICYmIGRhdGFbaSArIDJdID09PSAweDAzKSB7XG4gICAgICBFUEJQb3NpdGlvbnMucHVzaChpICsgMik7XG4gICAgICBpICs9IDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGkrKztcbiAgICB9XG4gIH1cblxuICAvLyBJZiBubyBFbXVsYXRpb24gUHJldmVudGlvbiBCeXRlcyB3ZXJlIGZvdW5kIGp1c3QgcmV0dXJuIHRoZSBvcmlnaW5hbFxuICAvLyBhcnJheVxuICBpZiAoRVBCUG9zaXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgLy8gQ3JlYXRlIGEgbmV3IGFycmF5IHRvIGhvbGQgdGhlIE5BTCB1bml0IGRhdGFcbiAgY29uc3QgbmV3TGVuZ3RoID0gbGVuZ3RoIC0gRVBCUG9zaXRpb25zLmxlbmd0aDtcbiAgY29uc3QgbmV3RGF0YSA9IG5ldyBVaW50OEFycmF5KG5ld0xlbmd0aCk7XG4gIGxldCBzb3VyY2VJbmRleCA9IDA7XG4gIGZvciAoaSA9IDA7IGkgPCBuZXdMZW5ndGg7IHNvdXJjZUluZGV4KyssIGkrKykge1xuICAgIGlmIChzb3VyY2VJbmRleCA9PT0gRVBCUG9zaXRpb25zWzBdKSB7XG4gICAgICAvLyBTa2lwIHRoaXMgYnl0ZVxuICAgICAgc291cmNlSW5kZXgrKztcbiAgICAgIC8vIFJlbW92ZSB0aGlzIHBvc2l0aW9uIGluZGV4XG4gICAgICBFUEJQb3NpdGlvbnMuc2hpZnQoKTtcbiAgICB9XG4gICAgbmV3RGF0YVtpXSA9IGRhdGFbc291cmNlSW5kZXhdO1xuICB9XG4gIHJldHVybiBuZXdEYXRhO1xufVxuZnVuY3Rpb24gcGFyc2VFbXNnKGRhdGEpIHtcbiAgY29uc3QgdmVyc2lvbiA9IGRhdGFbMF07XG4gIGxldCBzY2hlbWVJZFVyaSA9ICcnO1xuICBsZXQgdmFsdWUgPSAnJztcbiAgbGV0IHRpbWVTY2FsZSA9IDA7XG4gIGxldCBwcmVzZW50YXRpb25UaW1lRGVsdGEgPSAwO1xuICBsZXQgcHJlc2VudGF0aW9uVGltZSA9IDA7XG4gIGxldCBldmVudER1cmF0aW9uID0gMDtcbiAgbGV0IGlkID0gMDtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGlmICh2ZXJzaW9uID09PSAwKSB7XG4gICAgd2hpbGUgKGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKSAhPT0gJ1xcMCcpIHtcbiAgICAgIHNjaGVtZUlkVXJpICs9IGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKTtcbiAgICAgIG9mZnNldCArPSAxO1xuICAgIH1cbiAgICBzY2hlbWVJZFVyaSArPSBiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSk7XG4gICAgb2Zmc2V0ICs9IDE7XG4gICAgd2hpbGUgKGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKSAhPT0gJ1xcMCcpIHtcbiAgICAgIHZhbHVlICs9IGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKTtcbiAgICAgIG9mZnNldCArPSAxO1xuICAgIH1cbiAgICB2YWx1ZSArPSBiaW4yc3RyKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyAxKSk7XG4gICAgb2Zmc2V0ICs9IDE7XG4gICAgdGltZVNjYWxlID0gcmVhZFVpbnQzMihkYXRhLCAxMik7XG4gICAgcHJlc2VudGF0aW9uVGltZURlbHRhID0gcmVhZFVpbnQzMihkYXRhLCAxNik7XG4gICAgZXZlbnREdXJhdGlvbiA9IHJlYWRVaW50MzIoZGF0YSwgMjApO1xuICAgIGlkID0gcmVhZFVpbnQzMihkYXRhLCAyNCk7XG4gICAgb2Zmc2V0ID0gMjg7XG4gIH0gZWxzZSBpZiAodmVyc2lvbiA9PT0gMSkge1xuICAgIG9mZnNldCArPSA0O1xuICAgIHRpbWVTY2FsZSA9IHJlYWRVaW50MzIoZGF0YSwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gNDtcbiAgICBjb25zdCBsZWZ0UHJlc2VudGF0aW9uVGltZSA9IHJlYWRVaW50MzIoZGF0YSwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gNDtcbiAgICBjb25zdCByaWdodFByZXNlbnRhdGlvblRpbWUgPSByZWFkVWludDMyKGRhdGEsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IDQ7XG4gICAgcHJlc2VudGF0aW9uVGltZSA9IDIgKiogMzIgKiBsZWZ0UHJlc2VudGF0aW9uVGltZSArIHJpZ2h0UHJlc2VudGF0aW9uVGltZTtcbiAgICBpZiAoIWlzU2FmZUludGVnZXIocHJlc2VudGF0aW9uVGltZSkpIHtcbiAgICAgIHByZXNlbnRhdGlvblRpbWUgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICAgIGxvZ2dlci53YXJuKCdQcmVzZW50YXRpb24gdGltZSBleGNlZWRzIHNhZmUgaW50ZWdlciBsaW1pdCBhbmQgd3JhcHBlZCB0byBtYXggc2FmZSBpbnRlZ2VyIGluIHBhcnNpbmcgZW1zZyBib3gnKTtcbiAgICB9XG4gICAgZXZlbnREdXJhdGlvbiA9IHJlYWRVaW50MzIoZGF0YSwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gNDtcbiAgICBpZCA9IHJlYWRVaW50MzIoZGF0YSwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gNDtcbiAgICB3aGlsZSAoYmluMnN0cihkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgMSkpICE9PSAnXFwwJykge1xuICAgICAgc2NoZW1lSWRVcmkgKz0gYmluMnN0cihkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgMSkpO1xuICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgfVxuICAgIHNjaGVtZUlkVXJpICs9IGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKTtcbiAgICBvZmZzZXQgKz0gMTtcbiAgICB3aGlsZSAoYmluMnN0cihkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgMSkpICE9PSAnXFwwJykge1xuICAgICAgdmFsdWUgKz0gYmluMnN0cihkYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgMSkpO1xuICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgfVxuICAgIHZhbHVlICs9IGJpbjJzdHIoZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIDEpKTtcbiAgICBvZmZzZXQgKz0gMTtcbiAgfVxuICBjb25zdCBwYXlsb2FkID0gZGF0YS5zdWJhcnJheShvZmZzZXQsIGRhdGEuYnl0ZUxlbmd0aCk7XG4gIHJldHVybiB7XG4gICAgc2NoZW1lSWRVcmksXG4gICAgdmFsdWUsXG4gICAgdGltZVNjYWxlLFxuICAgIHByZXNlbnRhdGlvblRpbWUsXG4gICAgcHJlc2VudGF0aW9uVGltZURlbHRhLFxuICAgIGV2ZW50RHVyYXRpb24sXG4gICAgaWQsXG4gICAgcGF5bG9hZFxuICB9O1xufVxuZnVuY3Rpb24gbXA0Qm94KHR5cGUsIC4uLnBheWxvYWQpIHtcbiAgY29uc3QgbGVuID0gcGF5bG9hZC5sZW5ndGg7XG4gIGxldCBzaXplID0gODtcbiAgbGV0IGkgPSBsZW47XG4gIHdoaWxlIChpLS0pIHtcbiAgICBzaXplICs9IHBheWxvYWRbaV0uYnl0ZUxlbmd0aDtcbiAgfVxuICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgcmVzdWx0WzBdID0gc2l6ZSA+PiAyNCAmIDB4ZmY7XG4gIHJlc3VsdFsxXSA9IHNpemUgPj4gMTYgJiAweGZmO1xuICByZXN1bHRbMl0gPSBzaXplID4+IDggJiAweGZmO1xuICByZXN1bHRbM10gPSBzaXplICYgMHhmZjtcbiAgcmVzdWx0LnNldCh0eXBlLCA0KTtcbiAgZm9yIChpID0gMCwgc2l6ZSA9IDg7IGkgPCBsZW47IGkrKykge1xuICAgIHJlc3VsdC5zZXQocGF5bG9hZFtpXSwgc2l6ZSk7XG4gICAgc2l6ZSArPSBwYXlsb2FkW2ldLmJ5dGVMZW5ndGg7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG1wNHBzc2goc3lzdGVtSWQsIGtleWlkcywgZGF0YSkge1xuICBpZiAoc3lzdGVtSWQuYnl0ZUxlbmd0aCAhPT0gMTYpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBzeXN0ZW0gaWQnKTtcbiAgfVxuICBsZXQgdmVyc2lvbjtcbiAgbGV0IGtpZHM7XG4gIGlmIChrZXlpZHMpIHtcbiAgICB2ZXJzaW9uID0gMTtcbiAgICBraWRzID0gbmV3IFVpbnQ4QXJyYXkoa2V5aWRzLmxlbmd0aCAqIDE2KTtcbiAgICBmb3IgKGxldCBpeCA9IDA7IGl4IDwga2V5aWRzLmxlbmd0aDsgaXgrKykge1xuICAgICAgY29uc3QgayA9IGtleWlkc1tpeF07IC8vIHVpbnQ4YXJyYXlcbiAgICAgIGlmIChrLmJ5dGVMZW5ndGggIT09IDE2KSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIGtleScpO1xuICAgICAgfVxuICAgICAga2lkcy5zZXQoaywgaXggKiAxNik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZlcnNpb24gPSAwO1xuICAgIGtpZHMgPSBuZXcgVWludDhBcnJheSgpO1xuICB9XG4gIGxldCBraWRDb3VudDtcbiAgaWYgKHZlcnNpb24gPiAwKSB7XG4gICAga2lkQ291bnQgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICBpZiAoa2V5aWRzLmxlbmd0aCA+IDApIHtcbiAgICAgIG5ldyBEYXRhVmlldyhraWRDb3VudC5idWZmZXIpLnNldFVpbnQzMigwLCBrZXlpZHMubGVuZ3RoLCBmYWxzZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGtpZENvdW50ID0gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgfVxuICBjb25zdCBkYXRhU2l6ZSA9IG5ldyBVaW50OEFycmF5KDQpO1xuICBpZiAoZGF0YSAmJiBkYXRhLmJ5dGVMZW5ndGggPiAwKSB7XG4gICAgbmV3IERhdGFWaWV3KGRhdGFTaXplLmJ1ZmZlcikuc2V0VWludDMyKDAsIGRhdGEuYnl0ZUxlbmd0aCwgZmFsc2UpO1xuICB9XG4gIHJldHVybiBtcDRCb3goWzExMiwgMTE1LCAxMTUsIDEwNF0sIG5ldyBVaW50OEFycmF5KFt2ZXJzaW9uLCAweDAwLCAweDAwLCAweDAwIC8vIEZsYWdzXG4gIF0pLCBzeXN0ZW1JZCxcbiAgLy8gMTYgYnl0ZXNcbiAga2lkQ291bnQsIGtpZHMsIGRhdGFTaXplLCBkYXRhIHx8IG5ldyBVaW50OEFycmF5KCkpO1xufVxuZnVuY3Rpb24gcGFyc2VQc3NoKGluaXREYXRhKSB7XG4gIGlmICghKGluaXREYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8IGluaXREYXRhLmJ5dGVMZW5ndGggPCAzMikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICB2ZXJzaW9uOiAwLFxuICAgIHN5c3RlbUlkOiAnJyxcbiAgICBraWRzOiBudWxsLFxuICAgIGRhdGE6IG51bGxcbiAgfTtcbiAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhpbml0RGF0YSk7XG4gIGNvbnN0IGJveFNpemUgPSB2aWV3LmdldFVpbnQzMigwKTtcbiAgaWYgKGluaXREYXRhLmJ5dGVMZW5ndGggIT09IGJveFNpemUgJiYgYm94U2l6ZSA+IDQ0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgdHlwZSA9IHZpZXcuZ2V0VWludDMyKDQpO1xuICBpZiAodHlwZSAhPT0gMHg3MDczNzM2OCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJlc3VsdC52ZXJzaW9uID0gdmlldy5nZXRVaW50MzIoOCkgPj4+IDI0O1xuICBpZiAocmVzdWx0LnZlcnNpb24gPiAxKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmVzdWx0LnN5c3RlbUlkID0gSGV4LmhleER1bXAobmV3IFVpbnQ4QXJyYXkoaW5pdERhdGEsIDEyLCAxNikpO1xuICBjb25zdCBkYXRhU2l6ZU9yS2lkQ291bnQgPSB2aWV3LmdldFVpbnQzMigyOCk7XG4gIGlmIChyZXN1bHQudmVyc2lvbiA9PT0gMCkge1xuICAgIGlmIChib3hTaXplIC0gMzIgPCBkYXRhU2l6ZU9yS2lkQ291bnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXN1bHQuZGF0YSA9IG5ldyBVaW50OEFycmF5KGluaXREYXRhLCAzMiwgZGF0YVNpemVPcktpZENvdW50KTtcbiAgfSBlbHNlIGlmIChyZXN1bHQudmVyc2lvbiA9PT0gMSkge1xuICAgIHJlc3VsdC5raWRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhU2l6ZU9yS2lkQ291bnQ7IGkrKykge1xuICAgICAgcmVzdWx0LmtpZHMucHVzaChuZXcgVWludDhBcnJheShpbml0RGF0YSwgMzIgKyBpICogMTYsIDE2KSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmxldCBrZXlVcmlUb0tleUlkTWFwID0ge307XG5jbGFzcyBMZXZlbEtleSB7XG4gIHN0YXRpYyBjbGVhcktleVVyaVRvS2V5SWRNYXAoKSB7XG4gICAga2V5VXJpVG9LZXlJZE1hcCA9IHt9O1xuICB9XG4gIGNvbnN0cnVjdG9yKG1ldGhvZCwgdXJpLCBmb3JtYXQsIGZvcm1hdHZlcnNpb25zID0gWzFdLCBpdiA9IG51bGwpIHtcbiAgICB0aGlzLnVyaSA9IHZvaWQgMDtcbiAgICB0aGlzLm1ldGhvZCA9IHZvaWQgMDtcbiAgICB0aGlzLmtleUZvcm1hdCA9IHZvaWQgMDtcbiAgICB0aGlzLmtleUZvcm1hdFZlcnNpb25zID0gdm9pZCAwO1xuICAgIHRoaXMuZW5jcnlwdGVkID0gdm9pZCAwO1xuICAgIHRoaXMuaXNDb21tb25FbmNyeXB0aW9uID0gdm9pZCAwO1xuICAgIHRoaXMuaXYgPSBudWxsO1xuICAgIHRoaXMua2V5ID0gbnVsbDtcbiAgICB0aGlzLmtleUlkID0gbnVsbDtcbiAgICB0aGlzLnBzc2ggPSBudWxsO1xuICAgIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICAgIHRoaXMudXJpID0gdXJpO1xuICAgIHRoaXMua2V5Rm9ybWF0ID0gZm9ybWF0O1xuICAgIHRoaXMua2V5Rm9ybWF0VmVyc2lvbnMgPSBmb3JtYXR2ZXJzaW9ucztcbiAgICB0aGlzLml2ID0gaXY7XG4gICAgdGhpcy5lbmNyeXB0ZWQgPSBtZXRob2QgPyBtZXRob2QgIT09ICdOT05FJyA6IGZhbHNlO1xuICAgIHRoaXMuaXNDb21tb25FbmNyeXB0aW9uID0gdGhpcy5lbmNyeXB0ZWQgJiYgbWV0aG9kICE9PSAnQUVTLTEyOCc7XG4gIH1cbiAgaXNTdXBwb3J0ZWQoKSB7XG4gICAgLy8gSWYgaXQncyBTZWdtZW50IGVuY3J5cHRpb24gb3IgTm8gZW5jcnlwdGlvbiwganVzdCBzZWxlY3QgdGhhdCBrZXkgc3lzdGVtXG4gICAgaWYgKHRoaXMubWV0aG9kKSB7XG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09ICdBRVMtMTI4JyB8fCB0aGlzLm1ldGhvZCA9PT0gJ05PTkUnKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMua2V5Rm9ybWF0ID09PSAnaWRlbnRpdHknKSB7XG4gICAgICAgIC8vIE1haW50YWluIHN1cHBvcnQgZm9yIGNsZWFyIFNBTVBMRS1BRVMgd2l0aCBNUEVHLTMgVFNcbiAgICAgICAgcmV0dXJuIHRoaXMubWV0aG9kID09PSAnU0FNUExFLUFFUyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2ggKHRoaXMua2V5Rm9ybWF0KSB7XG4gICAgICAgICAgY2FzZSBLZXlTeXN0ZW1Gb3JtYXRzLkZBSVJQTEFZOlxuICAgICAgICAgIGNhc2UgS2V5U3lzdGVtRm9ybWF0cy5XSURFVklORTpcbiAgICAgICAgICBjYXNlIEtleVN5c3RlbUZvcm1hdHMuUExBWVJFQURZOlxuICAgICAgICAgIGNhc2UgS2V5U3lzdGVtRm9ybWF0cy5DTEVBUktFWTpcbiAgICAgICAgICAgIHJldHVybiBbJ0lTTy0yMzAwMS03JywgJ1NBTVBMRS1BRVMnLCAnU0FNUExFLUFFUy1DRU5DJywgJ1NBTVBMRS1BRVMtQ1RSJ10uaW5kZXhPZih0aGlzLm1ldGhvZCkgIT09IC0xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBnZXREZWNyeXB0RGF0YShzbikge1xuICAgIGlmICghdGhpcy5lbmNyeXB0ZWQgfHwgIXRoaXMudXJpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMubWV0aG9kID09PSAnQUVTLTEyOCcgJiYgdGhpcy51cmkgJiYgIXRoaXMuaXYpIHtcbiAgICAgIGlmICh0eXBlb2Ygc24gIT09ICdudW1iZXInKSB7XG4gICAgICAgIC8vIFdlIGFyZSBmZXRjaGluZyBkZWNyeXB0aW9uIGRhdGEgZm9yIGEgaW5pdGlhbGl6YXRpb24gc2VnbWVudFxuICAgICAgICAvLyBJZiB0aGUgc2VnbWVudCB3YXMgZW5jcnlwdGVkIHdpdGggQUVTLTEyOFxuICAgICAgICAvLyBJdCBtdXN0IGhhdmUgYW4gSVYgZGVmaW5lZC4gV2UgY2Fubm90IHN1YnN0aXR1dGUgdGhlIFNlZ21lbnQgTnVtYmVyIGluLlxuICAgICAgICBpZiAodGhpcy5tZXRob2QgPT09ICdBRVMtMTI4JyAmJiAhdGhpcy5pdikge1xuICAgICAgICAgIGxvZ2dlci53YXJuKGBtaXNzaW5nIElWIGZvciBpbml0aWFsaXphdGlvbiBzZWdtZW50IHdpdGggbWV0aG9kPVwiJHt0aGlzLm1ldGhvZH1cIiAtIGNvbXBsaWFuY2UgaXNzdWVgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFeHBsaWNpdGx5IHNldCBzbiB0byByZXN1bHRpbmcgdmFsdWUgZnJvbSBpbXBsaWNpdCBjb252ZXJzaW9ucyAnaW5pdFNlZ21lbnQnIHZhbHVlcyBmb3IgSVYgZ2VuZXJhdGlvbi5cbiAgICAgICAgc24gPSAwO1xuICAgICAgfVxuICAgICAgY29uc3QgaXYgPSBjcmVhdGVJbml0aWFsaXphdGlvblZlY3Rvcihzbik7XG4gICAgICBjb25zdCBkZWNyeXB0ZGF0YSA9IG5ldyBMZXZlbEtleSh0aGlzLm1ldGhvZCwgdGhpcy51cmksICdpZGVudGl0eScsIHRoaXMua2V5Rm9ybWF0VmVyc2lvbnMsIGl2KTtcbiAgICAgIHJldHVybiBkZWNyeXB0ZGF0YTtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIGtleUlkIGlmIHBvc3NpYmxlXG4gICAgY29uc3Qga2V5Qnl0ZXMgPSBjb252ZXJ0RGF0YVVyaVRvQXJyYXlCeXRlcyh0aGlzLnVyaSk7XG4gICAgaWYgKGtleUJ5dGVzKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMua2V5Rm9ybWF0KSB7XG4gICAgICAgIGNhc2UgS2V5U3lzdGVtRm9ybWF0cy5XSURFVklORTpcbiAgICAgICAgICB0aGlzLnBzc2ggPSBrZXlCeXRlcztcbiAgICAgICAgICAvLyBJbiBjYXNlIG9mIHdpZGV2aW5lIGtleUlEIGlzIGVtYmVkZGVkIGluIFBTU0ggYm94LiBSZWFkIEtleSBJRC5cbiAgICAgICAgICBpZiAoa2V5Qnl0ZXMubGVuZ3RoID49IDIyKSB7XG4gICAgICAgICAgICB0aGlzLmtleUlkID0ga2V5Qnl0ZXMuc3ViYXJyYXkoa2V5Qnl0ZXMubGVuZ3RoIC0gMjIsIGtleUJ5dGVzLmxlbmd0aCAtIDYpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBLZXlTeXN0ZW1Gb3JtYXRzLlBMQVlSRUFEWTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBQbGF5UmVhZHlLZXlTeXN0ZW1VVUlEID0gbmV3IFVpbnQ4QXJyYXkoWzB4OWEsIDB4MDQsIDB4ZjAsIDB4NzksIDB4OTgsIDB4NDAsIDB4NDIsIDB4ODYsIDB4YWIsIDB4OTIsIDB4ZTYsIDB4NWIsIDB4ZTAsIDB4ODgsIDB4NWYsIDB4OTVdKTtcbiAgICAgICAgICAgIHRoaXMucHNzaCA9IG1wNHBzc2goUGxheVJlYWR5S2V5U3lzdGVtVVVJRCwgbnVsbCwga2V5Qnl0ZXMpO1xuICAgICAgICAgICAgY29uc3Qga2V5Qnl0ZXNVdGYxNiA9IG5ldyBVaW50MTZBcnJheShrZXlCeXRlcy5idWZmZXIsIGtleUJ5dGVzLmJ5dGVPZmZzZXQsIGtleUJ5dGVzLmJ5dGVMZW5ndGggLyAyKTtcbiAgICAgICAgICAgIGNvbnN0IGtleUJ5dGVTdHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIEFycmF5LmZyb20oa2V5Qnl0ZXNVdGYxNikpO1xuXG4gICAgICAgICAgICAvLyBQYXJzZSBQbGF5cmVhZHkgV1JNSGVhZGVyIFhNTFxuICAgICAgICAgICAgY29uc3QgeG1sS2V5Qnl0ZXMgPSBrZXlCeXRlU3RyLnN1YnN0cmluZyhrZXlCeXRlU3RyLmluZGV4T2YoJzwnKSwga2V5Qnl0ZVN0ci5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICAgICAgICAgICAgY29uc3QgeG1sRG9jID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyh4bWxLZXlCeXRlcywgJ3RleHQveG1sJyk7XG4gICAgICAgICAgICBjb25zdCBrZXlEYXRhID0geG1sRG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdLSUQnKVswXTtcbiAgICAgICAgICAgIGlmIChrZXlEYXRhKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGtleUlkID0ga2V5RGF0YS5jaGlsZE5vZGVzWzBdID8ga2V5RGF0YS5jaGlsZE5vZGVzWzBdLm5vZGVWYWx1ZSA6IGtleURhdGEuZ2V0QXR0cmlidXRlKCdWQUxVRScpO1xuICAgICAgICAgICAgICBpZiAoa2V5SWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlJZEFycmF5ID0gYmFzZTY0RGVjb2RlKGtleUlkKS5zdWJhcnJheSgwLCAxNik7XG4gICAgICAgICAgICAgICAgLy8gS0lEIHZhbHVlIGluIFBSTyBpcyBhIGJhc2U2NC1lbmNvZGVkIGxpdHRsZSBlbmRpYW4gR1VJRCBpbnRlcnByZXRhdGlvbiBvZiBVVUlEXG4gICAgICAgICAgICAgICAgLy8gS0lEIHZhbHVlIGluIOKAmHRlbmPigJkgaXMgYSBiaWcgZW5kaWFuIFVVSUQgR1VJRCBpbnRlcnByZXRhdGlvbiBvZiBVVUlEXG4gICAgICAgICAgICAgICAgY2hhbmdlRW5kaWFubmVzcyhrZXlJZEFycmF5KTtcbiAgICAgICAgICAgICAgICB0aGlzLmtleUlkID0ga2V5SWRBcnJheTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGxldCBrZXlkYXRhID0ga2V5Qnl0ZXMuc3ViYXJyYXkoMCwgMTYpO1xuICAgICAgICAgICAgaWYgKGtleWRhdGEubGVuZ3RoICE9PSAxNikge1xuICAgICAgICAgICAgICBjb25zdCBwYWRkZWQgPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgICAgICAgICAgIHBhZGRlZC5zZXQoa2V5ZGF0YSwgMTYgLSBrZXlkYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICAgIGtleWRhdGEgPSBwYWRkZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmtleUlkID0ga2V5ZGF0YTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IGJlaGF2aW9yOiBhc3NpZ24gYSBuZXcga2V5SWQgZm9yIGVhY2ggdXJpXG4gICAgaWYgKCF0aGlzLmtleUlkIHx8IHRoaXMua2V5SWQuYnl0ZUxlbmd0aCAhPT0gMTYpIHtcbiAgICAgIGxldCBrZXlJZCA9IGtleVVyaVRvS2V5SWRNYXBbdGhpcy51cmldO1xuICAgICAgaWYgKCFrZXlJZCkge1xuICAgICAgICBjb25zdCB2YWwgPSBPYmplY3Qua2V5cyhrZXlVcmlUb0tleUlkTWFwKS5sZW5ndGggJSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICAgICAga2V5SWQgPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgICAgIGNvbnN0IGR2ID0gbmV3IERhdGFWaWV3KGtleUlkLmJ1ZmZlciwgMTIsIDQpOyAvLyBKdXN0IHNldCB0aGUgbGFzdCA0IGJ5dGVzXG4gICAgICAgIGR2LnNldFVpbnQzMigwLCB2YWwpO1xuICAgICAgICBrZXlVcmlUb0tleUlkTWFwW3RoaXMudXJpXSA9IGtleUlkO1xuICAgICAgfVxuICAgICAgdGhpcy5rZXlJZCA9IGtleUlkO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlSW5pdGlhbGl6YXRpb25WZWN0b3Ioc2VnbWVudE51bWJlcikge1xuICBjb25zdCB1aW50OFZpZXcgPSBuZXcgVWludDhBcnJheSgxNik7XG4gIGZvciAobGV0IGkgPSAxMjsgaSA8IDE2OyBpKyspIHtcbiAgICB1aW50OFZpZXdbaV0gPSBzZWdtZW50TnVtYmVyID4+IDggKiAoMTUgLSBpKSAmIDB4ZmY7XG4gIH1cbiAgcmV0dXJuIHVpbnQ4Vmlldztcbn1cblxuY29uc3QgVkFSSUFCTEVfUkVQTEFDRU1FTlRfUkVHRVggPSAvXFx7XFwkKFthLXpBLVowLTktX10rKVxcfS9nO1xuZnVuY3Rpb24gaGFzVmFyaWFibGVSZWZlcmVuY2VzKHN0cikge1xuICByZXR1cm4gVkFSSUFCTEVfUkVQTEFDRU1FTlRfUkVHRVgudGVzdChzdHIpO1xufVxuZnVuY3Rpb24gc3Vic3RpdHV0ZVZhcmlhYmxlc0luQXR0cmlidXRlcyhwYXJzZWQsIGF0dHIsIGF0dHJpYnV0ZU5hbWVzKSB7XG4gIGlmIChwYXJzZWQudmFyaWFibGVMaXN0ICE9PSBudWxsIHx8IHBhcnNlZC5oYXNWYXJpYWJsZVJlZnMpIHtcbiAgICBmb3IgKGxldCBpID0gYXR0cmlidXRlTmFtZXMubGVuZ3RoOyBpLS07KSB7XG4gICAgICBjb25zdCBuYW1lID0gYXR0cmlidXRlTmFtZXNbaV07XG4gICAgICBjb25zdCB2YWx1ZSA9IGF0dHJbbmFtZV07XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgYXR0cltuYW1lXSA9IHN1YnN0aXR1dGVWYXJpYWJsZXMocGFyc2VkLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzdWJzdGl0dXRlVmFyaWFibGVzKHBhcnNlZCwgdmFsdWUpIHtcbiAgaWYgKHBhcnNlZC52YXJpYWJsZUxpc3QgIT09IG51bGwgfHwgcGFyc2VkLmhhc1ZhcmlhYmxlUmVmcykge1xuICAgIGNvbnN0IHZhcmlhYmxlTGlzdCA9IHBhcnNlZC52YXJpYWJsZUxpc3Q7XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoVkFSSUFCTEVfUkVQTEFDRU1FTlRfUkVHRVgsIHZhcmlhYmxlUmVmZXJlbmNlID0+IHtcbiAgICAgIGNvbnN0IHZhcmlhYmxlTmFtZSA9IHZhcmlhYmxlUmVmZXJlbmNlLnN1YnN0cmluZygyLCB2YXJpYWJsZVJlZmVyZW5jZS5sZW5ndGggLSAxKTtcbiAgICAgIGNvbnN0IHZhcmlhYmxlVmFsdWUgPSB2YXJpYWJsZUxpc3QgPT0gbnVsbCA/IHZvaWQgMCA6IHZhcmlhYmxlTGlzdFt2YXJpYWJsZU5hbWVdO1xuICAgICAgaWYgKHZhcmlhYmxlVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwYXJzZWQucGxheWxpc3RQYXJzaW5nRXJyb3IgfHwgKHBhcnNlZC5wbGF5bGlzdFBhcnNpbmdFcnJvciA9IG5ldyBFcnJvcihgTWlzc2luZyBwcmVjZWRpbmcgRVhULVgtREVGSU5FIHRhZyBmb3IgVmFyaWFibGUgUmVmZXJlbmNlOiBcIiR7dmFyaWFibGVOYW1lfVwiYCkpO1xuICAgICAgICByZXR1cm4gdmFyaWFibGVSZWZlcmVuY2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFyaWFibGVWYWx1ZTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBhZGRWYXJpYWJsZURlZmluaXRpb24ocGFyc2VkLCBhdHRyLCBwYXJlbnRVcmwpIHtcbiAgbGV0IHZhcmlhYmxlTGlzdCA9IHBhcnNlZC52YXJpYWJsZUxpc3Q7XG4gIGlmICghdmFyaWFibGVMaXN0KSB7XG4gICAgcGFyc2VkLnZhcmlhYmxlTGlzdCA9IHZhcmlhYmxlTGlzdCA9IHt9O1xuICB9XG4gIGxldCBOQU1FO1xuICBsZXQgVkFMVUU7XG4gIGlmICgnUVVFUllQQVJBTScgaW4gYXR0cikge1xuICAgIE5BTUUgPSBhdHRyLlFVRVJZUEFSQU07XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNlYXJjaFBhcmFtcyA9IG5ldyBzZWxmLlVSTChwYXJlbnRVcmwpLnNlYXJjaFBhcmFtcztcbiAgICAgIGlmIChzZWFyY2hQYXJhbXMuaGFzKE5BTUUpKSB7XG4gICAgICAgIFZBTFVFID0gc2VhcmNoUGFyYW1zLmdldChOQU1FKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke05BTUV9XCIgZG9lcyBub3QgbWF0Y2ggYW55IHF1ZXJ5IHBhcmFtZXRlciBpbiBVUkk6IFwiJHtwYXJlbnRVcmx9XCJgKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcGFyc2VkLnBsYXlsaXN0UGFyc2luZ0Vycm9yIHx8IChwYXJzZWQucGxheWxpc3RQYXJzaW5nRXJyb3IgPSBuZXcgRXJyb3IoYEVYVC1YLURFRklORSBRVUVSWVBBUkFNOiAke2Vycm9yLm1lc3NhZ2V9YCkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBOQU1FID0gYXR0ci5OQU1FO1xuICAgIFZBTFVFID0gYXR0ci5WQUxVRTtcbiAgfVxuICBpZiAoTkFNRSBpbiB2YXJpYWJsZUxpc3QpIHtcbiAgICBwYXJzZWQucGxheWxpc3RQYXJzaW5nRXJyb3IgfHwgKHBhcnNlZC5wbGF5bGlzdFBhcnNpbmdFcnJvciA9IG5ldyBFcnJvcihgRVhULVgtREVGSU5FIGR1cGxpY2F0ZSBWYXJpYWJsZSBOYW1lIGRlY2xhcmF0aW9uczogXCIke05BTUV9XCJgKSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyaWFibGVMaXN0W05BTUVdID0gVkFMVUUgfHwgJyc7XG4gIH1cbn1cbmZ1bmN0aW9uIGltcG9ydFZhcmlhYmxlRGVmaW5pdGlvbihwYXJzZWQsIGF0dHIsIHNvdXJjZVZhcmlhYmxlTGlzdCkge1xuICBjb25zdCBJTVBPUlQgPSBhdHRyLklNUE9SVDtcbiAgaWYgKHNvdXJjZVZhcmlhYmxlTGlzdCAmJiBJTVBPUlQgaW4gc291cmNlVmFyaWFibGVMaXN0KSB7XG4gICAgbGV0IHZhcmlhYmxlTGlzdCA9IHBhcnNlZC52YXJpYWJsZUxpc3Q7XG4gICAgaWYgKCF2YXJpYWJsZUxpc3QpIHtcbiAgICAgIHBhcnNlZC52YXJpYWJsZUxpc3QgPSB2YXJpYWJsZUxpc3QgPSB7fTtcbiAgICB9XG4gICAgdmFyaWFibGVMaXN0W0lNUE9SVF0gPSBzb3VyY2VWYXJpYWJsZUxpc3RbSU1QT1JUXTtcbiAgfSBlbHNlIHtcbiAgICBwYXJzZWQucGxheWxpc3RQYXJzaW5nRXJyb3IgfHwgKHBhcnNlZC5wbGF5bGlzdFBhcnNpbmdFcnJvciA9IG5ldyBFcnJvcihgRVhULVgtREVGSU5FIElNUE9SVCBhdHRyaWJ1dGUgbm90IGZvdW5kIGluIE11bHRpdmFyaWFudCBQbGF5bGlzdDogXCIke0lNUE9SVH1cImApKTtcbiAgfVxufVxuXG4vKipcbiAqIE1lZGlhU291cmNlIGhlbHBlclxuICovXG5cbmZ1bmN0aW9uIGdldE1lZGlhU291cmNlKHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSA9IHRydWUpIHtcbiAgaWYgKHR5cGVvZiBzZWxmID09PSAndW5kZWZpbmVkJykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgY29uc3QgbW1zID0gKHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSB8fCAhc2VsZi5NZWRpYVNvdXJjZSkgJiYgc2VsZi5NYW5hZ2VkTWVkaWFTb3VyY2U7XG4gIHJldHVybiBtbXMgfHwgc2VsZi5NZWRpYVNvdXJjZSB8fCBzZWxmLldlYktpdE1lZGlhU291cmNlO1xufVxuXG4vLyBmcm9tIGh0dHA6Ly9tcDRyYS5vcmcvY29kZWNzLmh0bWxcbi8vIHZhbHVlcyBpbmRpY2F0ZSBjb2RlYyBzZWxlY3Rpb24gcHJlZmVyZW5jZSAobG93ZXIgaXMgaGlnaGVyIHByaW9yaXR5KVxuY29uc3Qgc2FtcGxlRW50cnlDb2Rlc0lTTyA9IHtcbiAgYXVkaW86IHtcbiAgICBhM2RzOiAxLFxuICAgICdhYy0zJzogMC45NSxcbiAgICAnYWMtNCc6IDEsXG4gICAgYWxhYzogMC45LFxuICAgIGFsYXc6IDEsXG4gICAgZHJhMTogMSxcbiAgICAnZHRzKyc6IDEsXG4gICAgJ2R0cy0nOiAxLFxuICAgIGR0c2M6IDEsXG4gICAgZHRzZTogMSxcbiAgICBkdHNoOiAxLFxuICAgICdlYy0zJzogMC45LFxuICAgIGVuY2E6IDEsXG4gICAgZkxhQzogMC45LFxuICAgIC8vIE1QNC1SQSBsaXN0ZWQgY29kZWMgZW50cnkgZm9yIEZMQUNcbiAgICBmbGFjOiAwLjksXG4gICAgLy8gbGVnYWN5IGJyb3dzZXIgY29kZWMgbmFtZSBmb3IgRkxBQ1xuICAgIEZMQUM6IDAuOSxcbiAgICAvLyBzb21lIG1hbmlmZXN0cyBtYXkgbGlzdCBcIkZMQUNcIiB3aXRoIEFwcGxlJ3MgdG9vbHNcbiAgICBnNzE5OiAxLFxuICAgIGc3MjY6IDEsXG4gICAgbTRhZTogMSxcbiAgICBtaGExOiAxLFxuICAgIG1oYTI6IDEsXG4gICAgbWhtMTogMSxcbiAgICBtaG0yOiAxLFxuICAgIG1scGE6IDEsXG4gICAgbXA0YTogMSxcbiAgICAncmF3ICc6IDEsXG4gICAgT3B1czogMSxcbiAgICBvcHVzOiAxLFxuICAgIC8vIGJyb3dzZXJzIGV4cGVjdCB0aGlzIHRvIGJlIGxvd2VyY2FzZSBkZXNwaXRlIE1QNFJBIHNheXMgJ09wdXMnXG4gICAgc2FtcjogMSxcbiAgICBzYXdiOiAxLFxuICAgIHNhd3A6IDEsXG4gICAgc2V2YzogMSxcbiAgICBzcWNwOiAxLFxuICAgIHNzbXY6IDEsXG4gICAgdHdvczogMSxcbiAgICB1bGF3OiAxXG4gIH0sXG4gIHZpZGVvOiB7XG4gICAgYXZjMTogMSxcbiAgICBhdmMyOiAxLFxuICAgIGF2YzM6IDEsXG4gICAgYXZjNDogMSxcbiAgICBhdmNwOiAxLFxuICAgIGF2MDE6IDAuOCxcbiAgICBkcmFjOiAxLFxuICAgIGR2YTE6IDEsXG4gICAgZHZhdjogMSxcbiAgICBkdmgxOiAwLjcsXG4gICAgZHZoZTogMC43LFxuICAgIGVuY3Y6IDEsXG4gICAgaGV2MTogMC43NSxcbiAgICBodmMxOiAwLjc1LFxuICAgIG1qcDI6IDEsXG4gICAgbXA0djogMSxcbiAgICBtdmMxOiAxLFxuICAgIG12YzI6IDEsXG4gICAgbXZjMzogMSxcbiAgICBtdmM0OiAxLFxuICAgIHJlc3Y6IDEsXG4gICAgcnY2MDogMSxcbiAgICBzMjYzOiAxLFxuICAgIHN2YzE6IDEsXG4gICAgc3ZjMjogMSxcbiAgICAndmMtMSc6IDEsXG4gICAgdnAwODogMSxcbiAgICB2cDA5OiAwLjlcbiAgfSxcbiAgdGV4dDoge1xuICAgIHN0cHA6IDEsXG4gICAgd3Z0dDogMVxuICB9XG59O1xuZnVuY3Rpb24gaXNDb2RlY1R5cGUoY29kZWMsIHR5cGUpIHtcbiAgY29uc3QgdHlwZUNvZGVzID0gc2FtcGxlRW50cnlDb2Rlc0lTT1t0eXBlXTtcbiAgcmV0dXJuICEhdHlwZUNvZGVzICYmICEhdHlwZUNvZGVzW2NvZGVjLnNsaWNlKDAsIDQpXTtcbn1cbmZ1bmN0aW9uIGFyZUNvZGVjc01lZGlhU291cmNlU3VwcG9ydGVkKGNvZGVjcywgdHlwZSwgcHJlZmVyTWFuYWdlZE1lZGlhU291cmNlID0gdHJ1ZSkge1xuICByZXR1cm4gIWNvZGVjcy5zcGxpdCgnLCcpLnNvbWUoY29kZWMgPT4gIWlzQ29kZWNNZWRpYVNvdXJjZVN1cHBvcnRlZChjb2RlYywgdHlwZSwgcHJlZmVyTWFuYWdlZE1lZGlhU291cmNlKSk7XG59XG5mdW5jdGlvbiBpc0NvZGVjTWVkaWFTb3VyY2VTdXBwb3J0ZWQoY29kZWMsIHR5cGUsIHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSA9IHRydWUpIHtcbiAgdmFyIF9NZWRpYVNvdXJjZSRpc1R5cGVTdTtcbiAgY29uc3QgTWVkaWFTb3VyY2UgPSBnZXRNZWRpYVNvdXJjZShwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UpO1xuICByZXR1cm4gKF9NZWRpYVNvdXJjZSRpc1R5cGVTdSA9IE1lZGlhU291cmNlID09IG51bGwgPyB2b2lkIDAgOiBNZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQobWltZVR5cGVGb3JDb2RlYyhjb2RlYywgdHlwZSkpKSAhPSBudWxsID8gX01lZGlhU291cmNlJGlzVHlwZVN1IDogZmFsc2U7XG59XG5mdW5jdGlvbiBtaW1lVHlwZUZvckNvZGVjKGNvZGVjLCB0eXBlKSB7XG4gIHJldHVybiBgJHt0eXBlfS9tcDQ7Y29kZWNzPVwiJHtjb2RlY31cImA7XG59XG5mdW5jdGlvbiB2aWRlb0NvZGVjUHJlZmVyZW5jZVZhbHVlKHZpZGVvQ29kZWMpIHtcbiAgaWYgKHZpZGVvQ29kZWMpIHtcbiAgICBjb25zdCBmb3VyQ0MgPSB2aWRlb0NvZGVjLnN1YnN0cmluZygwLCA0KTtcbiAgICByZXR1cm4gc2FtcGxlRW50cnlDb2Rlc0lTTy52aWRlb1tmb3VyQ0NdO1xuICB9XG4gIHJldHVybiAyO1xufVxuZnVuY3Rpb24gY29kZWNzU2V0U2VsZWN0aW9uUHJlZmVyZW5jZVZhbHVlKGNvZGVjU2V0KSB7XG4gIHJldHVybiBjb2RlY1NldC5zcGxpdCgnLCcpLnJlZHVjZSgobnVtLCBmb3VyQ0MpID0+IHtcbiAgICBjb25zdCBwcmVmZXJlbmNlVmFsdWUgPSBzYW1wbGVFbnRyeUNvZGVzSVNPLnZpZGVvW2ZvdXJDQ107XG4gICAgaWYgKHByZWZlcmVuY2VWYWx1ZSkge1xuICAgICAgcmV0dXJuIChwcmVmZXJlbmNlVmFsdWUgKiAyICsgbnVtKSAvIChudW0gPyAzIDogMik7XG4gICAgfVxuICAgIHJldHVybiAoc2FtcGxlRW50cnlDb2Rlc0lTTy5hdWRpb1tmb3VyQ0NdICsgbnVtKSAvIChudW0gPyAyIDogMSk7XG4gIH0sIDApO1xufVxuY29uc3QgQ09ERUNfQ09NUEFUSUJMRV9OQU1FUyA9IHt9O1xuZnVuY3Rpb24gZ2V0Q29kZWNDb21wYXRpYmxlTmFtZUxvd2VyKGxvd2VyQ2FzZUNvZGVjLCBwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UgPSB0cnVlKSB7XG4gIGlmIChDT0RFQ19DT01QQVRJQkxFX05BTUVTW2xvd2VyQ2FzZUNvZGVjXSkge1xuICAgIHJldHVybiBDT0RFQ19DT01QQVRJQkxFX05BTUVTW2xvd2VyQ2FzZUNvZGVjXTtcbiAgfVxuXG4gIC8vIElkZWFseSBmTGFDIGFuZCBPcHVzIHdvdWxkIGJlIGZpcnN0IChzcGVjLWNvbXBsaWFudCkgYnV0XG4gIC8vIHNvbWUgYnJvd3NlcnMgd2lsbCByZXBvcnQgdGhhdCBmTGFDIGlzIHN1cHBvcnRlZCB0aGVuIGZhaWwuXG4gIC8vIHNlZTogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTQyMjcyOFxuICBjb25zdCBjb2RlY3NUb0NoZWNrID0ge1xuICAgIGZsYWM6IFsnZmxhYycsICdmTGFDJywgJ0ZMQUMnXSxcbiAgICBvcHVzOiBbJ29wdXMnLCAnT3B1cyddXG4gIH1bbG93ZXJDYXNlQ29kZWNdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvZGVjc1RvQ2hlY2subGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaXNDb2RlY01lZGlhU291cmNlU3VwcG9ydGVkKGNvZGVjc1RvQ2hlY2tbaV0sICdhdWRpbycsIHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSkpIHtcbiAgICAgIENPREVDX0NPTVBBVElCTEVfTkFNRVNbbG93ZXJDYXNlQ29kZWNdID0gY29kZWNzVG9DaGVja1tpXTtcbiAgICAgIHJldHVybiBjb2RlY3NUb0NoZWNrW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbG93ZXJDYXNlQ29kZWM7XG59XG5jb25zdCBBVURJT19DT0RFQ19SRUdFWFAgPSAvZmxhY3xvcHVzL2k7XG5mdW5jdGlvbiBnZXRDb2RlY0NvbXBhdGlibGVOYW1lKGNvZGVjLCBwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UgPSB0cnVlKSB7XG4gIHJldHVybiBjb2RlYy5yZXBsYWNlKEFVRElPX0NPREVDX1JFR0VYUCwgbSA9PiBnZXRDb2RlY0NvbXBhdGlibGVOYW1lTG93ZXIobS50b0xvd2VyQ2FzZSgpLCBwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UpKTtcbn1cbmZ1bmN0aW9uIHBpY2tNb3N0Q29tcGxldGVDb2RlY05hbWUocGFyc2VkQ29kZWMsIGxldmVsQ29kZWMpIHtcbiAgLy8gUGFyc2luZyBvZiBtcDRhIGNvZGVjcyBzdHJpbmdzIGluIG1wNC10b29scyBmcm9tIG1lZGlhIGlzIGluY29tcGxldGUgYXMgb2YgZDhjNmM3YVxuICAvLyBzbyB1c2UgbGV2ZWwgY29kZWMgaXMgcGFyc2VkIGNvZGVjIGlzIHVuYXZhaWxhYmxlIG9yIGluY29tcGxldGVcbiAgaWYgKHBhcnNlZENvZGVjICYmIHBhcnNlZENvZGVjICE9PSAnbXA0YScpIHtcbiAgICByZXR1cm4gcGFyc2VkQ29kZWM7XG4gIH1cbiAgcmV0dXJuIGxldmVsQ29kZWM7XG59XG5mdW5jdGlvbiBjb252ZXJ0QVZDMVRvQVZDT1RJKGNvZGVjKSB7XG4gIC8vIENvbnZlcnQgYXZjMSBjb2RlYyBzdHJpbmcgZnJvbSBSRkMtNDI4MSB0byBSRkMtNjM4MSBmb3IgTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkXG4gIGNvbnN0IGF2Y2RhdGEgPSBjb2RlYy5zcGxpdCgnLicpO1xuICBpZiAoYXZjZGF0YS5sZW5ndGggPiAyKSB7XG4gICAgbGV0IHJlc3VsdCA9IGF2Y2RhdGEuc2hpZnQoKSArICcuJztcbiAgICByZXN1bHQgKz0gcGFyc2VJbnQoYXZjZGF0YS5zaGlmdCgpKS50b1N0cmluZygxNik7XG4gICAgcmVzdWx0ICs9ICgnMDAwJyArIHBhcnNlSW50KGF2Y2RhdGEuc2hpZnQoKSkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICByZXR1cm4gY29kZWM7XG59XG5cbmNvbnN0IE1BU1RFUl9QTEFZTElTVF9SRUdFWCA9IC8jRVhULVgtU1RSRUFNLUlORjooW15cXHJcXG5dKikoPzpbXFxyXFxuXSg/OiNbXlxcclxcbl0qKT8pKihbXlxcclxcbl0rKXwjRVhULVgtKFNFU1NJT04tREFUQXxTRVNTSU9OLUtFWXxERUZJTkV8Q09OVEVOVC1TVEVFUklOR3xTVEFSVCk6KFteXFxyXFxuXSopW1xcclxcbl0rL2c7XG5jb25zdCBNQVNURVJfUExBWUxJU1RfTUVESUFfUkVHRVggPSAvI0VYVC1YLU1FRElBOiguKikvZztcbmNvbnN0IElTX01FRElBX1BMQVlMSVNUID0gL14jRVhUKD86SU5GfC1YLVRBUkdFVERVUkFUSU9OKTovbTsgLy8gSGFuZGxlIGVtcHR5IE1lZGlhIFBsYXlsaXN0IChmaXJzdCBFWFRJTkYgbm90IHNpZ25hbGVkLCBidXQgVEFSR0VURFVSQVRJT04gcHJlc2VudClcblxuY29uc3QgTEVWRUxfUExBWUxJU1RfUkVHRVhfRkFTVCA9IG5ldyBSZWdFeHAoWy8jRVhUSU5GOlxccyooXFxkKig/OlxcLlxcZCspPykoPzosKC4qKVxccyspPy8uc291cmNlLFxuLy8gZHVyYXRpb24gKCNFWFRJTkY6PGR1cmF0aW9uPiw8dGl0bGU+KSwgZ3JvdXAgMSA9PiBkdXJhdGlvbiwgZ3JvdXAgMiA9PiB0aXRsZVxuLyg/ISMpICooXFxTW1xcUyBdKikvLnNvdXJjZSxcbi8vIHNlZ21lbnQgVVJJLCBncm91cCAzID0+IHRoZSBVUkkgKG5vdGUgbmV3bGluZSBpcyBub3QgZWF0ZW4pXG4vI0VYVC1YLUJZVEVSQU5HRToqKC4rKS8uc291cmNlLFxuLy8gbmV4dCBzZWdtZW50J3MgYnl0ZXJhbmdlLCBncm91cCA0ID0+IHJhbmdlIHNwZWMgKHhAeSlcbi8jRVhULVgtUFJPR1JBTS1EQVRFLVRJTUU6KC4rKS8uc291cmNlLFxuLy8gbmV4dCBzZWdtZW50J3MgcHJvZ3JhbSBkYXRlL3RpbWUgZ3JvdXAgNSA9PiB0aGUgZGF0ZXRpbWUgc3BlY1xuLyMuKi8uc291cmNlIC8vIEFsbCBvdGhlciBub24tc2VnbWVudCBvcmllbnRlZCB0YWdzIHdpbGwgbWF0Y2ggd2l0aCBhbGwgZ3JvdXBzIGVtcHR5XG5dLmpvaW4oJ3wnKSwgJ2cnKTtcbmNvbnN0IExFVkVMX1BMQVlMSVNUX1JFR0VYX1NMT1cgPSBuZXcgUmVnRXhwKFsvIyhFWFRNM1UpLy5zb3VyY2UsIC8jRVhULVgtKERBVEVSQU5HRXxERUZJTkV8S0VZfE1BUHxQQVJUfFBBUlQtSU5GfFBMQVlMSVNULVRZUEV8UFJFTE9BRC1ISU5UfFJFTkRJVElPTi1SRVBPUlR8U0VSVkVSLUNPTlRST0x8U0tJUHxTVEFSVCk6KC4rKS8uc291cmNlLCAvI0VYVC1YLShCSVRSQVRFfERJU0NPTlRJTlVJVFktU0VRVUVOQ0V8TUVESUEtU0VRVUVOQ0V8VEFSR0VURFVSQVRJT058VkVSU0lPTik6ICooXFxkKykvLnNvdXJjZSwgLyNFWFQtWC0oRElTQ09OVElOVUlUWXxFTkRMSVNUfEdBUHxJTkRFUEVOREVOVC1TRUdNRU5UUykvLnNvdXJjZSwgLygjKShbXjpdKik6KC4qKS8uc291cmNlLCAvKCMpKC4qKSg/Oi4qKVxccj9cXG4/Ly5zb3VyY2VdLmpvaW4oJ3wnKSk7XG5jbGFzcyBNM1U4UGFyc2VyIHtcbiAgc3RhdGljIGZpbmRHcm91cChncm91cHMsIG1lZGlhR3JvdXBJZCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBncm91cCA9IGdyb3Vwc1tpXTtcbiAgICAgIGlmIChncm91cC5pZCA9PT0gbWVkaWFHcm91cElkKSB7XG4gICAgICAgIHJldHVybiBncm91cDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc3RhdGljIHJlc29sdmUodXJsLCBiYXNlVXJsKSB7XG4gICAgcmV0dXJuIHVybFRvb2xraXRFeHBvcnRzLmJ1aWxkQWJzb2x1dGVVUkwoYmFzZVVybCwgdXJsLCB7XG4gICAgICBhbHdheXNOb3JtYWxpemU6IHRydWVcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgaXNNZWRpYVBsYXlsaXN0KHN0cikge1xuICAgIHJldHVybiBJU19NRURJQV9QTEFZTElTVC50ZXN0KHN0cik7XG4gIH1cbiAgc3RhdGljIHBhcnNlTWFzdGVyUGxheWxpc3Qoc3RyaW5nLCBiYXNldXJsKSB7XG4gICAgY29uc3QgaGFzVmFyaWFibGVSZWZzID0gaGFzVmFyaWFibGVSZWZlcmVuY2VzKHN0cmluZykgO1xuICAgIGNvbnN0IHBhcnNlZCA9IHtcbiAgICAgIGNvbnRlbnRTdGVlcmluZzogbnVsbCxcbiAgICAgIGxldmVsczogW10sXG4gICAgICBwbGF5bGlzdFBhcnNpbmdFcnJvcjogbnVsbCxcbiAgICAgIHNlc3Npb25EYXRhOiBudWxsLFxuICAgICAgc2Vzc2lvbktleXM6IG51bGwsXG4gICAgICBzdGFydFRpbWVPZmZzZXQ6IG51bGwsXG4gICAgICB2YXJpYWJsZUxpc3Q6IG51bGwsXG4gICAgICBoYXNWYXJpYWJsZVJlZnNcbiAgICB9O1xuICAgIGNvbnN0IGxldmVsc1dpdGhLbm93bkNvZGVjcyA9IFtdO1xuICAgIE1BU1RFUl9QTEFZTElTVF9SRUdFWC5sYXN0SW5kZXggPSAwO1xuICAgIGxldCByZXN1bHQ7XG4gICAgd2hpbGUgKChyZXN1bHQgPSBNQVNURVJfUExBWUxJU1RfUkVHRVguZXhlYyhzdHJpbmcpKSAhPSBudWxsKSB7XG4gICAgICBpZiAocmVzdWx0WzFdKSB7XG4gICAgICAgIHZhciBfbGV2ZWwkdW5rbm93bkNvZGVjcztcbiAgICAgICAgLy8gJyNFWFQtWC1TVFJFQU0tSU5GJyBpcyBmb3VuZCwgcGFyc2UgbGV2ZWwgdGFnICBpbiBncm91cCAxXG4gICAgICAgIGNvbnN0IGF0dHJzID0gbmV3IEF0dHJMaXN0KHJlc3VsdFsxXSk7XG4gICAgICAgIHtcbiAgICAgICAgICBzdWJzdGl0dXRlVmFyaWFibGVzSW5BdHRyaWJ1dGVzKHBhcnNlZCwgYXR0cnMsIFsnQ09ERUNTJywgJ1NVUFBMRU1FTlRBTC1DT0RFQ1MnLCAnQUxMT1dFRC1DUEMnLCAnUEFUSFdBWS1JRCcsICdTVEFCTEUtVkFSSUFOVC1JRCcsICdBVURJTycsICdWSURFTycsICdTVUJUSVRMRVMnLCAnQ0xPU0VELUNBUFRJT05TJywgJ05BTUUnXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gc3Vic3RpdHV0ZVZhcmlhYmxlcyhwYXJzZWQsIHJlc3VsdFsyXSkgO1xuICAgICAgICBjb25zdCBsZXZlbCA9IHtcbiAgICAgICAgICBhdHRycyxcbiAgICAgICAgICBiaXRyYXRlOiBhdHRycy5kZWNpbWFsSW50ZWdlcignQkFORFdJRFRIJykgfHwgYXR0cnMuZGVjaW1hbEludGVnZXIoJ0FWRVJBR0UtQkFORFdJRFRIJyksXG4gICAgICAgICAgbmFtZTogYXR0cnMuTkFNRSxcbiAgICAgICAgICB1cmw6IE0zVThQYXJzZXIucmVzb2x2ZSh1cmksIGJhc2V1cmwpXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc29sdXRpb24gPSBhdHRycy5kZWNpbWFsUmVzb2x1dGlvbignUkVTT0xVVElPTicpO1xuICAgICAgICBpZiAocmVzb2x1dGlvbikge1xuICAgICAgICAgIGxldmVsLndpZHRoID0gcmVzb2x1dGlvbi53aWR0aDtcbiAgICAgICAgICBsZXZlbC5oZWlnaHQgPSByZXNvbHV0aW9uLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBzZXRDb2RlY3MoYXR0cnMuQ09ERUNTLCBsZXZlbCk7XG4gICAgICAgIGlmICghKChfbGV2ZWwkdW5rbm93bkNvZGVjcyA9IGxldmVsLnVua25vd25Db2RlY3MpICE9IG51bGwgJiYgX2xldmVsJHVua25vd25Db2RlY3MubGVuZ3RoKSkge1xuICAgICAgICAgIGxldmVsc1dpdGhLbm93bkNvZGVjcy5wdXNoKGxldmVsKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZWQubGV2ZWxzLnB1c2gobGV2ZWwpO1xuICAgICAgfSBlbHNlIGlmIChyZXN1bHRbM10pIHtcbiAgICAgICAgY29uc3QgdGFnID0gcmVzdWx0WzNdO1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gcmVzdWx0WzRdO1xuICAgICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICAgIGNhc2UgJ1NFU1NJT04tREFUQSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC8vICNFWFQtWC1TRVNTSU9OLURBVEFcbiAgICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbkF0dHJzID0gbmV3IEF0dHJMaXN0KGF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3Vic3RpdHV0ZVZhcmlhYmxlc0luQXR0cmlidXRlcyhwYXJzZWQsIHNlc3Npb25BdHRycywgWydEQVRBLUlEJywgJ0xBTkdVQUdFJywgJ1ZBTFVFJywgJ1VSSSddKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBkYXRhSWQgPSBzZXNzaW9uQXR0cnNbJ0RBVEEtSUQnXTtcbiAgICAgICAgICAgICAgaWYgKGRhdGFJZCkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWQuc2Vzc2lvbkRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHBhcnNlZC5zZXNzaW9uRGF0YSA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJzZWQuc2Vzc2lvbkRhdGFbZGF0YUlkXSA9IHNlc3Npb25BdHRycztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdTRVNTSU9OLUtFWSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC8vICNFWFQtWC1TRVNTSU9OLUtFWVxuICAgICAgICAgICAgICBjb25zdCBzZXNzaW9uS2V5ID0gcGFyc2VLZXkoYXR0cmlidXRlcywgYmFzZXVybCwgcGFyc2VkKTtcbiAgICAgICAgICAgICAgaWYgKHNlc3Npb25LZXkuZW5jcnlwdGVkICYmIHNlc3Npb25LZXkuaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWQuc2Vzc2lvbktleXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHBhcnNlZC5zZXNzaW9uS2V5cyA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJzZWQuc2Vzc2lvbktleXMucHVzaChzZXNzaW9uS2V5KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgW0tleXNdIElnbm9yaW5nIGludmFsaWQgRVhULVgtU0VTU0lPTi1LRVkgdGFnOiBcIiR7YXR0cmlidXRlc31cImApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ0RFRklORSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC8vICNFWFQtWC1ERUZJTkVcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhcmlhYmxlQXR0cmlidXRlcyA9IG5ldyBBdHRyTGlzdChhdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgICAgICBzdWJzdGl0dXRlVmFyaWFibGVzSW5BdHRyaWJ1dGVzKHBhcnNlZCwgdmFyaWFibGVBdHRyaWJ1dGVzLCBbJ05BTUUnLCAnVkFMVUUnLCAnUVVFUllQQVJBTSddKTtcbiAgICAgICAgICAgICAgICBhZGRWYXJpYWJsZURlZmluaXRpb24ocGFyc2VkLCB2YXJpYWJsZUF0dHJpYnV0ZXMsIGJhc2V1cmwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ0NPTlRFTlQtU1RFRVJJTkcnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAvLyAjRVhULVgtQ09OVEVOVC1TVEVFUklOR1xuICAgICAgICAgICAgICBjb25zdCBjb250ZW50U3RlZXJpbmdBdHRyaWJ1dGVzID0gbmV3IEF0dHJMaXN0KGF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3Vic3RpdHV0ZVZhcmlhYmxlc0luQXR0cmlidXRlcyhwYXJzZWQsIGNvbnRlbnRTdGVlcmluZ0F0dHJpYnV0ZXMsIFsnU0VSVkVSLVVSSScsICdQQVRIV0FZLUlEJ10pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHBhcnNlZC5jb250ZW50U3RlZXJpbmcgPSB7XG4gICAgICAgICAgICAgICAgdXJpOiBNM1U4UGFyc2VyLnJlc29sdmUoY29udGVudFN0ZWVyaW5nQXR0cmlidXRlc1snU0VSVkVSLVVSSSddLCBiYXNldXJsKSxcbiAgICAgICAgICAgICAgICBwYXRod2F5SWQ6IGNvbnRlbnRTdGVlcmluZ0F0dHJpYnV0ZXNbJ1BBVEhXQVktSUQnXSB8fCAnLidcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnU1RBUlQnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAvLyAjRVhULVgtU1RBUlRcbiAgICAgICAgICAgICAgcGFyc2VkLnN0YXJ0VGltZU9mZnNldCA9IHBhcnNlU3RhcnRUaW1lT2Zmc2V0KGF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBGaWx0ZXIgb3V0IGxldmVscyB3aXRoIHVua25vd24gY29kZWNzIGlmIGl0IGRvZXMgbm90IHJlbW92ZSBhbGwgbGV2ZWxzXG4gICAgY29uc3Qgc3RyaXBVbmtub3duQ29kZWNMZXZlbHMgPSBsZXZlbHNXaXRoS25vd25Db2RlY3MubGVuZ3RoID4gMCAmJiBsZXZlbHNXaXRoS25vd25Db2RlY3MubGVuZ3RoIDwgcGFyc2VkLmxldmVscy5sZW5ndGg7XG4gICAgcGFyc2VkLmxldmVscyA9IHN0cmlwVW5rbm93bkNvZGVjTGV2ZWxzID8gbGV2ZWxzV2l0aEtub3duQ29kZWNzIDogcGFyc2VkLmxldmVscztcbiAgICBpZiAocGFyc2VkLmxldmVscy5sZW5ndGggPT09IDApIHtcbiAgICAgIHBhcnNlZC5wbGF5bGlzdFBhcnNpbmdFcnJvciA9IG5ldyBFcnJvcignbm8gbGV2ZWxzIGZvdW5kIGluIG1hbmlmZXN0Jyk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cbiAgc3RhdGljIHBhcnNlTWFzdGVyUGxheWxpc3RNZWRpYShzdHJpbmcsIGJhc2V1cmwsIHBhcnNlZCkge1xuICAgIGxldCByZXN1bHQ7XG4gICAgY29uc3QgcmVzdWx0cyA9IHt9O1xuICAgIGNvbnN0IGxldmVscyA9IHBhcnNlZC5sZXZlbHM7XG4gICAgY29uc3QgZ3JvdXBzQnlUeXBlID0ge1xuICAgICAgQVVESU86IGxldmVscy5tYXAobGV2ZWwgPT4gKHtcbiAgICAgICAgaWQ6IGxldmVsLmF0dHJzLkFVRElPLFxuICAgICAgICBhdWRpb0NvZGVjOiBsZXZlbC5hdWRpb0NvZGVjXG4gICAgICB9KSksXG4gICAgICBTVUJUSVRMRVM6IGxldmVscy5tYXAobGV2ZWwgPT4gKHtcbiAgICAgICAgaWQ6IGxldmVsLmF0dHJzLlNVQlRJVExFUyxcbiAgICAgICAgdGV4dENvZGVjOiBsZXZlbC50ZXh0Q29kZWNcbiAgICAgIH0pKSxcbiAgICAgICdDTE9TRUQtQ0FQVElPTlMnOiBbXVxuICAgIH07XG4gICAgbGV0IGlkID0gMDtcbiAgICBNQVNURVJfUExBWUxJU1RfTUVESUFfUkVHRVgubGFzdEluZGV4ID0gMDtcbiAgICB3aGlsZSAoKHJlc3VsdCA9IE1BU1RFUl9QTEFZTElTVF9NRURJQV9SRUdFWC5leGVjKHN0cmluZykpICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBhdHRycyA9IG5ldyBBdHRyTGlzdChyZXN1bHRbMV0pO1xuICAgICAgY29uc3QgdHlwZSA9IGF0dHJzLlRZUEU7XG4gICAgICBpZiAodHlwZSkge1xuICAgICAgICBjb25zdCBncm91cHMgPSBncm91cHNCeVR5cGVbdHlwZV07XG4gICAgICAgIGNvbnN0IG1lZGlhcyA9IHJlc3VsdHNbdHlwZV0gfHwgW107XG4gICAgICAgIHJlc3VsdHNbdHlwZV0gPSBtZWRpYXM7XG4gICAgICAgIHtcbiAgICAgICAgICBzdWJzdGl0dXRlVmFyaWFibGVzSW5BdHRyaWJ1dGVzKHBhcnNlZCwgYXR0cnMsIFsnVVJJJywgJ0dST1VQLUlEJywgJ0xBTkdVQUdFJywgJ0FTU09DLUxBTkdVQUdFJywgJ1NUQUJMRS1SRU5ESVRJT04tSUQnLCAnTkFNRScsICdJTlNUUkVBTS1JRCcsICdDSEFSQUNURVJJU1RJQ1MnLCAnQ0hBTk5FTFMnXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGFuZyA9IGF0dHJzLkxBTkdVQUdFO1xuICAgICAgICBjb25zdCBhc3NvY0xhbmcgPSBhdHRyc1snQVNTT0MtTEFOR1VBR0UnXTtcbiAgICAgICAgY29uc3QgY2hhbm5lbHMgPSBhdHRycy5DSEFOTkVMUztcbiAgICAgICAgY29uc3QgY2hhcmFjdGVyaXN0aWNzID0gYXR0cnMuQ0hBUkFDVEVSSVNUSUNTO1xuICAgICAgICBjb25zdCBpbnN0cmVhbUlkID0gYXR0cnNbJ0lOU1RSRUFNLUlEJ107XG4gICAgICAgIGNvbnN0IG1lZGlhID0ge1xuICAgICAgICAgIGF0dHJzLFxuICAgICAgICAgIGJpdHJhdGU6IDAsXG4gICAgICAgICAgaWQ6IGlkKyssXG4gICAgICAgICAgZ3JvdXBJZDogYXR0cnNbJ0dST1VQLUlEJ10gfHwgJycsXG4gICAgICAgICAgbmFtZTogYXR0cnMuTkFNRSB8fCBsYW5nIHx8ICcnLFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgZGVmYXVsdDogYXR0cnMuYm9vbCgnREVGQVVMVCcpLFxuICAgICAgICAgIGF1dG9zZWxlY3Q6IGF0dHJzLmJvb2woJ0FVVE9TRUxFQ1QnKSxcbiAgICAgICAgICBmb3JjZWQ6IGF0dHJzLmJvb2woJ0ZPUkNFRCcpLFxuICAgICAgICAgIGxhbmcsXG4gICAgICAgICAgdXJsOiBhdHRycy5VUkkgPyBNM1U4UGFyc2VyLnJlc29sdmUoYXR0cnMuVVJJLCBiYXNldXJsKSA6ICcnXG4gICAgICAgIH07XG4gICAgICAgIGlmIChhc3NvY0xhbmcpIHtcbiAgICAgICAgICBtZWRpYS5hc3NvY0xhbmcgPSBhc3NvY0xhbmc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5uZWxzKSB7XG4gICAgICAgICAgbWVkaWEuY2hhbm5lbHMgPSBjaGFubmVscztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhcmFjdGVyaXN0aWNzKSB7XG4gICAgICAgICAgbWVkaWEuY2hhcmFjdGVyaXN0aWNzID0gY2hhcmFjdGVyaXN0aWNzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnN0cmVhbUlkKSB7XG4gICAgICAgICAgbWVkaWEuaW5zdHJlYW1JZCA9IGluc3RyZWFtSWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwcyAhPSBudWxsICYmIGdyb3Vwcy5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgYXVkaW8gb3IgdGV4dCBncm91cHMgc2lnbmFsbGVkIGluIHRoZSBtYW5pZmVzdCwgbGV0J3MgbG9vayBmb3IgYSBtYXRjaGluZyBjb2RlYyBzdHJpbmcgZm9yIHRoaXMgdHJhY2tcbiAgICAgICAgICAvLyBJZiB3ZSBkb24ndCBmaW5kIHRoZSB0cmFjayBzaWduYWxsZWQsIGxldHMgdXNlIHRoZSBmaXJzdCBhdWRpbyBncm91cHMgY29kZWMgd2UgaGF2ZVxuICAgICAgICAgIC8vIEFjdGluZyBhcyBhIGJlc3QgZ3Vlc3NcbiAgICAgICAgICBjb25zdCBncm91cENvZGVjID0gTTNVOFBhcnNlci5maW5kR3JvdXAoZ3JvdXBzLCBtZWRpYS5ncm91cElkKSB8fCBncm91cHNbMF07XG4gICAgICAgICAgYXNzaWduQ29kZWMobWVkaWEsIGdyb3VwQ29kZWMsICdhdWRpb0NvZGVjJyk7XG4gICAgICAgICAgYXNzaWduQ29kZWMobWVkaWEsIGdyb3VwQ29kZWMsICd0ZXh0Q29kZWMnKTtcbiAgICAgICAgfVxuICAgICAgICBtZWRpYXMucHVzaChtZWRpYSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG4gIHN0YXRpYyBwYXJzZUxldmVsUGxheWxpc3Qoc3RyaW5nLCBiYXNldXJsLCBpZCwgdHlwZSwgbGV2ZWxVcmxJZCwgbXVsdGl2YXJpYW50VmFyaWFibGVMaXN0KSB7XG4gICAgY29uc3QgbGV2ZWwgPSBuZXcgTGV2ZWxEZXRhaWxzKGJhc2V1cmwpO1xuICAgIGNvbnN0IGZyYWdtZW50cyA9IGxldmVsLmZyYWdtZW50cztcbiAgICAvLyBUaGUgbW9zdCByZWNlbnQgaW5pdCBzZWdtZW50IHNlZW4gKGFwcGxpZXMgdG8gYWxsIHN1YnNlcXVlbnQgc2VnbWVudHMpXG4gICAgbGV0IGN1cnJlbnRJbml0U2VnbWVudCA9IG51bGw7XG4gICAgbGV0IGN1cnJlbnRTTiA9IDA7XG4gICAgbGV0IGN1cnJlbnRQYXJ0ID0gMDtcbiAgICBsZXQgdG90YWxkdXJhdGlvbiA9IDA7XG4gICAgbGV0IGRpc2NvbnRpbnVpdHlDb3VudGVyID0gMDtcbiAgICBsZXQgcHJldkZyYWcgPSBudWxsO1xuICAgIGxldCBmcmFnID0gbmV3IEZyYWdtZW50KHR5cGUsIGJhc2V1cmwpO1xuICAgIGxldCByZXN1bHQ7XG4gICAgbGV0IGk7XG4gICAgbGV0IGxldmVsa2V5cztcbiAgICBsZXQgZmlyc3RQZHRJbmRleCA9IC0xO1xuICAgIGxldCBjcmVhdGVOZXh0RnJhZyA9IGZhbHNlO1xuICAgIGxldCBuZXh0Qnl0ZVJhbmdlID0gbnVsbDtcbiAgICBMRVZFTF9QTEFZTElTVF9SRUdFWF9GQVNULmxhc3RJbmRleCA9IDA7XG4gICAgbGV2ZWwubTN1OCA9IHN0cmluZztcbiAgICBsZXZlbC5oYXNWYXJpYWJsZVJlZnMgPSBoYXNWYXJpYWJsZVJlZmVyZW5jZXMoc3RyaW5nKSA7XG4gICAgd2hpbGUgKChyZXN1bHQgPSBMRVZFTF9QTEFZTElTVF9SRUdFWF9GQVNULmV4ZWMoc3RyaW5nKSkgIT09IG51bGwpIHtcbiAgICAgIGlmIChjcmVhdGVOZXh0RnJhZykge1xuICAgICAgICBjcmVhdGVOZXh0RnJhZyA9IGZhbHNlO1xuICAgICAgICBmcmFnID0gbmV3IEZyYWdtZW50KHR5cGUsIGJhc2V1cmwpO1xuICAgICAgICAvLyBzZXR1cCB0aGUgbmV4dCBmcmFnbWVudCBmb3IgcGFydCBsb2FkaW5nXG4gICAgICAgIGZyYWcuc3RhcnQgPSB0b3RhbGR1cmF0aW9uO1xuICAgICAgICBmcmFnLnNuID0gY3VycmVudFNOO1xuICAgICAgICBmcmFnLmNjID0gZGlzY29udGludWl0eUNvdW50ZXI7XG4gICAgICAgIGZyYWcubGV2ZWwgPSBpZDtcbiAgICAgICAgaWYgKGN1cnJlbnRJbml0U2VnbWVudCkge1xuICAgICAgICAgIGZyYWcuaW5pdFNlZ21lbnQgPSBjdXJyZW50SW5pdFNlZ21lbnQ7XG4gICAgICAgICAgZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWUgPSBjdXJyZW50SW5pdFNlZ21lbnQucmF3UHJvZ3JhbURhdGVUaW1lO1xuICAgICAgICAgIGN1cnJlbnRJbml0U2VnbWVudC5yYXdQcm9ncmFtRGF0ZVRpbWUgPSBudWxsO1xuICAgICAgICAgIGlmIChuZXh0Qnl0ZVJhbmdlKSB7XG4gICAgICAgICAgICBmcmFnLnNldEJ5dGVSYW5nZShuZXh0Qnl0ZVJhbmdlKTtcbiAgICAgICAgICAgIG5leHRCeXRlUmFuZ2UgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgZHVyYXRpb24gPSByZXN1bHRbMV07XG4gICAgICBpZiAoZHVyYXRpb24pIHtcbiAgICAgICAgLy8gSU5GXG4gICAgICAgIGZyYWcuZHVyYXRpb24gPSBwYXJzZUZsb2F0KGR1cmF0aW9uKTtcbiAgICAgICAgLy8gYXZvaWQgc2xpY2VkIHN0cmluZ3MgICAgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzkzOVxuICAgICAgICBjb25zdCB0aXRsZSA9ICgnICcgKyByZXN1bHRbMl0pLnNsaWNlKDEpO1xuICAgICAgICBmcmFnLnRpdGxlID0gdGl0bGUgfHwgbnVsbDtcbiAgICAgICAgZnJhZy50YWdMaXN0LnB1c2godGl0bGUgPyBbJ0lORicsIGR1cmF0aW9uLCB0aXRsZV0gOiBbJ0lORicsIGR1cmF0aW9uXSk7XG4gICAgICB9IGVsc2UgaWYgKHJlc3VsdFszXSkge1xuICAgICAgICAvLyB1cmxcbiAgICAgICAgaWYgKGlzRmluaXRlTnVtYmVyKGZyYWcuZHVyYXRpb24pKSB7XG4gICAgICAgICAgZnJhZy5zdGFydCA9IHRvdGFsZHVyYXRpb247XG4gICAgICAgICAgaWYgKGxldmVsa2V5cykge1xuICAgICAgICAgICAgc2V0RnJhZ0xldmVsS2V5cyhmcmFnLCBsZXZlbGtleXMsIGxldmVsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnJhZy5zbiA9IGN1cnJlbnRTTjtcbiAgICAgICAgICBmcmFnLmxldmVsID0gaWQ7XG4gICAgICAgICAgZnJhZy5jYyA9IGRpc2NvbnRpbnVpdHlDb3VudGVyO1xuICAgICAgICAgIGZyYWdtZW50cy5wdXNoKGZyYWcpO1xuICAgICAgICAgIC8vIGF2b2lkIHNsaWNlZCBzdHJpbmdzICAgIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2lzc3Vlcy85MzlcbiAgICAgICAgICBjb25zdCB1cmkgPSAoJyAnICsgcmVzdWx0WzNdKS5zbGljZSgxKTtcbiAgICAgICAgICBmcmFnLnJlbHVybCA9IHN1YnN0aXR1dGVWYXJpYWJsZXMobGV2ZWwsIHVyaSkgO1xuICAgICAgICAgIGFzc2lnblByb2dyYW1EYXRlVGltZShmcmFnLCBwcmV2RnJhZyk7XG4gICAgICAgICAgcHJldkZyYWcgPSBmcmFnO1xuICAgICAgICAgIHRvdGFsZHVyYXRpb24gKz0gZnJhZy5kdXJhdGlvbjtcbiAgICAgICAgICBjdXJyZW50U04rKztcbiAgICAgICAgICBjdXJyZW50UGFydCA9IDA7XG4gICAgICAgICAgY3JlYXRlTmV4dEZyYWcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHJlc3VsdFs0XSkge1xuICAgICAgICAvLyBYLUJZVEVSQU5HRVxuICAgICAgICBjb25zdCBkYXRhID0gKCcgJyArIHJlc3VsdFs0XSkuc2xpY2UoMSk7XG4gICAgICAgIGlmIChwcmV2RnJhZykge1xuICAgICAgICAgIGZyYWcuc2V0Qnl0ZVJhbmdlKGRhdGEsIHByZXZGcmFnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmcmFnLnNldEJ5dGVSYW5nZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChyZXN1bHRbNV0pIHtcbiAgICAgICAgLy8gUFJPR1JBTS1EQVRFLVRJTUVcbiAgICAgICAgLy8gYXZvaWQgc2xpY2VkIHN0cmluZ3MgICAgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzkzOVxuICAgICAgICBmcmFnLnJhd1Byb2dyYW1EYXRlVGltZSA9ICgnICcgKyByZXN1bHRbNV0pLnNsaWNlKDEpO1xuICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaChbJ1BST0dSQU0tREFURS1USU1FJywgZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWVdKTtcbiAgICAgICAgaWYgKGZpcnN0UGR0SW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgZmlyc3RQZHRJbmRleCA9IGZyYWdtZW50cy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdFswXS5tYXRjaChMRVZFTF9QTEFZTElTVF9SRUdFWF9TTE9XKTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICBsb2dnZXIud2FybignTm8gbWF0Y2hlcyBvbiBzbG93IHJlZ2V4IG1hdGNoIGZvciBsZXZlbCBwbGF5bGlzdCEnKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHRbaV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhdm9pZCBzbGljZWQgc3RyaW5ncyAgICBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvOTM5XG4gICAgICAgIGNvbnN0IHRhZyA9ICgnICcgKyByZXN1bHRbaV0pLnNsaWNlKDEpO1xuICAgICAgICBjb25zdCB2YWx1ZTEgPSAoJyAnICsgcmVzdWx0W2kgKyAxXSkuc2xpY2UoMSk7XG4gICAgICAgIGNvbnN0IHZhbHVlMiA9IHJlc3VsdFtpICsgMl0gPyAoJyAnICsgcmVzdWx0W2kgKyAyXSkuc2xpY2UoMSkgOiAnJztcbiAgICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgICBjYXNlICdQTEFZTElTVC1UWVBFJzpcbiAgICAgICAgICAgIGxldmVsLnR5cGUgPSB2YWx1ZTEudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ01FRElBLVNFUVVFTkNFJzpcbiAgICAgICAgICAgIGN1cnJlbnRTTiA9IGxldmVsLnN0YXJ0U04gPSBwYXJzZUludCh2YWx1ZTEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnU0tJUCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IHNraXBBdHRycyA9IG5ldyBBdHRyTGlzdCh2YWx1ZTEpO1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3Vic3RpdHV0ZVZhcmlhYmxlc0luQXR0cmlidXRlcyhsZXZlbCwgc2tpcEF0dHJzLCBbJ1JFQ0VOVExZLVJFTU9WRUQtREFURVJBTkdFUyddKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBza2lwcGVkU2VnbWVudHMgPSBza2lwQXR0cnMuZGVjaW1hbEludGVnZXIoJ1NLSVBQRUQtU0VHTUVOVFMnKTtcbiAgICAgICAgICAgICAgaWYgKGlzRmluaXRlTnVtYmVyKHNraXBwZWRTZWdtZW50cykpIHtcbiAgICAgICAgICAgICAgICBsZXZlbC5za2lwcGVkU2VnbWVudHMgPSBza2lwcGVkU2VnbWVudHM7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyB3aWxsIHJlc3VsdCBpbiBmcmFnbWVudHNbXSBjb250YWluaW5nIHVuZGVmaW5lZCB2YWx1ZXMsIHdoaWNoIHdlIHdpbGwgZmlsbCBpbiB3aXRoIGBtZXJnZURldGFpbHNgXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgX2kgPSBza2lwcGVkU2VnbWVudHM7IF9pLS07KSB7XG4gICAgICAgICAgICAgICAgICBmcmFnbWVudHMudW5zaGlmdChudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudFNOICs9IHNraXBwZWRTZWdtZW50cztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCByZWNlbnRseVJlbW92ZWREYXRlcmFuZ2VzID0gc2tpcEF0dHJzLmVudW1lcmF0ZWRTdHJpbmcoJ1JFQ0VOVExZLVJFTU9WRUQtREFURVJBTkdFUycpO1xuICAgICAgICAgICAgICBpZiAocmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcykge1xuICAgICAgICAgICAgICAgIGxldmVsLnJlY2VudGx5UmVtb3ZlZERhdGVyYW5nZXMgPSByZWNlbnRseVJlbW92ZWREYXRlcmFuZ2VzLnNwbGl0KCdcXHQnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdUQVJHRVREVVJBVElPTic6XG4gICAgICAgICAgICBsZXZlbC50YXJnZXRkdXJhdGlvbiA9IE1hdGgubWF4KHBhcnNlSW50KHZhbHVlMSksIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnVkVSU0lPTic6XG4gICAgICAgICAgICBsZXZlbC52ZXJzaW9uID0gcGFyc2VJbnQodmFsdWUxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0lOREVQRU5ERU5ULVNFR01FTlRTJzpcbiAgICAgICAgICBjYXNlICdFWFRNM1UnOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnRU5ETElTVCc6XG4gICAgICAgICAgICBsZXZlbC5saXZlID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICAgIGlmICh2YWx1ZTEgfHwgdmFsdWUyKSB7XG4gICAgICAgICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKHZhbHVlMiA/IFt2YWx1ZTEsIHZhbHVlMl0gOiBbdmFsdWUxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdESVNDT05USU5VSVRZJzpcbiAgICAgICAgICAgIGRpc2NvbnRpbnVpdHlDb3VudGVyKys7XG4gICAgICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaChbJ0RJUyddKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0dBUCc6XG4gICAgICAgICAgICBmcmFnLmdhcCA9IHRydWU7XG4gICAgICAgICAgICBmcmFnLnRhZ0xpc3QucHVzaChbdGFnXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdCSVRSQVRFJzpcbiAgICAgICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKFt0YWcsIHZhbHVlMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnREFURVJBTkdFJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgZGF0ZVJhbmdlQXR0ciA9IG5ldyBBdHRyTGlzdCh2YWx1ZTEpO1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3Vic3RpdHV0ZVZhcmlhYmxlc0luQXR0cmlidXRlcyhsZXZlbCwgZGF0ZVJhbmdlQXR0ciwgWydJRCcsICdDTEFTUycsICdTVEFSVC1EQVRFJywgJ0VORC1EQVRFJywgJ1NDVEUzNS1DTUQnLCAnU0NURTM1LU9VVCcsICdTQ1RFMzUtSU4nXSk7XG4gICAgICAgICAgICAgICAgc3Vic3RpdHV0ZVZhcmlhYmxlc0luQXR0cmlidXRlcyhsZXZlbCwgZGF0ZVJhbmdlQXR0ciwgZGF0ZVJhbmdlQXR0ci5jbGllbnRBdHRycyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgZGF0ZVJhbmdlID0gbmV3IERhdGVSYW5nZShkYXRlUmFuZ2VBdHRyLCBsZXZlbC5kYXRlUmFuZ2VzW2RhdGVSYW5nZUF0dHIuSURdKTtcbiAgICAgICAgICAgICAgaWYgKGRhdGVSYW5nZS5pc1ZhbGlkIHx8IGxldmVsLnNraXBwZWRTZWdtZW50cykge1xuICAgICAgICAgICAgICAgIGxldmVsLmRhdGVSYW5nZXNbZGF0ZVJhbmdlLmlkXSA9IGRhdGVSYW5nZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgSWdub3JpbmcgaW52YWxpZCBEQVRFUkFOR0UgdGFnOiBcIiR7dmFsdWUxfVwiYCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gQWRkIHRvIGZyYWdtZW50IHRhZyBsaXN0IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSAoPCB2MS4yLjApXG4gICAgICAgICAgICAgIGZyYWcudGFnTGlzdC5wdXNoKFsnRVhULVgtREFURVJBTkdFJywgdmFsdWUxXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ0RFRklORSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YXJpYWJsZUF0dHJpYnV0ZXMgPSBuZXcgQXR0ckxpc3QodmFsdWUxKTtcbiAgICAgICAgICAgICAgICBzdWJzdGl0dXRlVmFyaWFibGVzSW5BdHRyaWJ1dGVzKGxldmVsLCB2YXJpYWJsZUF0dHJpYnV0ZXMsIFsnTkFNRScsICdWQUxVRScsICdJTVBPUlQnLCAnUVVFUllQQVJBTSddKTtcbiAgICAgICAgICAgICAgICBpZiAoJ0lNUE9SVCcgaW4gdmFyaWFibGVBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICBpbXBvcnRWYXJpYWJsZURlZmluaXRpb24obGV2ZWwsIHZhcmlhYmxlQXR0cmlidXRlcywgbXVsdGl2YXJpYW50VmFyaWFibGVMaXN0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgYWRkVmFyaWFibGVEZWZpbml0aW9uKGxldmVsLCB2YXJpYWJsZUF0dHJpYnV0ZXMsIGJhc2V1cmwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdESVNDT05USU5VSVRZLVNFUVVFTkNFJzpcbiAgICAgICAgICAgIGRpc2NvbnRpbnVpdHlDb3VudGVyID0gcGFyc2VJbnQodmFsdWUxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0tFWSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IGxldmVsS2V5ID0gcGFyc2VLZXkodmFsdWUxLCBiYXNldXJsLCBsZXZlbCk7XG4gICAgICAgICAgICAgIGlmIChsZXZlbEtleS5pc1N1cHBvcnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxldmVsS2V5Lm1ldGhvZCA9PT0gJ05PTkUnKSB7XG4gICAgICAgICAgICAgICAgICBsZXZlbGtleXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFsZXZlbGtleXMpIHtcbiAgICAgICAgICAgICAgICAgIGxldmVsa2V5cyA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGV2ZWxrZXlzW2xldmVsS2V5LmtleUZvcm1hdF0pIHtcbiAgICAgICAgICAgICAgICAgIGxldmVsa2V5cyA9IF9leHRlbmRzKHt9LCBsZXZlbGtleXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXZlbGtleXNbbGV2ZWxLZXkua2V5Rm9ybWF0XSA9IGxldmVsS2V5O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKGBbS2V5c10gSWdub3JpbmcgaW52YWxpZCBFWFQtWC1LRVkgdGFnOiBcIiR7dmFsdWUxfVwiYCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnU1RBUlQnOlxuICAgICAgICAgICAgbGV2ZWwuc3RhcnRUaW1lT2Zmc2V0ID0gcGFyc2VTdGFydFRpbWVPZmZzZXQodmFsdWUxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ01BUCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IG1hcEF0dHJzID0gbmV3IEF0dHJMaXN0KHZhbHVlMSk7XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdWJzdGl0dXRlVmFyaWFibGVzSW5BdHRyaWJ1dGVzKGxldmVsLCBtYXBBdHRycywgWydCWVRFUkFOR0UnLCAnVVJJJ10pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChmcmFnLmR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gSW5pdGlhbCBzZWdtZW50IHRhZyBpcyBhZnRlciBzZWdtZW50IGR1cmF0aW9uIHRhZy5cbiAgICAgICAgICAgICAgICAvLyAgICNFWFRJTkY6IDYuMFxuICAgICAgICAgICAgICAgIC8vICAgI0VYVC1YLU1BUDpVUkk9XCJpbml0Lm1wNFxuICAgICAgICAgICAgICAgIGNvbnN0IGluaXQgPSBuZXcgRnJhZ21lbnQodHlwZSwgYmFzZXVybCk7XG4gICAgICAgICAgICAgICAgc2V0SW5pdFNlZ21lbnQoaW5pdCwgbWFwQXR0cnMsIGlkLCBsZXZlbGtleXMpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRJbml0U2VnbWVudCA9IGluaXQ7XG4gICAgICAgICAgICAgICAgZnJhZy5pbml0U2VnbWVudCA9IGN1cnJlbnRJbml0U2VnbWVudDtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEluaXRTZWdtZW50LnJhd1Byb2dyYW1EYXRlVGltZSAmJiAhZnJhZy5yYXdQcm9ncmFtRGF0ZVRpbWUpIHtcbiAgICAgICAgICAgICAgICAgIGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lID0gY3VycmVudEluaXRTZWdtZW50LnJhd1Byb2dyYW1EYXRlVGltZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSW5pdGlhbCBzZWdtZW50IHRhZyBpcyBiZWZvcmUgc2VnbWVudCBkdXJhdGlvbiB0YWdcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgY2FzZSB3aGVyZSBFWFQtWC1NQVAgaXMgZGVjbGFyZWQgYWZ0ZXIgRVhULVgtQllURVJBTkdFXG4gICAgICAgICAgICAgICAgY29uc3QgZW5kID0gZnJhZy5ieXRlUmFuZ2VFbmRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgaWYgKGVuZCkge1xuICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBmcmFnLmJ5dGVSYW5nZVN0YXJ0T2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgbmV4dEJ5dGVSYW5nZSA9IGAke2VuZCAtIHN0YXJ0fUAke3N0YXJ0fWA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG5leHRCeXRlUmFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXRJbml0U2VnbWVudChmcmFnLCBtYXBBdHRycywgaWQsIGxldmVsa2V5cyk7XG4gICAgICAgICAgICAgICAgY3VycmVudEluaXRTZWdtZW50ID0gZnJhZztcbiAgICAgICAgICAgICAgICBjcmVhdGVOZXh0RnJhZyA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnU0VSVkVSLUNPTlRST0wnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCBzZXJ2ZXJDb250cm9sQXR0cnMgPSBuZXcgQXR0ckxpc3QodmFsdWUxKTtcbiAgICAgICAgICAgICAgbGV2ZWwuY2FuQmxvY2tSZWxvYWQgPSBzZXJ2ZXJDb250cm9sQXR0cnMuYm9vbCgnQ0FOLUJMT0NLLVJFTE9BRCcpO1xuICAgICAgICAgICAgICBsZXZlbC5jYW5Ta2lwVW50aWwgPSBzZXJ2ZXJDb250cm9sQXR0cnMub3B0aW9uYWxGbG9hdCgnQ0FOLVNLSVAtVU5USUwnLCAwKTtcbiAgICAgICAgICAgICAgbGV2ZWwuY2FuU2tpcERhdGVSYW5nZXMgPSBsZXZlbC5jYW5Ta2lwVW50aWwgPiAwICYmIHNlcnZlckNvbnRyb2xBdHRycy5ib29sKCdDQU4tU0tJUC1EQVRFUkFOR0VTJyk7XG4gICAgICAgICAgICAgIGxldmVsLnBhcnRIb2xkQmFjayA9IHNlcnZlckNvbnRyb2xBdHRycy5vcHRpb25hbEZsb2F0KCdQQVJULUhPTEQtQkFDSycsIDApO1xuICAgICAgICAgICAgICBsZXZlbC5ob2xkQmFjayA9IHNlcnZlckNvbnRyb2xBdHRycy5vcHRpb25hbEZsb2F0KCdIT0xELUJBQ0snLCAwKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnUEFSVC1JTkYnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCBwYXJ0SW5mQXR0cnMgPSBuZXcgQXR0ckxpc3QodmFsdWUxKTtcbiAgICAgICAgICAgICAgbGV2ZWwucGFydFRhcmdldCA9IHBhcnRJbmZBdHRycy5kZWNpbWFsRmxvYXRpbmdQb2ludCgnUEFSVC1UQVJHRVQnKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnUEFSVCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGxldCBwYXJ0TGlzdCA9IGxldmVsLnBhcnRMaXN0O1xuICAgICAgICAgICAgICBpZiAoIXBhcnRMaXN0KSB7XG4gICAgICAgICAgICAgICAgcGFydExpc3QgPSBsZXZlbC5wYXJ0TGlzdCA9IFtdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzRnJhZ21lbnRQYXJ0ID0gY3VycmVudFBhcnQgPiAwID8gcGFydExpc3RbcGFydExpc3QubGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gY3VycmVudFBhcnQrKztcbiAgICAgICAgICAgICAgY29uc3QgcGFydEF0dHJzID0gbmV3IEF0dHJMaXN0KHZhbHVlMSk7XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdWJzdGl0dXRlVmFyaWFibGVzSW5BdHRyaWJ1dGVzKGxldmVsLCBwYXJ0QXR0cnMsIFsnQllURVJBTkdFJywgJ1VSSSddKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBwYXJ0ID0gbmV3IFBhcnQocGFydEF0dHJzLCBmcmFnLCBiYXNldXJsLCBpbmRleCwgcHJldmlvdXNGcmFnbWVudFBhcnQpO1xuICAgICAgICAgICAgICBwYXJ0TGlzdC5wdXNoKHBhcnQpO1xuICAgICAgICAgICAgICBmcmFnLmR1cmF0aW9uICs9IHBhcnQuZHVyYXRpb247XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ1BSRUxPQUQtSElOVCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IHByZWxvYWRIaW50QXR0cnMgPSBuZXcgQXR0ckxpc3QodmFsdWUxKTtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN1YnN0aXR1dGVWYXJpYWJsZXNJbkF0dHJpYnV0ZXMobGV2ZWwsIHByZWxvYWRIaW50QXR0cnMsIFsnVVJJJ10pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldmVsLnByZWxvYWRIaW50ID0gcHJlbG9hZEhpbnRBdHRycztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnUkVORElUSU9OLVJFUE9SVCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlbmRpdGlvblJlcG9ydEF0dHJzID0gbmV3IEF0dHJMaXN0KHZhbHVlMSk7XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdWJzdGl0dXRlVmFyaWFibGVzSW5BdHRyaWJ1dGVzKGxldmVsLCByZW5kaXRpb25SZXBvcnRBdHRycywgWydVUkknXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGV2ZWwucmVuZGl0aW9uUmVwb3J0cyA9IGxldmVsLnJlbmRpdGlvblJlcG9ydHMgfHwgW107XG4gICAgICAgICAgICAgIGxldmVsLnJlbmRpdGlvblJlcG9ydHMucHVzaChyZW5kaXRpb25SZXBvcnRBdHRycyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBsb2dnZXIud2FybihgbGluZSBwYXJzZWQgYnV0IG5vdCBoYW5kbGVkOiAke3Jlc3VsdH1gKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcmV2RnJhZyAmJiAhcHJldkZyYWcucmVsdXJsKSB7XG4gICAgICBmcmFnbWVudHMucG9wKCk7XG4gICAgICB0b3RhbGR1cmF0aW9uIC09IHByZXZGcmFnLmR1cmF0aW9uO1xuICAgICAgaWYgKGxldmVsLnBhcnRMaXN0KSB7XG4gICAgICAgIGxldmVsLmZyYWdtZW50SGludCA9IHByZXZGcmFnO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobGV2ZWwucGFydExpc3QpIHtcbiAgICAgIGFzc2lnblByb2dyYW1EYXRlVGltZShmcmFnLCBwcmV2RnJhZyk7XG4gICAgICBmcmFnLmNjID0gZGlzY29udGludWl0eUNvdW50ZXI7XG4gICAgICBsZXZlbC5mcmFnbWVudEhpbnQgPSBmcmFnO1xuICAgICAgaWYgKGxldmVsa2V5cykge1xuICAgICAgICBzZXRGcmFnTGV2ZWxLZXlzKGZyYWcsIGxldmVsa2V5cywgbGV2ZWwpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmcmFnbWVudExlbmd0aCA9IGZyYWdtZW50cy5sZW5ndGg7XG4gICAgY29uc3QgZmlyc3RGcmFnbWVudCA9IGZyYWdtZW50c1swXTtcbiAgICBjb25zdCBsYXN0RnJhZ21lbnQgPSBmcmFnbWVudHNbZnJhZ21lbnRMZW5ndGggLSAxXTtcbiAgICB0b3RhbGR1cmF0aW9uICs9IGxldmVsLnNraXBwZWRTZWdtZW50cyAqIGxldmVsLnRhcmdldGR1cmF0aW9uO1xuICAgIGlmICh0b3RhbGR1cmF0aW9uID4gMCAmJiBmcmFnbWVudExlbmd0aCAmJiBsYXN0RnJhZ21lbnQpIHtcbiAgICAgIGxldmVsLmF2ZXJhZ2V0YXJnZXRkdXJhdGlvbiA9IHRvdGFsZHVyYXRpb24gLyBmcmFnbWVudExlbmd0aDtcbiAgICAgIGNvbnN0IGxhc3RTbiA9IGxhc3RGcmFnbWVudC5zbjtcbiAgICAgIGxldmVsLmVuZFNOID0gbGFzdFNuICE9PSAnaW5pdFNlZ21lbnQnID8gbGFzdFNuIDogMDtcbiAgICAgIGlmICghbGV2ZWwubGl2ZSkge1xuICAgICAgICBsYXN0RnJhZ21lbnQuZW5kTGlzdCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoZmlyc3RGcmFnbWVudCkge1xuICAgICAgICBsZXZlbC5zdGFydENDID0gZmlyc3RGcmFnbWVudC5jYztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV2ZWwuZW5kU04gPSAwO1xuICAgICAgbGV2ZWwuc3RhcnRDQyA9IDA7XG4gICAgfVxuICAgIGlmIChsZXZlbC5mcmFnbWVudEhpbnQpIHtcbiAgICAgIHRvdGFsZHVyYXRpb24gKz0gbGV2ZWwuZnJhZ21lbnRIaW50LmR1cmF0aW9uO1xuICAgIH1cbiAgICBsZXZlbC50b3RhbGR1cmF0aW9uID0gdG90YWxkdXJhdGlvbjtcbiAgICBsZXZlbC5lbmRDQyA9IGRpc2NvbnRpbnVpdHlDb3VudGVyO1xuXG4gICAgLyoqXG4gICAgICogQmFja2ZpbGwgYW55IG1pc3NpbmcgUERUIHZhbHVlc1xuICAgICAqIFwiSWYgdGhlIGZpcnN0IEVYVC1YLVBST0dSQU0tREFURS1USU1FIHRhZyBpbiBhIFBsYXlsaXN0IGFwcGVhcnMgYWZ0ZXJcbiAgICAgKiBvbmUgb3IgbW9yZSBNZWRpYSBTZWdtZW50IFVSSXMsIHRoZSBjbGllbnQgU0hPVUxEIGV4dHJhcG9sYXRlXG4gICAgICogYmFja3dhcmQgZnJvbSB0aGF0IHRhZyAodXNpbmcgRVhUSU5GIGR1cmF0aW9ucyBhbmQvb3IgbWVkaWFcbiAgICAgKiB0aW1lc3RhbXBzKSB0byBhc3NvY2lhdGUgZGF0ZXMgd2l0aCB0aG9zZSBzZWdtZW50cy5cIlxuICAgICAqIFdlIGhhdmUgYWxyZWFkeSBleHRyYXBvbGF0ZWQgZm9yd2FyZCwgYnV0IGFsbCBmcmFnbWVudHMgdXAgdG8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIFBEVCBkbyBub3QgaGF2ZSB0aGVpciBQRFRzXG4gICAgICogY29tcHV0ZWQuXG4gICAgICovXG4gICAgaWYgKGZpcnN0UGR0SW5kZXggPiAwKSB7XG4gICAgICBiYWNrZmlsbFByb2dyYW1EYXRlVGltZXMoZnJhZ21lbnRzLCBmaXJzdFBkdEluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIGxldmVsO1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZUtleShrZXlUYWdBdHRyaWJ1dGVzLCBiYXNldXJsLCBwYXJzZWQpIHtcbiAgdmFyIF9rZXlBdHRycyRNRVRIT0QsIF9rZXlBdHRycyRLRVlGT1JNQVQ7XG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM4MjE2I3NlY3Rpb24tNC4zLjIuNFxuICBjb25zdCBrZXlBdHRycyA9IG5ldyBBdHRyTGlzdChrZXlUYWdBdHRyaWJ1dGVzKTtcbiAge1xuICAgIHN1YnN0aXR1dGVWYXJpYWJsZXNJbkF0dHJpYnV0ZXMocGFyc2VkLCBrZXlBdHRycywgWydLRVlGT1JNQVQnLCAnS0VZRk9STUFUVkVSU0lPTlMnLCAnVVJJJywgJ0lWJywgJ1VSSSddKTtcbiAgfVxuICBjb25zdCBkZWNyeXB0bWV0aG9kID0gKF9rZXlBdHRycyRNRVRIT0QgPSBrZXlBdHRycy5NRVRIT0QpICE9IG51bGwgPyBfa2V5QXR0cnMkTUVUSE9EIDogJyc7XG4gIGNvbnN0IGRlY3J5cHR1cmkgPSBrZXlBdHRycy5VUkk7XG4gIGNvbnN0IGRlY3J5cHRpdiA9IGtleUF0dHJzLmhleGFkZWNpbWFsSW50ZWdlcignSVYnKTtcbiAgY29uc3QgZGVjcnlwdGtleWZvcm1hdHZlcnNpb25zID0ga2V5QXR0cnMuS0VZRk9STUFUVkVSU0lPTlM7XG4gIC8vIEZyb20gUkZDOiBUaGlzIGF0dHJpYnV0ZSBpcyBPUFRJT05BTDsgaXRzIGFic2VuY2UgaW5kaWNhdGVzIGFuIGltcGxpY2l0IHZhbHVlIG9mIFwiaWRlbnRpdHlcIi5cbiAgY29uc3QgZGVjcnlwdGtleWZvcm1hdCA9IChfa2V5QXR0cnMkS0VZRk9STUFUID0ga2V5QXR0cnMuS0VZRk9STUFUKSAhPSBudWxsID8gX2tleUF0dHJzJEtFWUZPUk1BVCA6ICdpZGVudGl0eSc7XG4gIGlmIChkZWNyeXB0dXJpICYmIGtleUF0dHJzLklWICYmICFkZWNyeXB0aXYpIHtcbiAgICBsb2dnZXIuZXJyb3IoYEludmFsaWQgSVY6ICR7a2V5QXR0cnMuSVZ9YCk7XG4gIH1cbiAgLy8gSWYgZGVjcnlwdHVyaSBpcyBhIFVSSSB3aXRoIGEgc2NoZW1lLCB0aGVuIGJhc2V1cmwgd2lsbCBiZSBpZ25vcmVkXG4gIC8vIE5vIHVyaSBpcyBhbGxvd2VkIHdoZW4gTUVUSE9EIGlzIE5PTkVcbiAgY29uc3QgcmVzb2x2ZWRVcmkgPSBkZWNyeXB0dXJpID8gTTNVOFBhcnNlci5yZXNvbHZlKGRlY3J5cHR1cmksIGJhc2V1cmwpIDogJyc7XG4gIGNvbnN0IGtleUZvcm1hdFZlcnNpb25zID0gKGRlY3J5cHRrZXlmb3JtYXR2ZXJzaW9ucyA/IGRlY3J5cHRrZXlmb3JtYXR2ZXJzaW9ucyA6ICcxJykuc3BsaXQoJy8nKS5tYXAoTnVtYmVyKS5maWx0ZXIoTnVtYmVyLmlzRmluaXRlKTtcbiAgcmV0dXJuIG5ldyBMZXZlbEtleShkZWNyeXB0bWV0aG9kLCByZXNvbHZlZFVyaSwgZGVjcnlwdGtleWZvcm1hdCwga2V5Rm9ybWF0VmVyc2lvbnMsIGRlY3J5cHRpdik7XG59XG5mdW5jdGlvbiBwYXJzZVN0YXJ0VGltZU9mZnNldChzdGFydEF0dHJpYnV0ZXMpIHtcbiAgY29uc3Qgc3RhcnRBdHRycyA9IG5ldyBBdHRyTGlzdChzdGFydEF0dHJpYnV0ZXMpO1xuICBjb25zdCBzdGFydFRpbWVPZmZzZXQgPSBzdGFydEF0dHJzLmRlY2ltYWxGbG9hdGluZ1BvaW50KCdUSU1FLU9GRlNFVCcpO1xuICBpZiAoaXNGaW5pdGVOdW1iZXIoc3RhcnRUaW1lT2Zmc2V0KSkge1xuICAgIHJldHVybiBzdGFydFRpbWVPZmZzZXQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBzZXRDb2RlY3MoY29kZWNzQXR0cmlidXRlVmFsdWUsIGxldmVsKSB7XG4gIGxldCBjb2RlY3MgPSAoY29kZWNzQXR0cmlidXRlVmFsdWUgfHwgJycpLnNwbGl0KC9bICxdKy8pLmZpbHRlcihjID0+IGMpO1xuICBbJ3ZpZGVvJywgJ2F1ZGlvJywgJ3RleHQnXS5mb3JFYWNoKHR5cGUgPT4ge1xuICAgIGNvbnN0IGZpbHRlcmVkID0gY29kZWNzLmZpbHRlcihjb2RlYyA9PiBpc0NvZGVjVHlwZShjb2RlYywgdHlwZSkpO1xuICAgIGlmIChmaWx0ZXJlZC5sZW5ndGgpIHtcbiAgICAgIC8vIENvbW1hIHNlcGFyYXRlZCBsaXN0IG9mIGFsbCBjb2RlY3MgZm9yIHR5cGVcbiAgICAgIGxldmVsW2Ake3R5cGV9Q29kZWNgXSA9IGZpbHRlcmVkLmpvaW4oJywnKTtcbiAgICAgIC8vIFJlbW92ZSBrbm93biBjb2RlY3Mgc28gdGhhdCBvbmx5IHVua25vd25Db2RlY3MgYXJlIGxlZnQgYWZ0ZXIgaXRlcmF0aW5nIHRocm91Z2ggZWFjaCB0eXBlXG4gICAgICBjb2RlY3MgPSBjb2RlY3MuZmlsdGVyKGNvZGVjID0+IGZpbHRlcmVkLmluZGV4T2YoY29kZWMpID09PSAtMSk7XG4gICAgfVxuICB9KTtcbiAgbGV2ZWwudW5rbm93bkNvZGVjcyA9IGNvZGVjcztcbn1cbmZ1bmN0aW9uIGFzc2lnbkNvZGVjKG1lZGlhLCBncm91cEl0ZW0sIGNvZGVjUHJvcGVydHkpIHtcbiAgY29uc3QgY29kZWNWYWx1ZSA9IGdyb3VwSXRlbVtjb2RlY1Byb3BlcnR5XTtcbiAgaWYgKGNvZGVjVmFsdWUpIHtcbiAgICBtZWRpYVtjb2RlY1Byb3BlcnR5XSA9IGNvZGVjVmFsdWU7XG4gIH1cbn1cbmZ1bmN0aW9uIGJhY2tmaWxsUHJvZ3JhbURhdGVUaW1lcyhmcmFnbWVudHMsIGZpcnN0UGR0SW5kZXgpIHtcbiAgbGV0IGZyYWdQcmV2ID0gZnJhZ21lbnRzW2ZpcnN0UGR0SW5kZXhdO1xuICBmb3IgKGxldCBpID0gZmlyc3RQZHRJbmRleDsgaS0tOykge1xuICAgIGNvbnN0IGZyYWcgPSBmcmFnbWVudHNbaV07XG4gICAgLy8gRXhpdCBvbiBkZWx0YS1wbGF5bGlzdCBza2lwcGVkIHNlZ21lbnRzXG4gICAgaWYgKCFmcmFnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZyYWcucHJvZ3JhbURhdGVUaW1lID0gZnJhZ1ByZXYucHJvZ3JhbURhdGVUaW1lIC0gZnJhZy5kdXJhdGlvbiAqIDEwMDA7XG4gICAgZnJhZ1ByZXYgPSBmcmFnO1xuICB9XG59XG5mdW5jdGlvbiBhc3NpZ25Qcm9ncmFtRGF0ZVRpbWUoZnJhZywgcHJldkZyYWcpIHtcbiAgaWYgKGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgZnJhZy5wcm9ncmFtRGF0ZVRpbWUgPSBEYXRlLnBhcnNlKGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lKTtcbiAgfSBlbHNlIGlmIChwcmV2RnJhZyAhPSBudWxsICYmIHByZXZGcmFnLnByb2dyYW1EYXRlVGltZSkge1xuICAgIGZyYWcucHJvZ3JhbURhdGVUaW1lID0gcHJldkZyYWcuZW5kUHJvZ3JhbURhdGVUaW1lO1xuICB9XG4gIGlmICghaXNGaW5pdGVOdW1iZXIoZnJhZy5wcm9ncmFtRGF0ZVRpbWUpKSB7XG4gICAgZnJhZy5wcm9ncmFtRGF0ZVRpbWUgPSBudWxsO1xuICAgIGZyYWcucmF3UHJvZ3JhbURhdGVUaW1lID0gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gc2V0SW5pdFNlZ21lbnQoZnJhZywgbWFwQXR0cnMsIGlkLCBsZXZlbGtleXMpIHtcbiAgZnJhZy5yZWx1cmwgPSBtYXBBdHRycy5VUkk7XG4gIGlmIChtYXBBdHRycy5CWVRFUkFOR0UpIHtcbiAgICBmcmFnLnNldEJ5dGVSYW5nZShtYXBBdHRycy5CWVRFUkFOR0UpO1xuICB9XG4gIGZyYWcubGV2ZWwgPSBpZDtcbiAgZnJhZy5zbiA9ICdpbml0U2VnbWVudCc7XG4gIGlmIChsZXZlbGtleXMpIHtcbiAgICBmcmFnLmxldmVsa2V5cyA9IGxldmVsa2V5cztcbiAgfVxuICBmcmFnLmluaXRTZWdtZW50ID0gbnVsbDtcbn1cbmZ1bmN0aW9uIHNldEZyYWdMZXZlbEtleXMoZnJhZywgbGV2ZWxrZXlzLCBsZXZlbCkge1xuICBmcmFnLmxldmVsa2V5cyA9IGxldmVsa2V5cztcbiAgY29uc3Qge1xuICAgIGVuY3J5cHRlZEZyYWdtZW50c1xuICB9ID0gbGV2ZWw7XG4gIGlmICgoIWVuY3J5cHRlZEZyYWdtZW50cy5sZW5ndGggfHwgZW5jcnlwdGVkRnJhZ21lbnRzW2VuY3J5cHRlZEZyYWdtZW50cy5sZW5ndGggLSAxXS5sZXZlbGtleXMgIT09IGxldmVsa2V5cykgJiYgT2JqZWN0LmtleXMobGV2ZWxrZXlzKS5zb21lKGZvcm1hdCA9PiBsZXZlbGtleXNbZm9ybWF0XS5pc0NvbW1vbkVuY3J5cHRpb24pKSB7XG4gICAgZW5jcnlwdGVkRnJhZ21lbnRzLnB1c2goZnJhZyk7XG4gIH1cbn1cblxudmFyIFBsYXlsaXN0Q29udGV4dFR5cGUgPSB7XG4gIE1BTklGRVNUOiBcIm1hbmlmZXN0XCIsXG4gIExFVkVMOiBcImxldmVsXCIsXG4gIEFVRElPX1RSQUNLOiBcImF1ZGlvVHJhY2tcIixcbiAgU1VCVElUTEVfVFJBQ0s6IFwic3VidGl0bGVUcmFja1wiXG59O1xudmFyIFBsYXlsaXN0TGV2ZWxUeXBlID0ge1xuICBNQUlOOiBcIm1haW5cIixcbiAgQVVESU86IFwiYXVkaW9cIixcbiAgU1VCVElUTEU6IFwic3VidGl0bGVcIlxufTtcblxuZnVuY3Rpb24gbWFwQ29udGV4dFRvTGV2ZWxUeXBlKGNvbnRleHQpIHtcbiAgY29uc3Qge1xuICAgIHR5cGVcbiAgfSA9IGNvbnRleHQ7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUGxheWxpc3RDb250ZXh0VHlwZS5BVURJT19UUkFDSzpcbiAgICAgIHJldHVybiBQbGF5bGlzdExldmVsVHlwZS5BVURJTztcbiAgICBjYXNlIFBsYXlsaXN0Q29udGV4dFR5cGUuU1VCVElUTEVfVFJBQ0s6XG4gICAgICByZXR1cm4gUGxheWxpc3RMZXZlbFR5cGUuU1VCVElUTEU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBQbGF5bGlzdExldmVsVHlwZS5NQUlOO1xuICB9XG59XG5mdW5jdGlvbiBnZXRSZXNwb25zZVVybChyZXNwb25zZSwgY29udGV4dCkge1xuICBsZXQgdXJsID0gcmVzcG9uc2UudXJsO1xuICAvLyByZXNwb25zZVVSTCBub3Qgc3VwcG9ydGVkIG9uIHNvbWUgYnJvd3NlcnMgKGl0IGlzIHVzZWQgdG8gZGV0ZWN0IFVSTCByZWRpcmVjdGlvbilcbiAgLy8gZGF0YS11cmkgbW9kZSBhbHNvIG5vdCBzdXBwb3J0ZWQgKGJ1dCBubyBuZWVkIHRvIGRldGVjdCByZWRpcmVjdGlvbilcbiAgaWYgKHVybCA9PT0gdW5kZWZpbmVkIHx8IHVybC5pbmRleE9mKCdkYXRhOicpID09PSAwKSB7XG4gICAgLy8gZmFsbGJhY2sgdG8gaW5pdGlhbCBVUkxcbiAgICB1cmwgPSBjb250ZXh0LnVybDtcbiAgfVxuICByZXR1cm4gdXJsO1xufVxuY2xhc3MgUGxheWxpc3RMb2FkZXIge1xuICBjb25zdHJ1Y3RvcihobHMpIHtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLmxvYWRlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMudmFyaWFibGVMaXN0ID0gbnVsbDtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cbiAgc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb24pIHt9XG4gIHN0b3BMb2FkKCkge1xuICAgIHRoaXMuZGVzdHJveUludGVybmFsTG9hZGVycygpO1xuICB9XG4gIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9MT0FESU5HLCB0aGlzLm9uTGV2ZWxMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkFVRElPX1RSQUNLX0xPQURJTkcsIHRoaXMub25BdWRpb1RyYWNrTG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5TVUJUSVRMRV9UUkFDS19MT0FESU5HLCB0aGlzLm9uU3VidGl0bGVUcmFja0xvYWRpbmcsIHRoaXMpO1xuICB9XG4gIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTEVWRUxfTE9BRElORywgdGhpcy5vbkxldmVsTG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQVVESU9fVFJBQ0tfTE9BRElORywgdGhpcy5vbkF1ZGlvVHJhY2tMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5TVUJUSVRMRV9UUkFDS19MT0FESU5HLCB0aGlzLm9uU3VidGl0bGVUcmFja0xvYWRpbmcsIHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZGVmYXVsdHMgb3IgY29uZmlndXJlZCBsb2FkZXItdHlwZSBvdmVybG9hZHMgKHBMb2FkZXIgYW5kIGxvYWRlciBjb25maWcgcGFyYW1zKVxuICAgKi9cbiAgY3JlYXRlSW50ZXJuYWxMb2FkZXIoY29udGV4dCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcbiAgICBjb25zdCBQTG9hZGVyID0gY29uZmlnLnBMb2FkZXI7XG4gICAgY29uc3QgTG9hZGVyID0gY29uZmlnLmxvYWRlcjtcbiAgICBjb25zdCBJbnRlcm5hbExvYWRlciA9IFBMb2FkZXIgfHwgTG9hZGVyO1xuICAgIGNvbnN0IGxvYWRlciA9IG5ldyBJbnRlcm5hbExvYWRlcihjb25maWcpO1xuICAgIHRoaXMubG9hZGVyc1tjb250ZXh0LnR5cGVdID0gbG9hZGVyO1xuICAgIHJldHVybiBsb2FkZXI7XG4gIH1cbiAgZ2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dCkge1xuICAgIHJldHVybiB0aGlzLmxvYWRlcnNbY29udGV4dC50eXBlXTtcbiAgfVxuICByZXNldEludGVybmFsTG9hZGVyKGNvbnRleHRUeXBlKSB7XG4gICAgaWYgKHRoaXMubG9hZGVyc1tjb250ZXh0VHlwZV0pIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmxvYWRlcnNbY29udGV4dFR5cGVdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsIGBkZXN0cm95YCBvbiBhbGwgaW50ZXJuYWwgbG9hZGVyIGluc3RhbmNlcyBtYXBwZWQgKG9uZSBwZXIgY29udGV4dCB0eXBlKVxuICAgKi9cbiAgZGVzdHJveUludGVybmFsTG9hZGVycygpIHtcbiAgICBmb3IgKGNvbnN0IGNvbnRleHRUeXBlIGluIHRoaXMubG9hZGVycykge1xuICAgICAgY29uc3QgbG9hZGVyID0gdGhpcy5sb2FkZXJzW2NvbnRleHRUeXBlXTtcbiAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgbG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVzZXRJbnRlcm5hbExvYWRlcihjb250ZXh0VHlwZSk7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy52YXJpYWJsZUxpc3QgPSBudWxsO1xuICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIHRoaXMuZGVzdHJveUludGVybmFsTG9hZGVycygpO1xuICB9XG4gIG9uTWFuaWZlc3RMb2FkaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgdXJsXG4gICAgfSA9IGRhdGE7XG4gICAgdGhpcy52YXJpYWJsZUxpc3QgPSBudWxsO1xuICAgIHRoaXMubG9hZCh7XG4gICAgICBpZDogbnVsbCxcbiAgICAgIGxldmVsOiAwLFxuICAgICAgcmVzcG9uc2VUeXBlOiAndGV4dCcsXG4gICAgICB0eXBlOiBQbGF5bGlzdENvbnRleHRUeXBlLk1BTklGRVNULFxuICAgICAgdXJsLFxuICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzOiBudWxsXG4gICAgfSk7XG4gIH1cbiAgb25MZXZlbExvYWRpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBpZCxcbiAgICAgIGxldmVsLFxuICAgICAgcGF0aHdheUlkLFxuICAgICAgdXJsLFxuICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzXG4gICAgfSA9IGRhdGE7XG4gICAgdGhpcy5sb2FkKHtcbiAgICAgIGlkLFxuICAgICAgbGV2ZWwsXG4gICAgICBwYXRod2F5SWQsXG4gICAgICByZXNwb25zZVR5cGU6ICd0ZXh0JyxcbiAgICAgIHR5cGU6IFBsYXlsaXN0Q29udGV4dFR5cGUuTEVWRUwsXG4gICAgICB1cmwsXG4gICAgICBkZWxpdmVyeURpcmVjdGl2ZXNcbiAgICB9KTtcbiAgfVxuICBvbkF1ZGlvVHJhY2tMb2FkaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgaWQsXG4gICAgICBncm91cElkLFxuICAgICAgdXJsLFxuICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzXG4gICAgfSA9IGRhdGE7XG4gICAgdGhpcy5sb2FkKHtcbiAgICAgIGlkLFxuICAgICAgZ3JvdXBJZCxcbiAgICAgIGxldmVsOiBudWxsLFxuICAgICAgcmVzcG9uc2VUeXBlOiAndGV4dCcsXG4gICAgICB0eXBlOiBQbGF5bGlzdENvbnRleHRUeXBlLkFVRElPX1RSQUNLLFxuICAgICAgdXJsLFxuICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzXG4gICAgfSk7XG4gIH1cbiAgb25TdWJ0aXRsZVRyYWNrTG9hZGluZyhldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlkLFxuICAgICAgZ3JvdXBJZCxcbiAgICAgIHVybCxcbiAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlc1xuICAgIH0gPSBkYXRhO1xuICAgIHRoaXMubG9hZCh7XG4gICAgICBpZCxcbiAgICAgIGdyb3VwSWQsXG4gICAgICBsZXZlbDogbnVsbCxcbiAgICAgIHJlc3BvbnNlVHlwZTogJ3RleHQnLFxuICAgICAgdHlwZTogUGxheWxpc3RDb250ZXh0VHlwZS5TVUJUSVRMRV9UUkFDSyxcbiAgICAgIHVybCxcbiAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlc1xuICAgIH0pO1xuICB9XG4gIGxvYWQoY29udGV4dCkge1xuICAgIHZhciBfY29udGV4dCRkZWxpdmVyeURpcmU7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuXG4gICAgLy8gbG9nZ2VyLmRlYnVnKGBbcGxheWxpc3QtbG9hZGVyXTogTG9hZGluZyBwbGF5bGlzdCBvZiB0eXBlICR7Y29udGV4dC50eXBlfSwgbGV2ZWw6ICR7Y29udGV4dC5sZXZlbH0sIGlkOiAke2NvbnRleHQuaWR9YCk7XG5cbiAgICAvLyBDaGVjayBpZiBhIGxvYWRlciBmb3IgdGhpcyBjb250ZXh0IGFscmVhZHkgZXhpc3RzXG4gICAgbGV0IGxvYWRlciA9IHRoaXMuZ2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dCk7XG4gICAgaWYgKGxvYWRlcikge1xuICAgICAgY29uc3QgbG9hZGVyQ29udGV4dCA9IGxvYWRlci5jb250ZXh0O1xuICAgICAgaWYgKGxvYWRlckNvbnRleHQgJiYgbG9hZGVyQ29udGV4dC51cmwgPT09IGNvbnRleHQudXJsICYmIGxvYWRlckNvbnRleHQubGV2ZWwgPT09IGNvbnRleHQubGV2ZWwpIHtcbiAgICAgICAgLy8gc2FtZSBVUkwgY2FuJ3Qgb3ZlcmxhcFxuICAgICAgICBsb2dnZXIudHJhY2UoJ1twbGF5bGlzdC1sb2FkZXJdOiBwbGF5bGlzdCByZXF1ZXN0IG9uZ29pbmcnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbG9nZ2VyLmxvZyhgW3BsYXlsaXN0LWxvYWRlcl06IGFib3J0aW5nIHByZXZpb3VzIGxvYWRlciBmb3IgdHlwZTogJHtjb250ZXh0LnR5cGV9YCk7XG4gICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBkaWZmZXJlbnQgY29uZmlncyBmb3IgcmV0cmllcyBkZXBlbmRpbmcgb25cbiAgICAvLyBjb250ZXh0IChtYW5pZmVzdCwgbGV2ZWwsIGF1ZGlvL3N1YnMgcGxheWxpc3QpXG4gICAgbGV0IGxvYWRQb2xpY3k7XG4gICAgaWYgKGNvbnRleHQudHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5NQU5JRkVTVCkge1xuICAgICAgbG9hZFBvbGljeSA9IGNvbmZpZy5tYW5pZmVzdExvYWRQb2xpY3kuZGVmYXVsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9hZFBvbGljeSA9IF9leHRlbmRzKHt9LCBjb25maWcucGxheWxpc3RMb2FkUG9saWN5LmRlZmF1bHQsIHtcbiAgICAgICAgdGltZW91dFJldHJ5OiBudWxsLFxuICAgICAgICBlcnJvclJldHJ5OiBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gICAgbG9hZGVyID0gdGhpcy5jcmVhdGVJbnRlcm5hbExvYWRlcihjb250ZXh0KTtcblxuICAgIC8vIE92ZXJyaWRlIGxldmVsL3RyYWNrIHRpbWVvdXQgZm9yIExMLUhMUyByZXF1ZXN0c1xuICAgIC8vICh0aGUgZGVmYXVsdCBvZiAxMDAwMG1zIGlzIGNvdW50ZXIgcHJvZHVjdGl2ZSB0byBibG9ja2luZyBwbGF5bGlzdCByZWxvYWQgcmVxdWVzdHMpXG4gICAgaWYgKGlzRmluaXRlTnVtYmVyKChfY29udGV4dCRkZWxpdmVyeURpcmUgPSBjb250ZXh0LmRlbGl2ZXJ5RGlyZWN0aXZlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jb250ZXh0JGRlbGl2ZXJ5RGlyZS5wYXJ0KSkge1xuICAgICAgbGV0IGxldmVsRGV0YWlscztcbiAgICAgIGlmIChjb250ZXh0LnR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuTEVWRUwgJiYgY29udGV4dC5sZXZlbCAhPT0gbnVsbCkge1xuICAgICAgICBsZXZlbERldGFpbHMgPSB0aGlzLmhscy5sZXZlbHNbY29udGV4dC5sZXZlbF0uZGV0YWlscztcbiAgICAgIH0gZWxzZSBpZiAoY29udGV4dC50eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLkFVRElPX1RSQUNLICYmIGNvbnRleHQuaWQgIT09IG51bGwpIHtcbiAgICAgICAgbGV2ZWxEZXRhaWxzID0gdGhpcy5obHMuYXVkaW9UcmFja3NbY29udGV4dC5pZF0uZGV0YWlscztcbiAgICAgIH0gZWxzZSBpZiAoY29udGV4dC50eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLICYmIGNvbnRleHQuaWQgIT09IG51bGwpIHtcbiAgICAgICAgbGV2ZWxEZXRhaWxzID0gdGhpcy5obHMuc3VidGl0bGVUcmFja3NbY29udGV4dC5pZF0uZGV0YWlscztcbiAgICAgIH1cbiAgICAgIGlmIChsZXZlbERldGFpbHMpIHtcbiAgICAgICAgY29uc3QgcGFydFRhcmdldCA9IGxldmVsRGV0YWlscy5wYXJ0VGFyZ2V0O1xuICAgICAgICBjb25zdCB0YXJnZXREdXJhdGlvbiA9IGxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbjtcbiAgICAgICAgaWYgKHBhcnRUYXJnZXQgJiYgdGFyZ2V0RHVyYXRpb24pIHtcbiAgICAgICAgICBjb25zdCBtYXhMb3dMYXRlbmN5UGxheWxpc3RSZWZyZXNoID0gTWF0aC5tYXgocGFydFRhcmdldCAqIDMsIHRhcmdldER1cmF0aW9uICogMC44KSAqIDEwMDA7XG4gICAgICAgICAgbG9hZFBvbGljeSA9IF9leHRlbmRzKHt9LCBsb2FkUG9saWN5LCB7XG4gICAgICAgICAgICBtYXhUaW1lVG9GaXJzdEJ5dGVNczogTWF0aC5taW4obWF4TG93TGF0ZW5jeVBsYXlsaXN0UmVmcmVzaCwgbG9hZFBvbGljeS5tYXhUaW1lVG9GaXJzdEJ5dGVNcyksXG4gICAgICAgICAgICBtYXhMb2FkVGltZU1zOiBNYXRoLm1pbihtYXhMb3dMYXRlbmN5UGxheWxpc3RSZWZyZXNoLCBsb2FkUG9saWN5Lm1heFRpbWVUb0ZpcnN0Qnl0ZU1zKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGxlZ2FjeVJldHJ5Q29tcGF0aWJpbGl0eSA9IGxvYWRQb2xpY3kuZXJyb3JSZXRyeSB8fCBsb2FkUG9saWN5LnRpbWVvdXRSZXRyeSB8fCB7fTtcbiAgICBjb25zdCBsb2FkZXJDb25maWcgPSB7XG4gICAgICBsb2FkUG9saWN5LFxuICAgICAgdGltZW91dDogbG9hZFBvbGljeS5tYXhMb2FkVGltZU1zLFxuICAgICAgbWF4UmV0cnk6IGxlZ2FjeVJldHJ5Q29tcGF0aWJpbGl0eS5tYXhOdW1SZXRyeSB8fCAwLFxuICAgICAgcmV0cnlEZWxheTogbGVnYWN5UmV0cnlDb21wYXRpYmlsaXR5LnJldHJ5RGVsYXlNcyB8fCAwLFxuICAgICAgbWF4UmV0cnlEZWxheTogbGVnYWN5UmV0cnlDb21wYXRpYmlsaXR5Lm1heFJldHJ5RGVsYXlNcyB8fCAwXG4gICAgfTtcbiAgICBjb25zdCBsb2FkZXJDYWxsYmFja3MgPSB7XG4gICAgICBvblN1Y2Nlc3M6IChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSA9PiB7XG4gICAgICAgIGNvbnN0IGxvYWRlciA9IHRoaXMuZ2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dCk7XG4gICAgICAgIHRoaXMucmVzZXRJbnRlcm5hbExvYWRlcihjb250ZXh0LnR5cGUpO1xuICAgICAgICBjb25zdCBzdHJpbmcgPSByZXNwb25zZS5kYXRhO1xuXG4gICAgICAgIC8vIFZhbGlkYXRlIGlmIGl0IGlzIGFuIE0zVTggYXQgYWxsXG4gICAgICAgIGlmIChzdHJpbmcuaW5kZXhPZignI0VYVE0zVScpICE9PSAwKSB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVNYW5pZmVzdFBhcnNpbmdFcnJvcihyZXNwb25zZSwgY29udGV4dCwgbmV3IEVycm9yKCdubyBFWFRNM1UgZGVsaW1pdGVyJyksIG5ldHdvcmtEZXRhaWxzIHx8IG51bGwsIHN0YXRzKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3RhdHMucGFyc2luZy5zdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBpZiAoTTNVOFBhcnNlci5pc01lZGlhUGxheWxpc3Qoc3RyaW5nKSkge1xuICAgICAgICAgIHRoaXMuaGFuZGxlVHJhY2tPckxldmVsUGxheWxpc3QocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscyB8fCBudWxsLCBsb2FkZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuaGFuZGxlTWFzdGVyUGxheWxpc3QocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbkVycm9yOiAocmVzcG9uc2UsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzLCBzdGF0cykgPT4ge1xuICAgICAgICB0aGlzLmhhbmRsZU5ldHdvcmtFcnJvcihjb250ZXh0LCBuZXR3b3JrRGV0YWlscywgZmFsc2UsIHJlc3BvbnNlLCBzdGF0cyk7XG4gICAgICB9LFxuICAgICAgb25UaW1lb3V0OiAoc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSA9PiB7XG4gICAgICAgIHRoaXMuaGFuZGxlTmV0d29ya0Vycm9yKGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzLCB0cnVlLCB1bmRlZmluZWQsIHN0YXRzKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gbG9nZ2VyLmRlYnVnKGBbcGxheWxpc3QtbG9hZGVyXTogQ2FsbGluZyBpbnRlcm5hbCBsb2FkZXIgZGVsZWdhdGUgZm9yIFVSTDogJHtjb250ZXh0LnVybH1gKTtcblxuICAgIGxvYWRlci5sb2FkKGNvbnRleHQsIGxvYWRlckNvbmZpZywgbG9hZGVyQ2FsbGJhY2tzKTtcbiAgfVxuICBoYW5kbGVNYXN0ZXJQbGF5bGlzdChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgY29uc3Qgc3RyaW5nID0gcmVzcG9uc2UuZGF0YTtcbiAgICBjb25zdCB1cmwgPSBnZXRSZXNwb25zZVVybChyZXNwb25zZSwgY29udGV4dCk7XG4gICAgY29uc3QgcGFyc2VkUmVzdWx0ID0gTTNVOFBhcnNlci5wYXJzZU1hc3RlclBsYXlsaXN0KHN0cmluZywgdXJsKTtcbiAgICBpZiAocGFyc2VkUmVzdWx0LnBsYXlsaXN0UGFyc2luZ0Vycm9yKSB7XG4gICAgICB0aGlzLmhhbmRsZU1hbmlmZXN0UGFyc2luZ0Vycm9yKHJlc3BvbnNlLCBjb250ZXh0LCBwYXJzZWRSZXN1bHQucGxheWxpc3RQYXJzaW5nRXJyb3IsIG5ldHdvcmtEZXRhaWxzLCBzdGF0cyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRlbnRTdGVlcmluZyxcbiAgICAgIGxldmVscyxcbiAgICAgIHNlc3Npb25EYXRhLFxuICAgICAgc2Vzc2lvbktleXMsXG4gICAgICBzdGFydFRpbWVPZmZzZXQsXG4gICAgICB2YXJpYWJsZUxpc3RcbiAgICB9ID0gcGFyc2VkUmVzdWx0O1xuICAgIHRoaXMudmFyaWFibGVMaXN0ID0gdmFyaWFibGVMaXN0O1xuICAgIGNvbnN0IHtcbiAgICAgIEFVRElPOiBhdWRpb1RyYWNrcyA9IFtdLFxuICAgICAgU1VCVElUTEVTOiBzdWJ0aXRsZXMsXG4gICAgICAnQ0xPU0VELUNBUFRJT05TJzogY2FwdGlvbnNcbiAgICB9ID0gTTNVOFBhcnNlci5wYXJzZU1hc3RlclBsYXlsaXN0TWVkaWEoc3RyaW5nLCB1cmwsIHBhcnNlZFJlc3VsdCk7XG4gICAgaWYgKGF1ZGlvVHJhY2tzLmxlbmd0aCkge1xuICAgICAgLy8gY2hlY2sgaWYgd2UgaGF2ZSBmb3VuZCBhbiBhdWRpbyB0cmFjayBlbWJlZGRlZCBpbiBtYWluIHBsYXlsaXN0IChhdWRpbyB0cmFjayB3aXRob3V0IFVSSSBhdHRyaWJ1dGUpXG4gICAgICBjb25zdCBlbWJlZGRlZEF1ZGlvRm91bmQgPSBhdWRpb1RyYWNrcy5zb21lKGF1ZGlvVHJhY2sgPT4gIWF1ZGlvVHJhY2sudXJsKTtcblxuICAgICAgLy8gaWYgbm8gZW1iZWRkZWQgYXVkaW8gdHJhY2sgZGVmaW5lZCwgYnV0IGF1ZGlvIGNvZGVjIHNpZ25hbGVkIGluIHF1YWxpdHkgbGV2ZWwsXG4gICAgICAvLyB3ZSBuZWVkIHRvIHNpZ25hbCB0aGlzIG1haW4gYXVkaW8gdHJhY2sgdGhpcyBjb3VsZCBoYXBwZW4gd2l0aCBwbGF5bGlzdHMgd2l0aFxuICAgICAgLy8gYWx0IGF1ZGlvIHJlbmRpdGlvbiBpbiB3aGljaCBxdWFsaXR5IGxldmVscyAobWFpbilcbiAgICAgIC8vIGNvbnRhaW5zIGJvdGggYXVkaW8rdmlkZW8uIGJ1dCB3aXRoIG1peGVkIGF1ZGlvIHRyYWNrIG5vdCBzaWduYWxlZFxuICAgICAgaWYgKCFlbWJlZGRlZEF1ZGlvRm91bmQgJiYgbGV2ZWxzWzBdLmF1ZGlvQ29kZWMgJiYgIWxldmVsc1swXS5hdHRycy5BVURJTykge1xuICAgICAgICBsb2dnZXIubG9nKCdbcGxheWxpc3QtbG9hZGVyXTogYXVkaW8gY29kZWMgc2lnbmFsZWQgaW4gcXVhbGl0eSBsZXZlbCwgYnV0IG5vIGVtYmVkZGVkIGF1ZGlvIHRyYWNrIHNpZ25hbGVkLCBjcmVhdGUgb25lJyk7XG4gICAgICAgIGF1ZGlvVHJhY2tzLnVuc2hpZnQoe1xuICAgICAgICAgIHR5cGU6ICdtYWluJyxcbiAgICAgICAgICBuYW1lOiAnbWFpbicsXG4gICAgICAgICAgZ3JvdXBJZDogJ21haW4nLFxuICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgICAgIGF1dG9zZWxlY3Q6IGZhbHNlLFxuICAgICAgICAgIGZvcmNlZDogZmFsc2UsXG4gICAgICAgICAgaWQ6IC0xLFxuICAgICAgICAgIGF0dHJzOiBuZXcgQXR0ckxpc3Qoe30pLFxuICAgICAgICAgIGJpdHJhdGU6IDAsXG4gICAgICAgICAgdXJsOiAnJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaGxzLnRyaWdnZXIoRXZlbnRzLk1BTklGRVNUX0xPQURFRCwge1xuICAgICAgbGV2ZWxzLFxuICAgICAgYXVkaW9UcmFja3MsXG4gICAgICBzdWJ0aXRsZXMsXG4gICAgICBjYXB0aW9ucyxcbiAgICAgIGNvbnRlbnRTdGVlcmluZyxcbiAgICAgIHVybCxcbiAgICAgIHN0YXRzLFxuICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICBzZXNzaW9uRGF0YSxcbiAgICAgIHNlc3Npb25LZXlzLFxuICAgICAgc3RhcnRUaW1lT2Zmc2V0LFxuICAgICAgdmFyaWFibGVMaXN0XG4gICAgfSk7XG4gIH1cbiAgaGFuZGxlVHJhY2tPckxldmVsUGxheWxpc3QocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscywgbG9hZGVyKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgY29uc3Qge1xuICAgICAgaWQsXG4gICAgICBsZXZlbCxcbiAgICAgIHR5cGVcbiAgICB9ID0gY29udGV4dDtcbiAgICBjb25zdCB1cmwgPSBnZXRSZXNwb25zZVVybChyZXNwb25zZSwgY29udGV4dCk7XG4gICAgY29uc3QgbGV2ZWxVcmxJZCA9IDA7XG4gICAgY29uc3QgbGV2ZWxJZCA9IGlzRmluaXRlTnVtYmVyKGxldmVsKSA/IGxldmVsIDogaXNGaW5pdGVOdW1iZXIoaWQpID8gaWQgOiAwO1xuICAgIGNvbnN0IGxldmVsVHlwZSA9IG1hcENvbnRleHRUb0xldmVsVHlwZShjb250ZXh0KTtcbiAgICBjb25zdCBsZXZlbERldGFpbHMgPSBNM1U4UGFyc2VyLnBhcnNlTGV2ZWxQbGF5bGlzdChyZXNwb25zZS5kYXRhLCB1cmwsIGxldmVsSWQsIGxldmVsVHlwZSwgbGV2ZWxVcmxJZCwgdGhpcy52YXJpYWJsZUxpc3QpO1xuXG4gICAgLy8gV2UgaGF2ZSBkb25lIG91ciBmaXJzdCByZXF1ZXN0IChNYW5pZmVzdC10eXBlKSBhbmQgcmVjZWl2ZVxuICAgIC8vIG5vdCBhIG1hc3RlciBwbGF5bGlzdCBidXQgYSBjaHVuay1saXN0ICh0cmFjay9sZXZlbClcbiAgICAvLyBXZSBmaXJlIHRoZSBtYW5pZmVzdC1sb2FkZWQgZXZlbnQgYW55d2F5IHdpdGggdGhlIHBhcnNlZCBsZXZlbC1kZXRhaWxzXG4gICAgLy8gYnkgY3JlYXRpbmcgYSBzaW5nbGUtbGV2ZWwgc3RydWN0dXJlIGZvciBpdC5cbiAgICBpZiAodHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5NQU5JRkVTVCkge1xuICAgICAgY29uc3Qgc2luZ2xlTGV2ZWwgPSB7XG4gICAgICAgIGF0dHJzOiBuZXcgQXR0ckxpc3Qoe30pLFxuICAgICAgICBiaXRyYXRlOiAwLFxuICAgICAgICBkZXRhaWxzOiBsZXZlbERldGFpbHMsXG4gICAgICAgIG5hbWU6ICcnLFxuICAgICAgICB1cmxcbiAgICAgIH07XG4gICAgICBobHMudHJpZ2dlcihFdmVudHMuTUFOSUZFU1RfTE9BREVELCB7XG4gICAgICAgIGxldmVsczogW3NpbmdsZUxldmVsXSxcbiAgICAgICAgYXVkaW9UcmFja3M6IFtdLFxuICAgICAgICB1cmwsXG4gICAgICAgIHN0YXRzLFxuICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgc2Vzc2lvbkRhdGE6IG51bGwsXG4gICAgICAgIHNlc3Npb25LZXlzOiBudWxsLFxuICAgICAgICBjb250ZW50U3RlZXJpbmc6IG51bGwsXG4gICAgICAgIHN0YXJ0VGltZU9mZnNldDogbnVsbCxcbiAgICAgICAgdmFyaWFibGVMaXN0OiBudWxsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBzYXZlIHBhcnNpbmcgdGltZVxuICAgIHN0YXRzLnBhcnNpbmcuZW5kID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICAvLyBleHRlbmQgdGhlIGNvbnRleHQgd2l0aCB0aGUgbmV3IGxldmVsRGV0YWlscyBwcm9wZXJ0eVxuICAgIGNvbnRleHQubGV2ZWxEZXRhaWxzID0gbGV2ZWxEZXRhaWxzO1xuICAgIHRoaXMuaGFuZGxlUGxheWxpc3RMb2FkZWQobGV2ZWxEZXRhaWxzLCByZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzLCBsb2FkZXIpO1xuICB9XG4gIGhhbmRsZU1hbmlmZXN0UGFyc2luZ0Vycm9yKHJlc3BvbnNlLCBjb250ZXh0LCBlcnJvciwgbmV0d29ya0RldGFpbHMsIHN0YXRzKSB7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgIHR5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUixcbiAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5NQU5JRkVTVF9QQVJTSU5HX0VSUk9SLFxuICAgICAgZmF0YWw6IGNvbnRleHQudHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5NQU5JRkVTVCxcbiAgICAgIHVybDogcmVzcG9uc2UudXJsLFxuICAgICAgZXJyOiBlcnJvcixcbiAgICAgIGVycm9yLFxuICAgICAgcmVhc29uOiBlcnJvci5tZXNzYWdlLFxuICAgICAgcmVzcG9uc2UsXG4gICAgICBjb250ZXh0LFxuICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICBzdGF0c1xuICAgIH0pO1xuICB9XG4gIGhhbmRsZU5ldHdvcmtFcnJvcihjb250ZXh0LCBuZXR3b3JrRGV0YWlscywgdGltZW91dCA9IGZhbHNlLCByZXNwb25zZSwgc3RhdHMpIHtcbiAgICBsZXQgbWVzc2FnZSA9IGBBIG5ldHdvcmsgJHt0aW1lb3V0ID8gJ3RpbWVvdXQnIDogJ2Vycm9yJyArIChyZXNwb25zZSA/ICcgKHN0YXR1cyAnICsgcmVzcG9uc2UuY29kZSArICcpJyA6ICcnKX0gb2NjdXJyZWQgd2hpbGUgbG9hZGluZyAke2NvbnRleHQudHlwZX1gO1xuICAgIGlmIChjb250ZXh0LnR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuTEVWRUwpIHtcbiAgICAgIG1lc3NhZ2UgKz0gYDogJHtjb250ZXh0LmxldmVsfSBpZDogJHtjb250ZXh0LmlkfWA7XG4gICAgfSBlbHNlIGlmIChjb250ZXh0LnR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuQVVESU9fVFJBQ0sgfHwgY29udGV4dC50eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLKSB7XG4gICAgICBtZXNzYWdlICs9IGAgaWQ6ICR7Y29udGV4dC5pZH0gZ3JvdXAtaWQ6IFwiJHtjb250ZXh0Lmdyb3VwSWR9XCJgO1xuICAgIH1cbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICBsb2dnZXIud2FybihgW3BsYXlsaXN0LWxvYWRlcl06ICR7bWVzc2FnZX1gKTtcbiAgICBsZXQgZGV0YWlscyA9IEVycm9yRGV0YWlscy5VTktOT1dOO1xuICAgIGxldCBmYXRhbCA9IGZhbHNlO1xuICAgIGNvbnN0IGxvYWRlciA9IHRoaXMuZ2V0SW50ZXJuYWxMb2FkZXIoY29udGV4dCk7XG4gICAgc3dpdGNoIChjb250ZXh0LnR5cGUpIHtcbiAgICAgIGNhc2UgUGxheWxpc3RDb250ZXh0VHlwZS5NQU5JRkVTVDpcbiAgICAgICAgZGV0YWlscyA9IHRpbWVvdXQgPyBFcnJvckRldGFpbHMuTUFOSUZFU1RfTE9BRF9USU1FT1VUIDogRXJyb3JEZXRhaWxzLk1BTklGRVNUX0xPQURfRVJST1I7XG4gICAgICAgIGZhdGFsID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBsYXlsaXN0Q29udGV4dFR5cGUuTEVWRUw6XG4gICAgICAgIGRldGFpbHMgPSB0aW1lb3V0ID8gRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfVElNRU9VVCA6IEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX0VSUk9SO1xuICAgICAgICBmYXRhbCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUGxheWxpc3RDb250ZXh0VHlwZS5BVURJT19UUkFDSzpcbiAgICAgICAgZGV0YWlscyA9IHRpbWVvdXQgPyBFcnJvckRldGFpbHMuQVVESU9fVFJBQ0tfTE9BRF9USU1FT1VUIDogRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfRVJST1I7XG4gICAgICAgIGZhdGFsID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQbGF5bGlzdENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLOlxuICAgICAgICBkZXRhaWxzID0gdGltZW91dCA/IEVycm9yRGV0YWlscy5TVUJUSVRMRV9UUkFDS19MT0FEX1RJTUVPVVQgOiBFcnJvckRldGFpbHMuU1VCVElUTEVfTE9BRF9FUlJPUjtcbiAgICAgICAgZmF0YWwgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIHRoaXMucmVzZXRJbnRlcm5hbExvYWRlcihjb250ZXh0LnR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBlcnJvckRhdGEgPSB7XG4gICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICBkZXRhaWxzLFxuICAgICAgZmF0YWwsXG4gICAgICB1cmw6IGNvbnRleHQudXJsLFxuICAgICAgbG9hZGVyLFxuICAgICAgY29udGV4dCxcbiAgICAgIGVycm9yLFxuICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICBzdGF0c1xuICAgIH07XG4gICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICBjb25zdCB1cmwgPSAobmV0d29ya0RldGFpbHMgPT0gbnVsbCA/IHZvaWQgMCA6IG5ldHdvcmtEZXRhaWxzLnVybCkgfHwgY29udGV4dC51cmw7XG4gICAgICBlcnJvckRhdGEucmVzcG9uc2UgPSBfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgIHVybCxcbiAgICAgICAgZGF0YTogdW5kZWZpbmVkXG4gICAgICB9LCByZXNwb25zZSk7XG4gICAgfVxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCBlcnJvckRhdGEpO1xuICB9XG4gIGhhbmRsZVBsYXlsaXN0TG9hZGVkKGxldmVsRGV0YWlscywgcmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscywgbG9hZGVyKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZSxcbiAgICAgIGxldmVsLFxuICAgICAgaWQsXG4gICAgICBncm91cElkLFxuICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzXG4gICAgfSA9IGNvbnRleHQ7XG4gICAgY29uc3QgdXJsID0gZ2V0UmVzcG9uc2VVcmwocmVzcG9uc2UsIGNvbnRleHQpO1xuICAgIGNvbnN0IHBhcmVudCA9IG1hcENvbnRleHRUb0xldmVsVHlwZShjb250ZXh0KTtcbiAgICBjb25zdCBsZXZlbEluZGV4ID0gdHlwZW9mIGNvbnRleHQubGV2ZWwgPT09ICdudW1iZXInICYmIHBhcmVudCA9PT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTiA/IGxldmVsIDogdW5kZWZpbmVkO1xuICAgIGlmICghbGV2ZWxEZXRhaWxzLmZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IF9lcnJvciA9IG5ldyBFcnJvcignTm8gU2VnbWVudHMgZm91bmQgaW4gUGxheWxpc3QnKTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5MRVZFTF9FTVBUWV9FUlJPUixcbiAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICB1cmwsXG4gICAgICAgIGVycm9yOiBfZXJyb3IsXG4gICAgICAgIHJlYXNvbjogX2Vycm9yLm1lc3NhZ2UsXG4gICAgICAgIHJlc3BvbnNlLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBsZXZlbDogbGV2ZWxJbmRleCxcbiAgICAgICAgcGFyZW50LFxuICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgc3RhdHNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbikge1xuICAgICAgbGV2ZWxEZXRhaWxzLnBsYXlsaXN0UGFyc2luZ0Vycm9yID0gbmV3IEVycm9yKCdNaXNzaW5nIFRhcmdldCBEdXJhdGlvbicpO1xuICAgIH1cbiAgICBjb25zdCBlcnJvciA9IGxldmVsRGV0YWlscy5wbGF5bGlzdFBhcnNpbmdFcnJvcjtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5MRVZFTF9QQVJTSU5HX0VSUk9SLFxuICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgIHVybCxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIHJlYXNvbjogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGxldmVsOiBsZXZlbEluZGV4LFxuICAgICAgICBwYXJlbnQsXG4gICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICBzdGF0c1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChsZXZlbERldGFpbHMubGl2ZSAmJiBsb2FkZXIpIHtcbiAgICAgIGlmIChsb2FkZXIuZ2V0Q2FjaGVBZ2UpIHtcbiAgICAgICAgbGV2ZWxEZXRhaWxzLmFnZUhlYWRlciA9IGxvYWRlci5nZXRDYWNoZUFnZSgpIHx8IDA7XG4gICAgICB9XG4gICAgICBpZiAoIWxvYWRlci5nZXRDYWNoZUFnZSB8fCBpc05hTihsZXZlbERldGFpbHMuYWdlSGVhZGVyKSkge1xuICAgICAgICBsZXZlbERldGFpbHMuYWdlSGVhZGVyID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFBsYXlsaXN0Q29udGV4dFR5cGUuTUFOSUZFU1Q6XG4gICAgICBjYXNlIFBsYXlsaXN0Q29udGV4dFR5cGUuTEVWRUw6XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5MRVZFTF9MT0FERUQsIHtcbiAgICAgICAgICBkZXRhaWxzOiBsZXZlbERldGFpbHMsXG4gICAgICAgICAgbGV2ZWw6IGxldmVsSW5kZXggfHwgMCxcbiAgICAgICAgICBpZDogaWQgfHwgMCxcbiAgICAgICAgICBzdGF0cyxcbiAgICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICBkZWxpdmVyeURpcmVjdGl2ZXNcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQbGF5bGlzdENvbnRleHRUeXBlLkFVRElPX1RSQUNLOlxuICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuQVVESU9fVFJBQ0tfTE9BREVELCB7XG4gICAgICAgICAgZGV0YWlsczogbGV2ZWxEZXRhaWxzLFxuICAgICAgICAgIGlkOiBpZCB8fCAwLFxuICAgICAgICAgIGdyb3VwSWQ6IGdyb3VwSWQgfHwgJycsXG4gICAgICAgICAgc3RhdHMsXG4gICAgICAgICAgbmV0d29ya0RldGFpbHMsXG4gICAgICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUGxheWxpc3RDb250ZXh0VHlwZS5TVUJUSVRMRV9UUkFDSzpcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLlNVQlRJVExFX1RSQUNLX0xPQURFRCwge1xuICAgICAgICAgIGRldGFpbHM6IGxldmVsRGV0YWlscyxcbiAgICAgICAgICBpZDogaWQgfHwgMCxcbiAgICAgICAgICBncm91cElkOiBncm91cElkIHx8ICcnLFxuICAgICAgICAgIHN0YXRzLFxuICAgICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlc1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNlbmRBZGRUcmFja0V2ZW50KHRyYWNrLCB2aWRlb0VsKSB7XG4gIGxldCBldmVudDtcbiAgdHJ5IHtcbiAgICBldmVudCA9IG5ldyBFdmVudCgnYWRkdHJhY2snKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gZm9yIElFMTFcbiAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgIGV2ZW50LmluaXRFdmVudCgnYWRkdHJhY2snLCBmYWxzZSwgZmFsc2UpO1xuICB9XG4gIGV2ZW50LnRyYWNrID0gdHJhY2s7XG4gIHZpZGVvRWwuZGlzcGF0Y2hFdmVudChldmVudCk7XG59XG5mdW5jdGlvbiBhZGRDdWVUb1RyYWNrKHRyYWNrLCBjdWUpIHtcbiAgLy8gU29tZXRpbWVzIHRoZXJlIGFyZSBjdWUgb3ZlcmxhcHMgb24gc2VnbWVudGVkIHZ0dHMgc28gdGhlIHNhbWVcbiAgLy8gY3VlIGNhbiBhcHBlYXIgbW9yZSB0aGFuIG9uY2UgaW4gZGlmZmVyZW50IHZ0dCBmaWxlcy5cbiAgLy8gVGhpcyBhdm9pZCBzaG93aW5nIGR1cGxpY2F0ZWQgY3VlcyB3aXRoIHNhbWUgdGltZWNvZGUgYW5kIHRleHQuXG4gIGNvbnN0IG1vZGUgPSB0cmFjay5tb2RlO1xuICBpZiAobW9kZSA9PT0gJ2Rpc2FibGVkJykge1xuICAgIHRyYWNrLm1vZGUgPSAnaGlkZGVuJztcbiAgfVxuICBpZiAodHJhY2suY3VlcyAmJiAhdHJhY2suY3Vlcy5nZXRDdWVCeUlkKGN1ZS5pZCkpIHtcbiAgICB0cnkge1xuICAgICAgdHJhY2suYWRkQ3VlKGN1ZSk7XG4gICAgICBpZiAoIXRyYWNrLmN1ZXMuZ2V0Q3VlQnlJZChjdWUuaWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgYWRkQ3VlIGlzIGZhaWxlZCBmb3I6ICR7Y3VlfWApO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nZ2VyLmRlYnVnKGBbdGV4dHRyYWNrLXV0aWxzXTogJHtlcnJ9YCk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB0ZXh0VHJhY2tDdWUgPSBuZXcgc2VsZi5UZXh0VHJhY2tDdWUoY3VlLnN0YXJ0VGltZSwgY3VlLmVuZFRpbWUsIGN1ZS50ZXh0KTtcbiAgICAgICAgdGV4dFRyYWNrQ3VlLmlkID0gY3VlLmlkO1xuICAgICAgICB0cmFjay5hZGRDdWUodGV4dFRyYWNrQ3VlKTtcbiAgICAgIH0gY2F0Y2ggKGVycjIpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGBbdGV4dHRyYWNrLXV0aWxzXTogTGVnYWN5IFRleHRUcmFja0N1ZSBmYWxsYmFjayBmYWlsZWQ6ICR7ZXJyMn1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKG1vZGUgPT09ICdkaXNhYmxlZCcpIHtcbiAgICB0cmFjay5tb2RlID0gbW9kZTtcbiAgfVxufVxuZnVuY3Rpb24gY2xlYXJDdXJyZW50Q3Vlcyh0cmFjaykge1xuICAvLyBXaGVuIHRyYWNrLm1vZGUgaXMgZGlzYWJsZWQsIHRyYWNrLmN1ZXMgd2lsbCBiZSBudWxsLlxuICAvLyBUbyBndWFyYW50ZWUgdGhlIHJlbW92YWwgb2YgY3Vlcywgd2UgbmVlZCB0byB0ZW1wb3JhcmlseVxuICAvLyBjaGFuZ2UgdGhlIG1vZGUgdG8gaGlkZGVuXG4gIGNvbnN0IG1vZGUgPSB0cmFjay5tb2RlO1xuICBpZiAobW9kZSA9PT0gJ2Rpc2FibGVkJykge1xuICAgIHRyYWNrLm1vZGUgPSAnaGlkZGVuJztcbiAgfVxuICBpZiAodHJhY2suY3Vlcykge1xuICAgIGZvciAobGV0IGkgPSB0cmFjay5jdWVzLmxlbmd0aDsgaS0tOykge1xuICAgICAgdHJhY2sucmVtb3ZlQ3VlKHRyYWNrLmN1ZXNbaV0pO1xuICAgIH1cbiAgfVxuICBpZiAobW9kZSA9PT0gJ2Rpc2FibGVkJykge1xuICAgIHRyYWNrLm1vZGUgPSBtb2RlO1xuICB9XG59XG5mdW5jdGlvbiByZW1vdmVDdWVzSW5SYW5nZSh0cmFjaywgc3RhcnQsIGVuZCwgcHJlZGljYXRlKSB7XG4gIGNvbnN0IG1vZGUgPSB0cmFjay5tb2RlO1xuICBpZiAobW9kZSA9PT0gJ2Rpc2FibGVkJykge1xuICAgIHRyYWNrLm1vZGUgPSAnaGlkZGVuJztcbiAgfVxuICBpZiAodHJhY2suY3VlcyAmJiB0cmFjay5jdWVzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBjdWVzID0gZ2V0Q3Vlc0luUmFuZ2UodHJhY2suY3Vlcywgc3RhcnQsIGVuZCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIXByZWRpY2F0ZSB8fCBwcmVkaWNhdGUoY3Vlc1tpXSkpIHtcbiAgICAgICAgdHJhY2sucmVtb3ZlQ3VlKGN1ZXNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAobW9kZSA9PT0gJ2Rpc2FibGVkJykge1xuICAgIHRyYWNrLm1vZGUgPSBtb2RlO1xuICB9XG59XG5cbi8vIEZpbmQgZmlyc3QgY3VlIHN0YXJ0aW5nIGFmdGVyIGdpdmVuIHRpbWUuXG4vLyBNb2RpZmllZCB2ZXJzaW9uIG9mIGJpbmFyeSBzZWFyY2ggTyhsb2cobikpLlxuZnVuY3Rpb24gZ2V0Rmlyc3RDdWVJbmRleEFmdGVyVGltZShjdWVzLCB0aW1lKSB7XG4gIC8vIElmIGZpcnN0IGN1ZSBzdGFydHMgYWZ0ZXIgdGltZSwgc3RhcnQgdGhlcmVcbiAgaWYgKHRpbWUgPCBjdWVzWzBdLnN0YXJ0VGltZSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIC8vIElmIHRoZSBsYXN0IGN1ZSBlbmRzIGJlZm9yZSB0aW1lIHRoZXJlIGlzIG5vIG92ZXJsYXBcbiAgY29uc3QgbGVuID0gY3Vlcy5sZW5ndGggLSAxO1xuICBpZiAodGltZSA+IGN1ZXNbbGVuXS5lbmRUaW1lKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGxldCBsZWZ0ID0gMDtcbiAgbGV0IHJpZ2h0ID0gbGVuO1xuICB3aGlsZSAobGVmdCA8PSByaWdodCkge1xuICAgIGNvbnN0IG1pZCA9IE1hdGguZmxvb3IoKHJpZ2h0ICsgbGVmdCkgLyAyKTtcbiAgICBpZiAodGltZSA8IGN1ZXNbbWlkXS5zdGFydFRpbWUpIHtcbiAgICAgIHJpZ2h0ID0gbWlkIC0gMTtcbiAgICB9IGVsc2UgaWYgKHRpbWUgPiBjdWVzW21pZF0uc3RhcnRUaW1lICYmIGxlZnQgPCBsZW4pIHtcbiAgICAgIGxlZnQgPSBtaWQgKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBpdCdzIG5vdCBsb3dlciBvciBoaWdoZXIsIGl0IG11c3QgYmUgZXF1YWwuXG4gICAgICByZXR1cm4gbWlkO1xuICAgIH1cbiAgfVxuICAvLyBBdCB0aGlzIHBvaW50LCBsZWZ0IGFuZCByaWdodCBoYXZlIHN3YXBwZWQuXG4gIC8vIE5vIGRpcmVjdCBtYXRjaCB3YXMgZm91bmQsIGxlZnQgb3IgcmlnaHQgZWxlbWVudCBtdXN0IGJlIHRoZSBjbG9zZXN0LiBDaGVjayB3aGljaCBvbmUgaGFzIHRoZSBzbWFsbGVzdCBkaWZmLlxuICByZXR1cm4gY3Vlc1tsZWZ0XS5zdGFydFRpbWUgLSB0aW1lIDwgdGltZSAtIGN1ZXNbcmlnaHRdLnN0YXJ0VGltZSA/IGxlZnQgOiByaWdodDtcbn1cbmZ1bmN0aW9uIGdldEN1ZXNJblJhbmdlKGN1ZXMsIHN0YXJ0LCBlbmQpIHtcbiAgY29uc3QgY3Vlc0ZvdW5kID0gW107XG4gIGNvbnN0IGZpcnN0Q3VlSW5SYW5nZSA9IGdldEZpcnN0Q3VlSW5kZXhBZnRlclRpbWUoY3Vlcywgc3RhcnQpO1xuICBpZiAoZmlyc3RDdWVJblJhbmdlID4gLTEpIHtcbiAgICBmb3IgKGxldCBpID0gZmlyc3RDdWVJblJhbmdlLCBsZW4gPSBjdWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBjdWUgPSBjdWVzW2ldO1xuICAgICAgaWYgKGN1ZS5zdGFydFRpbWUgPj0gc3RhcnQgJiYgY3VlLmVuZFRpbWUgPD0gZW5kKSB7XG4gICAgICAgIGN1ZXNGb3VuZC5wdXNoKGN1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGN1ZS5zdGFydFRpbWUgPiBlbmQpIHtcbiAgICAgICAgcmV0dXJuIGN1ZXNGb3VuZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGN1ZXNGb3VuZDtcbn1cbmZ1bmN0aW9uIGZpbHRlclN1YnRpdGxlVHJhY2tzKHRleHRUcmFja0xpc3QpIHtcbiAgY29uc3QgdHJhY2tzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dFRyYWNrTGlzdC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRyYWNrID0gdGV4dFRyYWNrTGlzdFtpXTtcbiAgICAvLyBFZGdlIGFkZHMgYSB0cmFjayB3aXRob3V0IGEgbGFiZWw7IHdlIGRvbid0IHdhbnQgdG8gdXNlIGl0XG4gICAgaWYgKCh0cmFjay5raW5kID09PSAnc3VidGl0bGVzJyB8fCB0cmFjay5raW5kID09PSAnY2FwdGlvbnMnKSAmJiB0cmFjay5sYWJlbCkge1xuICAgICAgdHJhY2tzLnB1c2godGV4dFRyYWNrTGlzdFtpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cmFja3M7XG59XG5cbnZhciBNZXRhZGF0YVNjaGVtYSA9IHtcbiAgYXVkaW9JZDM6IFwib3JnLmlkM1wiLFxuICBkYXRlUmFuZ2U6IFwiY29tLmFwcGxlLnF1aWNrdGltZS5ITFNcIixcbiAgZW1zZzogXCJodHRwczovL2FvbWVkaWEub3JnL2Vtc2cvSUQzXCJcbn07XG5cbmNvbnN0IE1JTl9DVUVfRFVSQVRJT04gPSAwLjI1O1xuZnVuY3Rpb24gZ2V0Q3VlQ2xhc3MoKSB7XG4gIGlmICh0eXBlb2Ygc2VsZiA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiB1bmRlZmluZWQ7XG4gIHJldHVybiBzZWxmLlZUVEN1ZSB8fCBzZWxmLlRleHRUcmFja0N1ZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUN1ZVdpdGhEYXRhRmllbGRzKEN1ZSwgc3RhcnRUaW1lLCBlbmRUaW1lLCBkYXRhLCB0eXBlKSB7XG4gIGxldCBjdWUgPSBuZXcgQ3VlKHN0YXJ0VGltZSwgZW5kVGltZSwgJycpO1xuICB0cnkge1xuICAgIGN1ZS52YWx1ZSA9IGRhdGE7XG4gICAgaWYgKHR5cGUpIHtcbiAgICAgIGN1ZS50eXBlID0gdHlwZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjdWUgPSBuZXcgQ3VlKHN0YXJ0VGltZSwgZW5kVGltZSwgSlNPTi5zdHJpbmdpZnkodHlwZSA/IF9vYmplY3RTcHJlYWQyKHtcbiAgICAgIHR5cGVcbiAgICB9LCBkYXRhKSA6IGRhdGEpKTtcbiAgfVxuICByZXR1cm4gY3VlO1xufVxuXG4vLyBWVFRDdWUgbGF0ZXN0IGRyYWZ0IGFsbG93cyBhbiBpbmZpbml0ZSBkdXJhdGlvbiwgZmFsbGJhY2tcbi8vIHRvIE1BWF9WQUxVRSBpZiBuZWNlc3NhcnlcbmNvbnN0IE1BWF9DVUVfRU5EVElNRSA9ICgoKSA9PiB7XG4gIGNvbnN0IEN1ZSA9IGdldEN1ZUNsYXNzKCk7XG4gIHRyeSB7XG4gICAgQ3VlICYmIG5ldyBDdWUoMCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCAnJyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTtcbiAgfVxuICByZXR1cm4gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xufSkoKTtcbmZ1bmN0aW9uIGRhdGVSYW5nZURhdGVUb1RpbWVsaW5lU2Vjb25kcyhkYXRlLCBvZmZzZXQpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0VGltZSgpIC8gMTAwMCAtIG9mZnNldDtcbn1cbmZ1bmN0aW9uIGhleFRvQXJyYXlCdWZmZXIoc3RyKSB7XG4gIHJldHVybiBVaW50OEFycmF5LmZyb20oc3RyLnJlcGxhY2UoL14weC8sICcnKS5yZXBsYWNlKC8oW1xcZGEtZkEtRl17Mn0pID8vZywgJzB4JDEgJykucmVwbGFjZSgvICskLywgJycpLnNwbGl0KCcgJykpLmJ1ZmZlcjtcbn1cbmNsYXNzIElEM1RyYWNrQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMuaWQzVHJhY2sgPSBudWxsO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIHRoaXMuZGF0ZVJhbmdlQ3Vlc0FwcGVuZGVkID0ge307XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5fcmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLmlkM1RyYWNrID0gbnVsbDtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB0aGlzLmRhdGVSYW5nZUN1ZXNBcHBlbmRlZCA9IHt9O1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmhscyA9IG51bGw7XG4gIH1cbiAgX3JlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGhscy5vbihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRlJBR19QQVJTSU5HX01FVEFEQVRBLCB0aGlzLm9uRnJhZ1BhcnNpbmdNZXRhZGF0YSwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsIHRoaXMub25CdWZmZXJGbHVzaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9VUERBVEVELCB0aGlzLm9uTGV2ZWxVcGRhdGVkLCB0aGlzKTtcbiAgfVxuICBfdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5GUkFHX1BBUlNJTkdfTUVUQURBVEEsIHRoaXMub25GcmFnUGFyc2luZ01ldGFkYXRhLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsIHRoaXMub25CdWZmZXJGbHVzaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTEVWRUxfVVBEQVRFRCwgdGhpcy5vbkxldmVsVXBkYXRlZCwgdGhpcyk7XG4gIH1cblxuICAvLyBBZGQgSUQzIG1ldGF0YWRhdGEgdGV4dCB0cmFjay5cbiAgb25NZWRpYUF0dGFjaGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5tZWRpYSA9IGRhdGEubWVkaWE7XG4gIH1cbiAgb25NZWRpYURldGFjaGluZygpIHtcbiAgICBpZiAoIXRoaXMuaWQzVHJhY2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2xlYXJDdXJyZW50Q3Vlcyh0aGlzLmlkM1RyYWNrKTtcbiAgICB0aGlzLmlkM1RyYWNrID0gbnVsbDtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB0aGlzLmRhdGVSYW5nZUN1ZXNBcHBlbmRlZCA9IHt9O1xuICB9XG4gIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIHRoaXMuZGF0ZVJhbmdlQ3Vlc0FwcGVuZGVkID0ge307XG4gIH1cbiAgY3JlYXRlVHJhY2sobWVkaWEpIHtcbiAgICBjb25zdCB0cmFjayA9IHRoaXMuZ2V0SUQzVHJhY2sobWVkaWEudGV4dFRyYWNrcyk7XG4gICAgdHJhY2subW9kZSA9ICdoaWRkZW4nO1xuICAgIHJldHVybiB0cmFjaztcbiAgfVxuICBnZXRJRDNUcmFjayh0ZXh0VHJhY2tzKSB7XG4gICAgaWYgKCF0aGlzLm1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dFRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdGV4dFRyYWNrID0gdGV4dFRyYWNrc1tpXTtcbiAgICAgIGlmICh0ZXh0VHJhY2sua2luZCA9PT0gJ21ldGFkYXRhJyAmJiB0ZXh0VHJhY2subGFiZWwgPT09ICdpZDMnKSB7XG4gICAgICAgIC8vIHNlbmQgJ2FkZHRyYWNrJyB3aGVuIHJldXNpbmcgdGhlIHRleHRUcmFjayBmb3IgbWV0YWRhdGEsXG4gICAgICAgIC8vIHNhbWUgYXMgd2hhdCB3ZSBkbyBmb3IgY2FwdGlvbnNcbiAgICAgICAgc2VuZEFkZFRyYWNrRXZlbnQodGV4dFRyYWNrLCB0aGlzLm1lZGlhKTtcbiAgICAgICAgcmV0dXJuIHRleHRUcmFjaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubWVkaWEuYWRkVGV4dFRyYWNrKCdtZXRhZGF0YScsICdpZDMnKTtcbiAgfVxuICBvbkZyYWdQYXJzaW5nTWV0YWRhdGEoZXZlbnQsIGRhdGEpIHtcbiAgICBpZiAoIXRoaXMubWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgaGxzOiB7XG4gICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgIGVuYWJsZUVtc2dNZXRhZGF0YUN1ZXMsXG4gICAgICAgICAgZW5hYmxlSUQzTWV0YWRhdGFDdWVzXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWVuYWJsZUVtc2dNZXRhZGF0YUN1ZXMgJiYgIWVuYWJsZUlEM01ldGFkYXRhQ3Vlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBzYW1wbGVzXG4gICAgfSA9IGRhdGE7XG5cbiAgICAvLyBjcmVhdGUgdHJhY2sgZHluYW1pY2FsbHlcbiAgICBpZiAoIXRoaXMuaWQzVHJhY2spIHtcbiAgICAgIHRoaXMuaWQzVHJhY2sgPSB0aGlzLmNyZWF0ZVRyYWNrKHRoaXMubWVkaWEpO1xuICAgIH1cbiAgICBjb25zdCBDdWUgPSBnZXRDdWVDbGFzcygpO1xuICAgIGlmICghQ3VlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdHlwZSA9IHNhbXBsZXNbaV0udHlwZTtcbiAgICAgIGlmICh0eXBlID09PSBNZXRhZGF0YVNjaGVtYS5lbXNnICYmICFlbmFibGVFbXNnTWV0YWRhdGFDdWVzIHx8ICFlbmFibGVJRDNNZXRhZGF0YUN1ZXMpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBmcmFtZXMgPSBnZXRJRDNGcmFtZXMoc2FtcGxlc1tpXS5kYXRhKTtcbiAgICAgIGlmIChmcmFtZXMpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gc2FtcGxlc1tpXS5wdHM7XG4gICAgICAgIGxldCBlbmRUaW1lID0gc3RhcnRUaW1lICsgc2FtcGxlc1tpXS5kdXJhdGlvbjtcbiAgICAgICAgaWYgKGVuZFRpbWUgPiBNQVhfQ1VFX0VORFRJTUUpIHtcbiAgICAgICAgICBlbmRUaW1lID0gTUFYX0NVRV9FTkRUSU1FO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpbWVEaWZmID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcbiAgICAgICAgaWYgKHRpbWVEaWZmIDw9IDApIHtcbiAgICAgICAgICBlbmRUaW1lID0gc3RhcnRUaW1lICsgTUlOX0NVRV9EVVJBVElPTjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGZyYW1lcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNvbnN0IGZyYW1lID0gZnJhbWVzW2pdO1xuICAgICAgICAgIC8vIFNhZmFyaSBkb2Vzbid0IHB1dCB0aGUgdGltZXN0YW1wIGZyYW1lIGluIHRoZSBUZXh0VHJhY2tcbiAgICAgICAgICBpZiAoIWlzVGltZVN0YW1wRnJhbWUoZnJhbWUpKSB7XG4gICAgICAgICAgICAvLyBhZGQgYSBib3VuZHMgdG8gYW55IHVuYm91bmRlZCBjdWVzXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUlkM0N1ZUVuZHMoc3RhcnRUaW1lLCB0eXBlKTtcbiAgICAgICAgICAgIGNvbnN0IGN1ZSA9IGNyZWF0ZUN1ZVdpdGhEYXRhRmllbGRzKEN1ZSwgc3RhcnRUaW1lLCBlbmRUaW1lLCBmcmFtZSwgdHlwZSk7XG4gICAgICAgICAgICBpZiAoY3VlKSB7XG4gICAgICAgICAgICAgIHRoaXMuaWQzVHJhY2suYWRkQ3VlKGN1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHVwZGF0ZUlkM0N1ZUVuZHMoc3RhcnRUaW1lLCB0eXBlKSB7XG4gICAgdmFyIF90aGlzJGlkM1RyYWNrO1xuICAgIGNvbnN0IGN1ZXMgPSAoX3RoaXMkaWQzVHJhY2sgPSB0aGlzLmlkM1RyYWNrKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkaWQzVHJhY2suY3VlcztcbiAgICBpZiAoY3Vlcykge1xuICAgICAgZm9yIChsZXQgaSA9IGN1ZXMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgIGNvbnN0IGN1ZSA9IGN1ZXNbaV07XG4gICAgICAgIGlmIChjdWUudHlwZSA9PT0gdHlwZSAmJiBjdWUuc3RhcnRUaW1lIDwgc3RhcnRUaW1lICYmIGN1ZS5lbmRUaW1lID09PSBNQVhfQ1VFX0VORFRJTUUpIHtcbiAgICAgICAgICBjdWUuZW5kVGltZSA9IHN0YXJ0VGltZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBvbkJ1ZmZlckZsdXNoaW5nKGV2ZW50LCB7XG4gICAgc3RhcnRPZmZzZXQsXG4gICAgZW5kT2Zmc2V0LFxuICAgIHR5cGVcbiAgfSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlkM1RyYWNrLFxuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFobHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY29uZmlnOiB7XG4gICAgICAgIGVuYWJsZUVtc2dNZXRhZGF0YUN1ZXMsXG4gICAgICAgIGVuYWJsZUlEM01ldGFkYXRhQ3Vlc1xuICAgICAgfVxuICAgIH0gPSBobHM7XG4gICAgaWYgKGlkM1RyYWNrICYmIChlbmFibGVFbXNnTWV0YWRhdGFDdWVzIHx8IGVuYWJsZUlEM01ldGFkYXRhQ3VlcykpIHtcbiAgICAgIGxldCBwcmVkaWNhdGU7XG4gICAgICBpZiAodHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgICBwcmVkaWNhdGUgPSBjdWUgPT4gY3VlLnR5cGUgPT09IE1ldGFkYXRhU2NoZW1hLmF1ZGlvSWQzICYmIGVuYWJsZUlEM01ldGFkYXRhQ3VlcztcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgICBwcmVkaWNhdGUgPSBjdWUgPT4gY3VlLnR5cGUgPT09IE1ldGFkYXRhU2NoZW1hLmVtc2cgJiYgZW5hYmxlRW1zZ01ldGFkYXRhQ3VlcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IGN1ZSA9PiBjdWUudHlwZSA9PT0gTWV0YWRhdGFTY2hlbWEuYXVkaW9JZDMgJiYgZW5hYmxlSUQzTWV0YWRhdGFDdWVzIHx8IGN1ZS50eXBlID09PSBNZXRhZGF0YVNjaGVtYS5lbXNnICYmIGVuYWJsZUVtc2dNZXRhZGF0YUN1ZXM7XG4gICAgICB9XG4gICAgICByZW1vdmVDdWVzSW5SYW5nZShpZDNUcmFjaywgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCwgcHJlZGljYXRlKTtcbiAgICB9XG4gIH1cbiAgb25MZXZlbFVwZGF0ZWQoZXZlbnQsIHtcbiAgICBkZXRhaWxzXG4gIH0pIHtcbiAgICBpZiAoIXRoaXMubWVkaWEgfHwgIWRldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lIHx8ICF0aGlzLmhscy5jb25maWcuZW5hYmxlRGF0ZVJhbmdlTWV0YWRhdGFDdWVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGRhdGVSYW5nZUN1ZXNBcHBlbmRlZCxcbiAgICAgIGlkM1RyYWNrXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgZGF0ZVJhbmdlc1xuICAgIH0gPSBkZXRhaWxzO1xuICAgIGNvbnN0IGlkcyA9IE9iamVjdC5rZXlzKGRhdGVSYW5nZXMpO1xuICAgIC8vIFJlbW92ZSBjdWVzIGZyb20gdHJhY2sgbm90IGZvdW5kIGluIGRldGFpbHMuZGF0ZVJhbmdlc1xuICAgIGlmIChpZDNUcmFjaykge1xuICAgICAgY29uc3QgaWRzVG9SZW1vdmUgPSBPYmplY3Qua2V5cyhkYXRlUmFuZ2VDdWVzQXBwZW5kZWQpLmZpbHRlcihpZCA9PiAhaWRzLmluY2x1ZGVzKGlkKSk7XG4gICAgICBmb3IgKGxldCBpID0gaWRzVG9SZW1vdmUubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgIGNvbnN0IGlkID0gaWRzVG9SZW1vdmVbaV07XG4gICAgICAgIE9iamVjdC5rZXlzKGRhdGVSYW5nZUN1ZXNBcHBlbmRlZFtpZF0uY3VlcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgIGlkM1RyYWNrLnJlbW92ZUN1ZShkYXRlUmFuZ2VDdWVzQXBwZW5kZWRbaWRdLmN1ZXNba2V5XSk7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWxldGUgZGF0ZVJhbmdlQ3Vlc0FwcGVuZGVkW2lkXTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRXhpdCBpZiB0aGUgcGxheWxpc3QgZG9lcyBub3QgaGF2ZSBEYXRlIFJhbmdlcyBvciBkb2VzIG5vdCBoYXZlIFByb2dyYW0gRGF0ZSBUaW1lXG4gICAgY29uc3QgbGFzdEZyYWdtZW50ID0gZGV0YWlscy5mcmFnbWVudHNbZGV0YWlscy5mcmFnbWVudHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKGlkcy5sZW5ndGggPT09IDAgfHwgIWlzRmluaXRlTnVtYmVyKGxhc3RGcmFnbWVudCA9PSBudWxsID8gdm9pZCAwIDogbGFzdEZyYWdtZW50LnByb2dyYW1EYXRlVGltZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlkM1RyYWNrKSB7XG4gICAgICB0aGlzLmlkM1RyYWNrID0gdGhpcy5jcmVhdGVUcmFjayh0aGlzLm1lZGlhKTtcbiAgICB9XG4gICAgY29uc3QgZGF0ZVRpbWVPZmZzZXQgPSBsYXN0RnJhZ21lbnQucHJvZ3JhbURhdGVUaW1lIC8gMTAwMCAtIGxhc3RGcmFnbWVudC5zdGFydDtcbiAgICBjb25zdCBDdWUgPSBnZXRDdWVDbGFzcygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpZCA9IGlkc1tpXTtcbiAgICAgIGNvbnN0IGRhdGVSYW5nZSA9IGRhdGVSYW5nZXNbaWRdO1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gZGF0ZVJhbmdlRGF0ZVRvVGltZWxpbmVTZWNvbmRzKGRhdGVSYW5nZS5zdGFydERhdGUsIGRhdGVUaW1lT2Zmc2V0KTtcblxuICAgICAgLy8gUHJvY2VzcyBEYXRlUmFuZ2VzIHRvIGRldGVybWluZSBlbmQtdGltZSAoa25vd24gRFVSQVRJT04sIEVORC1EQVRFLCBvciBFTkQtT04tTkVYVClcbiAgICAgIGNvbnN0IGFwcGVuZGVkRGF0ZVJhbmdlQ3VlcyA9IGRhdGVSYW5nZUN1ZXNBcHBlbmRlZFtpZF07XG4gICAgICBjb25zdCBjdWVzID0gKGFwcGVuZGVkRGF0ZVJhbmdlQ3VlcyA9PSBudWxsID8gdm9pZCAwIDogYXBwZW5kZWREYXRlUmFuZ2VDdWVzLmN1ZXMpIHx8IHt9O1xuICAgICAgbGV0IGR1cmF0aW9uS25vd24gPSAoYXBwZW5kZWREYXRlUmFuZ2VDdWVzID09IG51bGwgPyB2b2lkIDAgOiBhcHBlbmRlZERhdGVSYW5nZUN1ZXMuZHVyYXRpb25Lbm93bikgfHwgZmFsc2U7XG4gICAgICBsZXQgZW5kVGltZSA9IE1BWF9DVUVfRU5EVElNRTtcbiAgICAgIGNvbnN0IGVuZERhdGUgPSBkYXRlUmFuZ2UuZW5kRGF0ZTtcbiAgICAgIGlmIChlbmREYXRlKSB7XG4gICAgICAgIGVuZFRpbWUgPSBkYXRlUmFuZ2VEYXRlVG9UaW1lbGluZVNlY29uZHMoZW5kRGF0ZSwgZGF0ZVRpbWVPZmZzZXQpO1xuICAgICAgICBkdXJhdGlvbktub3duID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0ZVJhbmdlLmVuZE9uTmV4dCAmJiAhZHVyYXRpb25Lbm93bikge1xuICAgICAgICBjb25zdCBuZXh0RGF0ZVJhbmdlV2l0aFNhbWVDbGFzcyA9IGlkcy5yZWR1Y2UoKGNhbmRpZGF0ZURhdGVSYW5nZSwgaWQpID0+IHtcbiAgICAgICAgICBpZiAoaWQgIT09IGRhdGVSYW5nZS5pZCkge1xuICAgICAgICAgICAgY29uc3Qgb3RoZXJEYXRlUmFuZ2UgPSBkYXRlUmFuZ2VzW2lkXTtcbiAgICAgICAgICAgIGlmIChvdGhlckRhdGVSYW5nZS5jbGFzcyA9PT0gZGF0ZVJhbmdlLmNsYXNzICYmIG90aGVyRGF0ZVJhbmdlLnN0YXJ0RGF0ZSA+IGRhdGVSYW5nZS5zdGFydERhdGUgJiYgKCFjYW5kaWRhdGVEYXRlUmFuZ2UgfHwgZGF0ZVJhbmdlLnN0YXJ0RGF0ZSA8IGNhbmRpZGF0ZURhdGVSYW5nZS5zdGFydERhdGUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBvdGhlckRhdGVSYW5nZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZURhdGVSYW5nZTtcbiAgICAgICAgfSwgbnVsbCk7XG4gICAgICAgIGlmIChuZXh0RGF0ZVJhbmdlV2l0aFNhbWVDbGFzcykge1xuICAgICAgICAgIGVuZFRpbWUgPSBkYXRlUmFuZ2VEYXRlVG9UaW1lbGluZVNlY29uZHMobmV4dERhdGVSYW5nZVdpdGhTYW1lQ2xhc3Muc3RhcnREYXRlLCBkYXRlVGltZU9mZnNldCk7XG4gICAgICAgICAgZHVyYXRpb25Lbm93biA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIFRleHRUcmFjayBDdWVzIGZvciBlYWNoIE1ldGFkYXRhR3JvdXAgSXRlbSAoc2VsZWN0IERhdGVSYW5nZSBhdHRyaWJ1dGUpXG4gICAgICAvLyBUaGlzIGlzIHRvIGVtdWxhdGUgU2FmYXJpIEhMUyBwbGF5YmFjayBoYW5kbGluZyBvZiBEYXRlUmFuZ2UgdGFnc1xuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IE9iamVjdC5rZXlzKGRhdGVSYW5nZS5hdHRyKTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYXR0cmlidXRlcy5sZW5ndGg7IGorKykge1xuICAgICAgICBjb25zdCBrZXkgPSBhdHRyaWJ1dGVzW2pdO1xuICAgICAgICBpZiAoIWlzRGF0ZVJhbmdlQ3VlQXR0cmlidXRlKGtleSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdWUgPSBjdWVzW2tleV07XG4gICAgICAgIGlmIChjdWUpIHtcbiAgICAgICAgICBpZiAoZHVyYXRpb25Lbm93biAmJiAhYXBwZW5kZWREYXRlUmFuZ2VDdWVzLmR1cmF0aW9uS25vd24pIHtcbiAgICAgICAgICAgIGN1ZS5lbmRUaW1lID0gZW5kVGltZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoQ3VlKSB7XG4gICAgICAgICAgbGV0IGRhdGEgPSBkYXRlUmFuZ2UuYXR0cltrZXldO1xuICAgICAgICAgIGlmIChpc1NDVEUzNUF0dHJpYnV0ZShrZXkpKSB7XG4gICAgICAgICAgICBkYXRhID0gaGV4VG9BcnJheUJ1ZmZlcihkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgX2N1ZSA9IGNyZWF0ZUN1ZVdpdGhEYXRhRmllbGRzKEN1ZSwgc3RhcnRUaW1lLCBlbmRUaW1lLCB7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBkYXRhXG4gICAgICAgICAgfSwgTWV0YWRhdGFTY2hlbWEuZGF0ZVJhbmdlKTtcbiAgICAgICAgICBpZiAoX2N1ZSkge1xuICAgICAgICAgICAgX2N1ZS5pZCA9IGlkO1xuICAgICAgICAgICAgdGhpcy5pZDNUcmFjay5hZGRDdWUoX2N1ZSk7XG4gICAgICAgICAgICBjdWVzW2tleV0gPSBfY3VlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBLZWVwIHRyYWNrIG9mIHByb2Nlc3NlZCBEYXRlUmFuZ2VzIGJ5IElEIGZvciB1cGRhdGluZyBjdWVzIHdpdGggbmV3IERhdGVSYW5nZSB0YWcgYXR0cmlidXRlc1xuICAgICAgZGF0ZVJhbmdlQ3Vlc0FwcGVuZGVkW2lkXSA9IHtcbiAgICAgICAgY3VlcyxcbiAgICAgICAgZGF0ZVJhbmdlLFxuICAgICAgICBkdXJhdGlvbktub3duXG4gICAgICB9O1xuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBMYXRlbmN5Q29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIHRoaXMubGV2ZWxEZXRhaWxzID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gMDtcbiAgICB0aGlzLnN0YWxsQ291bnQgPSAwO1xuICAgIHRoaXMuX2xhdGVuY3kgPSBudWxsO1xuICAgIHRoaXMudGltZXVwZGF0ZUhhbmRsZXIgPSAoKSA9PiB0aGlzLnRpbWV1cGRhdGUoKTtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLmNvbmZpZyA9IGhscy5jb25maWc7XG4gICAgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG4gIGdldCBsYXRlbmN5KCkge1xuICAgIHJldHVybiB0aGlzLl9sYXRlbmN5IHx8IDA7XG4gIH1cbiAgZ2V0IG1heExhdGVuY3koKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29uZmlnLFxuICAgICAgbGV2ZWxEZXRhaWxzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIGxldmVsRGV0YWlscyA/IGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQgKiBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb24gOiAwO1xuICB9XG4gIGdldCB0YXJnZXRMYXRlbmN5KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGxldmVsRGV0YWlsc1xuICAgIH0gPSB0aGlzO1xuICAgIGlmIChsZXZlbERldGFpbHMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBob2xkQmFjayxcbiAgICAgIHBhcnRIb2xkQmFjayxcbiAgICAgIHRhcmdldGR1cmF0aW9uXG4gICAgfSA9IGxldmVsRGV0YWlscztcbiAgICBjb25zdCB7XG4gICAgICBsaXZlU3luY0R1cmF0aW9uLFxuICAgICAgbGl2ZVN5bmNEdXJhdGlvbkNvdW50LFxuICAgICAgbG93TGF0ZW5jeU1vZGVcbiAgICB9ID0gdGhpcy5jb25maWc7XG4gICAgY29uc3QgdXNlckNvbmZpZyA9IHRoaXMuaGxzLnVzZXJDb25maWc7XG4gICAgbGV0IHRhcmdldExhdGVuY3kgPSBsb3dMYXRlbmN5TW9kZSA/IHBhcnRIb2xkQmFjayB8fCBob2xkQmFjayA6IGhvbGRCYWNrO1xuICAgIGlmICh1c2VyQ29uZmlnLmxpdmVTeW5jRHVyYXRpb24gfHwgdXNlckNvbmZpZy5saXZlU3luY0R1cmF0aW9uQ291bnQgfHwgdGFyZ2V0TGF0ZW5jeSA9PT0gMCkge1xuICAgICAgdGFyZ2V0TGF0ZW5jeSA9IGxpdmVTeW5jRHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IGxpdmVTeW5jRHVyYXRpb24gOiBsaXZlU3luY0R1cmF0aW9uQ291bnQgKiB0YXJnZXRkdXJhdGlvbjtcbiAgICB9XG4gICAgY29uc3QgbWF4TGl2ZVN5bmNPblN0YWxsSW5jcmVhc2UgPSB0YXJnZXRkdXJhdGlvbjtcbiAgICBjb25zdCBsaXZlU3luY09uU3RhbGxJbmNyZWFzZSA9IDEuMDtcbiAgICByZXR1cm4gdGFyZ2V0TGF0ZW5jeSArIE1hdGgubWluKHRoaXMuc3RhbGxDb3VudCAqIGxpdmVTeW5jT25TdGFsbEluY3JlYXNlLCBtYXhMaXZlU3luY09uU3RhbGxJbmNyZWFzZSk7XG4gIH1cbiAgZ2V0IGxpdmVTeW5jUG9zaXRpb24oKSB7XG4gICAgY29uc3QgbGl2ZUVkZ2UgPSB0aGlzLmVzdGltYXRlTGl2ZUVkZ2UoKTtcbiAgICBjb25zdCB0YXJnZXRMYXRlbmN5ID0gdGhpcy50YXJnZXRMYXRlbmN5O1xuICAgIGNvbnN0IGxldmVsRGV0YWlscyA9IHRoaXMubGV2ZWxEZXRhaWxzO1xuICAgIGlmIChsaXZlRWRnZSA9PT0gbnVsbCB8fCB0YXJnZXRMYXRlbmN5ID09PSBudWxsIHx8IGxldmVsRGV0YWlscyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGVkZ2UgPSBsZXZlbERldGFpbHMuZWRnZTtcbiAgICBjb25zdCBzeW5jUG9zaXRpb24gPSBsaXZlRWRnZSAtIHRhcmdldExhdGVuY3kgLSB0aGlzLmVkZ2VTdGFsbGVkO1xuICAgIGNvbnN0IG1pbiA9IGVkZ2UgLSBsZXZlbERldGFpbHMudG90YWxkdXJhdGlvbjtcbiAgICBjb25zdCBtYXggPSBlZGdlIC0gKHRoaXMuY29uZmlnLmxvd0xhdGVuY3lNb2RlICYmIGxldmVsRGV0YWlscy5wYXJ0VGFyZ2V0IHx8IGxldmVsRGV0YWlscy50YXJnZXRkdXJhdGlvbik7XG4gICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG1pbiwgc3luY1Bvc2l0aW9uKSwgbWF4KTtcbiAgfVxuICBnZXQgZHJpZnQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgbGV2ZWxEZXRhaWxzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKGxldmVsRGV0YWlscyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiBsZXZlbERldGFpbHMuZHJpZnQ7XG4gIH1cbiAgZ2V0IGVkZ2VTdGFsbGVkKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGxldmVsRGV0YWlsc1xuICAgIH0gPSB0aGlzO1xuICAgIGlmIChsZXZlbERldGFpbHMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjb25zdCBtYXhMZXZlbFVwZGF0ZUFnZSA9ICh0aGlzLmNvbmZpZy5sb3dMYXRlbmN5TW9kZSAmJiBsZXZlbERldGFpbHMucGFydFRhcmdldCB8fCBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb24pICogMztcbiAgICByZXR1cm4gTWF0aC5tYXgobGV2ZWxEZXRhaWxzLmFnZSAtIG1heExldmVsVXBkYXRlQWdlLCAwKTtcbiAgfVxuICBnZXQgZm9yd2FyZEJ1ZmZlckxlbmd0aCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBtZWRpYSxcbiAgICAgIGxldmVsRGV0YWlsc1xuICAgIH0gPSB0aGlzO1xuICAgIGlmICghbWVkaWEgfHwgIWxldmVsRGV0YWlscykge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmZlcmVkUmFuZ2VzID0gbWVkaWEuYnVmZmVyZWQubGVuZ3RoO1xuICAgIHJldHVybiAoYnVmZmVyZWRSYW5nZXMgPyBtZWRpYS5idWZmZXJlZC5lbmQoYnVmZmVyZWRSYW5nZXMgLSAxKSA6IGxldmVsRGV0YWlscy5lZGdlKSAtIHRoaXMuY3VycmVudFRpbWU7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLm9uTWVkaWFEZXRhY2hpbmcoKTtcbiAgICB0aGlzLmxldmVsRGV0YWlscyA9IG51bGw7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuaGxzID0gdGhpcy50aW1ldXBkYXRlSGFuZGxlciA9IG51bGw7XG4gIH1cbiAgcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5obHMub24oRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgdGhpcy5obHMub24oRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICB0aGlzLmhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgdGhpcy5obHMub24oRXZlbnRzLkxFVkVMX1VQREFURUQsIHRoaXMub25MZXZlbFVwZGF0ZWQsIHRoaXMpO1xuICAgIHRoaXMuaGxzLm9uKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfVxuICB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHRoaXMuaGxzLm9mZihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICB0aGlzLmhscy5vZmYoRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICB0aGlzLmhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIHRoaXMuaGxzLm9mZihFdmVudHMuTEVWRUxfVVBEQVRFRCwgdGhpcy5vbkxldmVsVXBkYXRlZCwgdGhpcyk7XG4gICAgdGhpcy5obHMub2ZmKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfVxuICBvbk1lZGlhQXR0YWNoZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYTtcbiAgICB0aGlzLm1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ3RpbWV1cGRhdGUnLCB0aGlzLnRpbWV1cGRhdGVIYW5kbGVyKTtcbiAgfVxuICBvbk1lZGlhRGV0YWNoaW5nKCkge1xuICAgIGlmICh0aGlzLm1lZGlhKSB7XG4gICAgICB0aGlzLm1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RpbWV1cGRhdGUnLCB0aGlzLnRpbWV1cGRhdGVIYW5kbGVyKTtcbiAgICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIH1cbiAgfVxuICBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICB0aGlzLmxldmVsRGV0YWlscyA9IG51bGw7XG4gICAgdGhpcy5fbGF0ZW5jeSA9IG51bGw7XG4gICAgdGhpcy5zdGFsbENvdW50ID0gMDtcbiAgfVxuICBvbkxldmVsVXBkYXRlZChldmVudCwge1xuICAgIGRldGFpbHNcbiAgfSkge1xuICAgIHRoaXMubGV2ZWxEZXRhaWxzID0gZGV0YWlscztcbiAgICBpZiAoZGV0YWlscy5hZHZhbmNlZCkge1xuICAgICAgdGhpcy50aW1ldXBkYXRlKCk7XG4gICAgfVxuICAgIGlmICghZGV0YWlscy5saXZlICYmIHRoaXMubWVkaWEpIHtcbiAgICAgIHRoaXMubWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGltZXVwZGF0ZScsIHRoaXMudGltZXVwZGF0ZUhhbmRsZXIpO1xuICAgIH1cbiAgfVxuICBvbkVycm9yKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIF90aGlzJGxldmVsRGV0YWlscztcbiAgICBpZiAoZGF0YS5kZXRhaWxzICE9PSBFcnJvckRldGFpbHMuQlVGRkVSX1NUQUxMRURfRVJST1IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zdGFsbENvdW50Kys7XG4gICAgaWYgKChfdGhpcyRsZXZlbERldGFpbHMgPSB0aGlzLmxldmVsRGV0YWlscykgIT0gbnVsbCAmJiBfdGhpcyRsZXZlbERldGFpbHMubGl2ZSkge1xuICAgICAgbG9nZ2VyLndhcm4oJ1twbGF5YmFjay1yYXRlLWNvbnRyb2xsZXJdOiBTdGFsbCBkZXRlY3RlZCwgYWRqdXN0aW5nIHRhcmdldCBsYXRlbmN5Jyk7XG4gICAgfVxuICB9XG4gIHRpbWV1cGRhdGUoKSB7XG4gICAgY29uc3Qge1xuICAgICAgbWVkaWEsXG4gICAgICBsZXZlbERldGFpbHNcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIW1lZGlhIHx8ICFsZXZlbERldGFpbHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIGNvbnN0IGxhdGVuY3kgPSB0aGlzLmNvbXB1dGVMYXRlbmN5KCk7XG4gICAgaWYgKGxhdGVuY3kgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fbGF0ZW5jeSA9IGxhdGVuY3k7XG5cbiAgICAvLyBBZGFwdCBwbGF5YmFja1JhdGUgdG8gbWVldCB0YXJnZXQgbGF0ZW5jeSBpbiBsb3ctbGF0ZW5jeSBtb2RlXG4gICAgY29uc3Qge1xuICAgICAgbG93TGF0ZW5jeU1vZGUsXG4gICAgICBtYXhMaXZlU3luY1BsYXliYWNrUmF0ZVxuICAgIH0gPSB0aGlzLmNvbmZpZztcbiAgICBpZiAoIWxvd0xhdGVuY3lNb2RlIHx8IG1heExpdmVTeW5jUGxheWJhY2tSYXRlID09PSAxIHx8ICFsZXZlbERldGFpbHMubGl2ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRMYXRlbmN5ID0gdGhpcy50YXJnZXRMYXRlbmN5O1xuICAgIGlmICh0YXJnZXRMYXRlbmN5ID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRpc3RhbmNlRnJvbVRhcmdldCA9IGxhdGVuY3kgLSB0YXJnZXRMYXRlbmN5O1xuICAgIC8vIE9ubHkgYWRqdXN0IHBsYXliYWNrUmF0ZSB3aGVuIHdpdGhpbiBvbmUgdGFyZ2V0IGR1cmF0aW9uIG9mIHRhcmdldExhdGVuY3lcbiAgICAvLyBhbmQgbW9yZSB0aGFuIG9uZSBzZWNvbmQgZnJvbSB1bmRlci1idWZmZXJpbmcuXG4gICAgLy8gUGxheWJhY2sgZnVydGhlciB0aGFuIG9uZSB0YXJnZXQgZHVyYXRpb24gZnJvbSB0YXJnZXQgY2FuIGJlIGNvbnNpZGVyZWQgRFZSIHBsYXliYWNrLlxuICAgIGNvbnN0IGxpdmVNaW5MYXRlbmN5RHVyYXRpb24gPSBNYXRoLm1pbih0aGlzLm1heExhdGVuY3ksIHRhcmdldExhdGVuY3kgKyBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb24pO1xuICAgIGNvbnN0IGluTGl2ZVJhbmdlID0gZGlzdGFuY2VGcm9tVGFyZ2V0IDwgbGl2ZU1pbkxhdGVuY3lEdXJhdGlvbjtcbiAgICBpZiAoaW5MaXZlUmFuZ2UgJiYgZGlzdGFuY2VGcm9tVGFyZ2V0ID4gMC4wNSAmJiB0aGlzLmZvcndhcmRCdWZmZXJMZW5ndGggPiAxKSB7XG4gICAgICBjb25zdCBtYXggPSBNYXRoLm1pbigyLCBNYXRoLm1heCgxLjAsIG1heExpdmVTeW5jUGxheWJhY2tSYXRlKSk7XG4gICAgICBjb25zdCByYXRlID0gTWF0aC5yb3VuZCgyIC8gKDEgKyBNYXRoLmV4cCgtMC43NSAqIGRpc3RhbmNlRnJvbVRhcmdldCAtIHRoaXMuZWRnZVN0YWxsZWQpKSAqIDIwKSAvIDIwO1xuICAgICAgbWVkaWEucGxheWJhY2tSYXRlID0gTWF0aC5taW4obWF4LCBNYXRoLm1heCgxLCByYXRlKSk7XG4gICAgfSBlbHNlIGlmIChtZWRpYS5wbGF5YmFja1JhdGUgIT09IDEgJiYgbWVkaWEucGxheWJhY2tSYXRlICE9PSAwKSB7XG4gICAgICBtZWRpYS5wbGF5YmFja1JhdGUgPSAxO1xuICAgIH1cbiAgfVxuICBlc3RpbWF0ZUxpdmVFZGdlKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGxldmVsRGV0YWlsc1xuICAgIH0gPSB0aGlzO1xuICAgIGlmIChsZXZlbERldGFpbHMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbGV2ZWxEZXRhaWxzLmVkZ2UgKyBsZXZlbERldGFpbHMuYWdlO1xuICB9XG4gIGNvbXB1dGVMYXRlbmN5KCkge1xuICAgIGNvbnN0IGxpdmVFZGdlID0gdGhpcy5lc3RpbWF0ZUxpdmVFZGdlKCk7XG4gICAgaWYgKGxpdmVFZGdlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGxpdmVFZGdlIC0gdGhpcy5jdXJyZW50VGltZTtcbiAgfVxufVxuXG5jb25zdCBIZGNwTGV2ZWxzID0gWydOT05FJywgJ1RZUEUtMCcsICdUWVBFLTEnLCBudWxsXTtcbmZ1bmN0aW9uIGlzSGRjcExldmVsKHZhbHVlKSB7XG4gIHJldHVybiBIZGNwTGV2ZWxzLmluZGV4T2YodmFsdWUpID4gLTE7XG59XG5jb25zdCBWaWRlb1JhbmdlVmFsdWVzID0gWydTRFInLCAnUFEnLCAnSExHJ107XG5mdW5jdGlvbiBpc1ZpZGVvUmFuZ2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgVmlkZW9SYW5nZVZhbHVlcy5pbmRleE9mKHZhbHVlKSA+IC0xO1xufVxudmFyIEhsc1NraXAgPSB7XG4gIE5vOiBcIlwiLFxuICBZZXM6IFwiWUVTXCIsXG4gIHYyOiBcInYyXCJcbn07XG5mdW5jdGlvbiBnZXRTa2lwVmFsdWUoZGV0YWlscywgbXNuKSB7XG4gIGNvbnN0IHtcbiAgICBjYW5Ta2lwVW50aWwsXG4gICAgY2FuU2tpcERhdGVSYW5nZXMsXG4gICAgZW5kU05cbiAgfSA9IGRldGFpbHM7XG4gIGNvbnN0IHNuQ2hhbmdlR29hbCA9IG1zbiAhPT0gdW5kZWZpbmVkID8gbXNuIC0gZW5kU04gOiAwO1xuICBpZiAoY2FuU2tpcFVudGlsICYmIHNuQ2hhbmdlR29hbCA8IGNhblNraXBVbnRpbCkge1xuICAgIGlmIChjYW5Ta2lwRGF0ZVJhbmdlcykge1xuICAgICAgcmV0dXJuIEhsc1NraXAudjI7XG4gICAgfVxuICAgIHJldHVybiBIbHNTa2lwLlllcztcbiAgfVxuICByZXR1cm4gSGxzU2tpcC5Obztcbn1cbmNsYXNzIEhsc1VybFBhcmFtZXRlcnMge1xuICBjb25zdHJ1Y3Rvcihtc24sIHBhcnQsIHNraXApIHtcbiAgICB0aGlzLm1zbiA9IHZvaWQgMDtcbiAgICB0aGlzLnBhcnQgPSB2b2lkIDA7XG4gICAgdGhpcy5za2lwID0gdm9pZCAwO1xuICAgIHRoaXMubXNuID0gbXNuO1xuICAgIHRoaXMucGFydCA9IHBhcnQ7XG4gICAgdGhpcy5za2lwID0gc2tpcDtcbiAgfVxuICBhZGREaXJlY3RpdmVzKHVyaSkge1xuICAgIGNvbnN0IHVybCA9IG5ldyBzZWxmLlVSTCh1cmkpO1xuICAgIGlmICh0aGlzLm1zbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnX0hMU19tc24nLCB0aGlzLm1zbi50b1N0cmluZygpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMucGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnX0hMU19wYXJ0JywgdGhpcy5wYXJ0LnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5za2lwKSB7XG4gICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnX0hMU19za2lwJywgdGhpcy5za2lwKTtcbiAgICB9XG4gICAgcmV0dXJuIHVybC5ocmVmO1xuICB9XG59XG5jbGFzcyBMZXZlbCB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICB0aGlzLl9hdHRycyA9IHZvaWQgMDtcbiAgICB0aGlzLmF1ZGlvQ29kZWMgPSB2b2lkIDA7XG4gICAgdGhpcy5iaXRyYXRlID0gdm9pZCAwO1xuICAgIHRoaXMuY29kZWNTZXQgPSB2b2lkIDA7XG4gICAgdGhpcy51cmwgPSB2b2lkIDA7XG4gICAgdGhpcy5mcmFtZVJhdGUgPSB2b2lkIDA7XG4gICAgdGhpcy5oZWlnaHQgPSB2b2lkIDA7XG4gICAgdGhpcy5pZCA9IHZvaWQgMDtcbiAgICB0aGlzLm5hbWUgPSB2b2lkIDA7XG4gICAgdGhpcy52aWRlb0NvZGVjID0gdm9pZCAwO1xuICAgIHRoaXMud2lkdGggPSB2b2lkIDA7XG4gICAgdGhpcy5kZXRhaWxzID0gdm9pZCAwO1xuICAgIHRoaXMuZnJhZ21lbnRFcnJvciA9IDA7XG4gICAgdGhpcy5sb2FkRXJyb3IgPSAwO1xuICAgIHRoaXMubG9hZGVkID0gdm9pZCAwO1xuICAgIHRoaXMucmVhbEJpdHJhdGUgPSAwO1xuICAgIHRoaXMuc3VwcG9ydGVkUHJvbWlzZSA9IHZvaWQgMDtcbiAgICB0aGlzLnN1cHBvcnRlZFJlc3VsdCA9IHZvaWQgMDtcbiAgICB0aGlzLl9hdmdCaXRyYXRlID0gMDtcbiAgICB0aGlzLl9hdWRpb0dyb3VwcyA9IHZvaWQgMDtcbiAgICB0aGlzLl9zdWJ0aXRsZUdyb3VwcyA9IHZvaWQgMDtcbiAgICAvLyBEZXByZWNhdGVkIChyZXRhaW5lZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkpXG4gICAgdGhpcy5fdXJsSWQgPSAwO1xuICAgIHRoaXMudXJsID0gW2RhdGEudXJsXTtcbiAgICB0aGlzLl9hdHRycyA9IFtkYXRhLmF0dHJzXTtcbiAgICB0aGlzLmJpdHJhdGUgPSBkYXRhLmJpdHJhdGU7XG4gICAgaWYgKGRhdGEuZGV0YWlscykge1xuICAgICAgdGhpcy5kZXRhaWxzID0gZGF0YS5kZXRhaWxzO1xuICAgIH1cbiAgICB0aGlzLmlkID0gZGF0YS5pZCB8fCAwO1xuICAgIHRoaXMubmFtZSA9IGRhdGEubmFtZTtcbiAgICB0aGlzLndpZHRoID0gZGF0YS53aWR0aCB8fCAwO1xuICAgIHRoaXMuaGVpZ2h0ID0gZGF0YS5oZWlnaHQgfHwgMDtcbiAgICB0aGlzLmZyYW1lUmF0ZSA9IGRhdGEuYXR0cnMub3B0aW9uYWxGbG9hdCgnRlJBTUUtUkFURScsIDApO1xuICAgIHRoaXMuX2F2Z0JpdHJhdGUgPSBkYXRhLmF0dHJzLmRlY2ltYWxJbnRlZ2VyKCdBVkVSQUdFLUJBTkRXSURUSCcpO1xuICAgIHRoaXMuYXVkaW9Db2RlYyA9IGRhdGEuYXVkaW9Db2RlYztcbiAgICB0aGlzLnZpZGVvQ29kZWMgPSBkYXRhLnZpZGVvQ29kZWM7XG4gICAgdGhpcy5jb2RlY1NldCA9IFtkYXRhLnZpZGVvQ29kZWMsIGRhdGEuYXVkaW9Db2RlY10uZmlsdGVyKGMgPT4gISFjKS5tYXAocyA9PiBzLnN1YnN0cmluZygwLCA0KSkuam9pbignLCcpO1xuICAgIHRoaXMuYWRkR3JvdXBJZCgnYXVkaW8nLCBkYXRhLmF0dHJzLkFVRElPKTtcbiAgICB0aGlzLmFkZEdyb3VwSWQoJ3RleHQnLCBkYXRhLmF0dHJzLlNVQlRJVExFUyk7XG4gIH1cbiAgZ2V0IG1heEJpdHJhdGUoKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KHRoaXMucmVhbEJpdHJhdGUsIHRoaXMuYml0cmF0ZSk7XG4gIH1cbiAgZ2V0IGF2ZXJhZ2VCaXRyYXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9hdmdCaXRyYXRlIHx8IHRoaXMucmVhbEJpdHJhdGUgfHwgdGhpcy5iaXRyYXRlO1xuICB9XG4gIGdldCBhdHRycygpIHtcbiAgICByZXR1cm4gdGhpcy5fYXR0cnNbMF07XG4gIH1cbiAgZ2V0IGNvZGVjcygpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRycy5DT0RFQ1MgfHwgJyc7XG4gIH1cbiAgZ2V0IHBhdGh3YXlJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyc1snUEFUSFdBWS1JRCddIHx8ICcuJztcbiAgfVxuICBnZXQgdmlkZW9SYW5nZSgpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyc1snVklERU8tUkFOR0UnXSB8fCAnU0RSJztcbiAgfVxuICBnZXQgc2NvcmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cnMub3B0aW9uYWxGbG9hdCgnU0NPUkUnLCAwKTtcbiAgfVxuICBnZXQgdXJpKCkge1xuICAgIHJldHVybiB0aGlzLnVybFswXSB8fCAnJztcbiAgfVxuICBoYXNBdWRpb0dyb3VwKGdyb3VwSWQpIHtcbiAgICByZXR1cm4gaGFzR3JvdXAodGhpcy5fYXVkaW9Hcm91cHMsIGdyb3VwSWQpO1xuICB9XG4gIGhhc1N1YnRpdGxlR3JvdXAoZ3JvdXBJZCkge1xuICAgIHJldHVybiBoYXNHcm91cCh0aGlzLl9zdWJ0aXRsZUdyb3VwcywgZ3JvdXBJZCk7XG4gIH1cbiAgZ2V0IGF1ZGlvR3JvdXBzKCkge1xuICAgIHJldHVybiB0aGlzLl9hdWRpb0dyb3VwcztcbiAgfVxuICBnZXQgc3VidGl0bGVHcm91cHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N1YnRpdGxlR3JvdXBzO1xuICB9XG4gIGFkZEdyb3VwSWQodHlwZSwgZ3JvdXBJZCkge1xuICAgIGlmICghZ3JvdXBJZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgbGV0IGF1ZGlvR3JvdXBzID0gdGhpcy5fYXVkaW9Hcm91cHM7XG4gICAgICBpZiAoIWF1ZGlvR3JvdXBzKSB7XG4gICAgICAgIGF1ZGlvR3JvdXBzID0gdGhpcy5fYXVkaW9Hcm91cHMgPSBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChhdWRpb0dyb3Vwcy5pbmRleE9mKGdyb3VwSWQpID09PSAtMSkge1xuICAgICAgICBhdWRpb0dyb3Vwcy5wdXNoKGdyb3VwSWQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICBsZXQgc3VidGl0bGVHcm91cHMgPSB0aGlzLl9zdWJ0aXRsZUdyb3VwcztcbiAgICAgIGlmICghc3VidGl0bGVHcm91cHMpIHtcbiAgICAgICAgc3VidGl0bGVHcm91cHMgPSB0aGlzLl9zdWJ0aXRsZUdyb3VwcyA9IFtdO1xuICAgICAgfVxuICAgICAgaWYgKHN1YnRpdGxlR3JvdXBzLmluZGV4T2YoZ3JvdXBJZCkgPT09IC0xKSB7XG4gICAgICAgIHN1YnRpdGxlR3JvdXBzLnB1c2goZ3JvdXBJZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gRGVwcmVjYXRlZCBtZXRob2RzIChyZXRhaW5lZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkpXG4gIGdldCB1cmxJZCgpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBzZXQgdXJsSWQodmFsdWUpIHt9XG4gIGdldCBhdWRpb0dyb3VwSWRzKCkge1xuICAgIHJldHVybiB0aGlzLmF1ZGlvR3JvdXBzID8gW3RoaXMuYXVkaW9Hcm91cElkXSA6IHVuZGVmaW5lZDtcbiAgfVxuICBnZXQgdGV4dEdyb3VwSWRzKCkge1xuICAgIHJldHVybiB0aGlzLnN1YnRpdGxlR3JvdXBzID8gW3RoaXMudGV4dEdyb3VwSWRdIDogdW5kZWZpbmVkO1xuICB9XG4gIGdldCBhdWRpb0dyb3VwSWQoKSB7XG4gICAgdmFyIF90aGlzJGF1ZGlvR3JvdXBzO1xuICAgIHJldHVybiAoX3RoaXMkYXVkaW9Hcm91cHMgPSB0aGlzLmF1ZGlvR3JvdXBzKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkYXVkaW9Hcm91cHNbMF07XG4gIH1cbiAgZ2V0IHRleHRHcm91cElkKCkge1xuICAgIHZhciBfdGhpcyRzdWJ0aXRsZUdyb3VwcztcbiAgICByZXR1cm4gKF90aGlzJHN1YnRpdGxlR3JvdXBzID0gdGhpcy5zdWJ0aXRsZUdyb3VwcykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHN1YnRpdGxlR3JvdXBzWzBdO1xuICB9XG4gIGFkZEZhbGxiYWNrKCkge31cbn1cbmZ1bmN0aW9uIGhhc0dyb3VwKGdyb3VwcywgZ3JvdXBJZCkge1xuICBpZiAoIWdyb3VwSWQgfHwgIWdyb3Vwcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gZ3JvdXBzLmluZGV4T2YoZ3JvdXBJZCkgIT09IC0xO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVGcm9tVG9QVFMoZnJhZ0Zyb20sIGZyYWdUbykge1xuICBjb25zdCBmcmFnVG9QVFMgPSBmcmFnVG8uc3RhcnRQVFM7XG4gIC8vIGlmIHdlIGtub3cgc3RhcnRQVFNbdG9JZHhdXG4gIGlmIChpc0Zpbml0ZU51bWJlcihmcmFnVG9QVFMpKSB7XG4gICAgLy8gdXBkYXRlIGZyYWdtZW50IGR1cmF0aW9uLlxuICAgIC8vIGl0IGhlbHBzIHRvIGZpeCBkcmlmdHMgYmV0d2VlbiBwbGF5bGlzdCByZXBvcnRlZCBkdXJhdGlvbiBhbmQgZnJhZ21lbnQgcmVhbCBkdXJhdGlvblxuICAgIGxldCBkdXJhdGlvbiA9IDA7XG4gICAgbGV0IGZyYWc7XG4gICAgaWYgKGZyYWdUby5zbiA+IGZyYWdGcm9tLnNuKSB7XG4gICAgICBkdXJhdGlvbiA9IGZyYWdUb1BUUyAtIGZyYWdGcm9tLnN0YXJ0O1xuICAgICAgZnJhZyA9IGZyYWdGcm9tO1xuICAgIH0gZWxzZSB7XG4gICAgICBkdXJhdGlvbiA9IGZyYWdGcm9tLnN0YXJ0IC0gZnJhZ1RvUFRTO1xuICAgICAgZnJhZyA9IGZyYWdUbztcbiAgICB9XG4gICAgaWYgKGZyYWcuZHVyYXRpb24gIT09IGR1cmF0aW9uKSB7XG4gICAgICBmcmFnLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgfVxuICAgIC8vIHdlIGRvbnQga25vdyBzdGFydFBUU1t0b0lkeF1cbiAgfSBlbHNlIGlmIChmcmFnVG8uc24gPiBmcmFnRnJvbS5zbikge1xuICAgIGNvbnN0IGNvbnRpZ3VvdXMgPSBmcmFnRnJvbS5jYyA9PT0gZnJhZ1RvLmNjO1xuICAgIC8vIFRPRE86IFdpdGggcGFydC1sb2FkaW5nIGVuZC9kdXJhdGlvbnMgd2UgbmVlZCB0byBjb25maXJtIHRoZSB3aG9sZSBmcmFnbWVudCBpcyBsb2FkZWQgYmVmb3JlIHVzaW5nIChvciBzZXR0aW5nKSBtaW5FbmRQVFNcbiAgICBpZiAoY29udGlndW91cyAmJiBmcmFnRnJvbS5taW5FbmRQVFMpIHtcbiAgICAgIGZyYWdUby5zdGFydCA9IGZyYWdGcm9tLnN0YXJ0ICsgKGZyYWdGcm9tLm1pbkVuZFBUUyAtIGZyYWdGcm9tLnN0YXJ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnJhZ1RvLnN0YXJ0ID0gZnJhZ0Zyb20uc3RhcnQgKyBmcmFnRnJvbS5kdXJhdGlvbjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZnJhZ1RvLnN0YXJ0ID0gTWF0aC5tYXgoZnJhZ0Zyb20uc3RhcnQgLSBmcmFnVG8uZHVyYXRpb24sIDApO1xuICB9XG59XG5mdW5jdGlvbiB1cGRhdGVGcmFnUFRTRFRTKGRldGFpbHMsIGZyYWcsIHN0YXJ0UFRTLCBlbmRQVFMsIHN0YXJ0RFRTLCBlbmREVFMpIHtcbiAgY29uc3QgcGFyc2VkTWVkaWFEdXJhdGlvbiA9IGVuZFBUUyAtIHN0YXJ0UFRTO1xuICBpZiAocGFyc2VkTWVkaWFEdXJhdGlvbiA8PSAwKSB7XG4gICAgbG9nZ2VyLndhcm4oJ0ZyYWdtZW50IHNob3VsZCBoYXZlIGEgcG9zaXRpdmUgZHVyYXRpb24nLCBmcmFnKTtcbiAgICBlbmRQVFMgPSBzdGFydFBUUyArIGZyYWcuZHVyYXRpb247XG4gICAgZW5kRFRTID0gc3RhcnREVFMgKyBmcmFnLmR1cmF0aW9uO1xuICB9XG4gIGxldCBtYXhTdGFydFBUUyA9IHN0YXJ0UFRTO1xuICBsZXQgbWluRW5kUFRTID0gZW5kUFRTO1xuICBjb25zdCBmcmFnU3RhcnRQdHMgPSBmcmFnLnN0YXJ0UFRTO1xuICBjb25zdCBmcmFnRW5kUHRzID0gZnJhZy5lbmRQVFM7XG4gIGlmIChpc0Zpbml0ZU51bWJlcihmcmFnU3RhcnRQdHMpKSB7XG4gICAgLy8gZGVsdGEgUFRTIGJldHdlZW4gYXVkaW8gYW5kIHZpZGVvXG4gICAgY29uc3QgZGVsdGFQVFMgPSBNYXRoLmFicyhmcmFnU3RhcnRQdHMgLSBzdGFydFBUUyk7XG4gICAgaWYgKCFpc0Zpbml0ZU51bWJlcihmcmFnLmRlbHRhUFRTKSkge1xuICAgICAgZnJhZy5kZWx0YVBUUyA9IGRlbHRhUFRTO1xuICAgIH0gZWxzZSB7XG4gICAgICBmcmFnLmRlbHRhUFRTID0gTWF0aC5tYXgoZGVsdGFQVFMsIGZyYWcuZGVsdGFQVFMpO1xuICAgIH1cbiAgICBtYXhTdGFydFBUUyA9IE1hdGgubWF4KHN0YXJ0UFRTLCBmcmFnU3RhcnRQdHMpO1xuICAgIHN0YXJ0UFRTID0gTWF0aC5taW4oc3RhcnRQVFMsIGZyYWdTdGFydFB0cyk7XG4gICAgc3RhcnREVFMgPSBNYXRoLm1pbihzdGFydERUUywgZnJhZy5zdGFydERUUyk7XG4gICAgbWluRW5kUFRTID0gTWF0aC5taW4oZW5kUFRTLCBmcmFnRW5kUHRzKTtcbiAgICBlbmRQVFMgPSBNYXRoLm1heChlbmRQVFMsIGZyYWdFbmRQdHMpO1xuICAgIGVuZERUUyA9IE1hdGgubWF4KGVuZERUUywgZnJhZy5lbmREVFMpO1xuICB9XG4gIGNvbnN0IGRyaWZ0ID0gc3RhcnRQVFMgLSBmcmFnLnN0YXJ0O1xuICBpZiAoZnJhZy5zdGFydCAhPT0gMCkge1xuICAgIGZyYWcuc3RhcnQgPSBzdGFydFBUUztcbiAgfVxuICBmcmFnLmR1cmF0aW9uID0gZW5kUFRTIC0gZnJhZy5zdGFydDtcbiAgZnJhZy5zdGFydFBUUyA9IHN0YXJ0UFRTO1xuICBmcmFnLm1heFN0YXJ0UFRTID0gbWF4U3RhcnRQVFM7XG4gIGZyYWcuc3RhcnREVFMgPSBzdGFydERUUztcbiAgZnJhZy5lbmRQVFMgPSBlbmRQVFM7XG4gIGZyYWcubWluRW5kUFRTID0gbWluRW5kUFRTO1xuICBmcmFnLmVuZERUUyA9IGVuZERUUztcbiAgY29uc3Qgc24gPSBmcmFnLnNuOyAvLyAnaW5pdFNlZ21lbnQnXG4gIC8vIGV4aXQgaWYgc24gb3V0IG9mIHJhbmdlXG4gIGlmICghZGV0YWlscyB8fCBzbiA8IGRldGFpbHMuc3RhcnRTTiB8fCBzbiA+IGRldGFpbHMuZW5kU04pIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBsZXQgaTtcbiAgY29uc3QgZnJhZ0lkeCA9IHNuIC0gZGV0YWlscy5zdGFydFNOO1xuICBjb25zdCBmcmFnbWVudHMgPSBkZXRhaWxzLmZyYWdtZW50cztcbiAgLy8gdXBkYXRlIGZyYWcgcmVmZXJlbmNlIGluIGZyYWdtZW50cyBhcnJheVxuICAvLyByYXRpb25hbGUgaXMgdGhhdCBmcmFnbWVudHMgYXJyYXkgbWlnaHQgbm90IGNvbnRhaW4gdGhpcyBmcmFnIG9iamVjdC5cbiAgLy8gdGhpcyB3aWxsIGhhcHBlbiBpZiBwbGF5bGlzdCBoYXMgYmVlbiByZWZyZXNoZWQgYmV0d2VlbiBmcmFnIGxvYWRpbmcgYW5kIGNhbGwgdG8gdXBkYXRlRnJhZ1BUU0RUUygpXG4gIC8vIGlmIHdlIGRvbid0IHVwZGF0ZSBmcmFnLCB3ZSB3b24ndCBiZSBhYmxlIHRvIHByb3BhZ2F0ZSBQVFMgaW5mbyBvbiB0aGUgcGxheWxpc3RcbiAgLy8gcmVzdWx0aW5nIGluIGludmFsaWQgc2xpZGluZyBjb21wdXRhdGlvblxuICBmcmFnbWVudHNbZnJhZ0lkeF0gPSBmcmFnO1xuICAvLyBhZGp1c3QgZnJhZ21lbnQgUFRTL2R1cmF0aW9uIGZyb20gc2VxbnVtLTEgdG8gZnJhZyAwXG4gIGZvciAoaSA9IGZyYWdJZHg7IGkgPiAwOyBpLS0pIHtcbiAgICB1cGRhdGVGcm9tVG9QVFMoZnJhZ21lbnRzW2ldLCBmcmFnbWVudHNbaSAtIDFdKTtcbiAgfVxuXG4gIC8vIGFkanVzdCBmcmFnbWVudCBQVFMvZHVyYXRpb24gZnJvbSBzZXFudW0gdG8gbGFzdCBmcmFnXG4gIGZvciAoaSA9IGZyYWdJZHg7IGkgPCBmcmFnbWVudHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgdXBkYXRlRnJvbVRvUFRTKGZyYWdtZW50c1tpXSwgZnJhZ21lbnRzW2kgKyAxXSk7XG4gIH1cbiAgaWYgKGRldGFpbHMuZnJhZ21lbnRIaW50KSB7XG4gICAgdXBkYXRlRnJvbVRvUFRTKGZyYWdtZW50c1tmcmFnbWVudHMubGVuZ3RoIC0gMV0sIGRldGFpbHMuZnJhZ21lbnRIaW50KTtcbiAgfVxuICBkZXRhaWxzLlBUU0tub3duID0gZGV0YWlscy5hbGlnbmVkU2xpZGluZyA9IHRydWU7XG4gIHJldHVybiBkcmlmdDtcbn1cbmZ1bmN0aW9uIG1lcmdlRGV0YWlscyhvbGREZXRhaWxzLCBuZXdEZXRhaWxzKSB7XG4gIC8vIFRyYWNrIHRoZSBsYXN0IGluaXRTZWdtZW50IHByb2Nlc3NlZC4gSW5pdGlhbGl6ZSBpdCB0byB0aGUgbGFzdCBvbmUgb24gdGhlIHRpbWVsaW5lLlxuICBsZXQgY3VycmVudEluaXRTZWdtZW50ID0gbnVsbDtcbiAgY29uc3Qgb2xkRnJhZ21lbnRzID0gb2xkRGV0YWlscy5mcmFnbWVudHM7XG4gIGZvciAobGV0IGkgPSBvbGRGcmFnbWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBvbGRJbml0ID0gb2xkRnJhZ21lbnRzW2ldLmluaXRTZWdtZW50O1xuICAgIGlmIChvbGRJbml0KSB7XG4gICAgICBjdXJyZW50SW5pdFNlZ21lbnQgPSBvbGRJbml0O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChvbGREZXRhaWxzLmZyYWdtZW50SGludCkge1xuICAgIC8vIHByZXZlbnQgUFRTIGFuZCBkdXJhdGlvbiBmcm9tIGJlaW5nIGFkanVzdGVkIG9uIHRoZSBuZXh0IGhpbnRcbiAgICBkZWxldGUgb2xkRGV0YWlscy5mcmFnbWVudEhpbnQuZW5kUFRTO1xuICB9XG4gIC8vIGNoZWNrIGlmIG9sZC9uZXcgcGxheWxpc3RzIGhhdmUgZnJhZ21lbnRzIGluIGNvbW1vblxuICAvLyBsb29wIHRocm91Z2ggb3ZlcmxhcHBpbmcgU04gYW5kIHVwZGF0ZSBzdGFydFBUUyAsIGNjLCBhbmQgZHVyYXRpb24gaWYgYW55IGZvdW5kXG4gIGxldCBjY09mZnNldCA9IDA7XG4gIGxldCBQVFNGcmFnO1xuICBtYXBGcmFnbWVudEludGVyc2VjdGlvbihvbGREZXRhaWxzLCBuZXdEZXRhaWxzLCAob2xkRnJhZywgbmV3RnJhZykgPT4ge1xuICAgIGlmIChvbGRGcmFnLnJlbHVybCkge1xuICAgICAgLy8gRG8gbm90IGNvbXBhcmUgQ0MgaWYgdGhlIG9sZCBmcmFnbWVudCBoYXMgbm8gdXJsLiBUaGlzIGlzIGEgbGV2ZWwuZnJhZ21lbnRIaW50IHVzZWQgYnkgTEwtSExTIHBhcnRzLlxuICAgICAgLy8gSXQgbWF5YmUgYmUgb2ZmIGJ5IDEgaWYgaXQgd2FzIGNyZWF0ZWQgYmVmb3JlIGFueSBwYXJ0cyBvciBkaXNjb250aW51aXR5IHRhZ3Mgd2VyZSBhcHBlbmRlZCB0byB0aGUgZW5kXG4gICAgICAvLyBvZiB0aGUgcGxheWxpc3QuXG4gICAgICBjY09mZnNldCA9IG9sZEZyYWcuY2MgLSBuZXdGcmFnLmNjO1xuICAgIH1cbiAgICBpZiAoaXNGaW5pdGVOdW1iZXIob2xkRnJhZy5zdGFydFBUUykgJiYgaXNGaW5pdGVOdW1iZXIob2xkRnJhZy5lbmRQVFMpKSB7XG4gICAgICBuZXdGcmFnLnN0YXJ0ID0gbmV3RnJhZy5zdGFydFBUUyA9IG9sZEZyYWcuc3RhcnRQVFM7XG4gICAgICBuZXdGcmFnLnN0YXJ0RFRTID0gb2xkRnJhZy5zdGFydERUUztcbiAgICAgIG5ld0ZyYWcubWF4U3RhcnRQVFMgPSBvbGRGcmFnLm1heFN0YXJ0UFRTO1xuICAgICAgbmV3RnJhZy5lbmRQVFMgPSBvbGRGcmFnLmVuZFBUUztcbiAgICAgIG5ld0ZyYWcuZW5kRFRTID0gb2xkRnJhZy5lbmREVFM7XG4gICAgICBuZXdGcmFnLm1pbkVuZFBUUyA9IG9sZEZyYWcubWluRW5kUFRTO1xuICAgICAgbmV3RnJhZy5kdXJhdGlvbiA9IG9sZEZyYWcuZW5kUFRTIC0gb2xkRnJhZy5zdGFydFBUUztcbiAgICAgIGlmIChuZXdGcmFnLmR1cmF0aW9uKSB7XG4gICAgICAgIFBUU0ZyYWcgPSBuZXdGcmFnO1xuICAgICAgfVxuXG4gICAgICAvLyBQVFMgaXMga25vd24gd2hlbiBhbnkgc2VnbWVudCBoYXMgc3RhcnRQVFMgYW5kIGVuZFBUU1xuICAgICAgbmV3RGV0YWlscy5QVFNLbm93biA9IG5ld0RldGFpbHMuYWxpZ25lZFNsaWRpbmcgPSB0cnVlO1xuICAgIH1cbiAgICBuZXdGcmFnLmVsZW1lbnRhcnlTdHJlYW1zID0gb2xkRnJhZy5lbGVtZW50YXJ5U3RyZWFtcztcbiAgICBuZXdGcmFnLmxvYWRlciA9IG9sZEZyYWcubG9hZGVyO1xuICAgIG5ld0ZyYWcuc3RhdHMgPSBvbGRGcmFnLnN0YXRzO1xuICAgIGlmIChvbGRGcmFnLmluaXRTZWdtZW50KSB7XG4gICAgICBuZXdGcmFnLmluaXRTZWdtZW50ID0gb2xkRnJhZy5pbml0U2VnbWVudDtcbiAgICAgIGN1cnJlbnRJbml0U2VnbWVudCA9IG9sZEZyYWcuaW5pdFNlZ21lbnQ7XG4gICAgfVxuICB9KTtcbiAgaWYgKGN1cnJlbnRJbml0U2VnbWVudCkge1xuICAgIGNvbnN0IGZyYWdtZW50c1RvQ2hlY2sgPSBuZXdEZXRhaWxzLmZyYWdtZW50SGludCA/IG5ld0RldGFpbHMuZnJhZ21lbnRzLmNvbmNhdChuZXdEZXRhaWxzLmZyYWdtZW50SGludCkgOiBuZXdEZXRhaWxzLmZyYWdtZW50cztcbiAgICBmcmFnbWVudHNUb0NoZWNrLmZvckVhY2goZnJhZyA9PiB7XG4gICAgICB2YXIgX2N1cnJlbnRJbml0U2VnbWVudDtcbiAgICAgIGlmIChmcmFnICYmICghZnJhZy5pbml0U2VnbWVudCB8fCBmcmFnLmluaXRTZWdtZW50LnJlbHVybCA9PT0gKChfY3VycmVudEluaXRTZWdtZW50ID0gY3VycmVudEluaXRTZWdtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2N1cnJlbnRJbml0U2VnbWVudC5yZWx1cmwpKSkge1xuICAgICAgICBmcmFnLmluaXRTZWdtZW50ID0gY3VycmVudEluaXRTZWdtZW50O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGlmIChuZXdEZXRhaWxzLnNraXBwZWRTZWdtZW50cykge1xuICAgIG5ld0RldGFpbHMuZGVsdGFVcGRhdGVGYWlsZWQgPSBuZXdEZXRhaWxzLmZyYWdtZW50cy5zb21lKGZyYWcgPT4gIWZyYWcpO1xuICAgIGlmIChuZXdEZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkKSB7XG4gICAgICBsb2dnZXIud2FybignW2xldmVsLWhlbHBlcl0gUHJldmlvdXMgcGxheWxpc3QgbWlzc2luZyBzZWdtZW50cyBza2lwcGVkIGluIGRlbHRhIHBsYXlsaXN0Jyk7XG4gICAgICBmb3IgKGxldCBpID0gbmV3RGV0YWlscy5za2lwcGVkU2VnbWVudHM7IGktLTspIHtcbiAgICAgICAgbmV3RGV0YWlscy5mcmFnbWVudHMuc2hpZnQoKTtcbiAgICAgIH1cbiAgICAgIG5ld0RldGFpbHMuc3RhcnRTTiA9IG5ld0RldGFpbHMuZnJhZ21lbnRzWzBdLnNuO1xuICAgICAgbmV3RGV0YWlscy5zdGFydENDID0gbmV3RGV0YWlscy5mcmFnbWVudHNbMF0uY2M7XG4gICAgfSBlbHNlIGlmIChuZXdEZXRhaWxzLmNhblNraXBEYXRlUmFuZ2VzKSB7XG4gICAgICBuZXdEZXRhaWxzLmRhdGVSYW5nZXMgPSBtZXJnZURhdGVSYW5nZXMob2xkRGV0YWlscy5kYXRlUmFuZ2VzLCBuZXdEZXRhaWxzLmRhdGVSYW5nZXMsIG5ld0RldGFpbHMucmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcyk7XG4gICAgfVxuICB9XG4gIGNvbnN0IG5ld0ZyYWdtZW50cyA9IG5ld0RldGFpbHMuZnJhZ21lbnRzO1xuICBpZiAoY2NPZmZzZXQpIHtcbiAgICBsb2dnZXIud2FybignZGlzY29udGludWl0eSBzbGlkaW5nIGZyb20gcGxheWxpc3QsIHRha2UgZHJpZnQgaW50byBhY2NvdW50Jyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdGcmFnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5ld0ZyYWdtZW50c1tpXS5jYyArPSBjY09mZnNldDtcbiAgICB9XG4gIH1cbiAgaWYgKG5ld0RldGFpbHMuc2tpcHBlZFNlZ21lbnRzKSB7XG4gICAgbmV3RGV0YWlscy5zdGFydENDID0gbmV3RGV0YWlscy5mcmFnbWVudHNbMF0uY2M7XG4gIH1cblxuICAvLyBNZXJnZSBwYXJ0c1xuICBtYXBQYXJ0SW50ZXJzZWN0aW9uKG9sZERldGFpbHMucGFydExpc3QsIG5ld0RldGFpbHMucGFydExpc3QsIChvbGRQYXJ0LCBuZXdQYXJ0KSA9PiB7XG4gICAgbmV3UGFydC5lbGVtZW50YXJ5U3RyZWFtcyA9IG9sZFBhcnQuZWxlbWVudGFyeVN0cmVhbXM7XG4gICAgbmV3UGFydC5zdGF0cyA9IG9sZFBhcnQuc3RhdHM7XG4gIH0pO1xuXG4gIC8vIGlmIGF0IGxlYXN0IG9uZSBmcmFnbWVudCBjb250YWlucyBQVFMgaW5mbywgcmVjb21wdXRlIFBUUyBpbmZvcm1hdGlvbiBmb3IgYWxsIGZyYWdtZW50c1xuICBpZiAoUFRTRnJhZykge1xuICAgIHVwZGF0ZUZyYWdQVFNEVFMobmV3RGV0YWlscywgUFRTRnJhZywgUFRTRnJhZy5zdGFydFBUUywgUFRTRnJhZy5lbmRQVFMsIFBUU0ZyYWcuc3RhcnREVFMsIFBUU0ZyYWcuZW5kRFRTKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBlbnN1cmUgdGhhdCBkZWx0YSBpcyB3aXRoaW4gb2xkRnJhZ21lbnRzIHJhbmdlXG4gICAgLy8gYWxzbyBhZGp1c3Qgc2xpZGluZyBpbiBjYXNlIGRlbHRhIGlzIDAgKHdlIGNvdWxkIGhhdmUgb2xkPVs1MC02MF0gYW5kIG5ldz1vbGQ9WzUwLTYxXSlcbiAgICAvLyBpbiB0aGF0IGNhc2Ugd2UgYWxzbyBuZWVkIHRvIGFkanVzdCBzdGFydCBvZmZzZXQgb2YgYWxsIGZyYWdtZW50c1xuICAgIGFkanVzdFNsaWRpbmcob2xkRGV0YWlscywgbmV3RGV0YWlscyk7XG4gIH1cbiAgaWYgKG5ld0ZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICBuZXdEZXRhaWxzLnRvdGFsZHVyYXRpb24gPSBuZXdEZXRhaWxzLmVkZ2UgLSBuZXdGcmFnbWVudHNbMF0uc3RhcnQ7XG4gIH1cbiAgbmV3RGV0YWlscy5kcmlmdFN0YXJ0VGltZSA9IG9sZERldGFpbHMuZHJpZnRTdGFydFRpbWU7XG4gIG5ld0RldGFpbHMuZHJpZnRTdGFydCA9IG9sZERldGFpbHMuZHJpZnRTdGFydDtcbiAgY29uc3QgYWR2YW5jZWREYXRlVGltZSA9IG5ld0RldGFpbHMuYWR2YW5jZWREYXRlVGltZTtcbiAgaWYgKG5ld0RldGFpbHMuYWR2YW5jZWQgJiYgYWR2YW5jZWREYXRlVGltZSkge1xuICAgIGNvbnN0IGVkZ2UgPSBuZXdEZXRhaWxzLmVkZ2U7XG4gICAgaWYgKCFuZXdEZXRhaWxzLmRyaWZ0U3RhcnQpIHtcbiAgICAgIG5ld0RldGFpbHMuZHJpZnRTdGFydFRpbWUgPSBhZHZhbmNlZERhdGVUaW1lO1xuICAgICAgbmV3RGV0YWlscy5kcmlmdFN0YXJ0ID0gZWRnZTtcbiAgICB9XG4gICAgbmV3RGV0YWlscy5kcmlmdEVuZFRpbWUgPSBhZHZhbmNlZERhdGVUaW1lO1xuICAgIG5ld0RldGFpbHMuZHJpZnRFbmQgPSBlZGdlO1xuICB9IGVsc2Uge1xuICAgIG5ld0RldGFpbHMuZHJpZnRFbmRUaW1lID0gb2xkRGV0YWlscy5kcmlmdEVuZFRpbWU7XG4gICAgbmV3RGV0YWlscy5kcmlmdEVuZCA9IG9sZERldGFpbHMuZHJpZnRFbmQ7XG4gICAgbmV3RGV0YWlscy5hZHZhbmNlZERhdGVUaW1lID0gb2xkRGV0YWlscy5hZHZhbmNlZERhdGVUaW1lO1xuICB9XG59XG5mdW5jdGlvbiBtZXJnZURhdGVSYW5nZXMob2xkRGF0ZVJhbmdlcywgZGVsdGFEYXRlUmFuZ2VzLCByZWNlbnRseVJlbW92ZWREYXRlcmFuZ2VzKSB7XG4gIGNvbnN0IGRhdGVSYW5nZXMgPSBfZXh0ZW5kcyh7fSwgb2xkRGF0ZVJhbmdlcyk7XG4gIGlmIChyZWNlbnRseVJlbW92ZWREYXRlcmFuZ2VzKSB7XG4gICAgcmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcy5mb3JFYWNoKGlkID0+IHtcbiAgICAgIGRlbGV0ZSBkYXRlUmFuZ2VzW2lkXTtcbiAgICB9KTtcbiAgfVxuICBPYmplY3Qua2V5cyhkZWx0YURhdGVSYW5nZXMpLmZvckVhY2goaWQgPT4ge1xuICAgIGNvbnN0IGRhdGVSYW5nZSA9IG5ldyBEYXRlUmFuZ2UoZGVsdGFEYXRlUmFuZ2VzW2lkXS5hdHRyLCBkYXRlUmFuZ2VzW2lkXSk7XG4gICAgaWYgKGRhdGVSYW5nZS5pc1ZhbGlkKSB7XG4gICAgICBkYXRlUmFuZ2VzW2lkXSA9IGRhdGVSYW5nZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyLndhcm4oYElnbm9yaW5nIGludmFsaWQgUGxheWxpc3QgRGVsdGEgVXBkYXRlIERBVEVSQU5HRSB0YWc6IFwiJHtKU09OLnN0cmluZ2lmeShkZWx0YURhdGVSYW5nZXNbaWRdLmF0dHIpfVwiYCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGRhdGVSYW5nZXM7XG59XG5mdW5jdGlvbiBtYXBQYXJ0SW50ZXJzZWN0aW9uKG9sZFBhcnRzLCBuZXdQYXJ0cywgaW50ZXJzZWN0aW9uRm4pIHtcbiAgaWYgKG9sZFBhcnRzICYmIG5ld1BhcnRzKSB7XG4gICAgbGV0IGRlbHRhID0gMDtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gb2xkUGFydHMubGVuZ3RoOyBpIDw9IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBvbGRQYXJ0ID0gb2xkUGFydHNbaV07XG4gICAgICBjb25zdCBuZXdQYXJ0ID0gbmV3UGFydHNbaSArIGRlbHRhXTtcbiAgICAgIGlmIChvbGRQYXJ0ICYmIG5ld1BhcnQgJiYgb2xkUGFydC5pbmRleCA9PT0gbmV3UGFydC5pbmRleCAmJiBvbGRQYXJ0LmZyYWdtZW50LnNuID09PSBuZXdQYXJ0LmZyYWdtZW50LnNuKSB7XG4gICAgICAgIGludGVyc2VjdGlvbkZuKG9sZFBhcnQsIG5ld1BhcnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsdGEtLTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcEZyYWdtZW50SW50ZXJzZWN0aW9uKG9sZERldGFpbHMsIG5ld0RldGFpbHMsIGludGVyc2VjdGlvbkZuKSB7XG4gIGNvbnN0IHNraXBwZWRTZWdtZW50cyA9IG5ld0RldGFpbHMuc2tpcHBlZFNlZ21lbnRzO1xuICBjb25zdCBzdGFydCA9IE1hdGgubWF4KG9sZERldGFpbHMuc3RhcnRTTiwgbmV3RGV0YWlscy5zdGFydFNOKSAtIG5ld0RldGFpbHMuc3RhcnRTTjtcbiAgY29uc3QgZW5kID0gKG9sZERldGFpbHMuZnJhZ21lbnRIaW50ID8gMSA6IDApICsgKHNraXBwZWRTZWdtZW50cyA/IG5ld0RldGFpbHMuZW5kU04gOiBNYXRoLm1pbihvbGREZXRhaWxzLmVuZFNOLCBuZXdEZXRhaWxzLmVuZFNOKSkgLSBuZXdEZXRhaWxzLnN0YXJ0U047XG4gIGNvbnN0IGRlbHRhID0gbmV3RGV0YWlscy5zdGFydFNOIC0gb2xkRGV0YWlscy5zdGFydFNOO1xuICBjb25zdCBuZXdGcmFncyA9IG5ld0RldGFpbHMuZnJhZ21lbnRIaW50ID8gbmV3RGV0YWlscy5mcmFnbWVudHMuY29uY2F0KG5ld0RldGFpbHMuZnJhZ21lbnRIaW50KSA6IG5ld0RldGFpbHMuZnJhZ21lbnRzO1xuICBjb25zdCBvbGRGcmFncyA9IG9sZERldGFpbHMuZnJhZ21lbnRIaW50ID8gb2xkRGV0YWlscy5mcmFnbWVudHMuY29uY2F0KG9sZERldGFpbHMuZnJhZ21lbnRIaW50KSA6IG9sZERldGFpbHMuZnJhZ21lbnRzO1xuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPD0gZW5kOyBpKyspIHtcbiAgICBjb25zdCBvbGRGcmFnID0gb2xkRnJhZ3NbZGVsdGEgKyBpXTtcbiAgICBsZXQgbmV3RnJhZyA9IG5ld0ZyYWdzW2ldO1xuICAgIGlmIChza2lwcGVkU2VnbWVudHMgJiYgIW5ld0ZyYWcgJiYgaSA8IHNraXBwZWRTZWdtZW50cykge1xuICAgICAgLy8gRmlsbCBpbiBza2lwcGVkIHNlZ21lbnRzIGluIGRlbHRhIHBsYXlsaXN0XG4gICAgICBuZXdGcmFnID0gbmV3RGV0YWlscy5mcmFnbWVudHNbaV0gPSBvbGRGcmFnO1xuICAgIH1cbiAgICBpZiAob2xkRnJhZyAmJiBuZXdGcmFnKSB7XG4gICAgICBpbnRlcnNlY3Rpb25GbihvbGRGcmFnLCBuZXdGcmFnKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFkanVzdFNsaWRpbmcob2xkRGV0YWlscywgbmV3RGV0YWlscykge1xuICBjb25zdCBkZWx0YSA9IG5ld0RldGFpbHMuc3RhcnRTTiArIG5ld0RldGFpbHMuc2tpcHBlZFNlZ21lbnRzIC0gb2xkRGV0YWlscy5zdGFydFNOO1xuICBjb25zdCBvbGRGcmFnbWVudHMgPSBvbGREZXRhaWxzLmZyYWdtZW50cztcbiAgaWYgKGRlbHRhIDwgMCB8fCBkZWx0YSA+PSBvbGRGcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFkZFNsaWRpbmcobmV3RGV0YWlscywgb2xkRnJhZ21lbnRzW2RlbHRhXS5zdGFydCk7XG59XG5mdW5jdGlvbiBhZGRTbGlkaW5nKGRldGFpbHMsIHN0YXJ0KSB7XG4gIGlmIChzdGFydCkge1xuICAgIGNvbnN0IGZyYWdtZW50cyA9IGRldGFpbHMuZnJhZ21lbnRzO1xuICAgIGZvciAobGV0IGkgPSBkZXRhaWxzLnNraXBwZWRTZWdtZW50czsgaSA8IGZyYWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgZnJhZ21lbnRzW2ldLnN0YXJ0ICs9IHN0YXJ0O1xuICAgIH1cbiAgICBpZiAoZGV0YWlscy5mcmFnbWVudEhpbnQpIHtcbiAgICAgIGRldGFpbHMuZnJhZ21lbnRIaW50LnN0YXJ0ICs9IHN0YXJ0O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY29tcHV0ZVJlbG9hZEludGVydmFsKG5ld0RldGFpbHMsIGRpc3RhbmNlVG9MaXZlRWRnZU1zID0gSW5maW5pdHkpIHtcbiAgbGV0IHJlbG9hZEludGVydmFsID0gMTAwMCAqIG5ld0RldGFpbHMudGFyZ2V0ZHVyYXRpb247XG4gIGlmIChuZXdEZXRhaWxzLnVwZGF0ZWQpIHtcbiAgICAvLyBVc2UgbGFzdCBzZWdtZW50IGR1cmF0aW9uIHdoZW4gc2hvcnRlciB0aGFuIHRhcmdldCBkdXJhdGlvbiBhbmQgbmVhciBsaXZlIGVkZ2VcbiAgICBjb25zdCBmcmFnbWVudHMgPSBuZXdEZXRhaWxzLmZyYWdtZW50cztcbiAgICBjb25zdCBsaXZlRWRnZU1heFRhcmdldER1cmF0aW9ucyA9IDQ7XG4gICAgaWYgKGZyYWdtZW50cy5sZW5ndGggJiYgcmVsb2FkSW50ZXJ2YWwgKiBsaXZlRWRnZU1heFRhcmdldER1cmF0aW9ucyA+IGRpc3RhbmNlVG9MaXZlRWRnZU1zKSB7XG4gICAgICBjb25zdCBsYXN0U2VnbWVudER1cmF0aW9uID0gZnJhZ21lbnRzW2ZyYWdtZW50cy5sZW5ndGggLSAxXS5kdXJhdGlvbiAqIDEwMDA7XG4gICAgICBpZiAobGFzdFNlZ21lbnREdXJhdGlvbiA8IHJlbG9hZEludGVydmFsKSB7XG4gICAgICAgIHJlbG9hZEludGVydmFsID0gbGFzdFNlZ21lbnREdXJhdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gZXN0aW1hdGUgPSAnbWlzcyBoYWxmIGF2ZXJhZ2UnO1xuICAgIC8vIGZvbGxvdyBITFMgU3BlYywgSWYgdGhlIGNsaWVudCByZWxvYWRzIGEgUGxheWxpc3QgZmlsZSBhbmQgZmluZHMgdGhhdCBpdCBoYXMgbm90XG4gICAgLy8gY2hhbmdlZCB0aGVuIGl0IE1VU1Qgd2FpdCBmb3IgYSBwZXJpb2Qgb2Ygb25lLWhhbGYgdGhlIHRhcmdldFxuICAgIC8vIGR1cmF0aW9uIGJlZm9yZSByZXRyeWluZy5cbiAgICByZWxvYWRJbnRlcnZhbCAvPSAyO1xuICB9XG4gIHJldHVybiBNYXRoLnJvdW5kKHJlbG9hZEludGVydmFsKTtcbn1cbmZ1bmN0aW9uIGdldEZyYWdtZW50V2l0aFNOKGxldmVsLCBzbiwgZnJhZ0N1cnJlbnQpIHtcbiAgaWYgKCEobGV2ZWwgIT0gbnVsbCAmJiBsZXZlbC5kZXRhaWxzKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGxldmVsRGV0YWlscyA9IGxldmVsLmRldGFpbHM7XG4gIGxldCBmcmFnbWVudCA9IGxldmVsRGV0YWlscy5mcmFnbWVudHNbc24gLSBsZXZlbERldGFpbHMuc3RhcnRTTl07XG4gIGlmIChmcmFnbWVudCkge1xuICAgIHJldHVybiBmcmFnbWVudDtcbiAgfVxuICBmcmFnbWVudCA9IGxldmVsRGV0YWlscy5mcmFnbWVudEhpbnQ7XG4gIGlmIChmcmFnbWVudCAmJiBmcmFnbWVudC5zbiA9PT0gc24pIHtcbiAgICByZXR1cm4gZnJhZ21lbnQ7XG4gIH1cbiAgaWYgKHNuIDwgbGV2ZWxEZXRhaWxzLnN0YXJ0U04gJiYgZnJhZ0N1cnJlbnQgJiYgZnJhZ0N1cnJlbnQuc24gPT09IHNuKSB7XG4gICAgcmV0dXJuIGZyYWdDdXJyZW50O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0UGFydFdpdGgobGV2ZWwsIHNuLCBwYXJ0SW5kZXgpIHtcbiAgdmFyIF9sZXZlbCRkZXRhaWxzO1xuICBpZiAoIShsZXZlbCAhPSBudWxsICYmIGxldmVsLmRldGFpbHMpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGZpbmRQYXJ0KChfbGV2ZWwkZGV0YWlscyA9IGxldmVsLmRldGFpbHMpID09IG51bGwgPyB2b2lkIDAgOiBfbGV2ZWwkZGV0YWlscy5wYXJ0TGlzdCwgc24sIHBhcnRJbmRleCk7XG59XG5mdW5jdGlvbiBmaW5kUGFydChwYXJ0TGlzdCwgc24sIHBhcnRJbmRleCkge1xuICBpZiAocGFydExpc3QpIHtcbiAgICBmb3IgKGxldCBpID0gcGFydExpc3QubGVuZ3RoOyBpLS07KSB7XG4gICAgICBjb25zdCBwYXJ0ID0gcGFydExpc3RbaV07XG4gICAgICBpZiAocGFydC5pbmRleCA9PT0gcGFydEluZGV4ICYmIHBhcnQuZnJhZ21lbnQuc24gPT09IHNuKSB7XG4gICAgICAgIHJldHVybiBwYXJ0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHJlYXNzaWduRnJhZ21lbnRMZXZlbEluZGV4ZXMobGV2ZWxzKSB7XG4gIGxldmVscy5mb3JFYWNoKChsZXZlbCwgaW5kZXgpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBkZXRhaWxzXG4gICAgfSA9IGxldmVsO1xuICAgIGlmIChkZXRhaWxzICE9IG51bGwgJiYgZGV0YWlscy5mcmFnbWVudHMpIHtcbiAgICAgIGRldGFpbHMuZnJhZ21lbnRzLmZvckVhY2goZnJhZ21lbnQgPT4ge1xuICAgICAgICBmcmFnbWVudC5sZXZlbCA9IGluZGV4O1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gaXNUaW1lb3V0RXJyb3IoZXJyb3IpIHtcbiAgc3dpdGNoIChlcnJvci5kZXRhaWxzKSB7XG4gICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQ6XG4gICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfVElNRU9VVDpcbiAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX1RJTUVPVVQ6XG4gICAgY2FzZSBFcnJvckRldGFpbHMuTUFOSUZFU1RfTE9BRF9USU1FT1VUOlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0UmV0cnlDb25maWcobG9hZFBvbGljeSwgZXJyb3IpIHtcbiAgY29uc3QgaXNUaW1lb3V0ID0gaXNUaW1lb3V0RXJyb3IoZXJyb3IpO1xuICByZXR1cm4gbG9hZFBvbGljeS5kZWZhdWx0W2Ake2lzVGltZW91dCA/ICd0aW1lb3V0JyA6ICdlcnJvcid9UmV0cnlgXTtcbn1cbmZ1bmN0aW9uIGdldFJldHJ5RGVsYXkocmV0cnlDb25maWcsIHJldHJ5Q291bnQpIHtcbiAgLy8gZXhwb25lbnRpYWwgYmFja29mZiBjYXBwZWQgdG8gbWF4IHJldHJ5IGRlbGF5XG4gIGNvbnN0IGJhY2tvZmZGYWN0b3IgPSByZXRyeUNvbmZpZy5iYWNrb2ZmID09PSAnbGluZWFyJyA/IDEgOiBNYXRoLnBvdygyLCByZXRyeUNvdW50KTtcbiAgcmV0dXJuIE1hdGgubWluKGJhY2tvZmZGYWN0b3IgKiByZXRyeUNvbmZpZy5yZXRyeURlbGF5TXMsIHJldHJ5Q29uZmlnLm1heFJldHJ5RGVsYXlNcyk7XG59XG5mdW5jdGlvbiBnZXRMb2FkZXJDb25maWdXaXRob3V0UmV0aWVzKGxvZGVyQ29uZmlnKSB7XG4gIHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgbG9kZXJDb25maWcpLCB7XG4gICAgZXJyb3JSZXRyeTogbnVsbCxcbiAgICB0aW1lb3V0UmV0cnk6IG51bGxcbiAgfSk7XG59XG5mdW5jdGlvbiBzaG91bGRSZXRyeShyZXRyeUNvbmZpZywgcmV0cnlDb3VudCwgaXNUaW1lb3V0LCBsb2FkZXJSZXNwb25zZSkge1xuICBpZiAoIXJldHJ5Q29uZmlnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGh0dHBTdGF0dXMgPSBsb2FkZXJSZXNwb25zZSA9PSBudWxsID8gdm9pZCAwIDogbG9hZGVyUmVzcG9uc2UuY29kZTtcbiAgY29uc3QgcmV0cnkgPSByZXRyeUNvdW50IDwgcmV0cnlDb25maWcubWF4TnVtUmV0cnkgJiYgKHJldHJ5Rm9ySHR0cFN0YXR1cyhodHRwU3RhdHVzKSB8fCAhIWlzVGltZW91dCk7XG4gIHJldHVybiByZXRyeUNvbmZpZy5zaG91bGRSZXRyeSA/IHJldHJ5Q29uZmlnLnNob3VsZFJldHJ5KHJldHJ5Q29uZmlnLCByZXRyeUNvdW50LCBpc1RpbWVvdXQsIGxvYWRlclJlc3BvbnNlLCByZXRyeSkgOiByZXRyeTtcbn1cbmZ1bmN0aW9uIHJldHJ5Rm9ySHR0cFN0YXR1cyhodHRwU3RhdHVzKSB7XG4gIC8vIERvIG5vdCByZXRyeSBvbiBzdGF0dXMgNHh4LCBzdGF0dXMgMCAoQ09SUyBlcnJvciksIG9yIHVuZGVmaW5lZCAoZGVjcnlwdC9nYXAvcGFyc2UgZXJyb3IpXG4gIHJldHVybiBodHRwU3RhdHVzID09PSAwICYmIG5hdmlnYXRvci5vbkxpbmUgPT09IGZhbHNlIHx8ICEhaHR0cFN0YXR1cyAmJiAoaHR0cFN0YXR1cyA8IDQwMCB8fCBodHRwU3RhdHVzID4gNDk5KTtcbn1cblxuY29uc3QgQmluYXJ5U2VhcmNoID0ge1xuICAvKipcbiAgICogU2VhcmNoZXMgZm9yIGFuIGl0ZW0gaW4gYW4gYXJyYXkgd2hpY2ggbWF0Y2hlcyBhIGNlcnRhaW4gY29uZGl0aW9uLlxuICAgKiBUaGlzIHJlcXVpcmVzIHRoZSBjb25kaXRpb24gdG8gb25seSBtYXRjaCBvbmUgaXRlbSBpbiB0aGUgYXJyYXksXG4gICAqIGFuZCBmb3IgdGhlIGFycmF5IHRvIGJlIG9yZGVyZWQuXG4gICAqXG4gICAqIEBwYXJhbSBsaXN0IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAqIEBwYXJhbSBjb21wYXJpc29uRm5cbiAgICogICAgICBDYWxsZWQgYW5kIHByb3ZpZGVkIGEgY2FuZGlkYXRlIGl0ZW0gYXMgdGhlIGZpcnN0IGFyZ3VtZW50LlxuICAgKiAgICAgIFNob3VsZCByZXR1cm46XG4gICAqICAgICAgICAgID4gLTEgaWYgdGhlIGl0ZW0gc2hvdWxkIGJlIGxvY2F0ZWQgYXQgYSBsb3dlciBpbmRleCB0aGFuIHRoZSBwcm92aWRlZCBpdGVtLlxuICAgKiAgICAgICAgICA+IDEgaWYgdGhlIGl0ZW0gc2hvdWxkIGJlIGxvY2F0ZWQgYXQgYSBoaWdoZXIgaW5kZXggdGhhbiB0aGUgcHJvdmlkZWQgaXRlbS5cbiAgICogICAgICAgICAgPiAwIGlmIHRoZSBpdGVtIGlzIHRoZSBpdGVtIHlvdSdyZSBsb29raW5nIGZvci5cbiAgICpcbiAgICogQHJldHVybnMgdGhlIG9iamVjdCBpZiBmb3VuZCwgb3RoZXJ3aXNlIHJldHVybnMgbnVsbFxuICAgKi9cbiAgc2VhcmNoOiBmdW5jdGlvbiAobGlzdCwgY29tcGFyaXNvbkZuKSB7XG4gICAgbGV0IG1pbkluZGV4ID0gMDtcbiAgICBsZXQgbWF4SW5kZXggPSBsaXN0Lmxlbmd0aCAtIDE7XG4gICAgbGV0IGN1cnJlbnRJbmRleCA9IG51bGw7XG4gICAgbGV0IGN1cnJlbnRFbGVtZW50ID0gbnVsbDtcbiAgICB3aGlsZSAobWluSW5kZXggPD0gbWF4SW5kZXgpIHtcbiAgICAgIGN1cnJlbnRJbmRleCA9IChtaW5JbmRleCArIG1heEluZGV4KSAvIDIgfCAwO1xuICAgICAgY3VycmVudEVsZW1lbnQgPSBsaXN0W2N1cnJlbnRJbmRleF07XG4gICAgICBjb25zdCBjb21wYXJpc29uUmVzdWx0ID0gY29tcGFyaXNvbkZuKGN1cnJlbnRFbGVtZW50KTtcbiAgICAgIGlmIChjb21wYXJpc29uUmVzdWx0ID4gMCkge1xuICAgICAgICBtaW5JbmRleCA9IGN1cnJlbnRJbmRleCArIDE7XG4gICAgICB9IGVsc2UgaWYgKGNvbXBhcmlzb25SZXN1bHQgPCAwKSB7XG4gICAgICAgIG1heEluZGV4ID0gY3VycmVudEluZGV4IC0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50RWxlbWVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBmaXJzdCBmcmFnbWVudCB3aG9zZSBlbmRQZHQgdmFsdWUgZXhjZWVkcyB0aGUgZ2l2ZW4gUERULCBvciBudWxsLlxuICogQHBhcmFtIGZyYWdtZW50cyAtIFRoZSBhcnJheSBvZiBjYW5kaWRhdGUgZnJhZ21lbnRzXG4gKiBAcGFyYW0gUERUVmFsdWUgLSBUaGUgUERUIHZhbHVlIHdoaWNoIG11c3QgYmUgZXhjZWVkZWRcbiAqIEBwYXJhbSBtYXhGcmFnTG9va1VwVG9sZXJhbmNlIC0gVGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgYSBmcmFnbWVudCdzIHN0YXJ0L2VuZCBjYW4gYmUgd2l0aGluIGluIG9yZGVyIHRvIGJlIGNvbnNpZGVyZWQgY29udGlndW91c1xuICovXG5mdW5jdGlvbiBmaW5kRnJhZ21lbnRCeVBEVChmcmFnbWVudHMsIFBEVFZhbHVlLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlKSB7XG4gIGlmIChQRFRWYWx1ZSA9PT0gbnVsbCB8fCAhQXJyYXkuaXNBcnJheShmcmFnbWVudHMpIHx8ICFmcmFnbWVudHMubGVuZ3RoIHx8ICFpc0Zpbml0ZU51bWJlcihQRFRWYWx1ZSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIGlmIGxlc3MgdGhhbiBzdGFydFxuICBjb25zdCBzdGFydFBEVCA9IGZyYWdtZW50c1swXS5wcm9ncmFtRGF0ZVRpbWU7XG4gIGlmIChQRFRWYWx1ZSA8IChzdGFydFBEVCB8fCAwKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGVuZFBEVCA9IGZyYWdtZW50c1tmcmFnbWVudHMubGVuZ3RoIC0gMV0uZW5kUHJvZ3JhbURhdGVUaW1lO1xuICBpZiAoUERUVmFsdWUgPj0gKGVuZFBEVCB8fCAwKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgPSBtYXhGcmFnTG9va1VwVG9sZXJhbmNlIHx8IDA7XG4gIGZvciAobGV0IHNlZyA9IDA7IHNlZyA8IGZyYWdtZW50cy5sZW5ndGg7ICsrc2VnKSB7XG4gICAgY29uc3QgZnJhZyA9IGZyYWdtZW50c1tzZWddO1xuICAgIGlmIChwZHRXaXRoaW5Ub2xlcmFuY2VUZXN0KFBEVFZhbHVlLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBmcmFnKSkge1xuICAgICAgcmV0dXJuIGZyYWc7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEZpbmRzIGEgZnJhZ21lbnQgYmFzZWQgb24gdGhlIFNOIG9mIHRoZSBwcmV2aW91cyBmcmFnbWVudDsgb3IgYmFzZWQgb24gdGhlIG5lZWRzIG9mIHRoZSBjdXJyZW50IGJ1ZmZlci5cbiAqIFRoaXMgbWV0aG9kIGNvbXBlbnNhdGVzIGZvciBzbWFsbCBidWZmZXIgZ2FwcyBieSBhcHBseWluZyBhIHRvbGVyYW5jZSB0byB0aGUgc3RhcnQgb2YgYW55IGNhbmRpZGF0ZSBmcmFnbWVudCwgdGh1c1xuICogYnJlYWtpbmcgYW55IHRyYXBzIHdoaWNoIHdvdWxkIGNhdXNlIHRoZSBzYW1lIGZyYWdtZW50IHRvIGJlIGNvbnRpbnVvdXNseSBzZWxlY3RlZCB3aXRoaW4gYSBzbWFsbCByYW5nZS5cbiAqIEBwYXJhbSBmcmFnUHJldmlvdXMgLSBUaGUgbGFzdCBmcmFnIHN1Y2Nlc3NmdWxseSBhcHBlbmRlZFxuICogQHBhcmFtIGZyYWdtZW50cyAtIFRoZSBhcnJheSBvZiBjYW5kaWRhdGUgZnJhZ21lbnRzXG4gKiBAcGFyYW0gYnVmZmVyRW5kIC0gVGhlIGVuZCBvZiB0aGUgY29udGlndW91cyBidWZmZXJlZCByYW5nZSB0aGUgcGxheWhlYWQgaXMgY3VycmVudGx5IHdpdGhpblxuICogQHBhcmFtIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgLSBUaGUgYW1vdW50IG9mIHRpbWUgdGhhdCBhIGZyYWdtZW50J3Mgc3RhcnQvZW5kIGNhbiBiZSB3aXRoaW4gaW4gb3JkZXIgdG8gYmUgY29uc2lkZXJlZCBjb250aWd1b3VzXG4gKiBAcmV0dXJucyBhIG1hdGNoaW5nIGZyYWdtZW50IG9yIG51bGxcbiAqL1xuZnVuY3Rpb24gZmluZEZyYWdtZW50QnlQVFMoZnJhZ1ByZXZpb3VzLCBmcmFnbWVudHMsIGJ1ZmZlckVuZCA9IDAsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgPSAwKSB7XG4gIGxldCBmcmFnTmV4dCA9IG51bGw7XG4gIGlmIChmcmFnUHJldmlvdXMpIHtcbiAgICBmcmFnTmV4dCA9IGZyYWdtZW50c1tmcmFnUHJldmlvdXMuc24gLSBmcmFnbWVudHNbMF0uc24gKyAxXSB8fCBudWxsO1xuICAgIC8vIGNoZWNrIGZvciBidWZmZXItZW5kIHJvdW5kaW5nIGVycm9yXG4gICAgY29uc3QgYnVmZmVyRWRnZUVycm9yID0gZnJhZ1ByZXZpb3VzLmVuZERUUyAtIGJ1ZmZlckVuZDtcbiAgICBpZiAoYnVmZmVyRWRnZUVycm9yID4gMCAmJiBidWZmZXJFZGdlRXJyb3IgPCAwLjAwMDAwMTUpIHtcbiAgICAgIGJ1ZmZlckVuZCArPSAwLjAwMDAwMTU7XG4gICAgfVxuICB9IGVsc2UgaWYgKGJ1ZmZlckVuZCA9PT0gMCAmJiBmcmFnbWVudHNbMF0uc3RhcnQgPT09IDApIHtcbiAgICBmcmFnTmV4dCA9IGZyYWdtZW50c1swXTtcbiAgfVxuICAvLyBQcmVmZXIgdGhlIG5leHQgZnJhZ21lbnQgaWYgaXQncyB3aXRoaW4gdG9sZXJhbmNlXG4gIGlmIChmcmFnTmV4dCAmJiAoIWZyYWdQcmV2aW91cyB8fCBmcmFnUHJldmlvdXMubGV2ZWwgPT09IGZyYWdOZXh0LmxldmVsKSAmJiBmcmFnbWVudFdpdGhpblRvbGVyYW5jZVRlc3QoYnVmZmVyRW5kLCBtYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBmcmFnTmV4dCkgPT09IDApIHtcbiAgICByZXR1cm4gZnJhZ05leHQ7XG4gIH1cbiAgLy8gV2UgbWlnaHQgYmUgc2Vla2luZyBwYXN0IHRoZSB0b2xlcmFuY2Ugc28gZmluZCB0aGUgYmVzdCBtYXRjaFxuICBjb25zdCBmb3VuZEZyYWdtZW50ID0gQmluYXJ5U2VhcmNoLnNlYXJjaChmcmFnbWVudHMsIGZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdC5iaW5kKG51bGwsIGJ1ZmZlckVuZCwgbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSkpO1xuICBpZiAoZm91bmRGcmFnbWVudCAmJiAoZm91bmRGcmFnbWVudCAhPT0gZnJhZ1ByZXZpb3VzIHx8ICFmcmFnTmV4dCkpIHtcbiAgICByZXR1cm4gZm91bmRGcmFnbWVudDtcbiAgfVxuICAvLyBJZiBubyBtYXRjaCB3YXMgZm91bmQgcmV0dXJuIHRoZSBuZXh0IGZyYWdtZW50IGFmdGVyIGZyYWdQcmV2aW91cywgb3IgbnVsbFxuICByZXR1cm4gZnJhZ05leHQ7XG59XG5cbi8qKlxuICogVGhlIHRlc3QgZnVuY3Rpb24gdXNlZCBieSB0aGUgZmluZEZyYWdtZW50QnlTbidzIEJpbmFyeVNlYXJjaCB0byBsb29rIGZvciB0aGUgYmVzdCBtYXRjaCB0byB0aGUgY3VycmVudCBidWZmZXIgY29uZGl0aW9ucy5cbiAqIEBwYXJhbSBjYW5kaWRhdGUgLSBUaGUgZnJhZ21lbnQgdG8gdGVzdFxuICogQHBhcmFtIGJ1ZmZlckVuZCAtIFRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgYnVmZmVyZWQgcmFuZ2UgdGhlIHBsYXloZWFkIGlzIGN1cnJlbnRseSB3aXRoaW5cbiAqIEBwYXJhbSBtYXhGcmFnTG9va1VwVG9sZXJhbmNlIC0gVGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgYSBmcmFnbWVudCdzIHN0YXJ0IGNhbiBiZSB3aXRoaW4gaW4gb3JkZXIgdG8gYmUgY29uc2lkZXJlZCBjb250aWd1b3VzXG4gKiBAcmV0dXJucyAwIGlmIGl0IG1hdGNoZXMsIDEgaWYgdG9vIGxvdywgLTEgaWYgdG9vIGhpZ2hcbiAqL1xuZnVuY3Rpb24gZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0KGJ1ZmZlckVuZCA9IDAsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UgPSAwLCBjYW5kaWRhdGUpIHtcbiAgLy8gZWFnZXJseSBhY2NlcHQgYW4gYWNjdXJhdGUgbWF0Y2ggKG5vIHRvbGVyYW5jZSlcbiAgaWYgKGNhbmRpZGF0ZS5zdGFydCA8PSBidWZmZXJFbmQgJiYgY2FuZGlkYXRlLnN0YXJ0ICsgY2FuZGlkYXRlLmR1cmF0aW9uID4gYnVmZmVyRW5kKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgLy8gb2Zmc2V0IHNob3VsZCBiZSB3aXRoaW4gZnJhZ21lbnQgYm91bmRhcnkgLSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZVxuICAvLyB0aGlzIGlzIHRvIGNvcGUgd2l0aCBzaXR1YXRpb25zIGxpa2VcbiAgLy8gYnVmZmVyRW5kID0gOS45OTFcbiAgLy8gZnJhZ1vDmF0gOiBbMCwxMF1cbiAgLy8gZnJhZ1sxXSA6IFsxMCwyMF1cbiAgLy8gYnVmZmVyRW5kIGlzIHdpdGhpbiBmcmFnWzBdIHJhbmdlIC4uLiBhbHRob3VnaCB3aGF0IHdlIGFyZSBleHBlY3RpbmcgaXMgdG8gcmV0dXJuIGZyYWdbMV0gaGVyZVxuICAvLyAgICAgICAgICAgICAgZnJhZyBzdGFydCAgICAgICAgICAgICAgIGZyYWcgc3RhcnQrZHVyYXRpb25cbiAgLy8gICAgICAgICAgICAgICAgICB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gIC8vICAgICAgICAgICAgICA8LS0tPiAgICAgICAgICAgICAgICAgICAgICAgICA8LS0tPlxuICAvLyAgLi4uLS0tLS0tLS0+PC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tPjwtLS0tLS0tLS0uLi4uXG4gIC8vIHByZXZpb3VzIGZyYWcgICAgICAgICBtYXRjaGluZyBmcmFnbWVudCAgICAgICAgIG5leHQgZnJhZ1xuICAvLyAgcmV0dXJuIC0xICAgICAgICAgICAgIHJldHVybiAwICAgICAgICAgICAgICAgICByZXR1cm4gMVxuICAvLyBsb2dnZXIubG9nKGBsZXZlbC9zbi9zdGFydC9lbmQvYnVmRW5kOiR7bGV2ZWx9LyR7Y2FuZGlkYXRlLnNufS8ke2NhbmRpZGF0ZS5zdGFydH0vJHsoY2FuZGlkYXRlLnN0YXJ0K2NhbmRpZGF0ZS5kdXJhdGlvbil9LyR7YnVmZmVyRW5kfWApO1xuICAvLyBTZXQgdGhlIGxvb2t1cCB0b2xlcmFuY2UgdG8gYmUgc21hbGwgZW5vdWdoIHRvIGRldGVjdCB0aGUgY3VycmVudCBzZWdtZW50IC0gZW5zdXJlcyB3ZSBkb24ndCBza2lwIG92ZXIgdmVyeSBzbWFsbCBzZWdtZW50c1xuICBjb25zdCBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPSBNYXRoLm1pbihtYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBjYW5kaWRhdGUuZHVyYXRpb24gKyAoY2FuZGlkYXRlLmRlbHRhUFRTID8gY2FuZGlkYXRlLmRlbHRhUFRTIDogMCkpO1xuICBpZiAoY2FuZGlkYXRlLnN0YXJ0ICsgY2FuZGlkYXRlLmR1cmF0aW9uIC0gY2FuZGlkYXRlTG9va3VwVG9sZXJhbmNlIDw9IGJ1ZmZlckVuZCkge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2UgaWYgKGNhbmRpZGF0ZS5zdGFydCAtIGNhbmRpZGF0ZUxvb2t1cFRvbGVyYW5jZSA+IGJ1ZmZlckVuZCAmJiBjYW5kaWRhdGUuc3RhcnQpIHtcbiAgICAvLyBpZiBtYXhGcmFnTG9va1VwVG9sZXJhbmNlIHdpbGwgaGF2ZSBuZWdhdGl2ZSB2YWx1ZSB0aGVuIGRvbid0IHJldHVybiAtMSBmb3IgZmlyc3QgZWxlbWVudFxuICAgIHJldHVybiAtMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLyoqXG4gKiBUaGUgdGVzdCBmdW5jdGlvbiB1c2VkIGJ5IHRoZSBmaW5kRnJhZ21lbnRCeVBkdCdzIEJpbmFyeVNlYXJjaCB0byBsb29rIGZvciB0aGUgYmVzdCBtYXRjaCB0byB0aGUgY3VycmVudCBidWZmZXIgY29uZGl0aW9ucy5cbiAqIFRoaXMgZnVuY3Rpb24gdGVzdHMgdGhlIGNhbmRpZGF0ZSdzIHByb2dyYW0gZGF0ZSB0aW1lIHZhbHVlcywgYXMgcmVwcmVzZW50ZWQgaW4gVW5peCB0aW1lXG4gKiBAcGFyYW0gY2FuZGlkYXRlIC0gVGhlIGZyYWdtZW50IHRvIHRlc3RcbiAqIEBwYXJhbSBwZHRCdWZmZXJFbmQgLSBUaGUgVW5peCB0aW1lIHJlcHJlc2VudGluZyB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGJ1ZmZlcmVkIHJhbmdlXG4gKiBAcGFyYW0gbWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSAtIFRoZSBhbW91bnQgb2YgdGltZSB0aGF0IGEgZnJhZ21lbnQncyBzdGFydCBjYW4gYmUgd2l0aGluIGluIG9yZGVyIHRvIGJlIGNvbnNpZGVyZWQgY29udGlndW91c1xuICogQHJldHVybnMgdHJ1ZSBpZiBjb250aWd1b3VzLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZnVuY3Rpb24gcGR0V2l0aGluVG9sZXJhbmNlVGVzdChwZHRCdWZmZXJFbmQsIG1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGNhbmRpZGF0ZSkge1xuICBjb25zdCBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPSBNYXRoLm1pbihtYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBjYW5kaWRhdGUuZHVyYXRpb24gKyAoY2FuZGlkYXRlLmRlbHRhUFRTID8gY2FuZGlkYXRlLmRlbHRhUFRTIDogMCkpICogMTAwMDtcblxuICAvLyBlbmRQcm9ncmFtRGF0ZVRpbWUgY2FuIGJlIG51bGwsIGRlZmF1bHQgdG8gemVyb1xuICBjb25zdCBlbmRQcm9ncmFtRGF0ZVRpbWUgPSBjYW5kaWRhdGUuZW5kUHJvZ3JhbURhdGVUaW1lIHx8IDA7XG4gIHJldHVybiBlbmRQcm9ncmFtRGF0ZVRpbWUgLSBjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UgPiBwZHRCdWZmZXJFbmQ7XG59XG5mdW5jdGlvbiBmaW5kRnJhZ1dpdGhDQyhmcmFnbWVudHMsIGNjKSB7XG4gIHJldHVybiBCaW5hcnlTZWFyY2guc2VhcmNoKGZyYWdtZW50cywgY2FuZGlkYXRlID0+IHtcbiAgICBpZiAoY2FuZGlkYXRlLmNjIDwgY2MpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoY2FuZGlkYXRlLmNjID4gY2MpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIE5ldHdvcmtFcnJvckFjdGlvbiA9IHtcbiAgRG9Ob3RoaW5nOiAwLFxuICBTZW5kRW5kQ2FsbGJhY2s6IDEsXG4gIFNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3g6IDIsXG4gIFJlbW92ZUFsdGVybmF0ZVBlcm1hbmVudGx5OiAzLFxuICBJbnNlcnREaXNjb250aW51aXR5OiA0LFxuICBSZXRyeVJlcXVlc3Q6IDVcbn07XG52YXIgRXJyb3JBY3Rpb25GbGFncyA9IHtcbiAgTm9uZTogMCxcbiAgTW92ZUFsbEFsdGVybmF0ZXNNYXRjaGluZ0hvc3Q6IDEsXG4gIE1vdmVBbGxBbHRlcm5hdGVzTWF0Y2hpbmdIRENQOiAyLFxuICBTd2l0Y2hUb1NEUjogNFxufTsgLy8gUmVzZXJ2ZWQgZm9yIGZ1dHVyZSB1c2VcbmNsYXNzIEVycm9yQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMucGxheWxpc3RFcnJvciA9IDA7XG4gICAgdGhpcy5wZW5hbGl6ZWRSZW5kaXRpb25zID0ge307XG4gICAgdGhpcy5sb2cgPSB2b2lkIDA7XG4gICAgdGhpcy53YXJuID0gdm9pZCAwO1xuICAgIHRoaXMuZXJyb3IgPSB2b2lkIDA7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5sb2cgPSBsb2dnZXIubG9nLmJpbmQobG9nZ2VyLCBgW2luZm9dOmApO1xuICAgIHRoaXMud2FybiA9IGxvZ2dlci53YXJuLmJpbmQobG9nZ2VyLCBgW3dhcm5pbmddOmApO1xuICAgIHRoaXMuZXJyb3IgPSBsb2dnZXIuZXJyb3IuYmluZChsb2dnZXIsIGBbZXJyb3JdOmApO1xuICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBobHMub24oRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9VUERBVEVELCB0aGlzLm9uTGV2ZWxVcGRhdGVkLCB0aGlzKTtcbiAgfVxuICB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGlmICghaGxzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGhscy5vZmYoRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3JPdXQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX1VQREFURUQsIHRoaXMub25MZXZlbFVwZGF0ZWQsIHRoaXMpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuaGxzID0gbnVsbDtcbiAgICB0aGlzLnBlbmFsaXplZFJlbmRpdGlvbnMgPSB7fTtcbiAgfVxuICBzdGFydExvYWQoc3RhcnRQb3NpdGlvbikge31cbiAgc3RvcExvYWQoKSB7XG4gICAgdGhpcy5wbGF5bGlzdEVycm9yID0gMDtcbiAgfVxuICBnZXRWYXJpYW50TGV2ZWxJbmRleChmcmFnKSB7XG4gICAgcmV0dXJuIChmcmFnID09IG51bGwgPyB2b2lkIDAgOiBmcmFnLnR5cGUpID09PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOID8gZnJhZy5sZXZlbCA6IHRoaXMuaGxzLmxvYWRMZXZlbDtcbiAgfVxuICBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICB0aGlzLnBsYXlsaXN0RXJyb3IgPSAwO1xuICAgIHRoaXMucGVuYWxpemVkUmVuZGl0aW9ucyA9IHt9O1xuICB9XG4gIG9uTGV2ZWxVcGRhdGVkKCkge1xuICAgIHRoaXMucGxheWxpc3RFcnJvciA9IDA7XG4gIH1cbiAgb25FcnJvcihldmVudCwgZGF0YSkge1xuICAgIHZhciBfZGF0YSRmcmFnLCBfZGF0YSRsZXZlbDtcbiAgICBpZiAoZGF0YS5mYXRhbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBjb25zdCBjb250ZXh0ID0gZGF0YS5jb250ZXh0O1xuICAgIHN3aXRjaCAoZGF0YS5kZXRhaWxzKSB7XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVDpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfVElNRU9VVDpcbiAgICAgICAgZGF0YS5lcnJvckFjdGlvbiA9IHRoaXMuZ2V0RnJhZ1JldHJ5T3JTd2l0Y2hBY3Rpb24oZGF0YSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUjpcbiAgICAgICAgLy8gaWdub3JlIGVtcHR5IHNlZ21lbnQgZXJyb3JzIG1hcmtlZCBhcyBnYXBcbiAgICAgICAgaWYgKChfZGF0YSRmcmFnID0gZGF0YS5mcmFnKSAhPSBudWxsICYmIF9kYXRhJGZyYWcuZ2FwKSB7XG4gICAgICAgICAgZGF0YS5lcnJvckFjdGlvbiA9IHtcbiAgICAgICAgICAgIGFjdGlvbjogTmV0d29ya0Vycm9yQWN0aW9uLkRvTm90aGluZyxcbiAgICAgICAgICAgIGZsYWdzOiBFcnJvckFjdGlvbkZsYWdzLk5vbmVcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19HQVA6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0RFQ1JZUFRfRVJST1I6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBTd2l0Y2ggbGV2ZWwgaWYgcG9zc2libGUsIG90aGVyd2lzZSBhbGxvdyByZXRyeSBjb3VudCB0byByZWFjaCBtYXggZXJyb3IgcmV0cmllc1xuICAgICAgICAgIGRhdGEuZXJyb3JBY3Rpb24gPSB0aGlzLmdldEZyYWdSZXRyeU9yU3dpdGNoQWN0aW9uKGRhdGEpO1xuICAgICAgICAgIGRhdGEuZXJyb3JBY3Rpb24uYWN0aW9uID0gTmV0d29ya0Vycm9yQWN0aW9uLlNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3g7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9FTVBUWV9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX1BBUlNJTkdfRVJST1I6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2RhdGEkY29udGV4dCwgX2RhdGEkY29udGV4dCRsZXZlbERlO1xuICAgICAgICAgIC8vIE9ubHkgcmV0cnkgd2hlbiBlbXB0eSBhbmQgbGl2ZVxuICAgICAgICAgIGNvbnN0IGxldmVsSW5kZXggPSBkYXRhLnBhcmVudCA9PT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTiA/IGRhdGEubGV2ZWwgOiBobHMubG9hZExldmVsO1xuICAgICAgICAgIGlmIChkYXRhLmRldGFpbHMgPT09IEVycm9yRGV0YWlscy5MRVZFTF9FTVBUWV9FUlJPUiAmJiAhISgoX2RhdGEkY29udGV4dCA9IGRhdGEuY29udGV4dCkgIT0gbnVsbCAmJiAoX2RhdGEkY29udGV4dCRsZXZlbERlID0gX2RhdGEkY29udGV4dC5sZXZlbERldGFpbHMpICE9IG51bGwgJiYgX2RhdGEkY29udGV4dCRsZXZlbERlLmxpdmUpKSB7XG4gICAgICAgICAgICBkYXRhLmVycm9yQWN0aW9uID0gdGhpcy5nZXRQbGF5bGlzdFJldHJ5T3JTd2l0Y2hBY3Rpb24oZGF0YSwgbGV2ZWxJbmRleCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEVzY2FsYXRlIHRvIGZhdGFsIGlmIG5vdCByZXRyeWluZyBvciBzd2l0Y2hpbmdcbiAgICAgICAgICAgIGRhdGEubGV2ZWxSZXRyeSA9IGZhbHNlO1xuICAgICAgICAgICAgZGF0YS5lcnJvckFjdGlvbiA9IHRoaXMuZ2V0TGV2ZWxTd2l0Y2hBY3Rpb24oZGF0YSwgbGV2ZWxJbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9MT0FEX1RJTUVPVVQ6XG4gICAgICAgIGlmICh0eXBlb2YgKGNvbnRleHQgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRleHQubGV2ZWwpID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGRhdGEuZXJyb3JBY3Rpb24gPSB0aGlzLmdldFBsYXlsaXN0UmV0cnlPclN3aXRjaEFjdGlvbihkYXRhLCBjb250ZXh0LmxldmVsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQVVESU9fVFJBQ0tfTE9BRF9USU1FT1VUOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuU1VCVElUTEVfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLlNVQlRJVExFX1RSQUNLX0xPQURfVElNRU9VVDpcbiAgICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgICBjb25zdCBsZXZlbCA9IGhscy5sZXZlbHNbaGxzLmxvYWRMZXZlbF07XG4gICAgICAgICAgaWYgKGxldmVsICYmIChjb250ZXh0LnR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuQVVESU9fVFJBQ0sgJiYgbGV2ZWwuaGFzQXVkaW9Hcm91cChjb250ZXh0Lmdyb3VwSWQpIHx8IGNvbnRleHQudHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5TVUJUSVRMRV9UUkFDSyAmJiBsZXZlbC5oYXNTdWJ0aXRsZUdyb3VwKGNvbnRleHQuZ3JvdXBJZCkpKSB7XG4gICAgICAgICAgICAvLyBQZXJmb3JtIFBhdGh3YXkgc3dpdGNoIG9yIFJlZHVuZGFudCBmYWlsb3ZlciBpZiBwb3NzaWJsZSBmb3IgZmFzdGVzdCByZWNvdmVyeVxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGFsbG93IHBsYXlsaXN0IHJldHJ5IGNvdW50IHRvIHJlYWNoIG1heCBlcnJvciByZXRyaWVzXG4gICAgICAgICAgICBkYXRhLmVycm9yQWN0aW9uID0gdGhpcy5nZXRQbGF5bGlzdFJldHJ5T3JTd2l0Y2hBY3Rpb24oZGF0YSwgaGxzLmxvYWRMZXZlbCk7XG4gICAgICAgICAgICBkYXRhLmVycm9yQWN0aW9uLmFjdGlvbiA9IE5ldHdvcmtFcnJvckFjdGlvbi5TZW5kQWx0ZXJuYXRlVG9QZW5hbHR5Qm94O1xuICAgICAgICAgICAgZGF0YS5lcnJvckFjdGlvbi5mbGFncyA9IEVycm9yQWN0aW9uRmxhZ3MuTW92ZUFsbEFsdGVybmF0ZXNNYXRjaGluZ0hvc3Q7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fU1RBVFVTX09VVFBVVF9SRVNUUklDVEVEOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgbGV2ZWwgPSBobHMubGV2ZWxzW2hscy5sb2FkTGV2ZWxdO1xuICAgICAgICAgIGNvbnN0IHJlc3RyaWN0ZWRIZGNwTGV2ZWwgPSBsZXZlbCA9PSBudWxsID8gdm9pZCAwIDogbGV2ZWwuYXR0cnNbJ0hEQ1AtTEVWRUwnXTtcbiAgICAgICAgICBpZiAocmVzdHJpY3RlZEhkY3BMZXZlbCkge1xuICAgICAgICAgICAgZGF0YS5lcnJvckFjdGlvbiA9IHtcbiAgICAgICAgICAgICAgYWN0aW9uOiBOZXR3b3JrRXJyb3JBY3Rpb24uU2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveCxcbiAgICAgICAgICAgICAgZmxhZ3M6IEVycm9yQWN0aW9uRmxhZ3MuTW92ZUFsbEFsdGVybmF0ZXNNYXRjaGluZ0hEQ1AsXG4gICAgICAgICAgICAgIGhkY3BMZXZlbDogcmVzdHJpY3RlZEhkY3BMZXZlbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5rZXlTeXN0ZW1FcnJvcihkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX0FERF9DT0RFQ19FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLlJFTVVYX0FMTE9DX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORF9FUlJPUjpcbiAgICAgICAgZGF0YS5lcnJvckFjdGlvbiA9IHRoaXMuZ2V0TGV2ZWxTd2l0Y2hBY3Rpb24oZGF0YSwgKF9kYXRhJGxldmVsID0gZGF0YS5sZXZlbCkgIT0gbnVsbCA/IF9kYXRhJGxldmVsIDogaGxzLmxvYWRMZXZlbCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLklOVEVSTkFMX0VYQ0VQVElPTjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRJTkdfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfRlVMTF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX1NXSVRDSF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkJVRkZFUl9TVEFMTEVEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX1NFRUtfT1ZFUl9IT0xFOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX05VREdFX09OX1NUQUxMOlxuICAgICAgICBkYXRhLmVycm9yQWN0aW9uID0ge1xuICAgICAgICAgIGFjdGlvbjogTmV0d29ya0Vycm9yQWN0aW9uLkRvTm90aGluZyxcbiAgICAgICAgICBmbGFnczogRXJyb3JBY3Rpb25GbGFncy5Ob25lXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRhdGEudHlwZSA9PT0gRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SKSB7XG4gICAgICB0aGlzLmtleVN5c3RlbUVycm9yKGRhdGEpO1xuICAgIH1cbiAgfVxuICBrZXlTeXN0ZW1FcnJvcihkYXRhKSB7XG4gICAgY29uc3QgbGV2ZWxJbmRleCA9IHRoaXMuZ2V0VmFyaWFudExldmVsSW5kZXgoZGF0YS5mcmFnKTtcbiAgICAvLyBEbyBub3QgcmV0cnkgbGV2ZWwuIEVzY2FsYXRlIHRvIGZhdGFsIGlmIHN3aXRjaGluZyBsZXZlbHMgZmFpbHMuXG4gICAgZGF0YS5sZXZlbFJldHJ5ID0gZmFsc2U7XG4gICAgZGF0YS5lcnJvckFjdGlvbiA9IHRoaXMuZ2V0TGV2ZWxTd2l0Y2hBY3Rpb24oZGF0YSwgbGV2ZWxJbmRleCk7XG4gIH1cbiAgZ2V0UGxheWxpc3RSZXRyeU9yU3dpdGNoQWN0aW9uKGRhdGEsIGxldmVsSW5kZXgpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBjb25zdCByZXRyeUNvbmZpZyA9IGdldFJldHJ5Q29uZmlnKGhscy5jb25maWcucGxheWxpc3RMb2FkUG9saWN5LCBkYXRhKTtcbiAgICBjb25zdCByZXRyeUNvdW50ID0gdGhpcy5wbGF5bGlzdEVycm9yKys7XG4gICAgY29uc3QgcmV0cnkgPSBzaG91bGRSZXRyeShyZXRyeUNvbmZpZywgcmV0cnlDb3VudCwgaXNUaW1lb3V0RXJyb3IoZGF0YSksIGRhdGEucmVzcG9uc2UpO1xuICAgIGlmIChyZXRyeSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWN0aW9uOiBOZXR3b3JrRXJyb3JBY3Rpb24uUmV0cnlSZXF1ZXN0LFxuICAgICAgICBmbGFnczogRXJyb3JBY3Rpb25GbGFncy5Ob25lLFxuICAgICAgICByZXRyeUNvbmZpZyxcbiAgICAgICAgcmV0cnlDb3VudFxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgZXJyb3JBY3Rpb24gPSB0aGlzLmdldExldmVsU3dpdGNoQWN0aW9uKGRhdGEsIGxldmVsSW5kZXgpO1xuICAgIGlmIChyZXRyeUNvbmZpZykge1xuICAgICAgZXJyb3JBY3Rpb24ucmV0cnlDb25maWcgPSByZXRyeUNvbmZpZztcbiAgICAgIGVycm9yQWN0aW9uLnJldHJ5Q291bnQgPSByZXRyeUNvdW50O1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3JBY3Rpb247XG4gIH1cbiAgZ2V0RnJhZ1JldHJ5T3JTd2l0Y2hBY3Rpb24oZGF0YSkge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIC8vIFNoYXJlIGZyYWdtZW50IGVycm9yIGNvdW50IGFjY3Jvc3MgbWVkaWEgb3B0aW9ucyAobWFpbiwgYXVkaW8sIHN1YnMpXG4gICAgLy8gVGhpcyBhbGxvd3MgZm9yIGxldmVsIGJhc2VkIHJlbmRpdGlvbiBzd2l0Y2hpbmcgd2hlbiBtZWRpYSBvcHRpb24gYXNzZXRzIGZhaWxcbiAgICBjb25zdCB2YXJpYW50TGV2ZWxJbmRleCA9IHRoaXMuZ2V0VmFyaWFudExldmVsSW5kZXgoZGF0YS5mcmFnKTtcbiAgICBjb25zdCBsZXZlbCA9IGhscy5sZXZlbHNbdmFyaWFudExldmVsSW5kZXhdO1xuICAgIGNvbnN0IHtcbiAgICAgIGZyYWdMb2FkUG9saWN5LFxuICAgICAga2V5TG9hZFBvbGljeVxuICAgIH0gPSBobHMuY29uZmlnO1xuICAgIGNvbnN0IHJldHJ5Q29uZmlnID0gZ2V0UmV0cnlDb25maWcoZGF0YS5kZXRhaWxzLnN0YXJ0c1dpdGgoJ2tleScpID8ga2V5TG9hZFBvbGljeSA6IGZyYWdMb2FkUG9saWN5LCBkYXRhKTtcbiAgICBjb25zdCBmcmFnbWVudEVycm9ycyA9IGhscy5sZXZlbHMucmVkdWNlKChhY2MsIGxldmVsKSA9PiBhY2MgKyBsZXZlbC5mcmFnbWVudEVycm9yLCAwKTtcbiAgICAvLyBTd2l0Y2ggbGV2ZWxzIHdoZW4gb3V0IG9mIHJldHJpZWQgb3IgbGV2ZWwgaW5kZXggb3V0IG9mIGJvdW5kc1xuICAgIGlmIChsZXZlbCkge1xuICAgICAgaWYgKGRhdGEuZGV0YWlscyAhPT0gRXJyb3JEZXRhaWxzLkZSQUdfR0FQKSB7XG4gICAgICAgIGxldmVsLmZyYWdtZW50RXJyb3IrKztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJldHJ5ID0gc2hvdWxkUmV0cnkocmV0cnlDb25maWcsIGZyYWdtZW50RXJyb3JzLCBpc1RpbWVvdXRFcnJvcihkYXRhKSwgZGF0YS5yZXNwb25zZSk7XG4gICAgICBpZiAocmV0cnkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBhY3Rpb246IE5ldHdvcmtFcnJvckFjdGlvbi5SZXRyeVJlcXVlc3QsXG4gICAgICAgICAgZmxhZ3M6IEVycm9yQWN0aW9uRmxhZ3MuTm9uZSxcbiAgICAgICAgICByZXRyeUNvbmZpZyxcbiAgICAgICAgICByZXRyeUNvdW50OiBmcmFnbWVudEVycm9yc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBSZWFjaCBtYXggcmV0cnkgY291bnQsIG9yIE1pc3NpbmcgbGV2ZWwgcmVmZXJlbmNlXG4gICAgLy8gU3dpdGNoIHRvIHZhbGlkIGluZGV4XG4gICAgY29uc3QgZXJyb3JBY3Rpb24gPSB0aGlzLmdldExldmVsU3dpdGNoQWN0aW9uKGRhdGEsIHZhcmlhbnRMZXZlbEluZGV4KTtcbiAgICAvLyBBZGQgcmV0cnkgZGV0YWlscyB0byBhbGxvdyBza2lwcGluZyBvZiBGUkFHX1BBUlNJTkdfRVJST1JcbiAgICBpZiAocmV0cnlDb25maWcpIHtcbiAgICAgIGVycm9yQWN0aW9uLnJldHJ5Q29uZmlnID0gcmV0cnlDb25maWc7XG4gICAgICBlcnJvckFjdGlvbi5yZXRyeUNvdW50ID0gZnJhZ21lbnRFcnJvcnM7XG4gICAgfVxuICAgIHJldHVybiBlcnJvckFjdGlvbjtcbiAgfVxuICBnZXRMZXZlbFN3aXRjaEFjdGlvbihkYXRhLCBsZXZlbEluZGV4KSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgaWYgKGxldmVsSW5kZXggPT09IG51bGwgfHwgbGV2ZWxJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBsZXZlbEluZGV4ID0gaGxzLmxvYWRMZXZlbDtcbiAgICB9XG4gICAgY29uc3QgbGV2ZWwgPSB0aGlzLmhscy5sZXZlbHNbbGV2ZWxJbmRleF07XG4gICAgaWYgKGxldmVsKSB7XG4gICAgICB2YXIgX2RhdGEkZnJhZzIsIF9kYXRhJGNvbnRleHQyO1xuICAgICAgY29uc3QgZXJyb3JEZXRhaWxzID0gZGF0YS5kZXRhaWxzO1xuICAgICAgbGV2ZWwubG9hZEVycm9yKys7XG4gICAgICBpZiAoZXJyb3JEZXRhaWxzID09PSBFcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORF9FUlJPUikge1xuICAgICAgICBsZXZlbC5mcmFnbWVudEVycm9yKys7XG4gICAgICB9XG4gICAgICAvLyBTZWFyY2ggZm9yIG5leHQgbGV2ZWwgdG8gcmV0cnlcbiAgICAgIGxldCBuZXh0TGV2ZWwgPSAtMTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbGV2ZWxzLFxuICAgICAgICBsb2FkTGV2ZWwsXG4gICAgICAgIG1pbkF1dG9MZXZlbCxcbiAgICAgICAgbWF4QXV0b0xldmVsXG4gICAgICB9ID0gaGxzO1xuICAgICAgaWYgKCFobHMuYXV0b0xldmVsRW5hYmxlZCkge1xuICAgICAgICBobHMubG9hZExldmVsID0gLTE7XG4gICAgICB9XG4gICAgICBjb25zdCBmcmFnRXJyb3JUeXBlID0gKF9kYXRhJGZyYWcyID0gZGF0YS5mcmFnKSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGEkZnJhZzIudHlwZTtcbiAgICAgIC8vIEZpbmQgYWx0ZXJuYXRlIGF1ZGlvIGNvZGVjIGlmIGF2YWlsYWJsZSBvbiBhdWRpbyBjb2RlYyBlcnJvclxuICAgICAgY29uc3QgaXNBdWRpb0NvZGVjRXJyb3IgPSBmcmFnRXJyb3JUeXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5BVURJTyAmJiBlcnJvckRldGFpbHMgPT09IEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1IgfHwgZGF0YS5zb3VyY2VCdWZmZXJOYW1lID09PSAnYXVkaW8nICYmIChlcnJvckRldGFpbHMgPT09IEVycm9yRGV0YWlscy5CVUZGRVJfQUREX0NPREVDX0VSUk9SIHx8IGVycm9yRGV0YWlscyA9PT0gRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRfRVJST1IpO1xuICAgICAgY29uc3QgZmluZEF1ZGlvQ29kZWNBbHRlcm5hdGUgPSBpc0F1ZGlvQ29kZWNFcnJvciAmJiBsZXZlbHMuc29tZSgoe1xuICAgICAgICBhdWRpb0NvZGVjXG4gICAgICB9KSA9PiBsZXZlbC5hdWRpb0NvZGVjICE9PSBhdWRpb0NvZGVjKTtcbiAgICAgIC8vIEZpbmQgYWx0ZXJuYXRlIHZpZGVvIGNvZGVjIGlmIGF2YWlsYWJsZSBvbiB2aWRlbyBjb2RlYyBlcnJvclxuICAgICAgY29uc3QgaXNWaWRlb0NvZGVjRXJyb3IgPSBkYXRhLnNvdXJjZUJ1ZmZlck5hbWUgPT09ICd2aWRlbycgJiYgKGVycm9yRGV0YWlscyA9PT0gRXJyb3JEZXRhaWxzLkJVRkZFUl9BRERfQ09ERUNfRVJST1IgfHwgZXJyb3JEZXRhaWxzID09PSBFcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORF9FUlJPUik7XG4gICAgICBjb25zdCBmaW5kVmlkZW9Db2RlY0FsdGVybmF0ZSA9IGlzVmlkZW9Db2RlY0Vycm9yICYmIGxldmVscy5zb21lKCh7XG4gICAgICAgIGNvZGVjU2V0LFxuICAgICAgICBhdWRpb0NvZGVjXG4gICAgICB9KSA9PiBsZXZlbC5jb2RlY1NldCAhPT0gY29kZWNTZXQgJiYgbGV2ZWwuYXVkaW9Db2RlYyA9PT0gYXVkaW9Db2RlYyk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHR5cGU6IHBsYXlsaXN0RXJyb3JUeXBlLFxuICAgICAgICBncm91cElkOiBwbGF5bGlzdEVycm9yR3JvdXBJZFxuICAgICAgfSA9IChfZGF0YSRjb250ZXh0MiA9IGRhdGEuY29udGV4dCkgIT0gbnVsbCA/IF9kYXRhJGNvbnRleHQyIDoge307XG4gICAgICBmb3IgKGxldCBpID0gbGV2ZWxzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSAoaSArIGxvYWRMZXZlbCkgJSBsZXZlbHMubGVuZ3RoO1xuICAgICAgICBpZiAoY2FuZGlkYXRlICE9PSBsb2FkTGV2ZWwgJiYgY2FuZGlkYXRlID49IG1pbkF1dG9MZXZlbCAmJiBjYW5kaWRhdGUgPD0gbWF4QXV0b0xldmVsICYmIGxldmVsc1tjYW5kaWRhdGVdLmxvYWRFcnJvciA9PT0gMCkge1xuICAgICAgICAgIHZhciBfbGV2ZWwkYXVkaW9Hcm91cHMsIF9sZXZlbCRzdWJ0aXRsZUdyb3VwcztcbiAgICAgICAgICBjb25zdCBsZXZlbENhbmRpZGF0ZSA9IGxldmVsc1tjYW5kaWRhdGVdO1xuICAgICAgICAgIC8vIFNraXAgbGV2ZWwgc3dpdGNoIGlmIEdBUCB0YWcgaXMgZm91bmQgaW4gbmV4dCBsZXZlbCBhdCBzYW1lIHBvc2l0aW9uXG4gICAgICAgICAgaWYgKGVycm9yRGV0YWlscyA9PT0gRXJyb3JEZXRhaWxzLkZSQUdfR0FQICYmIGRhdGEuZnJhZykge1xuICAgICAgICAgICAgY29uc3QgbGV2ZWxEZXRhaWxzID0gbGV2ZWxzW2NhbmRpZGF0ZV0uZGV0YWlscztcbiAgICAgICAgICAgIGlmIChsZXZlbERldGFpbHMpIHtcbiAgICAgICAgICAgICAgY29uc3QgZnJhZ0NhbmRpZGF0ZSA9IGZpbmRGcmFnbWVudEJ5UFRTKGRhdGEuZnJhZywgbGV2ZWxEZXRhaWxzLmZyYWdtZW50cywgZGF0YS5mcmFnLnN0YXJ0KTtcbiAgICAgICAgICAgICAgaWYgKGZyYWdDYW5kaWRhdGUgIT0gbnVsbCAmJiBmcmFnQ2FuZGlkYXRlLmdhcCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChwbGF5bGlzdEVycm9yVHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5BVURJT19UUkFDSyAmJiBsZXZlbENhbmRpZGF0ZS5oYXNBdWRpb0dyb3VwKHBsYXlsaXN0RXJyb3JHcm91cElkKSB8fCBwbGF5bGlzdEVycm9yVHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5TVUJUSVRMRV9UUkFDSyAmJiBsZXZlbENhbmRpZGF0ZS5oYXNTdWJ0aXRsZUdyb3VwKHBsYXlsaXN0RXJyb3JHcm91cElkKSkge1xuICAgICAgICAgICAgLy8gRm9yIGF1ZGlvL3N1YnMgcGxheWxpc3QgZXJyb3JzIGZpbmQgYW5vdGhlciBncm91cCBJRCBvciBmYWxsdGhyb3VnaCB0byByZWR1bmRhbnQgZmFpbC1vdmVyXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGZyYWdFcnJvclR5cGUgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLkFVRElPICYmIChfbGV2ZWwkYXVkaW9Hcm91cHMgPSBsZXZlbC5hdWRpb0dyb3VwcykgIT0gbnVsbCAmJiBfbGV2ZWwkYXVkaW9Hcm91cHMuc29tZShncm91cElkID0+IGxldmVsQ2FuZGlkYXRlLmhhc0F1ZGlvR3JvdXAoZ3JvdXBJZCkpIHx8IGZyYWdFcnJvclR5cGUgPT09IFBsYXlsaXN0TGV2ZWxUeXBlLlNVQlRJVExFICYmIChfbGV2ZWwkc3VidGl0bGVHcm91cHMgPSBsZXZlbC5zdWJ0aXRsZUdyb3VwcykgIT0gbnVsbCAmJiBfbGV2ZWwkc3VidGl0bGVHcm91cHMuc29tZShncm91cElkID0+IGxldmVsQ2FuZGlkYXRlLmhhc1N1YnRpdGxlR3JvdXAoZ3JvdXBJZCkpIHx8IGZpbmRBdWRpb0NvZGVjQWx0ZXJuYXRlICYmIGxldmVsLmF1ZGlvQ29kZWMgPT09IGxldmVsQ2FuZGlkYXRlLmF1ZGlvQ29kZWMgfHwgIWZpbmRBdWRpb0NvZGVjQWx0ZXJuYXRlICYmIGxldmVsLmF1ZGlvQ29kZWMgIT09IGxldmVsQ2FuZGlkYXRlLmF1ZGlvQ29kZWMgfHwgZmluZFZpZGVvQ29kZWNBbHRlcm5hdGUgJiYgbGV2ZWwuY29kZWNTZXQgPT09IGxldmVsQ2FuZGlkYXRlLmNvZGVjU2V0KSB7XG4gICAgICAgICAgICAvLyBGb3IgdmlkZW8vYXVkaW8vc3VicyBmcmFnIGVycm9ycyBmaW5kIGFub3RoZXIgZ3JvdXAgSUQgb3IgZmFsbHRocm91Z2ggdG8gcmVkdW5kYW50IGZhaWwtb3ZlclxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5leHRMZXZlbCA9IGNhbmRpZGF0ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5leHRMZXZlbCA+IC0xICYmIGhscy5sb2FkTGV2ZWwgIT09IG5leHRMZXZlbCkge1xuICAgICAgICBkYXRhLmxldmVsUmV0cnkgPSB0cnVlO1xuICAgICAgICB0aGlzLnBsYXlsaXN0RXJyb3IgPSAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFjdGlvbjogTmV0d29ya0Vycm9yQWN0aW9uLlNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3gsXG4gICAgICAgICAgZmxhZ3M6IEVycm9yQWN0aW9uRmxhZ3MuTm9uZSxcbiAgICAgICAgICBuZXh0QXV0b0xldmVsOiBuZXh0TGV2ZWxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gTm8gbGV2ZWxzIHRvIHN3aXRjaCAvIE1hbnVhbCBsZXZlbCBzZWxlY3Rpb24gLyBMZXZlbCBub3QgZm91bmRcbiAgICAvLyBSZXNvbHZlIHdpdGggUGF0aHdheSBzd2l0Y2gsIFJlZHVuZGFudCBmYWlsLW92ZXIsIG9yIHN0YXkgb24gbG93ZXN0IExldmVsXG4gICAgcmV0dXJuIHtcbiAgICAgIGFjdGlvbjogTmV0d29ya0Vycm9yQWN0aW9uLlNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3gsXG4gICAgICBmbGFnczogRXJyb3JBY3Rpb25GbGFncy5Nb3ZlQWxsQWx0ZXJuYXRlc01hdGNoaW5nSG9zdFxuICAgIH07XG4gIH1cbiAgb25FcnJvck91dChldmVudCwgZGF0YSkge1xuICAgIHZhciBfZGF0YSRlcnJvckFjdGlvbjtcbiAgICBzd2l0Y2ggKChfZGF0YSRlcnJvckFjdGlvbiA9IGRhdGEuZXJyb3JBY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YSRlcnJvckFjdGlvbi5hY3Rpb24pIHtcbiAgICAgIGNhc2UgTmV0d29ya0Vycm9yQWN0aW9uLkRvTm90aGluZzpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIE5ldHdvcmtFcnJvckFjdGlvbi5TZW5kQWx0ZXJuYXRlVG9QZW5hbHR5Qm94OlxuICAgICAgICB0aGlzLnNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3goZGF0YSk7XG4gICAgICAgIGlmICghZGF0YS5lcnJvckFjdGlvbi5yZXNvbHZlZCAmJiBkYXRhLmRldGFpbHMgIT09IEVycm9yRGV0YWlscy5GUkFHX0dBUCkge1xuICAgICAgICAgIGRhdGEuZmF0YWwgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKC9NZWRpYVNvdXJjZSByZWFkeVN0YXRlOiBlbmRlZC8udGVzdChkYXRhLmVycm9yLm1lc3NhZ2UpKSB7XG4gICAgICAgICAgdGhpcy53YXJuKGBNZWRpYVNvdXJjZSBlbmRlZCBhZnRlciBcIiR7ZGF0YS5zb3VyY2VCdWZmZXJOYW1lfVwiIHNvdXJjZUJ1ZmZlciBhcHBlbmQgZXJyb3IuIEF0dGVtcHRpbmcgdG8gcmVjb3ZlciBmcm9tIG1lZGlhIGVycm9yLmApO1xuICAgICAgICAgIHRoaXMuaGxzLnJlY292ZXJNZWRpYUVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIE5ldHdvcmtFcnJvckFjdGlvbi5SZXRyeVJlcXVlc3Q6XG4gICAgICAgIC8vIGhhbmRsZWQgYnkgc3RyZWFtIGFuZCBwbGF5bGlzdC9sZXZlbCBjb250cm9sbGVyc1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGRhdGEuZmF0YWwpIHtcbiAgICAgIHRoaXMuaGxzLnN0b3BMb2FkKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIHNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3goZGF0YSkge1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGNvbnN0IGVycm9yQWN0aW9uID0gZGF0YS5lcnJvckFjdGlvbjtcbiAgICBpZiAoIWVycm9yQWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGZsYWdzLFxuICAgICAgaGRjcExldmVsLFxuICAgICAgbmV4dEF1dG9MZXZlbFxuICAgIH0gPSBlcnJvckFjdGlvbjtcbiAgICBzd2l0Y2ggKGZsYWdzKSB7XG4gICAgICBjYXNlIEVycm9yQWN0aW9uRmxhZ3MuTm9uZTpcbiAgICAgICAgdGhpcy5zd2l0Y2hMZXZlbChkYXRhLCBuZXh0QXV0b0xldmVsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVycm9yQWN0aW9uRmxhZ3MuTW92ZUFsbEFsdGVybmF0ZXNNYXRjaGluZ0hEQ1A6XG4gICAgICAgIGlmIChoZGNwTGV2ZWwpIHtcbiAgICAgICAgICBobHMubWF4SGRjcExldmVsID0gSGRjcExldmVsc1tIZGNwTGV2ZWxzLmluZGV4T2YoaGRjcExldmVsKSAtIDFdO1xuICAgICAgICAgIGVycm9yQWN0aW9uLnJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndhcm4oYFJlc3RyaWN0aW5nIHBsYXliYWNrIHRvIEhEQ1AtTEVWRUwgb2YgXCIke2hscy5tYXhIZGNwTGV2ZWx9XCIgb3IgbG93ZXJgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIElmIG5vdCByZXNvbHZlZCBieSBwcmV2aW91cyBhY3Rpb25zIHRyeSB0byBzd2l0Y2ggdG8gbmV4dCBsZXZlbFxuICAgIGlmICghZXJyb3JBY3Rpb24ucmVzb2x2ZWQpIHtcbiAgICAgIHRoaXMuc3dpdGNoTGV2ZWwoZGF0YSwgbmV4dEF1dG9MZXZlbCk7XG4gICAgfVxuICB9XG4gIHN3aXRjaExldmVsKGRhdGEsIGxldmVsSW5kZXgpIHtcbiAgICBpZiAobGV2ZWxJbmRleCAhPT0gdW5kZWZpbmVkICYmIGRhdGEuZXJyb3JBY3Rpb24pIHtcbiAgICAgIHRoaXMud2Fybihgc3dpdGNoaW5nIHRvIGxldmVsICR7bGV2ZWxJbmRleH0gYWZ0ZXIgJHtkYXRhLmRldGFpbHN9YCk7XG4gICAgICB0aGlzLmhscy5uZXh0QXV0b0xldmVsID0gbGV2ZWxJbmRleDtcbiAgICAgIGRhdGEuZXJyb3JBY3Rpb24ucmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgLy8gU3RyZWFtIGNvbnRyb2xsZXIgaXMgcmVzcG9uc2libGUgZm9yIHRoaXMgYnV0IHdvbid0IHN3aXRjaCBvbiBmYWxzZSBzdGFydFxuICAgICAgdGhpcy5obHMubmV4dExvYWRMZXZlbCA9IHRoaXMuaGxzLm5leHRBdXRvTGV2ZWw7XG4gICAgfVxuICB9XG59XG5cbmNsYXNzIEJhc2VQbGF5bGlzdENvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihobHMsIGxvZ1ByZWZpeCkge1xuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMudGltZXIgPSAtMTtcbiAgICB0aGlzLnJlcXVlc3RTY2hlZHVsZWQgPSAtMTtcbiAgICB0aGlzLmNhbkxvYWQgPSBmYWxzZTtcbiAgICB0aGlzLmxvZyA9IHZvaWQgMDtcbiAgICB0aGlzLndhcm4gPSB2b2lkIDA7XG4gICAgdGhpcy5sb2cgPSBsb2dnZXIubG9nLmJpbmQobG9nZ2VyLCBgJHtsb2dQcmVmaXh9OmApO1xuICAgIHRoaXMud2FybiA9IGxvZ2dlci53YXJuLmJpbmQobG9nZ2VyLCBgJHtsb2dQcmVmaXh9OmApO1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuaGxzID0gdGhpcy5sb2cgPSB0aGlzLndhcm4gPSBudWxsO1xuICB9XG4gIGNsZWFyVGltZXIoKSB7XG4gICAgaWYgKHRoaXMudGltZXIgIT09IC0xKSB7XG4gICAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgICAgIHRoaXMudGltZXIgPSAtMTtcbiAgICB9XG4gIH1cbiAgc3RhcnRMb2FkKCkge1xuICAgIHRoaXMuY2FuTG9hZCA9IHRydWU7XG4gICAgdGhpcy5yZXF1ZXN0U2NoZWR1bGVkID0gLTE7XG4gICAgdGhpcy5sb2FkUGxheWxpc3QoKTtcbiAgfVxuICBzdG9wTG9hZCgpIHtcbiAgICB0aGlzLmNhbkxvYWQgPSBmYWxzZTtcbiAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgfVxuICBzd2l0Y2hQYXJhbXMocGxheWxpc3RVcmksIHByZXZpb3VzKSB7XG4gICAgY29uc3QgcmVuZGl0aW9uUmVwb3J0cyA9IHByZXZpb3VzID09IG51bGwgPyB2b2lkIDAgOiBwcmV2aW91cy5yZW5kaXRpb25SZXBvcnRzO1xuICAgIGlmIChyZW5kaXRpb25SZXBvcnRzKSB7XG4gICAgICBsZXQgZm91bmRJbmRleCA9IC0xO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW5kaXRpb25SZXBvcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGF0dHIgPSByZW5kaXRpb25SZXBvcnRzW2ldO1xuICAgICAgICBsZXQgdXJpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHVyaSA9IG5ldyBzZWxmLlVSTChhdHRyLlVSSSwgcHJldmlvdXMudXJsKS5ocmVmO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGxvZ2dlci53YXJuKGBDb3VsZCBub3QgY29uc3RydWN0IG5ldyBVUkwgZm9yIFJlbmRpdGlvbiBSZXBvcnQ6ICR7ZXJyb3J9YCk7XG4gICAgICAgICAgdXJpID0gYXR0ci5VUkkgfHwgJyc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXNlIGV4YWN0IG1hdGNoLiBPdGhlcndpc2UsIHRoZSBsYXN0IHBhcnRpYWwgbWF0Y2gsIGlmIGFueSwgd2lsbCBiZSB1c2VkXG4gICAgICAgIC8vIChQbGF5bGlzdCBVUkkgaW5jbHVkZXMgYSBxdWVyeSBzdHJpbmcgdGhhdCB0aGUgUmVuZGl0aW9uIFJlcG9ydCBkb2VzIG5vdClcbiAgICAgICAgaWYgKHVyaSA9PT0gcGxheWxpc3RVcmkpIHtcbiAgICAgICAgICBmb3VuZEluZGV4ID0gaTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmICh1cmkgPT09IHBsYXlsaXN0VXJpLnN1YnN0cmluZygwLCB1cmkubGVuZ3RoKSkge1xuICAgICAgICAgIGZvdW5kSW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgY29uc3QgYXR0ciA9IHJlbmRpdGlvblJlcG9ydHNbZm91bmRJbmRleF07XG4gICAgICAgIGNvbnN0IG1zbiA9IHBhcnNlSW50KGF0dHJbJ0xBU1QtTVNOJ10pIHx8IChwcmV2aW91cyA9PSBudWxsID8gdm9pZCAwIDogcHJldmlvdXMubGFzdFBhcnRTbik7XG4gICAgICAgIGxldCBwYXJ0ID0gcGFyc2VJbnQoYXR0clsnTEFTVC1QQVJUJ10pIHx8IChwcmV2aW91cyA9PSBudWxsID8gdm9pZCAwIDogcHJldmlvdXMubGFzdFBhcnRJbmRleCk7XG4gICAgICAgIGlmICh0aGlzLmhscy5jb25maWcubG93TGF0ZW5jeU1vZGUpIHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50R29hbCA9IE1hdGgubWluKHByZXZpb3VzLmFnZSAtIHByZXZpb3VzLnBhcnRUYXJnZXQsIHByZXZpb3VzLnRhcmdldGR1cmF0aW9uKTtcbiAgICAgICAgICBpZiAocGFydCA+PSAwICYmIGN1cnJlbnRHb2FsID4gcHJldmlvdXMucGFydFRhcmdldCkge1xuICAgICAgICAgICAgcGFydCArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEhsc1VybFBhcmFtZXRlcnMobXNuLCBwYXJ0ID49IDAgPyBwYXJ0IDogdW5kZWZpbmVkLCBIbHNTa2lwLk5vKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbG9hZFBsYXlsaXN0KGhsc1VybFBhcmFtZXRlcnMpIHtcbiAgICBpZiAodGhpcy5yZXF1ZXN0U2NoZWR1bGVkID09PSAtMSkge1xuICAgICAgdGhpcy5yZXF1ZXN0U2NoZWR1bGVkID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9XG4gICAgLy8gTG9hZGluZyBpcyBoYW5kbGVkIGJ5IHRoZSBzdWJjbGFzc2VzXG4gIH1cbiAgc2hvdWxkTG9hZFBsYXlsaXN0KHBsYXlsaXN0KSB7XG4gICAgcmV0dXJuIHRoaXMuY2FuTG9hZCAmJiAhIXBsYXlsaXN0ICYmICEhcGxheWxpc3QudXJsICYmICghcGxheWxpc3QuZGV0YWlscyB8fCBwbGF5bGlzdC5kZXRhaWxzLmxpdmUpO1xuICB9XG4gIHNob3VsZFJlbG9hZFBsYXlsaXN0KHBsYXlsaXN0KSB7XG4gICAgcmV0dXJuIHRoaXMudGltZXIgPT09IC0xICYmIHRoaXMucmVxdWVzdFNjaGVkdWxlZCA9PT0gLTEgJiYgdGhpcy5zaG91bGRMb2FkUGxheWxpc3QocGxheWxpc3QpO1xuICB9XG4gIHBsYXlsaXN0TG9hZGVkKGluZGV4LCBkYXRhLCBwcmV2aW91c0RldGFpbHMpIHtcbiAgICBjb25zdCB7XG4gICAgICBkZXRhaWxzLFxuICAgICAgc3RhdHNcbiAgICB9ID0gZGF0YTtcblxuICAgIC8vIFNldCBsYXN0IHVwZGF0ZWQgZGF0ZS10aW1lXG4gICAgY29uc3Qgbm93ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICBjb25zdCBlbGFwc2VkID0gc3RhdHMubG9hZGluZy5maXJzdCA/IE1hdGgubWF4KDAsIG5vdyAtIHN0YXRzLmxvYWRpbmcuZmlyc3QpIDogMDtcbiAgICBkZXRhaWxzLmFkdmFuY2VkRGF0ZVRpbWUgPSBEYXRlLm5vdygpIC0gZWxhcHNlZDtcblxuICAgIC8vIGlmIGN1cnJlbnQgcGxheWxpc3QgaXMgYSBsaXZlIHBsYXlsaXN0LCBhcm0gYSB0aW1lciB0byByZWxvYWQgaXRcbiAgICBpZiAoZGV0YWlscy5saXZlIHx8IHByZXZpb3VzRGV0YWlscyAhPSBudWxsICYmIHByZXZpb3VzRGV0YWlscy5saXZlKSB7XG4gICAgICBkZXRhaWxzLnJlbG9hZGVkKHByZXZpb3VzRGV0YWlscyk7XG4gICAgICBpZiAocHJldmlvdXNEZXRhaWxzKSB7XG4gICAgICAgIHRoaXMubG9nKGBsaXZlIHBsYXlsaXN0ICR7aW5kZXh9ICR7ZGV0YWlscy5hZHZhbmNlZCA/ICdSRUZSRVNIRUQgJyArIGRldGFpbHMubGFzdFBhcnRTbiArICctJyArIGRldGFpbHMubGFzdFBhcnRJbmRleCA6IGRldGFpbHMudXBkYXRlZCA/ICdVUERBVEVEJyA6ICdNSVNTRUQnfWApO1xuICAgICAgfVxuICAgICAgLy8gTWVyZ2UgbGl2ZSBwbGF5bGlzdHMgdG8gYWRqdXN0IGZyYWdtZW50IHN0YXJ0cyBhbmQgZmlsbCBpbiBkZWx0YSBwbGF5bGlzdCBza2lwcGVkIHNlZ21lbnRzXG4gICAgICBpZiAocHJldmlvdXNEZXRhaWxzICYmIGRldGFpbHMuZnJhZ21lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbWVyZ2VEZXRhaWxzKHByZXZpb3VzRGV0YWlscywgZGV0YWlscyk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuY2FuTG9hZCB8fCAhZGV0YWlscy5saXZlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBkZWxpdmVyeURpcmVjdGl2ZXM7XG4gICAgICBsZXQgbXNuID0gdW5kZWZpbmVkO1xuICAgICAgbGV0IHBhcnQgPSB1bmRlZmluZWQ7XG4gICAgICBpZiAoZGV0YWlscy5jYW5CbG9ja1JlbG9hZCAmJiBkZXRhaWxzLmVuZFNOICYmIGRldGFpbHMuYWR2YW5jZWQpIHtcbiAgICAgICAgLy8gTG9hZCBsZXZlbCB3aXRoIExMLUhMUyBkZWxpdmVyeSBkaXJlY3RpdmVzXG4gICAgICAgIGNvbnN0IGxvd0xhdGVuY3lNb2RlID0gdGhpcy5obHMuY29uZmlnLmxvd0xhdGVuY3lNb2RlO1xuICAgICAgICBjb25zdCBsYXN0UGFydFNuID0gZGV0YWlscy5sYXN0UGFydFNuO1xuICAgICAgICBjb25zdCBlbmRTbiA9IGRldGFpbHMuZW5kU047XG4gICAgICAgIGNvbnN0IGxhc3RQYXJ0SW5kZXggPSBkZXRhaWxzLmxhc3RQYXJ0SW5kZXg7XG4gICAgICAgIGNvbnN0IGhhc1BhcnRzID0gbGFzdFBhcnRJbmRleCAhPT0gLTE7XG4gICAgICAgIGNvbnN0IGxhc3RQYXJ0ID0gbGFzdFBhcnRTbiA9PT0gZW5kU247XG4gICAgICAgIC8vIFdoZW4gbG93IGxhdGVuY3kgbW9kZSBpcyBkaXNhYmxlZCwgd2UnbGwgc2tpcCBwYXJ0IHJlcXVlc3RzIG9uY2UgdGhlIGxhc3QgcGFydCBpbmRleCBpcyBmb3VuZFxuICAgICAgICBjb25zdCBuZXh0U25TdGFydEluZGV4ID0gbG93TGF0ZW5jeU1vZGUgPyAwIDogbGFzdFBhcnRJbmRleDtcbiAgICAgICAgaWYgKGhhc1BhcnRzKSB7XG4gICAgICAgICAgbXNuID0gbGFzdFBhcnQgPyBlbmRTbiArIDEgOiBsYXN0UGFydFNuO1xuICAgICAgICAgIHBhcnQgPSBsYXN0UGFydCA/IG5leHRTblN0YXJ0SW5kZXggOiBsYXN0UGFydEluZGV4ICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtc24gPSBlbmRTbiArIDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTG93LUxhdGVuY3kgQ0ROIFR1bmUtaW46IFwiYWdlXCIgaGVhZGVyIGFuZCB0aW1lIHNpbmNlIGxvYWQgaW5kaWNhdGVzIHdlJ3JlIGJlaGluZCBieSBtb3JlIHRoYW4gb25lIHBhcnRcbiAgICAgICAgLy8gVXBkYXRlIGRpcmVjdGl2ZXMgdG8gb2J0YWluIHRoZSBQbGF5bGlzdCB0aGF0IGhhcyB0aGUgZXN0aW1hdGVkIGFkZGl0aW9uYWwgZHVyYXRpb24gb2YgbWVkaWFcbiAgICAgICAgY29uc3QgbGFzdEFkdmFuY2VkID0gZGV0YWlscy5hZ2U7XG4gICAgICAgIGNvbnN0IGNkbkFnZSA9IGxhc3RBZHZhbmNlZCArIGRldGFpbHMuYWdlSGVhZGVyO1xuICAgICAgICBsZXQgY3VycmVudEdvYWwgPSBNYXRoLm1pbihjZG5BZ2UgLSBkZXRhaWxzLnBhcnRUYXJnZXQsIGRldGFpbHMudGFyZ2V0ZHVyYXRpb24gKiAxLjUpO1xuICAgICAgICBpZiAoY3VycmVudEdvYWwgPiAwKSB7XG4gICAgICAgICAgaWYgKHByZXZpb3VzRGV0YWlscyAmJiBjdXJyZW50R29hbCA+IHByZXZpb3VzRGV0YWlscy50dW5lSW5Hb2FsKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBhdHRlbXB0ZWQgdG8gZ2V0IHRoZSBuZXh0IG9yIGxhdGVzdCBwbGF5bGlzdCB1cGRhdGUsIGJ1dCBjdXJyZW50R29hbCBpbmNyZWFzZWQsXG4gICAgICAgICAgICAvLyB0aGVuIHdlIGVpdGhlciBjYW4ndCBjYXRjaHVwLCBvciB0aGUgXCJhZ2VcIiBoZWFkZXIgY2Fubm90IGJlIHRydXN0ZWQuXG4gICAgICAgICAgICB0aGlzLndhcm4oYENETiBUdW5lLWluIGdvYWwgaW5jcmVhc2VkIGZyb206ICR7cHJldmlvdXNEZXRhaWxzLnR1bmVJbkdvYWx9IHRvOiAke2N1cnJlbnRHb2FsfSB3aXRoIHBsYXlsaXN0IGFnZTogJHtkZXRhaWxzLmFnZX1gKTtcbiAgICAgICAgICAgIGN1cnJlbnRHb2FsID0gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc2VnbWVudHMgPSBNYXRoLmZsb29yKGN1cnJlbnRHb2FsIC8gZGV0YWlscy50YXJnZXRkdXJhdGlvbik7XG4gICAgICAgICAgICBtc24gKz0gc2VnbWVudHM7XG4gICAgICAgICAgICBpZiAocGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gTWF0aC5yb3VuZChjdXJyZW50R29hbCAlIGRldGFpbHMudGFyZ2V0ZHVyYXRpb24gLyBkZXRhaWxzLnBhcnRUYXJnZXQpO1xuICAgICAgICAgICAgICBwYXJ0ICs9IHBhcnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sb2coYENETiBUdW5lLWluIGFnZTogJHtkZXRhaWxzLmFnZUhlYWRlcn1zIGxhc3QgYWR2YW5jZWQgJHtsYXN0QWR2YW5jZWQudG9GaXhlZCgyKX1zIGdvYWw6ICR7Y3VycmVudEdvYWx9IHNraXAgc24gJHtzZWdtZW50c30gdG8gcGFydCAke3BhcnR9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRldGFpbHMudHVuZUluR29hbCA9IGN1cnJlbnRHb2FsO1xuICAgICAgICB9XG4gICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlcyA9IHRoaXMuZ2V0RGVsaXZlcnlEaXJlY3RpdmVzKGRldGFpbHMsIGRhdGEuZGVsaXZlcnlEaXJlY3RpdmVzLCBtc24sIHBhcnQpO1xuICAgICAgICBpZiAobG93TGF0ZW5jeU1vZGUgfHwgIWxhc3RQYXJ0KSB7XG4gICAgICAgICAgdGhpcy5sb2FkUGxheWxpc3QoZGVsaXZlcnlEaXJlY3RpdmVzKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGV0YWlscy5jYW5CbG9ja1JlbG9hZCB8fCBkZXRhaWxzLmNhblNraXBVbnRpbCkge1xuICAgICAgICBkZWxpdmVyeURpcmVjdGl2ZXMgPSB0aGlzLmdldERlbGl2ZXJ5RGlyZWN0aXZlcyhkZXRhaWxzLCBkYXRhLmRlbGl2ZXJ5RGlyZWN0aXZlcywgbXNuLCBwYXJ0KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJ1ZmZlckluZm8gPSB0aGlzLmhscy5tYWluRm9yd2FyZEJ1ZmZlckluZm87XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGJ1ZmZlckluZm8gPyBidWZmZXJJbmZvLmVuZCAtIGJ1ZmZlckluZm8ubGVuIDogMDtcbiAgICAgIGNvbnN0IGRpc3RhbmNlVG9MaXZlRWRnZU1zID0gKGRldGFpbHMuZWRnZSAtIHBvc2l0aW9uKSAqIDEwMDA7XG4gICAgICBjb25zdCByZWxvYWRJbnRlcnZhbCA9IGNvbXB1dGVSZWxvYWRJbnRlcnZhbChkZXRhaWxzLCBkaXN0YW5jZVRvTGl2ZUVkZ2VNcyk7XG4gICAgICBpZiAoZGV0YWlscy51cGRhdGVkICYmIG5vdyA+IHRoaXMucmVxdWVzdFNjaGVkdWxlZCArIHJlbG9hZEludGVydmFsKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdFNjaGVkdWxlZCA9IHN0YXRzLmxvYWRpbmcuc3RhcnQ7XG4gICAgICB9XG4gICAgICBpZiAobXNuICE9PSB1bmRlZmluZWQgJiYgZGV0YWlscy5jYW5CbG9ja1JlbG9hZCkge1xuICAgICAgICB0aGlzLnJlcXVlc3RTY2hlZHVsZWQgPSBzdGF0cy5sb2FkaW5nLmZpcnN0ICsgcmVsb2FkSW50ZXJ2YWwgLSAoZGV0YWlscy5wYXJ0VGFyZ2V0ICogMTAwMCB8fCAxMDAwKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5yZXF1ZXN0U2NoZWR1bGVkID09PSAtMSB8fCB0aGlzLnJlcXVlc3RTY2hlZHVsZWQgKyByZWxvYWRJbnRlcnZhbCA8IG5vdykge1xuICAgICAgICB0aGlzLnJlcXVlc3RTY2hlZHVsZWQgPSBub3c7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucmVxdWVzdFNjaGVkdWxlZCAtIG5vdyA8PSAwKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdFNjaGVkdWxlZCArPSByZWxvYWRJbnRlcnZhbDtcbiAgICAgIH1cbiAgICAgIGxldCBlc3RpbWF0ZWRUaW1lVW50aWxVcGRhdGUgPSB0aGlzLnJlcXVlc3RTY2hlZHVsZWQgLSBub3c7XG4gICAgICBlc3RpbWF0ZWRUaW1lVW50aWxVcGRhdGUgPSBNYXRoLm1heCgwLCBlc3RpbWF0ZWRUaW1lVW50aWxVcGRhdGUpO1xuICAgICAgdGhpcy5sb2coYHJlbG9hZCBsaXZlIHBsYXlsaXN0ICR7aW5kZXh9IGluICR7TWF0aC5yb3VuZChlc3RpbWF0ZWRUaW1lVW50aWxVcGRhdGUpfSBtc2ApO1xuICAgICAgLy8gdGhpcy5sb2coXG4gICAgICAvLyAgIGBsaXZlIHJlbG9hZCAke2RldGFpbHMudXBkYXRlZCA/ICdSRUZSRVNIRUQnIDogJ01JU1NFRCd9XG4gICAgICAvLyByZWxvYWQgaW4gJHtlc3RpbWF0ZWRUaW1lVW50aWxVcGRhdGUgLyAxMDAwfVxuICAgICAgLy8gcm91bmQgdHJpcCAkeyhzdGF0cy5sb2FkaW5nLmVuZCAtIHN0YXRzLmxvYWRpbmcuc3RhcnQpIC8gMTAwMH1cbiAgICAgIC8vIGRpZmYgJHtcbiAgICAgIC8vICAgKHJlbG9hZEludGVydmFsIC1cbiAgICAgIC8vICAgICAoZXN0aW1hdGVkVGltZVVudGlsVXBkYXRlICtcbiAgICAgIC8vICAgICAgIHN0YXRzLmxvYWRpbmcuZW5kIC1cbiAgICAgIC8vICAgICAgIHN0YXRzLmxvYWRpbmcuc3RhcnQpKSAvXG4gICAgICAvLyAgIDEwMDBcbiAgICAgIC8vIH1cbiAgICAgIC8vIHJlbG9hZCBpbnRlcnZhbCAke3JlbG9hZEludGVydmFsIC8gMTAwMH1cbiAgICAgIC8vIHRhcmdldCBkdXJhdGlvbiAke2RldGFpbHMudGFyZ2V0ZHVyYXRpb259XG4gICAgICAvLyBkaXN0YW5jZSB0byBlZGdlICR7ZGlzdGFuY2VUb0xpdmVFZGdlTXMgLyAxMDAwfWBcbiAgICAgIC8vICk7XG5cbiAgICAgIHRoaXMudGltZXIgPSBzZWxmLnNldFRpbWVvdXQoKCkgPT4gdGhpcy5sb2FkUGxheWxpc3QoZGVsaXZlcnlEaXJlY3RpdmVzKSwgZXN0aW1hdGVkVGltZVVudGlsVXBkYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgfVxuICB9XG4gIGdldERlbGl2ZXJ5RGlyZWN0aXZlcyhkZXRhaWxzLCBwcmV2aW91c0RlbGl2ZXJ5RGlyZWN0aXZlcywgbXNuLCBwYXJ0KSB7XG4gICAgbGV0IHNraXAgPSBnZXRTa2lwVmFsdWUoZGV0YWlscywgbXNuKTtcbiAgICBpZiAocHJldmlvdXNEZWxpdmVyeURpcmVjdGl2ZXMgIT0gbnVsbCAmJiBwcmV2aW91c0RlbGl2ZXJ5RGlyZWN0aXZlcy5za2lwICYmIGRldGFpbHMuZGVsdGFVcGRhdGVGYWlsZWQpIHtcbiAgICAgIG1zbiA9IHByZXZpb3VzRGVsaXZlcnlEaXJlY3RpdmVzLm1zbjtcbiAgICAgIHBhcnQgPSBwcmV2aW91c0RlbGl2ZXJ5RGlyZWN0aXZlcy5wYXJ0O1xuICAgICAgc2tpcCA9IEhsc1NraXAuTm87XG4gICAgfVxuICAgIHJldHVybiBuZXcgSGxzVXJsUGFyYW1ldGVycyhtc24sIHBhcnQsIHNraXApO1xuICB9XG4gIGNoZWNrUmV0cnkoZXJyb3JFdmVudCkge1xuICAgIGNvbnN0IGVycm9yRGV0YWlscyA9IGVycm9yRXZlbnQuZGV0YWlscztcbiAgICBjb25zdCBpc1RpbWVvdXQgPSBpc1RpbWVvdXRFcnJvcihlcnJvckV2ZW50KTtcbiAgICBjb25zdCBlcnJvckFjdGlvbiA9IGVycm9yRXZlbnQuZXJyb3JBY3Rpb247XG4gICAgY29uc3Qge1xuICAgICAgYWN0aW9uLFxuICAgICAgcmV0cnlDb3VudCA9IDAsXG4gICAgICByZXRyeUNvbmZpZ1xuICAgIH0gPSBlcnJvckFjdGlvbiB8fCB7fTtcbiAgICBjb25zdCByZXRyeSA9ICEhZXJyb3JBY3Rpb24gJiYgISFyZXRyeUNvbmZpZyAmJiAoYWN0aW9uID09PSBOZXR3b3JrRXJyb3JBY3Rpb24uUmV0cnlSZXF1ZXN0IHx8ICFlcnJvckFjdGlvbi5yZXNvbHZlZCAmJiBhY3Rpb24gPT09IE5ldHdvcmtFcnJvckFjdGlvbi5TZW5kQWx0ZXJuYXRlVG9QZW5hbHR5Qm94KTtcbiAgICBpZiAocmV0cnkpIHtcbiAgICAgIHZhciBfZXJyb3JFdmVudCRjb250ZXh0O1xuICAgICAgdGhpcy5yZXF1ZXN0U2NoZWR1bGVkID0gLTE7XG4gICAgICBpZiAocmV0cnlDb3VudCA+PSByZXRyeUNvbmZpZy5tYXhOdW1SZXRyeSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoaXNUaW1lb3V0ICYmIChfZXJyb3JFdmVudCRjb250ZXh0ID0gZXJyb3JFdmVudC5jb250ZXh0KSAhPSBudWxsICYmIF9lcnJvckV2ZW50JGNvbnRleHQuZGVsaXZlcnlEaXJlY3RpdmVzKSB7XG4gICAgICAgIC8vIFRoZSBMTC1ITFMgcmVxdWVzdCBhbHJlYWR5IHRpbWVkIG91dCBzbyByZXRyeSBpbW1lZGlhdGVseVxuICAgICAgICB0aGlzLndhcm4oYFJldHJ5aW5nIHBsYXlsaXN0IGxvYWRpbmcgJHtyZXRyeUNvdW50ICsgMX0vJHtyZXRyeUNvbmZpZy5tYXhOdW1SZXRyeX0gYWZ0ZXIgXCIke2Vycm9yRGV0YWlsc31cIiB3aXRob3V0IGRlbGl2ZXJ5LWRpcmVjdGl2ZXNgKTtcbiAgICAgICAgdGhpcy5sb2FkUGxheWxpc3QoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGRlbGF5ID0gZ2V0UmV0cnlEZWxheShyZXRyeUNvbmZpZywgcmV0cnlDb3VudCk7XG4gICAgICAgIC8vIFNjaGVkdWxlIGxldmVsL3RyYWNrIHJlbG9hZFxuICAgICAgICB0aGlzLnRpbWVyID0gc2VsZi5zZXRUaW1lb3V0KCgpID0+IHRoaXMubG9hZFBsYXlsaXN0KCksIGRlbGF5KTtcbiAgICAgICAgdGhpcy53YXJuKGBSZXRyeWluZyBwbGF5bGlzdCBsb2FkaW5nICR7cmV0cnlDb3VudCArIDF9LyR7cmV0cnlDb25maWcubWF4TnVtUmV0cnl9IGFmdGVyIFwiJHtlcnJvckRldGFpbHN9XCIgaW4gJHtkZWxheX1tc2ApO1xuICAgICAgfVxuICAgICAgLy8gYGxldmVsUmV0cnkgPSB0cnVlYCB1c2VkIHRvIGluZm9ybSBvdGhlciBjb250cm9sbGVycyB0aGF0IGEgcmV0cnkgaXMgaGFwcGVuaW5nXG4gICAgICBlcnJvckV2ZW50LmxldmVsUmV0cnkgPSB0cnVlO1xuICAgICAgZXJyb3JBY3Rpb24ucmVzb2x2ZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcmV0cnk7XG4gIH1cbn1cblxuLypcbiAqIGNvbXB1dGUgYW4gRXhwb25lbnRpYWwgV2VpZ2h0ZWQgbW92aW5nIGF2ZXJhZ2VcbiAqIC0gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW92aW5nX2F2ZXJhZ2UjRXhwb25lbnRpYWxfbW92aW5nX2F2ZXJhZ2VcbiAqICAtIGhlYXZpbHkgaW5zcGlyZWQgZnJvbSBzaGFrYS1wbGF5ZXJcbiAqL1xuXG5jbGFzcyBFV01BIHtcbiAgLy8gIEFib3V0IGhhbGYgb2YgdGhlIGVzdGltYXRlZCB2YWx1ZSB3aWxsIGJlIGZyb20gdGhlIGxhc3QgfGhhbGZMaWZlfCBzYW1wbGVzIGJ5IHdlaWdodC5cbiAgY29uc3RydWN0b3IoaGFsZkxpZmUsIGVzdGltYXRlID0gMCwgd2VpZ2h0ID0gMCkge1xuICAgIHRoaXMuaGFsZkxpZmUgPSB2b2lkIDA7XG4gICAgdGhpcy5hbHBoYV8gPSB2b2lkIDA7XG4gICAgdGhpcy5lc3RpbWF0ZV8gPSB2b2lkIDA7XG4gICAgdGhpcy50b3RhbFdlaWdodF8gPSB2b2lkIDA7XG4gICAgdGhpcy5oYWxmTGlmZSA9IGhhbGZMaWZlO1xuICAgIC8vIExhcmdlciB2YWx1ZXMgb2YgYWxwaGEgZXhwaXJlIGhpc3RvcmljYWwgZGF0YSBtb3JlIHNsb3dseS5cbiAgICB0aGlzLmFscGhhXyA9IGhhbGZMaWZlID8gTWF0aC5leHAoTWF0aC5sb2coMC41KSAvIGhhbGZMaWZlKSA6IDA7XG4gICAgdGhpcy5lc3RpbWF0ZV8gPSBlc3RpbWF0ZTtcbiAgICB0aGlzLnRvdGFsV2VpZ2h0XyA9IHdlaWdodDtcbiAgfVxuICBzYW1wbGUod2VpZ2h0LCB2YWx1ZSkge1xuICAgIGNvbnN0IGFkakFscGhhID0gTWF0aC5wb3codGhpcy5hbHBoYV8sIHdlaWdodCk7XG4gICAgdGhpcy5lc3RpbWF0ZV8gPSB2YWx1ZSAqICgxIC0gYWRqQWxwaGEpICsgYWRqQWxwaGEgKiB0aGlzLmVzdGltYXRlXztcbiAgICB0aGlzLnRvdGFsV2VpZ2h0XyArPSB3ZWlnaHQ7XG4gIH1cbiAgZ2V0VG90YWxXZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMudG90YWxXZWlnaHRfO1xuICB9XG4gIGdldEVzdGltYXRlKCkge1xuICAgIGlmICh0aGlzLmFscGhhXykge1xuICAgICAgY29uc3QgemVyb0ZhY3RvciA9IDEgLSBNYXRoLnBvdyh0aGlzLmFscGhhXywgdGhpcy50b3RhbFdlaWdodF8pO1xuICAgICAgaWYgKHplcm9GYWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXN0aW1hdGVfIC8gemVyb0ZhY3RvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZXN0aW1hdGVfO1xuICB9XG59XG5cbi8qXG4gKiBFV01BIEJhbmR3aWR0aCBFc3RpbWF0b3JcbiAqICAtIGhlYXZpbHkgaW5zcGlyZWQgZnJvbSBzaGFrYS1wbGF5ZXJcbiAqIFRyYWNrcyBiYW5kd2lkdGggc2FtcGxlcyBhbmQgZXN0aW1hdGVzIGF2YWlsYWJsZSBiYW5kd2lkdGguXG4gKiBCYXNlZCBvbiB0aGUgbWluaW11bSBvZiB0d28gZXhwb25lbnRpYWxseS13ZWlnaHRlZCBtb3ZpbmcgYXZlcmFnZXMgd2l0aFxuICogZGlmZmVyZW50IGhhbGYtbGl2ZXMuXG4gKi9cblxuY2xhc3MgRXdtYUJhbmRXaWR0aEVzdGltYXRvciB7XG4gIGNvbnN0cnVjdG9yKHNsb3csIGZhc3QsIGRlZmF1bHRFc3RpbWF0ZSwgZGVmYXVsdFRURkIgPSAxMDApIHtcbiAgICB0aGlzLmRlZmF1bHRFc3RpbWF0ZV8gPSB2b2lkIDA7XG4gICAgdGhpcy5taW5XZWlnaHRfID0gdm9pZCAwO1xuICAgIHRoaXMubWluRGVsYXlNc18gPSB2b2lkIDA7XG4gICAgdGhpcy5zbG93XyA9IHZvaWQgMDtcbiAgICB0aGlzLmZhc3RfID0gdm9pZCAwO1xuICAgIHRoaXMuZGVmYXVsdFRURkJfID0gdm9pZCAwO1xuICAgIHRoaXMudHRmYl8gPSB2b2lkIDA7XG4gICAgdGhpcy5kZWZhdWx0RXN0aW1hdGVfID0gZGVmYXVsdEVzdGltYXRlO1xuICAgIHRoaXMubWluV2VpZ2h0XyA9IDAuMDAxO1xuICAgIHRoaXMubWluRGVsYXlNc18gPSA1MDtcbiAgICB0aGlzLnNsb3dfID0gbmV3IEVXTUEoc2xvdyk7XG4gICAgdGhpcy5mYXN0XyA9IG5ldyBFV01BKGZhc3QpO1xuICAgIHRoaXMuZGVmYXVsdFRURkJfID0gZGVmYXVsdFRURkI7XG4gICAgdGhpcy50dGZiXyA9IG5ldyBFV01BKHNsb3cpO1xuICB9XG4gIHVwZGF0ZShzbG93LCBmYXN0KSB7XG4gICAgY29uc3Qge1xuICAgICAgc2xvd18sXG4gICAgICBmYXN0XyxcbiAgICAgIHR0ZmJfXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKHNsb3dfLmhhbGZMaWZlICE9PSBzbG93KSB7XG4gICAgICB0aGlzLnNsb3dfID0gbmV3IEVXTUEoc2xvdywgc2xvd18uZ2V0RXN0aW1hdGUoKSwgc2xvd18uZ2V0VG90YWxXZWlnaHQoKSk7XG4gICAgfVxuICAgIGlmIChmYXN0Xy5oYWxmTGlmZSAhPT0gZmFzdCkge1xuICAgICAgdGhpcy5mYXN0XyA9IG5ldyBFV01BKGZhc3QsIGZhc3RfLmdldEVzdGltYXRlKCksIGZhc3RfLmdldFRvdGFsV2VpZ2h0KCkpO1xuICAgIH1cbiAgICBpZiAodHRmYl8uaGFsZkxpZmUgIT09IHNsb3cpIHtcbiAgICAgIHRoaXMudHRmYl8gPSBuZXcgRVdNQShzbG93LCB0dGZiXy5nZXRFc3RpbWF0ZSgpLCB0dGZiXy5nZXRUb3RhbFdlaWdodCgpKTtcbiAgICB9XG4gIH1cbiAgc2FtcGxlKGR1cmF0aW9uTXMsIG51bUJ5dGVzKSB7XG4gICAgZHVyYXRpb25NcyA9IE1hdGgubWF4KGR1cmF0aW9uTXMsIHRoaXMubWluRGVsYXlNc18pO1xuICAgIGNvbnN0IG51bUJpdHMgPSA4ICogbnVtQnl0ZXM7XG4gICAgLy8gd2VpZ2h0IGlzIGR1cmF0aW9uIGluIHNlY29uZHNcbiAgICBjb25zdCBkdXJhdGlvblMgPSBkdXJhdGlvbk1zIC8gMTAwMDtcbiAgICAvLyB2YWx1ZSBpcyBiYW5kd2lkdGggaW4gYml0cy9zXG4gICAgY29uc3QgYmFuZHdpZHRoSW5CcHMgPSBudW1CaXRzIC8gZHVyYXRpb25TO1xuICAgIHRoaXMuZmFzdF8uc2FtcGxlKGR1cmF0aW9uUywgYmFuZHdpZHRoSW5CcHMpO1xuICAgIHRoaXMuc2xvd18uc2FtcGxlKGR1cmF0aW9uUywgYmFuZHdpZHRoSW5CcHMpO1xuICB9XG4gIHNhbXBsZVRURkIodHRmYikge1xuICAgIC8vIHdlaWdodCBpcyBmcmVxdWVuY3kgY3VydmUgYXBwbGllZCB0byBUVEZCIGluIHNlY29uZHNcbiAgICAvLyAobG9uZ2VyIHRpbWVzIGhhdmUgbGVzcyB3ZWlnaHQgd2l0aCBleHBlY3RlZCBpbnB1dCB1bmRlciAxIHNlY29uZClcbiAgICBjb25zdCBzZWNvbmRzID0gdHRmYiAvIDEwMDA7XG4gICAgY29uc3Qgd2VpZ2h0ID0gTWF0aC5zcXJ0KDIpICogTWF0aC5leHAoLU1hdGgucG93KHNlY29uZHMsIDIpIC8gMik7XG4gICAgdGhpcy50dGZiXy5zYW1wbGUod2VpZ2h0LCBNYXRoLm1heCh0dGZiLCA1KSk7XG4gIH1cbiAgY2FuRXN0aW1hdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmFzdF8uZ2V0VG90YWxXZWlnaHQoKSA+PSB0aGlzLm1pbldlaWdodF87XG4gIH1cbiAgZ2V0RXN0aW1hdGUoKSB7XG4gICAgaWYgKHRoaXMuY2FuRXN0aW1hdGUoKSkge1xuICAgICAgLy8gY29uc29sZS5sb2coJ3Nsb3cgZXN0aW1hdGU6JysgTWF0aC5yb3VuZCh0aGlzLnNsb3dfLmdldEVzdGltYXRlKCkpKTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdmYXN0IGVzdGltYXRlOicrIE1hdGgucm91bmQodGhpcy5mYXN0Xy5nZXRFc3RpbWF0ZSgpKSk7XG4gICAgICAvLyBUYWtlIHRoZSBtaW5pbXVtIG9mIHRoZXNlIHR3byBlc3RpbWF0ZXMuICBUaGlzIHNob3VsZCBoYXZlIHRoZSBlZmZlY3Qgb2ZcbiAgICAgIC8vIGFkYXB0aW5nIGRvd24gcXVpY2tseSwgYnV0IHVwIG1vcmUgc2xvd2x5LlxuICAgICAgcmV0dXJuIE1hdGgubWluKHRoaXMuZmFzdF8uZ2V0RXN0aW1hdGUoKSwgdGhpcy5zbG93Xy5nZXRFc3RpbWF0ZSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdEVzdGltYXRlXztcbiAgICB9XG4gIH1cbiAgZ2V0RXN0aW1hdGVUVEZCKCkge1xuICAgIGlmICh0aGlzLnR0ZmJfLmdldFRvdGFsV2VpZ2h0KCkgPj0gdGhpcy5taW5XZWlnaHRfKSB7XG4gICAgICByZXR1cm4gdGhpcy50dGZiXy5nZXRFc3RpbWF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWZhdWx0VFRGQl87XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7fVxufVxuXG5jb25zdCBTVVBQT1JURURfSU5GT19ERUZBVUxUID0ge1xuICBzdXBwb3J0ZWQ6IHRydWUsXG4gIGNvbmZpZ3VyYXRpb25zOiBbXSxcbiAgZGVjb2RpbmdJbmZvUmVzdWx0czogW3tcbiAgICBzdXBwb3J0ZWQ6IHRydWUsXG4gICAgcG93ZXJFZmZpY2llbnQ6IHRydWUsXG4gICAgc21vb3RoOiB0cnVlXG4gIH1dXG59O1xuY29uc3QgU1VQUE9SVEVEX0lORk9fQ0FDSEUgPSB7fTtcbmZ1bmN0aW9uIHJlcXVpcmVzTWVkaWFDYXBhYmlsaXRpZXNEZWNvZGluZ0luZm8obGV2ZWwsIGF1ZGlvVHJhY2tzQnlHcm91cCwgY3VycmVudFZpZGVvUmFuZ2UsIGN1cnJlbnRGcmFtZVJhdGUsIGN1cnJlbnRCdywgYXVkaW9QcmVmZXJlbmNlKSB7XG4gIC8vIE9ubHkgdGVzdCBzdXBwb3J0IHdoZW4gY29uZmlndXJhdGlvbiBpcyBleGNlZWRzIG1pbmltdW0gb3B0aW9uc1xuICBjb25zdCBhdWRpb0dyb3VwcyA9IGxldmVsLmF1ZGlvQ29kZWMgPyBsZXZlbC5hdWRpb0dyb3VwcyA6IG51bGw7XG4gIGNvbnN0IGF1ZGlvQ29kZWNQcmVmZXJlbmNlID0gYXVkaW9QcmVmZXJlbmNlID09IG51bGwgPyB2b2lkIDAgOiBhdWRpb1ByZWZlcmVuY2UuYXVkaW9Db2RlYztcbiAgY29uc3QgY2hhbm5lbHNQcmVmZXJlbmNlID0gYXVkaW9QcmVmZXJlbmNlID09IG51bGwgPyB2b2lkIDAgOiBhdWRpb1ByZWZlcmVuY2UuY2hhbm5lbHM7XG4gIGNvbnN0IG1heENoYW5uZWxzID0gY2hhbm5lbHNQcmVmZXJlbmNlID8gcGFyc2VJbnQoY2hhbm5lbHNQcmVmZXJlbmNlKSA6IGF1ZGlvQ29kZWNQcmVmZXJlbmNlID8gSW5maW5pdHkgOiAyO1xuICBsZXQgYXVkaW9DaGFubmVscyA9IG51bGw7XG4gIGlmIChhdWRpb0dyb3VwcyAhPSBudWxsICYmIGF1ZGlvR3JvdXBzLmxlbmd0aCkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoYXVkaW9Hcm91cHMubGVuZ3RoID09PSAxICYmIGF1ZGlvR3JvdXBzWzBdKSB7XG4gICAgICAgIGF1ZGlvQ2hhbm5lbHMgPSBhdWRpb1RyYWNrc0J5R3JvdXAuZ3JvdXBzW2F1ZGlvR3JvdXBzWzBdXS5jaGFubmVscztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF1ZGlvQ2hhbm5lbHMgPSBhdWRpb0dyb3Vwcy5yZWR1Y2UoKGFjYywgZ3JvdXBJZCkgPT4ge1xuICAgICAgICAgIGlmIChncm91cElkKSB7XG4gICAgICAgICAgICBjb25zdCBhdWRpb1RyYWNrR3JvdXAgPSBhdWRpb1RyYWNrc0J5R3JvdXAuZ3JvdXBzW2dyb3VwSWRdO1xuICAgICAgICAgICAgaWYgKCFhdWRpb1RyYWNrR3JvdXApIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdWRpbyB0cmFjayBncm91cCAke2dyb3VwSWR9IG5vdCBmb3VuZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3VtIGFsbCBjaGFubmVsIGtleSB2YWx1ZXNcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGF1ZGlvVHJhY2tHcm91cC5jaGFubmVscykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICBhY2Nba2V5XSA9IChhY2Nba2V5XSB8fCAwKSArIGF1ZGlvVHJhY2tHcm91cC5jaGFubmVsc1trZXldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAyOiAwXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxldmVsLnZpZGVvQ29kZWMgIT09IHVuZGVmaW5lZCAmJiAobGV2ZWwud2lkdGggPiAxOTIwICYmIGxldmVsLmhlaWdodCA+IDEwODggfHwgbGV2ZWwuaGVpZ2h0ID4gMTkyMCAmJiBsZXZlbC53aWR0aCA+IDEwODggfHwgbGV2ZWwuZnJhbWVSYXRlID4gTWF0aC5tYXgoY3VycmVudEZyYW1lUmF0ZSwgMzApIHx8IGxldmVsLnZpZGVvUmFuZ2UgIT09ICdTRFInICYmIGxldmVsLnZpZGVvUmFuZ2UgIT09IGN1cnJlbnRWaWRlb1JhbmdlIHx8IGxldmVsLmJpdHJhdGUgPiBNYXRoLm1heChjdXJyZW50QncsIDhlNikpIHx8ICEhYXVkaW9DaGFubmVscyAmJiBpc0Zpbml0ZU51bWJlcihtYXhDaGFubmVscykgJiYgT2JqZWN0LmtleXMoYXVkaW9DaGFubmVscykuc29tZShjaGFubmVscyA9PiBwYXJzZUludChjaGFubmVscykgPiBtYXhDaGFubmVscyk7XG59XG5mdW5jdGlvbiBnZXRNZWRpYURlY29kaW5nSW5mb1Byb21pc2UobGV2ZWwsIGF1ZGlvVHJhY2tzQnlHcm91cCwgbWVkaWFDYXBhYmlsaXRpZXMpIHtcbiAgY29uc3QgdmlkZW9Db2RlY3MgPSBsZXZlbC52aWRlb0NvZGVjO1xuICBjb25zdCBhdWRpb0NvZGVjcyA9IGxldmVsLmF1ZGlvQ29kZWM7XG4gIGlmICghdmlkZW9Db2RlY3MgfHwgIWF1ZGlvQ29kZWNzIHx8ICFtZWRpYUNhcGFiaWxpdGllcykge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoU1VQUE9SVEVEX0lORk9fREVGQVVMVCk7XG4gIH1cbiAgY29uc3QgYmFzZVZpZGVvQ29uZmlndXJhdGlvbiA9IHtcbiAgICB3aWR0aDogbGV2ZWwud2lkdGgsXG4gICAgaGVpZ2h0OiBsZXZlbC5oZWlnaHQsXG4gICAgYml0cmF0ZTogTWF0aC5jZWlsKE1hdGgubWF4KGxldmVsLmJpdHJhdGUgKiAwLjksIGxldmVsLmF2ZXJhZ2VCaXRyYXRlKSksXG4gICAgLy8gQXNzdW1lIGEgZnJhbWVyYXRlIG9mIDMwZnBzIHNpbmNlIE1lZGlhQ2FwYWJpbGl0aWVzIHdpbGwgbm90IGFjY2VwdCBMZXZlbCBkZWZhdWx0IG9mIDAuXG4gICAgZnJhbWVyYXRlOiBsZXZlbC5mcmFtZVJhdGUgfHwgMzBcbiAgfTtcbiAgY29uc3QgdmlkZW9SYW5nZSA9IGxldmVsLnZpZGVvUmFuZ2U7XG4gIGlmICh2aWRlb1JhbmdlICE9PSAnU0RSJykge1xuICAgIGJhc2VWaWRlb0NvbmZpZ3VyYXRpb24udHJhbnNmZXJGdW5jdGlvbiA9IHZpZGVvUmFuZ2UudG9Mb3dlckNhc2UoKTtcbiAgfVxuICBjb25zdCBjb25maWd1cmF0aW9ucyA9IHZpZGVvQ29kZWNzLnNwbGl0KCcsJykubWFwKHZpZGVvQ29kZWMgPT4gKHtcbiAgICB0eXBlOiAnbWVkaWEtc291cmNlJyxcbiAgICB2aWRlbzogX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGJhc2VWaWRlb0NvbmZpZ3VyYXRpb24pLCB7fSwge1xuICAgICAgY29udGVudFR5cGU6IG1pbWVUeXBlRm9yQ29kZWModmlkZW9Db2RlYywgJ3ZpZGVvJylcbiAgICB9KVxuICB9KSk7XG4gIGlmIChhdWRpb0NvZGVjcyAmJiBsZXZlbC5hdWRpb0dyb3Vwcykge1xuICAgIGxldmVsLmF1ZGlvR3JvdXBzLmZvckVhY2goYXVkaW9Hcm91cElkID0+IHtcbiAgICAgIHZhciBfYXVkaW9UcmFja3NCeUdyb3VwJGc7XG4gICAgICBpZiAoIWF1ZGlvR3JvdXBJZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAoX2F1ZGlvVHJhY2tzQnlHcm91cCRnID0gYXVkaW9UcmFja3NCeUdyb3VwLmdyb3Vwc1thdWRpb0dyb3VwSWRdKSA9PSBudWxsID8gdm9pZCAwIDogX2F1ZGlvVHJhY2tzQnlHcm91cCRnLnRyYWNrcy5mb3JFYWNoKGF1ZGlvVHJhY2sgPT4ge1xuICAgICAgICBpZiAoYXVkaW9UcmFjay5ncm91cElkID09PSBhdWRpb0dyb3VwSWQpIHtcbiAgICAgICAgICBjb25zdCBjaGFubmVscyA9IGF1ZGlvVHJhY2suY2hhbm5lbHMgfHwgJyc7XG4gICAgICAgICAgY29uc3QgY2hhbm5lbHNOdW1iZXIgPSBwYXJzZUZsb2F0KGNoYW5uZWxzKTtcbiAgICAgICAgICBpZiAoaXNGaW5pdGVOdW1iZXIoY2hhbm5lbHNOdW1iZXIpICYmIGNoYW5uZWxzTnVtYmVyID4gMikge1xuICAgICAgICAgICAgY29uZmlndXJhdGlvbnMucHVzaC5hcHBseShjb25maWd1cmF0aW9ucywgYXVkaW9Db2RlY3Muc3BsaXQoJywnKS5tYXAoYXVkaW9Db2RlYyA9PiAoe1xuICAgICAgICAgICAgICB0eXBlOiAnbWVkaWEtc291cmNlJyxcbiAgICAgICAgICAgICAgYXVkaW86IHtcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogbWltZVR5cGVGb3JDb2RlYyhhdWRpb0NvZGVjLCAnYXVkaW8nKSxcbiAgICAgICAgICAgICAgICBjaGFubmVsczogJycgKyBjaGFubmVsc051bWJlclxuICAgICAgICAgICAgICAgIC8vIHNwYXRpYWxSZW5kZXJpbmc6XG4gICAgICAgICAgICAgICAgLy8gICBhdWRpb0NvZGVjID09PSAnZWMtMycgJiYgY2hhbm5lbHMuaW5kZXhPZignSk9DJyksXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gUHJvbWlzZS5hbGwoY29uZmlndXJhdGlvbnMubWFwKGNvbmZpZ3VyYXRpb24gPT4ge1xuICAgIC8vIENhY2hlIE1lZGlhQ2FwYWJpbGl0aWVzIHByb21pc2VzXG4gICAgY29uc3QgZGVjb2RpbmdJbmZvS2V5ID0gZ2V0TWVkaWFEZWNvZGluZ0luZm9LZXkoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIFNVUFBPUlRFRF9JTkZPX0NBQ0hFW2RlY29kaW5nSW5mb0tleV0gfHwgKFNVUFBPUlRFRF9JTkZPX0NBQ0hFW2RlY29kaW5nSW5mb0tleV0gPSBtZWRpYUNhcGFiaWxpdGllcy5kZWNvZGluZ0luZm8oY29uZmlndXJhdGlvbikpO1xuICB9KSkudGhlbihkZWNvZGluZ0luZm9SZXN1bHRzID0+ICh7XG4gICAgc3VwcG9ydGVkOiAhZGVjb2RpbmdJbmZvUmVzdWx0cy5zb21lKGluZm8gPT4gIWluZm8uc3VwcG9ydGVkKSxcbiAgICBjb25maWd1cmF0aW9ucyxcbiAgICBkZWNvZGluZ0luZm9SZXN1bHRzXG4gIH0pKS5jYXRjaChlcnJvciA9PiAoe1xuICAgIHN1cHBvcnRlZDogZmFsc2UsXG4gICAgY29uZmlndXJhdGlvbnMsXG4gICAgZGVjb2RpbmdJbmZvUmVzdWx0czogW10sXG4gICAgZXJyb3JcbiAgfSkpO1xufVxuZnVuY3Rpb24gZ2V0TWVkaWFEZWNvZGluZ0luZm9LZXkoY29uZmlnKSB7XG4gIGNvbnN0IHtcbiAgICBhdWRpbyxcbiAgICB2aWRlb1xuICB9ID0gY29uZmlnO1xuICBjb25zdCBtZWRpYUNvbmZpZyA9IHZpZGVvIHx8IGF1ZGlvO1xuICBpZiAobWVkaWFDb25maWcpIHtcbiAgICBjb25zdCBjb2RlYyA9IG1lZGlhQ29uZmlnLmNvbnRlbnRUeXBlLnNwbGl0KCdcIicpWzFdO1xuICAgIGlmICh2aWRlbykge1xuICAgICAgcmV0dXJuIGByJHt2aWRlby5oZWlnaHR9eCR7dmlkZW8ud2lkdGh9ZiR7TWF0aC5jZWlsKHZpZGVvLmZyYW1lcmF0ZSl9JHt2aWRlby50cmFuc2ZlckZ1bmN0aW9uIHx8ICdzZCd9XyR7Y29kZWN9XyR7TWF0aC5jZWlsKHZpZGVvLmJpdHJhdGUgLyAxZTUpfWA7XG4gICAgfVxuICAgIGlmIChhdWRpbykge1xuICAgICAgcmV0dXJuIGBjJHthdWRpby5jaGFubmVsc30ke2F1ZGlvLnNwYXRpYWxSZW5kZXJpbmcgPyAncycgOiAnbid9XyR7Y29kZWN9YDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIFdoZXRoZXIgd2UgY2FuIGRldGVjdCBhbmQgdmFsaWRhdGUgSERSIGNhcGFiaWxpdHkgd2l0aGluIHRoZSB3aW5kb3cgY29udGV4dFxuICovXG5mdW5jdGlvbiBpc0hkclN1cHBvcnRlZCgpIHtcbiAgaWYgKHR5cGVvZiBtYXRjaE1lZGlhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3QgbWVkaWFRdWVyeUxpc3QgPSBtYXRjaE1lZGlhKCcoZHluYW1pYy1yYW5nZTogaGlnaCknKTtcbiAgICBjb25zdCBiYWRRdWVyeSA9IG1hdGNoTWVkaWEoJ2JhZCBxdWVyeScpO1xuICAgIGlmIChtZWRpYVF1ZXJ5TGlzdC5tZWRpYSAhPT0gYmFkUXVlcnkubWVkaWEpIHtcbiAgICAgIHJldHVybiBtZWRpYVF1ZXJ5TGlzdC5tYXRjaGVzID09PSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogU2FuaXRpemVzIGlucHV0cyB0byByZXR1cm4gdGhlIGFjdGl2ZSB2aWRlbyBzZWxlY3Rpb24gb3B0aW9ucyBmb3IgSERSL1NEUi5cbiAqIFdoZW4gYm90aCBpbnB1dHMgYXJlIG51bGw6XG4gKlxuICogICAgYHsgcHJlZmVySERSOiBmYWxzZSwgYWxsb3dlZFZpZGVvUmFuZ2VzOiBbXSB9YFxuICpcbiAqIFdoZW4gYGN1cnJlbnRWaWRlb1JhbmdlYCBub24tbnVsbCwgbWFpbnRhaW4gdGhlIGFjdGl2ZSByYW5nZTpcbiAqXG4gKiAgICBgeyBwcmVmZXJIRFI6IGN1cnJlbnRWaWRlb1JhbmdlICE9PSAnU0RSJywgYWxsb3dlZFZpZGVvUmFuZ2VzOiBbY3VycmVudFZpZGVvUmFuZ2VdIH1gXG4gKlxuICogV2hlbiBWaWRlb1NlbGVjdGlvbk9wdGlvbiBub24tbnVsbDpcbiAqXG4gKiAgLSBBbGxvdyBhbGwgdmlkZW8gcmFuZ2VzIGlmIGBhbGxvd2VkVmlkZW9SYW5nZXNgIHVuc3BlY2lmaWVkLlxuICogIC0gSWYgYHByZWZlckhEUmAgaXMgbm9uLW51bGwgdXNlIHRoZSB2YWx1ZSB0byBmaWx0ZXIgYGFsbG93ZWRWaWRlb1Jhbmdlc2AuXG4gKiAgLSBFbHNlIGNoZWNrIHdpbmRvdyBmb3IgSERSIHN1cHBvcnQgYW5kIHNldCBgcHJlZmVySERSYCB0byB0aGUgcmVzdWx0LlxuICpcbiAqIEBwYXJhbSBjdXJyZW50VmlkZW9SYW5nZVxuICogQHBhcmFtIHZpZGVvUHJlZmVyZW5jZVxuICovXG5mdW5jdGlvbiBnZXRWaWRlb1NlbGVjdGlvbk9wdGlvbnMoY3VycmVudFZpZGVvUmFuZ2UsIHZpZGVvUHJlZmVyZW5jZSkge1xuICBsZXQgcHJlZmVySERSID0gZmFsc2U7XG4gIGxldCBhbGxvd2VkVmlkZW9SYW5nZXMgPSBbXTtcbiAgaWYgKGN1cnJlbnRWaWRlb1JhbmdlKSB7XG4gICAgcHJlZmVySERSID0gY3VycmVudFZpZGVvUmFuZ2UgIT09ICdTRFInO1xuICAgIGFsbG93ZWRWaWRlb1JhbmdlcyA9IFtjdXJyZW50VmlkZW9SYW5nZV07XG4gIH1cbiAgaWYgKHZpZGVvUHJlZmVyZW5jZSkge1xuICAgIGFsbG93ZWRWaWRlb1JhbmdlcyA9IHZpZGVvUHJlZmVyZW5jZS5hbGxvd2VkVmlkZW9SYW5nZXMgfHwgVmlkZW9SYW5nZVZhbHVlcy5zbGljZSgwKTtcbiAgICBwcmVmZXJIRFIgPSB2aWRlb1ByZWZlcmVuY2UucHJlZmVySERSICE9PSB1bmRlZmluZWQgPyB2aWRlb1ByZWZlcmVuY2UucHJlZmVySERSIDogaXNIZHJTdXBwb3J0ZWQoKTtcbiAgICBpZiAocHJlZmVySERSKSB7XG4gICAgICBhbGxvd2VkVmlkZW9SYW5nZXMgPSBhbGxvd2VkVmlkZW9SYW5nZXMuZmlsdGVyKHJhbmdlID0+IHJhbmdlICE9PSAnU0RSJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFsbG93ZWRWaWRlb1JhbmdlcyA9IFsnU0RSJ107XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgcHJlZmVySERSLFxuICAgIGFsbG93ZWRWaWRlb1Jhbmdlc1xuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRTdGFydENvZGVjVGllcihjb2RlY1RpZXJzLCBjdXJyZW50VmlkZW9SYW5nZSwgY3VycmVudEJ3LCBhdWRpb1ByZWZlcmVuY2UsIHZpZGVvUHJlZmVyZW5jZSkge1xuICBjb25zdCBjb2RlY1NldHMgPSBPYmplY3Qua2V5cyhjb2RlY1RpZXJzKTtcbiAgY29uc3QgY2hhbm5lbHNQcmVmZXJlbmNlID0gYXVkaW9QcmVmZXJlbmNlID09IG51bGwgPyB2b2lkIDAgOiBhdWRpb1ByZWZlcmVuY2UuY2hhbm5lbHM7XG4gIGNvbnN0IGF1ZGlvQ29kZWNQcmVmZXJlbmNlID0gYXVkaW9QcmVmZXJlbmNlID09IG51bGwgPyB2b2lkIDAgOiBhdWRpb1ByZWZlcmVuY2UuYXVkaW9Db2RlYztcbiAgY29uc3QgcHJlZmVyU3RlcmVvID0gY2hhbm5lbHNQcmVmZXJlbmNlICYmIHBhcnNlSW50KGNoYW5uZWxzUHJlZmVyZW5jZSkgPT09IDI7XG4gIC8vIFVzZSBmaXJzdCBsZXZlbCBzZXQgdG8gZGV0ZXJtaW5lIHN0ZXJlbywgYW5kIG1pbmltdW0gcmVzb2x1dGlvbiBhbmQgZnJhbWVyYXRlXG4gIGxldCBoYXNTdGVyZW8gPSB0cnVlO1xuICBsZXQgaGFzQ3VycmVudFZpZGVvUmFuZ2UgPSBmYWxzZTtcbiAgbGV0IG1pbkhlaWdodCA9IEluZmluaXR5O1xuICBsZXQgbWluRnJhbWVyYXRlID0gSW5maW5pdHk7XG4gIGxldCBtaW5CaXRyYXRlID0gSW5maW5pdHk7XG4gIGxldCBzZWxlY3RlZFNjb3JlID0gMDtcbiAgbGV0IHZpZGVvUmFuZ2VzID0gW107XG4gIGNvbnN0IHtcbiAgICBwcmVmZXJIRFIsXG4gICAgYWxsb3dlZFZpZGVvUmFuZ2VzXG4gIH0gPSBnZXRWaWRlb1NlbGVjdGlvbk9wdGlvbnMoY3VycmVudFZpZGVvUmFuZ2UsIHZpZGVvUHJlZmVyZW5jZSk7XG4gIGZvciAobGV0IGkgPSBjb2RlY1NldHMubGVuZ3RoOyBpLS07KSB7XG4gICAgY29uc3QgdGllciA9IGNvZGVjVGllcnNbY29kZWNTZXRzW2ldXTtcbiAgICBoYXNTdGVyZW8gPSB0aWVyLmNoYW5uZWxzWzJdID4gMDtcbiAgICBtaW5IZWlnaHQgPSBNYXRoLm1pbihtaW5IZWlnaHQsIHRpZXIubWluSGVpZ2h0KTtcbiAgICBtaW5GcmFtZXJhdGUgPSBNYXRoLm1pbihtaW5GcmFtZXJhdGUsIHRpZXIubWluRnJhbWVyYXRlKTtcbiAgICBtaW5CaXRyYXRlID0gTWF0aC5taW4obWluQml0cmF0ZSwgdGllci5taW5CaXRyYXRlKTtcbiAgICBjb25zdCBtYXRjaGluZ1ZpZGVvUmFuZ2VzID0gYWxsb3dlZFZpZGVvUmFuZ2VzLmZpbHRlcihyYW5nZSA9PiB0aWVyLnZpZGVvUmFuZ2VzW3JhbmdlXSA+IDApO1xuICAgIGlmIChtYXRjaGluZ1ZpZGVvUmFuZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgIGhhc0N1cnJlbnRWaWRlb1JhbmdlID0gdHJ1ZTtcbiAgICAgIHZpZGVvUmFuZ2VzID0gbWF0Y2hpbmdWaWRlb1JhbmdlcztcbiAgICB9XG4gIH1cbiAgbWluSGVpZ2h0ID0gaXNGaW5pdGVOdW1iZXIobWluSGVpZ2h0KSA/IG1pbkhlaWdodCA6IDA7XG4gIG1pbkZyYW1lcmF0ZSA9IGlzRmluaXRlTnVtYmVyKG1pbkZyYW1lcmF0ZSkgPyBtaW5GcmFtZXJhdGUgOiAwO1xuICBjb25zdCBtYXhIZWlnaHQgPSBNYXRoLm1heCgxMDgwLCBtaW5IZWlnaHQpO1xuICBjb25zdCBtYXhGcmFtZXJhdGUgPSBNYXRoLm1heCgzMCwgbWluRnJhbWVyYXRlKTtcbiAgbWluQml0cmF0ZSA9IGlzRmluaXRlTnVtYmVyKG1pbkJpdHJhdGUpID8gbWluQml0cmF0ZSA6IGN1cnJlbnRCdztcbiAgY3VycmVudEJ3ID0gTWF0aC5tYXgobWluQml0cmF0ZSwgY3VycmVudEJ3KTtcbiAgLy8gSWYgdGhlcmUgYXJlIG5vIHZhcmlhbnRzIHdpdGggbWF0Y2hpbmcgcHJlZmVyZW5jZSwgc2V0IGN1cnJlbnRWaWRlb1JhbmdlIHRvIHVuZGVmaW5lZFxuICBpZiAoIWhhc0N1cnJlbnRWaWRlb1JhbmdlKSB7XG4gICAgY3VycmVudFZpZGVvUmFuZ2UgPSB1bmRlZmluZWQ7XG4gICAgdmlkZW9SYW5nZXMgPSBbXTtcbiAgfVxuICBjb25zdCBjb2RlY1NldCA9IGNvZGVjU2V0cy5yZWR1Y2UoKHNlbGVjdGVkLCBjYW5kaWRhdGUpID0+IHtcbiAgICAvLyBSZW1vdmUgY2FuZGlhdGVzIHdoaWNoIGRvIG5vdCBtZWV0IGJpdHJhdGUsIGRlZmF1bHQgYXVkaW8sIHN0ZXJlbyBvciBjaGFubmVscyBwcmVmZXJlbmNlLCAxMDgwcCBvciBsb3dlciwgMzBmcHMgb3IgbG93ZXIsIG9yIFNEUi9IRFIgc2VsZWN0aW9uIGlmIHByZXNlbnRcbiAgICBjb25zdCBjYW5kaWRhdGVUaWVyID0gY29kZWNUaWVyc1tjYW5kaWRhdGVdO1xuICAgIGlmIChjYW5kaWRhdGUgPT09IHNlbGVjdGVkKSB7XG4gICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgfVxuICAgIGlmIChjYW5kaWRhdGVUaWVyLm1pbkJpdHJhdGUgPiBjdXJyZW50QncpIHtcbiAgICAgIGxvZ1N0YXJ0Q29kZWNDYW5kaWRhdGVJZ25vcmVkKGNhbmRpZGF0ZSwgYG1pbiBiaXRyYXRlIG9mICR7Y2FuZGlkYXRlVGllci5taW5CaXRyYXRlfSA+IGN1cnJlbnQgZXN0aW1hdGUgb2YgJHtjdXJyZW50Qnd9YCk7XG4gICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgfVxuICAgIGlmICghY2FuZGlkYXRlVGllci5oYXNEZWZhdWx0QXVkaW8pIHtcbiAgICAgIGxvZ1N0YXJ0Q29kZWNDYW5kaWRhdGVJZ25vcmVkKGNhbmRpZGF0ZSwgYG5vIHJlbmRpdGlvbnMgd2l0aCBkZWZhdWx0IG9yIGF1dG8tc2VsZWN0IHNvdW5kIGZvdW5kYCk7XG4gICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgfVxuICAgIGlmIChhdWRpb0NvZGVjUHJlZmVyZW5jZSAmJiBjYW5kaWRhdGUuaW5kZXhPZihhdWRpb0NvZGVjUHJlZmVyZW5jZS5zdWJzdHJpbmcoMCwgNCkpICUgNSAhPT0gMCkge1xuICAgICAgbG9nU3RhcnRDb2RlY0NhbmRpZGF0ZUlnbm9yZWQoY2FuZGlkYXRlLCBgYXVkaW8gY29kZWMgcHJlZmVyZW5jZSBcIiR7YXVkaW9Db2RlY1ByZWZlcmVuY2V9XCIgbm90IGZvdW5kYCk7XG4gICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgfVxuICAgIGlmIChjaGFubmVsc1ByZWZlcmVuY2UgJiYgIXByZWZlclN0ZXJlbykge1xuICAgICAgaWYgKCFjYW5kaWRhdGVUaWVyLmNoYW5uZWxzW2NoYW5uZWxzUHJlZmVyZW5jZV0pIHtcbiAgICAgICAgbG9nU3RhcnRDb2RlY0NhbmRpZGF0ZUlnbm9yZWQoY2FuZGlkYXRlLCBgbm8gcmVuZGl0aW9ucyB3aXRoICR7Y2hhbm5lbHNQcmVmZXJlbmNlfSBjaGFubmVsIHNvdW5kIGZvdW5kIChjaGFubmVscyBvcHRpb25zOiAke09iamVjdC5rZXlzKGNhbmRpZGF0ZVRpZXIuY2hhbm5lbHMpfSlgKTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoKCFhdWRpb0NvZGVjUHJlZmVyZW5jZSB8fCBwcmVmZXJTdGVyZW8pICYmIGhhc1N0ZXJlbyAmJiBjYW5kaWRhdGVUaWVyLmNoYW5uZWxzWycyJ10gPT09IDApIHtcbiAgICAgIGxvZ1N0YXJ0Q29kZWNDYW5kaWRhdGVJZ25vcmVkKGNhbmRpZGF0ZSwgYG5vIHJlbmRpdGlvbnMgd2l0aCBzdGVyZW8gc291bmQgZm91bmRgKTtcbiAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICB9XG4gICAgaWYgKGNhbmRpZGF0ZVRpZXIubWluSGVpZ2h0ID4gbWF4SGVpZ2h0KSB7XG4gICAgICBsb2dTdGFydENvZGVjQ2FuZGlkYXRlSWdub3JlZChjYW5kaWRhdGUsIGBtaW4gcmVzb2x1dGlvbiBvZiAke2NhbmRpZGF0ZVRpZXIubWluSGVpZ2h0fSA+IG1heGltdW0gb2YgJHttYXhIZWlnaHR9YCk7XG4gICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgfVxuICAgIGlmIChjYW5kaWRhdGVUaWVyLm1pbkZyYW1lcmF0ZSA+IG1heEZyYW1lcmF0ZSkge1xuICAgICAgbG9nU3RhcnRDb2RlY0NhbmRpZGF0ZUlnbm9yZWQoY2FuZGlkYXRlLCBgbWluIGZyYW1lcmF0ZSBvZiAke2NhbmRpZGF0ZVRpZXIubWluRnJhbWVyYXRlfSA+IG1heGltdW0gb2YgJHttYXhGcmFtZXJhdGV9YCk7XG4gICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgfVxuICAgIGlmICghdmlkZW9SYW5nZXMuc29tZShyYW5nZSA9PiBjYW5kaWRhdGVUaWVyLnZpZGVvUmFuZ2VzW3JhbmdlXSA+IDApKSB7XG4gICAgICBsb2dTdGFydENvZGVjQ2FuZGlkYXRlSWdub3JlZChjYW5kaWRhdGUsIGBubyB2YXJpYW50cyB3aXRoIFZJREVPLVJBTkdFIG9mICR7SlNPTi5zdHJpbmdpZnkodmlkZW9SYW5nZXMpfSBmb3VuZGApO1xuICAgICAgcmV0dXJuIHNlbGVjdGVkO1xuICAgIH1cbiAgICBpZiAoY2FuZGlkYXRlVGllci5tYXhTY29yZSA8IHNlbGVjdGVkU2NvcmUpIHtcbiAgICAgIGxvZ1N0YXJ0Q29kZWNDYW5kaWRhdGVJZ25vcmVkKGNhbmRpZGF0ZSwgYG1heCBzY29yZSBvZiAke2NhbmRpZGF0ZVRpZXIubWF4U2NvcmV9IDwgc2VsZWN0ZWQgbWF4IG9mICR7c2VsZWN0ZWRTY29yZX1gKTtcbiAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIGNhbmRpYXRlcyB3aXRoIGxlc3MgcHJlZmVycmVkIGNvZGVjcyBvciBtb3JlIGVycm9yc1xuICAgIGlmIChzZWxlY3RlZCAmJiAoY29kZWNzU2V0U2VsZWN0aW9uUHJlZmVyZW5jZVZhbHVlKGNhbmRpZGF0ZSkgPj0gY29kZWNzU2V0U2VsZWN0aW9uUHJlZmVyZW5jZVZhbHVlKHNlbGVjdGVkKSB8fCBjYW5kaWRhdGVUaWVyLmZyYWdtZW50RXJyb3IgPiBjb2RlY1RpZXJzW3NlbGVjdGVkXS5mcmFnbWVudEVycm9yKSkge1xuICAgICAgcmV0dXJuIHNlbGVjdGVkO1xuICAgIH1cbiAgICBzZWxlY3RlZFNjb3JlID0gY2FuZGlkYXRlVGllci5tYXhTY29yZTtcbiAgICByZXR1cm4gY2FuZGlkYXRlO1xuICB9LCB1bmRlZmluZWQpO1xuICByZXR1cm4ge1xuICAgIGNvZGVjU2V0LFxuICAgIHZpZGVvUmFuZ2VzLFxuICAgIHByZWZlckhEUixcbiAgICBtaW5GcmFtZXJhdGUsXG4gICAgbWluQml0cmF0ZVxuICB9O1xufVxuZnVuY3Rpb24gbG9nU3RhcnRDb2RlY0NhbmRpZGF0ZUlnbm9yZWQoY29kZVNldCwgcmVhc29uKSB7XG4gIGxvZ2dlci5sb2coYFthYnJdIHN0YXJ0IGNhbmRpZGF0ZXMgd2l0aCBcIiR7Y29kZVNldH1cIiBpZ25vcmVkIGJlY2F1c2UgJHtyZWFzb259YCk7XG59XG5mdW5jdGlvbiBnZXRBdWRpb1RyYWNrc0J5R3JvdXAoYWxsQXVkaW9UcmFja3MpIHtcbiAgcmV0dXJuIGFsbEF1ZGlvVHJhY2tzLnJlZHVjZSgoYXVkaW9UcmFja3NCeUdyb3VwLCB0cmFjaykgPT4ge1xuICAgIGxldCB0cmFja0dyb3VwID0gYXVkaW9UcmFja3NCeUdyb3VwLmdyb3Vwc1t0cmFjay5ncm91cElkXTtcbiAgICBpZiAoIXRyYWNrR3JvdXApIHtcbiAgICAgIHRyYWNrR3JvdXAgPSBhdWRpb1RyYWNrc0J5R3JvdXAuZ3JvdXBzW3RyYWNrLmdyb3VwSWRdID0ge1xuICAgICAgICB0cmFja3M6IFtdLFxuICAgICAgICBjaGFubmVsczoge1xuICAgICAgICAgIDI6IDBcbiAgICAgICAgfSxcbiAgICAgICAgaGFzRGVmYXVsdDogZmFsc2UsXG4gICAgICAgIGhhc0F1dG9TZWxlY3Q6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICB0cmFja0dyb3VwLnRyYWNrcy5wdXNoKHRyYWNrKTtcbiAgICBjb25zdCBjaGFubmVsc0tleSA9IHRyYWNrLmNoYW5uZWxzIHx8ICcyJztcbiAgICB0cmFja0dyb3VwLmNoYW5uZWxzW2NoYW5uZWxzS2V5XSA9ICh0cmFja0dyb3VwLmNoYW5uZWxzW2NoYW5uZWxzS2V5XSB8fCAwKSArIDE7XG4gICAgdHJhY2tHcm91cC5oYXNEZWZhdWx0ID0gdHJhY2tHcm91cC5oYXNEZWZhdWx0IHx8IHRyYWNrLmRlZmF1bHQ7XG4gICAgdHJhY2tHcm91cC5oYXNBdXRvU2VsZWN0ID0gdHJhY2tHcm91cC5oYXNBdXRvU2VsZWN0IHx8IHRyYWNrLmF1dG9zZWxlY3Q7XG4gICAgaWYgKHRyYWNrR3JvdXAuaGFzRGVmYXVsdCkge1xuICAgICAgYXVkaW9UcmFja3NCeUdyb3VwLmhhc0RlZmF1bHRBdWRpbyA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0cmFja0dyb3VwLmhhc0F1dG9TZWxlY3QpIHtcbiAgICAgIGF1ZGlvVHJhY2tzQnlHcm91cC5oYXNBdXRvU2VsZWN0QXVkaW8gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gYXVkaW9UcmFja3NCeUdyb3VwO1xuICB9LCB7XG4gICAgaGFzRGVmYXVsdEF1ZGlvOiBmYWxzZSxcbiAgICBoYXNBdXRvU2VsZWN0QXVkaW86IGZhbHNlLFxuICAgIGdyb3Vwczoge31cbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRDb2RlY1RpZXJzKGxldmVscywgYXVkaW9UcmFja3NCeUdyb3VwLCBtaW5BdXRvTGV2ZWwsIG1heEF1dG9MZXZlbCkge1xuICByZXR1cm4gbGV2ZWxzLnNsaWNlKG1pbkF1dG9MZXZlbCwgbWF4QXV0b0xldmVsICsgMSkucmVkdWNlKCh0aWVycywgbGV2ZWwpID0+IHtcbiAgICBpZiAoIWxldmVsLmNvZGVjU2V0KSB7XG4gICAgICByZXR1cm4gdGllcnM7XG4gICAgfVxuICAgIGNvbnN0IGF1ZGlvR3JvdXBzID0gbGV2ZWwuYXVkaW9Hcm91cHM7XG4gICAgbGV0IHRpZXIgPSB0aWVyc1tsZXZlbC5jb2RlY1NldF07XG4gICAgaWYgKCF0aWVyKSB7XG4gICAgICB0aWVyc1tsZXZlbC5jb2RlY1NldF0gPSB0aWVyID0ge1xuICAgICAgICBtaW5CaXRyYXRlOiBJbmZpbml0eSxcbiAgICAgICAgbWluSGVpZ2h0OiBJbmZpbml0eSxcbiAgICAgICAgbWluRnJhbWVyYXRlOiBJbmZpbml0eSxcbiAgICAgICAgbWF4U2NvcmU6IDAsXG4gICAgICAgIHZpZGVvUmFuZ2VzOiB7XG4gICAgICAgICAgU0RSOiAwXG4gICAgICAgIH0sXG4gICAgICAgIGNoYW5uZWxzOiB7XG4gICAgICAgICAgJzInOiAwXG4gICAgICAgIH0sXG4gICAgICAgIGhhc0RlZmF1bHRBdWRpbzogIWF1ZGlvR3JvdXBzLFxuICAgICAgICBmcmFnbWVudEVycm9yOiAwXG4gICAgICB9O1xuICAgIH1cbiAgICB0aWVyLm1pbkJpdHJhdGUgPSBNYXRoLm1pbih0aWVyLm1pbkJpdHJhdGUsIGxldmVsLmJpdHJhdGUpO1xuICAgIGNvbnN0IGxlc3NlcldpZHRoT3JIZWlnaHQgPSBNYXRoLm1pbihsZXZlbC5oZWlnaHQsIGxldmVsLndpZHRoKTtcbiAgICB0aWVyLm1pbkhlaWdodCA9IE1hdGgubWluKHRpZXIubWluSGVpZ2h0LCBsZXNzZXJXaWR0aE9ySGVpZ2h0KTtcbiAgICB0aWVyLm1pbkZyYW1lcmF0ZSA9IE1hdGgubWluKHRpZXIubWluRnJhbWVyYXRlLCBsZXZlbC5mcmFtZVJhdGUpO1xuICAgIHRpZXIubWF4U2NvcmUgPSBNYXRoLm1heCh0aWVyLm1heFNjb3JlLCBsZXZlbC5zY29yZSk7XG4gICAgdGllci5mcmFnbWVudEVycm9yICs9IGxldmVsLmZyYWdtZW50RXJyb3I7XG4gICAgdGllci52aWRlb1Jhbmdlc1tsZXZlbC52aWRlb1JhbmdlXSA9ICh0aWVyLnZpZGVvUmFuZ2VzW2xldmVsLnZpZGVvUmFuZ2VdIHx8IDApICsgMTtcbiAgICBpZiAoYXVkaW9Hcm91cHMpIHtcbiAgICAgIGF1ZGlvR3JvdXBzLmZvckVhY2goYXVkaW9Hcm91cElkID0+IHtcbiAgICAgICAgaWYgKCFhdWRpb0dyb3VwSWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXVkaW9Hcm91cCA9IGF1ZGlvVHJhY2tzQnlHcm91cC5ncm91cHNbYXVkaW9Hcm91cElkXTtcbiAgICAgICAgLy8gRGVmYXVsdCBhdWRpbyBpcyBhbnkgZ3JvdXAgd2l0aCBERUZBVUxUPVlFUywgb3IgaWYgbWlzc2luZyB0aGVuIGFueSBncm91cCB3aXRoIEFVVE9TRUxFQ1Q9WUVTLCBvciBhbGwgdmFyaWFudHNcbiAgICAgICAgdGllci5oYXNEZWZhdWx0QXVkaW8gPSB0aWVyLmhhc0RlZmF1bHRBdWRpbyB8fCBhdWRpb1RyYWNrc0J5R3JvdXAuaGFzRGVmYXVsdEF1ZGlvID8gYXVkaW9Hcm91cC5oYXNEZWZhdWx0IDogYXVkaW9Hcm91cC5oYXNBdXRvU2VsZWN0IHx8ICFhdWRpb1RyYWNrc0J5R3JvdXAuaGFzRGVmYXVsdEF1ZGlvICYmICFhdWRpb1RyYWNrc0J5R3JvdXAuaGFzQXV0b1NlbGVjdEF1ZGlvO1xuICAgICAgICBPYmplY3Qua2V5cyhhdWRpb0dyb3VwLmNoYW5uZWxzKS5mb3JFYWNoKGNoYW5uZWxzID0+IHtcbiAgICAgICAgICB0aWVyLmNoYW5uZWxzW2NoYW5uZWxzXSA9ICh0aWVyLmNoYW5uZWxzW2NoYW5uZWxzXSB8fCAwKSArIGF1ZGlvR3JvdXAuY2hhbm5lbHNbY2hhbm5lbHNdO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGllcnM7XG4gIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIGZpbmRNYXRjaGluZ09wdGlvbihvcHRpb24sIHRyYWNrcywgbWF0Y2hQcmVkaWNhdGUpIHtcbiAgaWYgKCdhdHRycycgaW4gb3B0aW9uKSB7XG4gICAgY29uc3QgaW5kZXggPSB0cmFja3MuaW5kZXhPZihvcHRpb24pO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB0cmFjayA9IHRyYWNrc1tpXTtcbiAgICBpZiAobWF0Y2hlc09wdGlvbihvcHRpb24sIHRyYWNrLCBtYXRjaFByZWRpY2F0ZSkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5mdW5jdGlvbiBtYXRjaGVzT3B0aW9uKG9wdGlvbiwgdHJhY2ssIG1hdGNoUHJlZGljYXRlKSB7XG4gIGNvbnN0IHtcbiAgICBncm91cElkLFxuICAgIG5hbWUsXG4gICAgbGFuZyxcbiAgICBhc3NvY0xhbmcsXG4gICAgY2hhcmFjdGVyaXN0aWNzLFxuICAgIGRlZmF1bHQ6IGlzRGVmYXVsdFxuICB9ID0gb3B0aW9uO1xuICBjb25zdCBmb3JjZWQgPSBvcHRpb24uZm9yY2VkO1xuICByZXR1cm4gKGdyb3VwSWQgPT09IHVuZGVmaW5lZCB8fCB0cmFjay5ncm91cElkID09PSBncm91cElkKSAmJiAobmFtZSA9PT0gdW5kZWZpbmVkIHx8IHRyYWNrLm5hbWUgPT09IG5hbWUpICYmIChsYW5nID09PSB1bmRlZmluZWQgfHwgdHJhY2subGFuZyA9PT0gbGFuZykgJiYgKGxhbmcgPT09IHVuZGVmaW5lZCB8fCB0cmFjay5hc3NvY0xhbmcgPT09IGFzc29jTGFuZykgJiYgKGlzRGVmYXVsdCA9PT0gdW5kZWZpbmVkIHx8IHRyYWNrLmRlZmF1bHQgPT09IGlzRGVmYXVsdCkgJiYgKGZvcmNlZCA9PT0gdW5kZWZpbmVkIHx8IHRyYWNrLmZvcmNlZCA9PT0gZm9yY2VkKSAmJiAoY2hhcmFjdGVyaXN0aWNzID09PSB1bmRlZmluZWQgfHwgY2hhcmFjdGVyaXN0aWNzTWF0Y2goY2hhcmFjdGVyaXN0aWNzLCB0cmFjay5jaGFyYWN0ZXJpc3RpY3MpKSAmJiAobWF0Y2hQcmVkaWNhdGUgPT09IHVuZGVmaW5lZCB8fCBtYXRjaFByZWRpY2F0ZShvcHRpb24sIHRyYWNrKSk7XG59XG5mdW5jdGlvbiBjaGFyYWN0ZXJpc3RpY3NNYXRjaChjaGFyYWN0ZXJpc3RpY3NBLCBjaGFyYWN0ZXJpc3RpY3NCID0gJycpIHtcbiAgY29uc3QgYXJyQSA9IGNoYXJhY3RlcmlzdGljc0Euc3BsaXQoJywnKTtcbiAgY29uc3QgYXJyQiA9IGNoYXJhY3RlcmlzdGljc0Iuc3BsaXQoJywnKTtcbiAgLy8gRXhwZWN0cyBlYWNoIGl0ZW0gdG8gYmUgdW5pcXVlOlxuICByZXR1cm4gYXJyQS5sZW5ndGggPT09IGFyckIubGVuZ3RoICYmICFhcnJBLnNvbWUoZWwgPT4gYXJyQi5pbmRleE9mKGVsKSA9PT0gLTEpO1xufVxuZnVuY3Rpb24gYXVkaW9NYXRjaFByZWRpY2F0ZShvcHRpb24sIHRyYWNrKSB7XG4gIGNvbnN0IHtcbiAgICBhdWRpb0NvZGVjLFxuICAgIGNoYW5uZWxzXG4gIH0gPSBvcHRpb247XG4gIHJldHVybiAoYXVkaW9Db2RlYyA9PT0gdW5kZWZpbmVkIHx8ICh0cmFjay5hdWRpb0NvZGVjIHx8ICcnKS5zdWJzdHJpbmcoMCwgNCkgPT09IGF1ZGlvQ29kZWMuc3Vic3RyaW5nKDAsIDQpKSAmJiAoY2hhbm5lbHMgPT09IHVuZGVmaW5lZCB8fCBjaGFubmVscyA9PT0gKHRyYWNrLmNoYW5uZWxzIHx8ICcyJykpO1xufVxuZnVuY3Rpb24gZmluZENsb3Nlc3RMZXZlbFdpdGhBdWRpb0dyb3VwKG9wdGlvbiwgbGV2ZWxzLCBhbGxBdWRpb1RyYWNrcywgc2VhcmNoSW5kZXgsIG1hdGNoUHJlZGljYXRlKSB7XG4gIGNvbnN0IGN1cnJlbnRMZXZlbCA9IGxldmVsc1tzZWFyY2hJbmRleF07XG4gIC8vIEFyZSB0aGVyZSB2YXJpYW50cyB3aXRoIHNhbWUgVVJJIGFzIGN1cnJlbnQgbGV2ZWw/XG4gIC8vIElmIHNvLCBmaW5kIGEgbWF0Y2ggdGhhdCBkb2VzIG5vdCByZXF1aXJlIGFueSBsZXZlbCBVUkkgY2hhbmdlXG4gIGNvbnN0IHZhcmlhbnRzID0gbGV2ZWxzLnJlZHVjZSgodmFyaWFudE1hcCwgbGV2ZWwsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgdXJpID0gbGV2ZWwudXJpO1xuICAgIGNvbnN0IHJlbmRpdGlvbnMgPSB2YXJpYW50TWFwW3VyaV0gfHwgKHZhcmlhbnRNYXBbdXJpXSA9IFtdKTtcbiAgICByZW5kaXRpb25zLnB1c2goaW5kZXgpO1xuICAgIHJldHVybiB2YXJpYW50TWFwO1xuICB9LCB7fSk7XG4gIGNvbnN0IHJlbmRpdGlvbnMgPSB2YXJpYW50c1tjdXJyZW50TGV2ZWwudXJpXTtcbiAgaWYgKHJlbmRpdGlvbnMubGVuZ3RoID4gMSkge1xuICAgIHNlYXJjaEluZGV4ID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgcmVuZGl0aW9ucyk7XG4gIH1cbiAgLy8gRmluZCBiZXN0IG1hdGNoXG4gIGNvbnN0IGN1cnJlbnRWaWRlb1JhbmdlID0gY3VycmVudExldmVsLnZpZGVvUmFuZ2U7XG4gIGNvbnN0IGN1cnJlbnRGcmFtZVJhdGUgPSBjdXJyZW50TGV2ZWwuZnJhbWVSYXRlO1xuICBjb25zdCBjdXJyZW50VmlkZW9Db2RlYyA9IGN1cnJlbnRMZXZlbC5jb2RlY1NldC5zdWJzdHJpbmcoMCwgNCk7XG4gIGNvbnN0IG1hdGNoaW5nVmlkZW8gPSBzZWFyY2hEb3duQW5kVXBMaXN0KGxldmVscywgc2VhcmNoSW5kZXgsIGxldmVsID0+IHtcbiAgICBpZiAobGV2ZWwudmlkZW9SYW5nZSAhPT0gY3VycmVudFZpZGVvUmFuZ2UgfHwgbGV2ZWwuZnJhbWVSYXRlICE9PSBjdXJyZW50RnJhbWVSYXRlIHx8IGxldmVsLmNvZGVjU2V0LnN1YnN0cmluZygwLCA0KSAhPT0gY3VycmVudFZpZGVvQ29kZWMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgYXVkaW9Hcm91cHMgPSBsZXZlbC5hdWRpb0dyb3VwcztcbiAgICBjb25zdCB0cmFja3MgPSBhbGxBdWRpb1RyYWNrcy5maWx0ZXIodHJhY2sgPT4gIWF1ZGlvR3JvdXBzIHx8IGF1ZGlvR3JvdXBzLmluZGV4T2YodHJhY2suZ3JvdXBJZCkgIT09IC0xKTtcbiAgICByZXR1cm4gZmluZE1hdGNoaW5nT3B0aW9uKG9wdGlvbiwgdHJhY2tzLCBtYXRjaFByZWRpY2F0ZSkgPiAtMTtcbiAgfSk7XG4gIGlmIChtYXRjaGluZ1ZpZGVvID4gLTEpIHtcbiAgICByZXR1cm4gbWF0Y2hpbmdWaWRlbztcbiAgfVxuICByZXR1cm4gc2VhcmNoRG93bkFuZFVwTGlzdChsZXZlbHMsIHNlYXJjaEluZGV4LCBsZXZlbCA9PiB7XG4gICAgY29uc3QgYXVkaW9Hcm91cHMgPSBsZXZlbC5hdWRpb0dyb3VwcztcbiAgICBjb25zdCB0cmFja3MgPSBhbGxBdWRpb1RyYWNrcy5maWx0ZXIodHJhY2sgPT4gIWF1ZGlvR3JvdXBzIHx8IGF1ZGlvR3JvdXBzLmluZGV4T2YodHJhY2suZ3JvdXBJZCkgIT09IC0xKTtcbiAgICByZXR1cm4gZmluZE1hdGNoaW5nT3B0aW9uKG9wdGlvbiwgdHJhY2tzLCBtYXRjaFByZWRpY2F0ZSkgPiAtMTtcbiAgfSk7XG59XG5mdW5jdGlvbiBzZWFyY2hEb3duQW5kVXBMaXN0KGFyciwgc2VhcmNoSW5kZXgsIHByZWRpY2F0ZSkge1xuICBmb3IgKGxldCBpID0gc2VhcmNoSW5kZXg7IGk7IGktLSkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyW2ldKSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIGZvciAobGV0IGkgPSBzZWFyY2hJbmRleCArIDE7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocHJlZGljYXRlKGFycltpXSkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbmNsYXNzIEFickNvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihfaGxzKSB7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5sYXN0TGV2ZWxMb2FkU2VjID0gMDtcbiAgICB0aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWwgPSAtMTtcbiAgICB0aGlzLmZpcnN0U2VsZWN0aW9uID0gLTE7XG4gICAgdGhpcy5fbmV4dEF1dG9MZXZlbCA9IC0xO1xuICAgIHRoaXMubmV4dEF1dG9MZXZlbEtleSA9ICcnO1xuICAgIHRoaXMuYXVkaW9UcmFja3NCeUdyb3VwID0gbnVsbDtcbiAgICB0aGlzLmNvZGVjVGllcnMgPSBudWxsO1xuICAgIHRoaXMudGltZXIgPSAtMTtcbiAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICB0aGlzLnBhcnRDdXJyZW50ID0gbnVsbDtcbiAgICB0aGlzLmJpdHJhdGVUZXN0RGVsYXkgPSAwO1xuICAgIHRoaXMuYndFc3RpbWF0b3IgPSB2b2lkIDA7XG4gICAgLypcbiAgICAgICAgVGhpcyBtZXRob2QgbW9uaXRvcnMgdGhlIGRvd25sb2FkIHJhdGUgb2YgdGhlIGN1cnJlbnQgZnJhZ21lbnQsIGFuZCB3aWxsIGRvd25zd2l0Y2ggaWYgdGhhdCBmcmFnbWVudCB3aWxsIG5vdCBsb2FkXG4gICAgICAgIHF1aWNrbHkgZW5vdWdoIHRvIHByZXZlbnQgdW5kZXJidWZmZXJpbmdcbiAgICAgICovXG4gICAgdGhpcy5fYWJhbmRvblJ1bGVzQ2hlY2sgPSAoKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZyYWdDdXJyZW50OiBmcmFnLFxuICAgICAgICBwYXJ0Q3VycmVudDogcGFydCxcbiAgICAgICAgaGxzXG4gICAgICB9ID0gdGhpcztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYXV0b0xldmVsRW5hYmxlZCxcbiAgICAgICAgbWVkaWFcbiAgICAgIH0gPSBobHM7XG4gICAgICBpZiAoIWZyYWcgfHwgIW1lZGlhKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3Qgc3RhdHMgPSBwYXJ0ID8gcGFydC5zdGF0cyA6IGZyYWcuc3RhdHM7XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IHBhcnQgPyBwYXJ0LmR1cmF0aW9uIDogZnJhZy5kdXJhdGlvbjtcbiAgICAgIGNvbnN0IHRpbWVMb2FkaW5nID0gbm93IC0gc3RhdHMubG9hZGluZy5zdGFydDtcbiAgICAgIGNvbnN0IG1pbkF1dG9MZXZlbCA9IGhscy5taW5BdXRvTGV2ZWw7XG4gICAgICAvLyBJZiBmcmFnIGxvYWRpbmcgaXMgYWJvcnRlZCwgY29tcGxldGUsIG9yIGZyb20gbG93ZXN0IGxldmVsLCBzdG9wIHRpbWVyIGFuZCByZXR1cm5cbiAgICAgIGlmIChzdGF0cy5hYm9ydGVkIHx8IHN0YXRzLmxvYWRlZCAmJiBzdGF0cy5sb2FkZWQgPT09IHN0YXRzLnRvdGFsIHx8IGZyYWcubGV2ZWwgPD0gbWluQXV0b0xldmVsKSB7XG4gICAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgICAvLyByZXNldCBmb3JjZWQgYXV0byBsZXZlbCB2YWx1ZSBzbyB0aGF0IG5leHQgbGV2ZWwgd2lsbCBiZSBzZWxlY3RlZFxuICAgICAgICB0aGlzLl9uZXh0QXV0b0xldmVsID0gLTE7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gVGhpcyBjaGVjayBvbmx5IHJ1bnMgaWYgd2UncmUgaW4gQUJSIG1vZGUgYW5kIGFjdHVhbGx5IHBsYXlpbmdcbiAgICAgIGlmICghYXV0b0xldmVsRW5hYmxlZCB8fCBtZWRpYS5wYXVzZWQgfHwgIW1lZGlhLnBsYXliYWNrUmF0ZSB8fCAhbWVkaWEucmVhZHlTdGF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBidWZmZXJJbmZvID0gaGxzLm1haW5Gb3J3YXJkQnVmZmVySW5mbztcbiAgICAgIGlmIChidWZmZXJJbmZvID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHR0ZmJFc3RpbWF0ZSA9IHRoaXMuYndFc3RpbWF0b3IuZ2V0RXN0aW1hdGVUVEZCKCk7XG4gICAgICBjb25zdCBwbGF5YmFja1JhdGUgPSBNYXRoLmFicyhtZWRpYS5wbGF5YmFja1JhdGUpO1xuICAgICAgLy8gVG8gbWFpbnRhaW4gc3RhYmxlIGFkYXB0aXZlIHBsYXliYWNrLCBvbmx5IGJlZ2luIG1vbml0b3JpbmcgZnJhZyBsb2FkaW5nIGFmdGVyIGhhbGYgb3IgbW9yZSBvZiBpdHMgcGxheWJhY2sgZHVyYXRpb24gaGFzIHBhc3NlZFxuICAgICAgaWYgKHRpbWVMb2FkaW5nIDw9IE1hdGgubWF4KHR0ZmJFc3RpbWF0ZSwgMTAwMCAqIChkdXJhdGlvbiAvIChwbGF5YmFja1JhdGUgKiAyKSkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gYnVmZmVyU3RhcnZhdGlvbkRlbGF5IGlzIGFuIGVzdGltYXRlIG9mIHRoZSBhbW91bnQgdGltZSAoaW4gc2Vjb25kcykgaXQgd2lsbCB0YWtlIHRvIGV4aGF1c3QgdGhlIGJ1ZmZlclxuICAgICAgY29uc3QgYnVmZmVyU3RhcnZhdGlvbkRlbGF5ID0gYnVmZmVySW5mby5sZW4gLyBwbGF5YmFja1JhdGU7XG4gICAgICBjb25zdCB0dGZiID0gc3RhdHMubG9hZGluZy5maXJzdCA/IHN0YXRzLmxvYWRpbmcuZmlyc3QgLSBzdGF0cy5sb2FkaW5nLnN0YXJ0IDogLTE7XG4gICAgICBjb25zdCBsb2FkZWRGaXJzdEJ5dGUgPSBzdGF0cy5sb2FkZWQgJiYgdHRmYiA+IC0xO1xuICAgICAgY29uc3QgYndFc3RpbWF0ZSA9IHRoaXMuZ2V0QndFc3RpbWF0ZSgpO1xuICAgICAgY29uc3QgbGV2ZWxzID0gaGxzLmxldmVscztcbiAgICAgIGNvbnN0IGxldmVsID0gbGV2ZWxzW2ZyYWcubGV2ZWxdO1xuICAgICAgY29uc3QgZXhwZWN0ZWRMZW4gPSBzdGF0cy50b3RhbCB8fCBNYXRoLm1heChzdGF0cy5sb2FkZWQsIE1hdGgucm91bmQoZHVyYXRpb24gKiBsZXZlbC5hdmVyYWdlQml0cmF0ZSAvIDgpKTtcbiAgICAgIGxldCB0aW1lU3RyZWFtaW5nID0gbG9hZGVkRmlyc3RCeXRlID8gdGltZUxvYWRpbmcgLSB0dGZiIDogdGltZUxvYWRpbmc7XG4gICAgICBpZiAodGltZVN0cmVhbWluZyA8IDEgJiYgbG9hZGVkRmlyc3RCeXRlKSB7XG4gICAgICAgIHRpbWVTdHJlYW1pbmcgPSBNYXRoLm1pbih0aW1lTG9hZGluZywgc3RhdHMubG9hZGVkICogOCAvIGJ3RXN0aW1hdGUpO1xuICAgICAgfVxuICAgICAgY29uc3QgbG9hZFJhdGUgPSBsb2FkZWRGaXJzdEJ5dGUgPyBzdGF0cy5sb2FkZWQgKiAxMDAwIC8gdGltZVN0cmVhbWluZyA6IDA7XG4gICAgICAvLyBmcmFnTG9hZERlbGF5IGlzIGFuIGVzdGltYXRlIG9mIHRoZSB0aW1lIChpbiBzZWNvbmRzKSBpdCB3aWxsIHRha2UgdG8gYnVmZmVyIHRoZSByZW1haW5kZXIgb2YgdGhlIGZyYWdtZW50XG4gICAgICBjb25zdCBmcmFnTG9hZGVkRGVsYXkgPSBsb2FkUmF0ZSA/IChleHBlY3RlZExlbiAtIHN0YXRzLmxvYWRlZCkgLyBsb2FkUmF0ZSA6IGV4cGVjdGVkTGVuICogOCAvIGJ3RXN0aW1hdGUgKyB0dGZiRXN0aW1hdGUgLyAxMDAwO1xuICAgICAgLy8gT25seSBkb3duc3dpdGNoIGlmIHRoZSB0aW1lIHRvIGZpbmlzaCBsb2FkaW5nIHRoZSBjdXJyZW50IGZyYWdtZW50IGlzIGdyZWF0ZXIgdGhhbiB0aGUgYW1vdW50IG9mIGJ1ZmZlciBsZWZ0XG4gICAgICBpZiAoZnJhZ0xvYWRlZERlbGF5IDw9IGJ1ZmZlclN0YXJ2YXRpb25EZWxheSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBid2UgPSBsb2FkUmF0ZSA/IGxvYWRSYXRlICogOCA6IGJ3RXN0aW1hdGU7XG4gICAgICBsZXQgZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgbGV0IG5leHRMb2FkTGV2ZWw7XG4gICAgICAvLyBJdGVyYXRlIHRocm91Z2ggbG93ZXIgbGV2ZWwgYW5kIHRyeSB0byBmaW5kIHRoZSBsYXJnZXN0IG9uZSB0aGF0IGF2b2lkcyByZWJ1ZmZlcmluZ1xuICAgICAgZm9yIChuZXh0TG9hZExldmVsID0gZnJhZy5sZXZlbCAtIDE7IG5leHRMb2FkTGV2ZWwgPiBtaW5BdXRvTGV2ZWw7IG5leHRMb2FkTGV2ZWwtLSkge1xuICAgICAgICAvLyBjb21wdXRlIHRpbWUgdG8gbG9hZCBuZXh0IGZyYWdtZW50IGF0IGxvd2VyIGxldmVsXG4gICAgICAgIC8vIDggPSBiaXRzIHBlciBieXRlIChicHMvQnBzKVxuICAgICAgICBjb25zdCBsZXZlbE5leHRCaXRyYXRlID0gbGV2ZWxzW25leHRMb2FkTGV2ZWxdLm1heEJpdHJhdGU7XG4gICAgICAgIGZyYWdMZXZlbE5leHRMb2FkZWREZWxheSA9IHRoaXMuZ2V0VGltZVRvTG9hZEZyYWcodHRmYkVzdGltYXRlIC8gMTAwMCwgYndlLCBkdXJhdGlvbiAqIGxldmVsTmV4dEJpdHJhdGUsICFsZXZlbHNbbmV4dExvYWRMZXZlbF0uZGV0YWlscyk7XG4gICAgICAgIGlmIChmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXkgPCBidWZmZXJTdGFydmF0aW9uRGVsYXkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gT25seSBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gaWYgaXQgdGFrZXMgbGVzcyB0aW1lIHRvIGxvYWQgYSBuZXcgZnJhZ21lbnQgYXQgbG93ZXN0IGxldmVsIGluc3RlYWQgb2YgY29udGludWluZ1xuICAgICAgLy8gdG8gbG9hZCB0aGUgY3VycmVudCBvbmVcbiAgICAgIGlmIChmcmFnTGV2ZWxOZXh0TG9hZGVkRGVsYXkgPj0gZnJhZ0xvYWRlZERlbGF5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgZXN0aW1hdGVkIGxvYWQgdGltZSBvZiBuZXcgc2VnbWVudCBpcyBjb21wbGV0ZWx5IHVucmVhc29uYWJsZSwgaWdub3JlIGFuZCBkbyBub3QgZW1lcmdlbmN5IHN3aXRjaCBkb3duXG4gICAgICBpZiAoZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5ID4gZHVyYXRpb24gKiAxMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBobHMubmV4dExvYWRMZXZlbCA9IGhscy5uZXh0QXV0b0xldmVsID0gbmV4dExvYWRMZXZlbDtcbiAgICAgIGlmIChsb2FkZWRGaXJzdEJ5dGUpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgaGFzIGJlZW4gbG9hZGluZyBwcm9ncmVzcywgc2FtcGxlIGJhbmR3aWR0aCB1c2luZyBsb2FkaW5nIHRpbWUgb2Zmc2V0IGJ5IG1pbmltdW0gVFRGQiB0aW1lXG4gICAgICAgIHRoaXMuYndFc3RpbWF0b3Iuc2FtcGxlKHRpbWVMb2FkaW5nIC0gTWF0aC5taW4odHRmYkVzdGltYXRlLCB0dGZiKSwgc3RhdHMubG9hZGVkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGhhcyBiZWVuIG5vIGxvYWRpbmcgcHJvZ3Jlc3MsIHNhbXBsZSBUVEZCXG4gICAgICAgIHRoaXMuYndFc3RpbWF0b3Iuc2FtcGxlVFRGQih0aW1lTG9hZGluZyk7XG4gICAgICB9XG4gICAgICBjb25zdCBuZXh0TG9hZExldmVsQml0cmF0ZSA9IGxldmVsc1tuZXh0TG9hZExldmVsXS5tYXhCaXRyYXRlO1xuICAgICAgaWYgKHRoaXMuZ2V0QndFc3RpbWF0ZSgpICogdGhpcy5obHMuY29uZmlnLmFickJhbmRXaWR0aFVwRmFjdG9yID4gbmV4dExvYWRMZXZlbEJpdHJhdGUpIHtcbiAgICAgICAgdGhpcy5yZXNldEVzdGltYXRvcihuZXh0TG9hZExldmVsQml0cmF0ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgIGxvZ2dlci53YXJuKGBbYWJyXSBGcmFnbWVudCAke2ZyYWcuc259JHtwYXJ0ID8gJyBwYXJ0ICcgKyBwYXJ0LmluZGV4IDogJyd9IG9mIGxldmVsICR7ZnJhZy5sZXZlbH0gaXMgbG9hZGluZyB0b28gc2xvd2x5O1xuICAgICAgVGltZSB0byB1bmRlcmJ1ZmZlcjogJHtidWZmZXJTdGFydmF0aW9uRGVsYXkudG9GaXhlZCgzKX0gc1xuICAgICAgRXN0aW1hdGVkIGxvYWQgdGltZSBmb3IgY3VycmVudCBmcmFnbWVudDogJHtmcmFnTG9hZGVkRGVsYXkudG9GaXhlZCgzKX0gc1xuICAgICAgRXN0aW1hdGVkIGxvYWQgdGltZSBmb3IgZG93biBzd2l0Y2ggZnJhZ21lbnQ6ICR7ZnJhZ0xldmVsTmV4dExvYWRlZERlbGF5LnRvRml4ZWQoMyl9IHNcbiAgICAgIFRURkIgZXN0aW1hdGU6ICR7dHRmYiB8IDB9IG1zXG4gICAgICBDdXJyZW50IEJXIGVzdGltYXRlOiAke2lzRmluaXRlTnVtYmVyKGJ3RXN0aW1hdGUpID8gYndFc3RpbWF0ZSB8IDAgOiAnVW5rbm93bid9IGJwc1xuICAgICAgTmV3IEJXIGVzdGltYXRlOiAke3RoaXMuZ2V0QndFc3RpbWF0ZSgpIHwgMH0gYnBzXG4gICAgICBTd2l0Y2hpbmcgdG8gbGV2ZWwgJHtuZXh0TG9hZExldmVsfSBAICR7bmV4dExvYWRMZXZlbEJpdHJhdGUgfCAwfSBicHNgKTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURUQsIHtcbiAgICAgICAgZnJhZyxcbiAgICAgICAgcGFydCxcbiAgICAgICAgc3RhdHNcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5obHMgPSBfaGxzO1xuICAgIHRoaXMuYndFc3RpbWF0b3IgPSB0aGlzLmluaXRFc3RpbWF0b3IoKTtcbiAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cbiAgcmVzZXRFc3RpbWF0b3IoYWJyRXdtYURlZmF1bHRFc3RpbWF0ZSkge1xuICAgIGlmIChhYnJFd21hRGVmYXVsdEVzdGltYXRlKSB7XG4gICAgICBsb2dnZXIubG9nKGBzZXR0aW5nIGluaXRpYWwgYndlIHRvICR7YWJyRXdtYURlZmF1bHRFc3RpbWF0ZX1gKTtcbiAgICAgIHRoaXMuaGxzLmNvbmZpZy5hYnJFd21hRGVmYXVsdEVzdGltYXRlID0gYWJyRXdtYURlZmF1bHRFc3RpbWF0ZTtcbiAgICB9XG4gICAgdGhpcy5maXJzdFNlbGVjdGlvbiA9IC0xO1xuICAgIHRoaXMuYndFc3RpbWF0b3IgPSB0aGlzLmluaXRFc3RpbWF0b3IoKTtcbiAgfVxuICBpbml0RXN0aW1hdG9yKCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcbiAgICByZXR1cm4gbmV3IEV3bWFCYW5kV2lkdGhFc3RpbWF0b3IoY29uZmlnLmFickV3bWFTbG93Vm9ELCBjb25maWcuYWJyRXdtYUZhc3RWb0QsIGNvbmZpZy5hYnJFd21hRGVmYXVsdEVzdGltYXRlKTtcbiAgfVxuICByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRlJBR19MT0FESU5HLCB0aGlzLm9uRnJhZ0xvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRlJBR19MT0FERUQsIHRoaXMub25GcmFnTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkZSQUdfQlVGRkVSRUQsIHRoaXMub25GcmFnQnVmZmVyZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxfU1dJVENISU5HLCB0aGlzLm9uTGV2ZWxTd2l0Y2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxfTE9BREVELCB0aGlzLm9uTGV2ZWxMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxTX1VQREFURUQsIHRoaXMub25MZXZlbHNVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1BWF9BVVRPX0xFVkVMX1VQREFURUQsIHRoaXMub25NYXhBdXRvTGV2ZWxVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICB9XG4gIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFobHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19MT0FESU5HLCB0aGlzLm9uRnJhZ0xvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkZSQUdfTE9BREVELCB0aGlzLm9uRnJhZ0xvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTEVWRUxfU1dJVENISU5HLCB0aGlzLm9uTGV2ZWxTd2l0Y2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX0xPQURFRCwgdGhpcy5vbkxldmVsTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTFNfVVBEQVRFRCwgdGhpcy5vbkxldmVsc1VwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BWF9BVVRPX0xFVkVMX1VQREFURUQsIHRoaXMub25NYXhBdXRvTGV2ZWxVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmhscyA9IHRoaXMuX2FiYW5kb25SdWxlc0NoZWNrID0gbnVsbDtcbiAgICB0aGlzLmZyYWdDdXJyZW50ID0gdGhpcy5wYXJ0Q3VycmVudCA9IG51bGw7XG4gIH1cbiAgb25NYW5pZmVzdExvYWRpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWwgPSAtMTtcbiAgICB0aGlzLmZpcnN0U2VsZWN0aW9uID0gLTE7XG4gICAgdGhpcy5sYXN0TGV2ZWxMb2FkU2VjID0gMDtcbiAgICB0aGlzLmZyYWdDdXJyZW50ID0gdGhpcy5wYXJ0Q3VycmVudCA9IG51bGw7XG4gICAgdGhpcy5vbkxldmVsc1VwZGF0ZWQoKTtcbiAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgfVxuICBvbkxldmVsc1VwZGF0ZWQoKSB7XG4gICAgaWYgKHRoaXMubGFzdExvYWRlZEZyYWdMZXZlbCA+IC0xICYmIHRoaXMuZnJhZ0N1cnJlbnQpIHtcbiAgICAgIHRoaXMubGFzdExvYWRlZEZyYWdMZXZlbCA9IHRoaXMuZnJhZ0N1cnJlbnQubGV2ZWw7XG4gICAgfVxuICAgIHRoaXMuX25leHRBdXRvTGV2ZWwgPSAtMTtcbiAgICB0aGlzLm9uTWF4QXV0b0xldmVsVXBkYXRlZCgpO1xuICAgIHRoaXMuY29kZWNUaWVycyA9IG51bGw7XG4gICAgdGhpcy5hdWRpb1RyYWNrc0J5R3JvdXAgPSBudWxsO1xuICB9XG4gIG9uTWF4QXV0b0xldmVsVXBkYXRlZCgpIHtcbiAgICB0aGlzLmZpcnN0U2VsZWN0aW9uID0gLTE7XG4gICAgdGhpcy5uZXh0QXV0b0xldmVsS2V5ID0gJyc7XG4gIH1cbiAgb25GcmFnTG9hZGluZyhldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IGZyYWcgPSBkYXRhLmZyYWc7XG4gICAgaWYgKHRoaXMuaWdub3JlRnJhZ21lbnQoZnJhZykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFmcmFnLmJpdHJhdGVUZXN0KSB7XG4gICAgICB2YXIgX2RhdGEkcGFydDtcbiAgICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBmcmFnO1xuICAgICAgdGhpcy5wYXJ0Q3VycmVudCA9IChfZGF0YSRwYXJ0ID0gZGF0YS5wYXJ0KSAhPSBudWxsID8gX2RhdGEkcGFydCA6IG51bGw7XG4gICAgfVxuICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgIHRoaXMudGltZXIgPSBzZWxmLnNldEludGVydmFsKHRoaXMuX2FiYW5kb25SdWxlc0NoZWNrLCAxMDApO1xuICB9XG4gIG9uTGV2ZWxTd2l0Y2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgfVxuICBvbkVycm9yKGV2ZW50LCBkYXRhKSB7XG4gICAgaWYgKGRhdGEuZmF0YWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3dpdGNoIChkYXRhLmRldGFpbHMpIHtcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkJVRkZFUl9BRERfQ09ERUNfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfQVBQRU5EX0VSUk9SOlxuICAgICAgICAvLyBSZXNldCBsYXN0IGxvYWRlZCBsZXZlbCBzbyB0aGF0IGEgbmV3IHNlbGVjdGlvbiBjYW4gYmUgbWFkZSBhZnRlciBjYWxsaW5nIHJlY292ZXJNZWRpYUVycm9yXG4gICAgICAgIHRoaXMubGFzdExvYWRlZEZyYWdMZXZlbCA9IC0xO1xuICAgICAgICB0aGlzLmZpcnN0U2VsZWN0aW9uID0gLTE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQ6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBmcmFnID0gZGF0YS5mcmFnO1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGZyYWdDdXJyZW50LFxuICAgICAgICAgICAgcGFydEN1cnJlbnQ6IHBhcnRcbiAgICAgICAgICB9ID0gdGhpcztcbiAgICAgICAgICBpZiAoZnJhZyAmJiBmcmFnQ3VycmVudCAmJiBmcmFnLnNuID09PSBmcmFnQ3VycmVudC5zbiAmJiBmcmFnLmxldmVsID09PSBmcmFnQ3VycmVudC5sZXZlbCkge1xuICAgICAgICAgICAgY29uc3Qgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICBjb25zdCBzdGF0cyA9IHBhcnQgPyBwYXJ0LnN0YXRzIDogZnJhZy5zdGF0cztcbiAgICAgICAgICAgIGNvbnN0IHRpbWVMb2FkaW5nID0gbm93IC0gc3RhdHMubG9hZGluZy5zdGFydDtcbiAgICAgICAgICAgIGNvbnN0IHR0ZmIgPSBzdGF0cy5sb2FkaW5nLmZpcnN0ID8gc3RhdHMubG9hZGluZy5maXJzdCAtIHN0YXRzLmxvYWRpbmcuc3RhcnQgOiAtMTtcbiAgICAgICAgICAgIGNvbnN0IGxvYWRlZEZpcnN0Qnl0ZSA9IHN0YXRzLmxvYWRlZCAmJiB0dGZiID4gLTE7XG4gICAgICAgICAgICBpZiAobG9hZGVkRmlyc3RCeXRlKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHR0ZmJFc3RpbWF0ZSA9IHRoaXMuYndFc3RpbWF0b3IuZ2V0RXN0aW1hdGVUVEZCKCk7XG4gICAgICAgICAgICAgIHRoaXMuYndFc3RpbWF0b3Iuc2FtcGxlKHRpbWVMb2FkaW5nIC0gTWF0aC5taW4odHRmYkVzdGltYXRlLCB0dGZiKSwgc3RhdHMubG9hZGVkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuYndFc3RpbWF0b3Iuc2FtcGxlVFRGQih0aW1lTG9hZGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICB9XG4gIGdldFRpbWVUb0xvYWRGcmFnKHRpbWVUb0ZpcnN0Qnl0ZVNlYywgYmFuZHdpZHRoLCBmcmFnU2l6ZUJpdHMsIGlzU3dpdGNoKSB7XG4gICAgY29uc3QgZnJhZ0xvYWRTZWMgPSB0aW1lVG9GaXJzdEJ5dGVTZWMgKyBmcmFnU2l6ZUJpdHMgLyBiYW5kd2lkdGg7XG4gICAgY29uc3QgcGxheWxpc3RMb2FkU2VjID0gaXNTd2l0Y2ggPyB0aGlzLmxhc3RMZXZlbExvYWRTZWMgOiAwO1xuICAgIHJldHVybiBmcmFnTG9hZFNlYyArIHBsYXlsaXN0TG9hZFNlYztcbiAgfVxuICBvbkxldmVsTG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuICAgIGNvbnN0IHtcbiAgICAgIGxvYWRpbmdcbiAgICB9ID0gZGF0YS5zdGF0cztcbiAgICBjb25zdCB0aW1lTG9hZGluZ01zID0gbG9hZGluZy5lbmQgLSBsb2FkaW5nLnN0YXJ0O1xuICAgIGlmIChpc0Zpbml0ZU51bWJlcih0aW1lTG9hZGluZ01zKSkge1xuICAgICAgdGhpcy5sYXN0TGV2ZWxMb2FkU2VjID0gdGltZUxvYWRpbmdNcyAvIDEwMDA7XG4gICAgfVxuICAgIGlmIChkYXRhLmRldGFpbHMubGl2ZSkge1xuICAgICAgdGhpcy5id0VzdGltYXRvci51cGRhdGUoY29uZmlnLmFickV3bWFTbG93TGl2ZSwgY29uZmlnLmFickV3bWFGYXN0TGl2ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYndFc3RpbWF0b3IudXBkYXRlKGNvbmZpZy5hYnJFd21hU2xvd1ZvRCwgY29uZmlnLmFickV3bWFGYXN0Vm9EKTtcbiAgICB9XG4gIH1cbiAgb25GcmFnTG9hZGVkKGV2ZW50LCB7XG4gICAgZnJhZyxcbiAgICBwYXJ0XG4gIH0pIHtcbiAgICBjb25zdCBzdGF0cyA9IHBhcnQgPyBwYXJ0LnN0YXRzIDogZnJhZy5zdGF0cztcbiAgICBpZiAoZnJhZy50eXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOKSB7XG4gICAgICB0aGlzLmJ3RXN0aW1hdG9yLnNhbXBsZVRURkIoc3RhdHMubG9hZGluZy5maXJzdCAtIHN0YXRzLmxvYWRpbmcuc3RhcnQpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pZ25vcmVGcmFnbWVudChmcmFnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBzdG9wIG1vbml0b3JpbmcgYncgb25jZSBmcmFnIGxvYWRlZFxuICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgIC8vIHJlc2V0IGZvcmNlZCBhdXRvIGxldmVsIHZhbHVlIHNvIHRoYXQgbmV4dCBsZXZlbCB3aWxsIGJlIHNlbGVjdGVkXG4gICAgaWYgKGZyYWcubGV2ZWwgPT09IHRoaXMuX25leHRBdXRvTGV2ZWwpIHtcbiAgICAgIHRoaXMuX25leHRBdXRvTGV2ZWwgPSAtMTtcbiAgICB9XG4gICAgdGhpcy5maXJzdFNlbGVjdGlvbiA9IC0xO1xuXG4gICAgLy8gY29tcHV0ZSBsZXZlbCBhdmVyYWdlIGJpdHJhdGVcbiAgICBpZiAodGhpcy5obHMuY29uZmlnLmFick1heFdpdGhSZWFsQml0cmF0ZSkge1xuICAgICAgY29uc3QgZHVyYXRpb24gPSBwYXJ0ID8gcGFydC5kdXJhdGlvbiA6IGZyYWcuZHVyYXRpb247XG4gICAgICBjb25zdCBsZXZlbCA9IHRoaXMuaGxzLmxldmVsc1tmcmFnLmxldmVsXTtcbiAgICAgIGNvbnN0IGxvYWRlZEJ5dGVzID0gKGxldmVsLmxvYWRlZCA/IGxldmVsLmxvYWRlZC5ieXRlcyA6IDApICsgc3RhdHMubG9hZGVkO1xuICAgICAgY29uc3QgbG9hZGVkRHVyYXRpb24gPSAobGV2ZWwubG9hZGVkID8gbGV2ZWwubG9hZGVkLmR1cmF0aW9uIDogMCkgKyBkdXJhdGlvbjtcbiAgICAgIGxldmVsLmxvYWRlZCA9IHtcbiAgICAgICAgYnl0ZXM6IGxvYWRlZEJ5dGVzLFxuICAgICAgICBkdXJhdGlvbjogbG9hZGVkRHVyYXRpb25cbiAgICAgIH07XG4gICAgICBsZXZlbC5yZWFsQml0cmF0ZSA9IE1hdGgucm91bmQoOCAqIGxvYWRlZEJ5dGVzIC8gbG9hZGVkRHVyYXRpb24pO1xuICAgIH1cbiAgICBpZiAoZnJhZy5iaXRyYXRlVGVzdCkge1xuICAgICAgY29uc3QgZnJhZ0J1ZmZlcmVkRGF0YSA9IHtcbiAgICAgICAgc3RhdHMsXG4gICAgICAgIGZyYWcsXG4gICAgICAgIHBhcnQsXG4gICAgICAgIGlkOiBmcmFnLnR5cGVcbiAgICAgIH07XG4gICAgICB0aGlzLm9uRnJhZ0J1ZmZlcmVkKEV2ZW50cy5GUkFHX0JVRkZFUkVELCBmcmFnQnVmZmVyZWREYXRhKTtcbiAgICAgIGZyYWcuYml0cmF0ZVRlc3QgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc3RvcmUgbGV2ZWwgaWQgYWZ0ZXIgc3VjY2Vzc2Z1bCBmcmFnbWVudCBsb2FkIGZvciBwbGF5YmFja1xuICAgICAgdGhpcy5sYXN0TG9hZGVkRnJhZ0xldmVsID0gZnJhZy5sZXZlbDtcbiAgICB9XG4gIH1cbiAgb25GcmFnQnVmZmVyZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnLFxuICAgICAgcGFydFxuICAgIH0gPSBkYXRhO1xuICAgIGNvbnN0IHN0YXRzID0gcGFydCAhPSBudWxsICYmIHBhcnQuc3RhdHMubG9hZGVkID8gcGFydC5zdGF0cyA6IGZyYWcuc3RhdHM7XG4gICAgaWYgKHN0YXRzLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaWdub3JlRnJhZ21lbnQoZnJhZykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gVXNlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gcGFyc2luZyBhbmQgcmVxdWVzdCBpbnN0ZWFkIG9mIGJ1ZmZlcmluZyBhbmQgcmVxdWVzdCB0byBjb21wdXRlIGZyYWdMb2FkaW5nUHJvY2Vzc2luZztcbiAgICAvLyByYXRpb25hbGUgaXMgdGhhdCBidWZmZXIgYXBwZW5kaW5nIG9ubHkgaGFwcGVucyBvbmNlIG1lZGlhIGlzIGF0dGFjaGVkLiBUaGlzIGNhbiBoYXBwZW4gd2hlbiBjb25maWcuc3RhcnRGcmFnUHJlZmV0Y2hcbiAgICAvLyBpcyB1c2VkLiBJZiB3ZSB1c2VkIGJ1ZmZlcmluZyBpbiB0aGF0IGNhc2UsIG91ciBCVyBlc3RpbWF0ZSBzYW1wbGUgd2lsbCBiZSB2ZXJ5IGxhcmdlLlxuICAgIGNvbnN0IHByb2Nlc3NpbmdNcyA9IHN0YXRzLnBhcnNpbmcuZW5kIC0gc3RhdHMubG9hZGluZy5zdGFydCAtIE1hdGgubWluKHN0YXRzLmxvYWRpbmcuZmlyc3QgLSBzdGF0cy5sb2FkaW5nLnN0YXJ0LCB0aGlzLmJ3RXN0aW1hdG9yLmdldEVzdGltYXRlVFRGQigpKTtcbiAgICB0aGlzLmJ3RXN0aW1hdG9yLnNhbXBsZShwcm9jZXNzaW5nTXMsIHN0YXRzLmxvYWRlZCk7XG4gICAgc3RhdHMuYndFc3RpbWF0ZSA9IHRoaXMuZ2V0QndFc3RpbWF0ZSgpO1xuICAgIGlmIChmcmFnLmJpdHJhdGVUZXN0KSB7XG4gICAgICB0aGlzLmJpdHJhdGVUZXN0RGVsYXkgPSBwcm9jZXNzaW5nTXMgLyAxMDAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJpdHJhdGVUZXN0RGVsYXkgPSAwO1xuICAgIH1cbiAgfVxuICBpZ25vcmVGcmFnbWVudChmcmFnKSB7XG4gICAgLy8gT25seSBjb3VudCBub24tYWx0LWF1ZGlvIGZyYWdzIHdoaWNoIHdlcmUgYWN0dWFsbHkgYnVmZmVyZWQgaW4gb3VyIEJXIGNhbGN1bGF0aW9uc1xuICAgIHJldHVybiBmcmFnLnR5cGUgIT09IFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4gfHwgZnJhZy5zbiA9PT0gJ2luaXRTZWdtZW50JztcbiAgfVxuICBjbGVhclRpbWVyKCkge1xuICAgIGlmICh0aGlzLnRpbWVyID4gLTEpIHtcbiAgICAgIHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICAgIHRoaXMudGltZXIgPSAtMTtcbiAgICB9XG4gIH1cbiAgZ2V0IGZpcnN0QXV0b0xldmVsKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1heEF1dG9MZXZlbCxcbiAgICAgIG1pbkF1dG9MZXZlbFxuICAgIH0gPSB0aGlzLmhscztcbiAgICBjb25zdCBid0VzdGltYXRlID0gdGhpcy5nZXRCd0VzdGltYXRlKCk7XG4gICAgY29uc3QgbWF4U3RhcnREZWxheSA9IHRoaXMuaGxzLmNvbmZpZy5tYXhTdGFydmF0aW9uRGVsYXk7XG4gICAgY29uc3QgYWJyQXV0b0xldmVsID0gdGhpcy5maW5kQmVzdExldmVsKGJ3RXN0aW1hdGUsIG1pbkF1dG9MZXZlbCwgbWF4QXV0b0xldmVsLCAwLCBtYXhTdGFydERlbGF5LCAxLCAxKTtcbiAgICBpZiAoYWJyQXV0b0xldmVsID4gLTEpIHtcbiAgICAgIHJldHVybiBhYnJBdXRvTGV2ZWw7XG4gICAgfVxuICAgIGNvbnN0IGZpcnN0TGV2ZWwgPSB0aGlzLmhscy5maXJzdExldmVsO1xuICAgIGNvbnN0IGNsYW1wZWQgPSBNYXRoLm1pbihNYXRoLm1heChmaXJzdExldmVsLCBtaW5BdXRvTGV2ZWwpLCBtYXhBdXRvTGV2ZWwpO1xuICAgIGxvZ2dlci53YXJuKGBbYWJyXSBDb3VsZCBub3QgZmluZCBiZXN0IHN0YXJ0aW5nIGF1dG8gbGV2ZWwuIERlZmF1bHRpbmcgdG8gZmlyc3QgaW4gcGxheWxpc3QgJHtmaXJzdExldmVsfSBjbGFtcGVkIHRvICR7Y2xhbXBlZH1gKTtcbiAgICByZXR1cm4gY2xhbXBlZDtcbiAgfVxuICBnZXQgZm9yY2VkQXV0b0xldmVsKCkge1xuICAgIGlmICh0aGlzLm5leHRBdXRvTGV2ZWxLZXkpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX25leHRBdXRvTGV2ZWw7XG4gIH1cblxuICAvLyByZXR1cm4gbmV4dCBhdXRvIGxldmVsXG4gIGdldCBuZXh0QXV0b0xldmVsKCkge1xuICAgIGNvbnN0IGZvcmNlZEF1dG9MZXZlbCA9IHRoaXMuZm9yY2VkQXV0b0xldmVsO1xuICAgIGNvbnN0IGJ3RXN0aW1hdG9yID0gdGhpcy5id0VzdGltYXRvcjtcbiAgICBjb25zdCB1c2VFc3RpbWF0ZSA9IGJ3RXN0aW1hdG9yLmNhbkVzdGltYXRlKCk7XG4gICAgY29uc3QgbG9hZGVkRmlyc3RGcmFnID0gdGhpcy5sYXN0TG9hZGVkRnJhZ0xldmVsID4gLTE7XG4gICAgLy8gaW4gY2FzZSBuZXh0IGF1dG8gbGV2ZWwgaGFzIGJlZW4gZm9yY2VkLCBhbmQgYncgbm90IGF2YWlsYWJsZSBvciBub3QgcmVsaWFibGUsIHJldHVybiBmb3JjZWQgdmFsdWVcbiAgICBpZiAoZm9yY2VkQXV0b0xldmVsICE9PSAtMSAmJiAoIXVzZUVzdGltYXRlIHx8ICFsb2FkZWRGaXJzdEZyYWcgfHwgdGhpcy5uZXh0QXV0b0xldmVsS2V5ID09PSB0aGlzLmdldEF1dG9MZXZlbEtleSgpKSkge1xuICAgICAgcmV0dXJuIGZvcmNlZEF1dG9MZXZlbDtcbiAgICB9XG5cbiAgICAvLyBjb21wdXRlIG5leHQgbGV2ZWwgdXNpbmcgQUJSIGxvZ2ljXG4gICAgY29uc3QgbmV4dEFCUkF1dG9MZXZlbCA9IHVzZUVzdGltYXRlICYmIGxvYWRlZEZpcnN0RnJhZyA/IHRoaXMuZ2V0TmV4dEFCUkF1dG9MZXZlbCgpIDogdGhpcy5maXJzdEF1dG9MZXZlbDtcblxuICAgIC8vIHVzZSBmb3JjZWQgYXV0byBsZXZlbCB3aGlsZSBpdCBoYXNuJ3QgZXJyb3JlZCBtb3JlIHRoYW4gQUJSIHNlbGVjdGlvblxuICAgIGlmIChmb3JjZWRBdXRvTGV2ZWwgIT09IC0xKSB7XG4gICAgICBjb25zdCBsZXZlbHMgPSB0aGlzLmhscy5sZXZlbHM7XG4gICAgICBpZiAobGV2ZWxzLmxlbmd0aCA+IE1hdGgubWF4KGZvcmNlZEF1dG9MZXZlbCwgbmV4dEFCUkF1dG9MZXZlbCkgJiYgbGV2ZWxzW2ZvcmNlZEF1dG9MZXZlbF0ubG9hZEVycm9yIDw9IGxldmVsc1tuZXh0QUJSQXV0b0xldmVsXS5sb2FkRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZvcmNlZEF1dG9MZXZlbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzYXZlIHJlc3VsdCB1bnRpbCBzdGF0ZSBoYXMgY2hhbmdlZFxuICAgIHRoaXMuX25leHRBdXRvTGV2ZWwgPSBuZXh0QUJSQXV0b0xldmVsO1xuICAgIHRoaXMubmV4dEF1dG9MZXZlbEtleSA9IHRoaXMuZ2V0QXV0b0xldmVsS2V5KCk7XG4gICAgcmV0dXJuIG5leHRBQlJBdXRvTGV2ZWw7XG4gIH1cbiAgZ2V0QXV0b0xldmVsS2V5KCkge1xuICAgIHZhciBfdGhpcyRobHMkbWFpbkZvcndhcmQ7XG4gICAgcmV0dXJuIGAke3RoaXMuZ2V0QndFc3RpbWF0ZSgpfV8keyhfdGhpcyRobHMkbWFpbkZvcndhcmQgPSB0aGlzLmhscy5tYWluRm9yd2FyZEJ1ZmZlckluZm8pID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRobHMkbWFpbkZvcndhcmQubGVufWA7XG4gIH1cbiAgZ2V0TmV4dEFCUkF1dG9MZXZlbCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnQ3VycmVudCxcbiAgICAgIHBhcnRDdXJyZW50LFxuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgbWF4QXV0b0xldmVsLFxuICAgICAgY29uZmlnLFxuICAgICAgbWluQXV0b0xldmVsLFxuICAgICAgbWVkaWFcbiAgICB9ID0gaGxzO1xuICAgIGNvbnN0IGN1cnJlbnRGcmFnRHVyYXRpb24gPSBwYXJ0Q3VycmVudCA/IHBhcnRDdXJyZW50LmR1cmF0aW9uIDogZnJhZ0N1cnJlbnQgPyBmcmFnQ3VycmVudC5kdXJhdGlvbiA6IDA7XG5cbiAgICAvLyBwbGF5YmFja1JhdGUgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoZSBwbGF5YmFjayByYXRlOyBpZiBtZWRpYS5wbGF5YmFja1JhdGUgaXMgMCwgd2UgdXNlIDEgdG8gbG9hZCBhc1xuICAgIC8vIGlmIHdlJ3JlIHBsYXlpbmcgYmFjayBhdCB0aGUgbm9ybWFsIHJhdGUuXG4gICAgY29uc3QgcGxheWJhY2tSYXRlID0gbWVkaWEgJiYgbWVkaWEucGxheWJhY2tSYXRlICE9PSAwID8gTWF0aC5hYnMobWVkaWEucGxheWJhY2tSYXRlKSA6IDEuMDtcbiAgICBjb25zdCBhdmdidyA9IHRoaXMuZ2V0QndFc3RpbWF0ZSgpO1xuICAgIC8vIGJ1ZmZlclN0YXJ2YXRpb25EZWxheSBpcyB0aGUgd2FsbC1jbG9jayB0aW1lIGxlZnQgdW50aWwgdGhlIHBsYXliYWNrIGJ1ZmZlciBpcyBleGhhdXN0ZWQuXG4gICAgY29uc3QgYnVmZmVySW5mbyA9IGhscy5tYWluRm9yd2FyZEJ1ZmZlckluZm87XG4gICAgY29uc3QgYnVmZmVyU3RhcnZhdGlvbkRlbGF5ID0gKGJ1ZmZlckluZm8gPyBidWZmZXJJbmZvLmxlbiA6IDApIC8gcGxheWJhY2tSYXRlO1xuICAgIGxldCBid0ZhY3RvciA9IGNvbmZpZy5hYnJCYW5kV2lkdGhGYWN0b3I7XG4gICAgbGV0IGJ3VXBGYWN0b3IgPSBjb25maWcuYWJyQmFuZFdpZHRoVXBGYWN0b3I7XG5cbiAgICAvLyBGaXJzdCwgbG9vayB0byBzZWUgaWYgd2UgY2FuIGZpbmQgYSBsZXZlbCBtYXRjaGluZyB3aXRoIG91ciBhdmcgYmFuZHdpZHRoIEFORCB0aGF0IGNvdWxkIGFsc28gZ3VhcmFudGVlIG5vIHJlYnVmZmVyaW5nIGF0IGFsbFxuICAgIGlmIChidWZmZXJTdGFydmF0aW9uRGVsYXkpIHtcbiAgICAgIGNvbnN0IF9iZXN0TGV2ZWwgPSB0aGlzLmZpbmRCZXN0TGV2ZWwoYXZnYncsIG1pbkF1dG9MZXZlbCwgbWF4QXV0b0xldmVsLCBidWZmZXJTdGFydmF0aW9uRGVsYXksIDAsIGJ3RmFjdG9yLCBid1VwRmFjdG9yKTtcbiAgICAgIGlmIChfYmVzdExldmVsID49IDApIHtcbiAgICAgICAgcmV0dXJuIF9iZXN0TGV2ZWw7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIG5vdCBwb3NzaWJsZSB0byBnZXQgcmlkIG9mIHJlYnVmZmVyaW5nLi4uIHRyeSB0byBmaW5kIGxldmVsIHRoYXQgd2lsbCBndWFyYW50ZWUgbGVzcyB0aGFuIG1heFN0YXJ2YXRpb25EZWxheSBvZiByZWJ1ZmZlcmluZ1xuICAgIGxldCBtYXhTdGFydmF0aW9uRGVsYXkgPSBjdXJyZW50RnJhZ0R1cmF0aW9uID8gTWF0aC5taW4oY3VycmVudEZyYWdEdXJhdGlvbiwgY29uZmlnLm1heFN0YXJ2YXRpb25EZWxheSkgOiBjb25maWcubWF4U3RhcnZhdGlvbkRlbGF5O1xuICAgIGlmICghYnVmZmVyU3RhcnZhdGlvbkRlbGF5KSB7XG4gICAgICAvLyBpbiBjYXNlIGJ1ZmZlciBpcyBlbXB0eSwgbGV0J3MgY2hlY2sgaWYgcHJldmlvdXMgZnJhZ21lbnQgd2FzIGxvYWRlZCB0byBwZXJmb3JtIGEgYml0cmF0ZSB0ZXN0XG4gICAgICBjb25zdCBiaXRyYXRlVGVzdERlbGF5ID0gdGhpcy5iaXRyYXRlVGVzdERlbGF5O1xuICAgICAgaWYgKGJpdHJhdGVUZXN0RGVsYXkpIHtcbiAgICAgICAgLy8gaWYgaXQgaXMgdGhlIGNhc2UsIHRoZW4gd2UgbmVlZCB0byBhZGp1c3Qgb3VyIG1heCBzdGFydmF0aW9uIGRlbGF5IHVzaW5nIG1heExvYWRpbmdEZWxheSBjb25maWcgdmFsdWVcbiAgICAgICAgLy8gbWF4IHZpZGVvIGxvYWRpbmcgZGVsYXkgdXNlZCBpbiAgYXV0b21hdGljIHN0YXJ0IGxldmVsIHNlbGVjdGlvbiA6XG4gICAgICAgIC8vIGluIHRoYXQgbW9kZSBBQlIgY29udHJvbGxlciB3aWxsIGVuc3VyZSB0aGF0IHZpZGVvIGxvYWRpbmcgdGltZSAoaWUgdGhlIHRpbWUgdG8gZmV0Y2ggdGhlIGZpcnN0IGZyYWdtZW50IGF0IGxvd2VzdCBxdWFsaXR5IGxldmVsICtcbiAgICAgICAgLy8gdGhlIHRpbWUgdG8gZmV0Y2ggdGhlIGZyYWdtZW50IGF0IHRoZSBhcHByb3ByaWF0ZSBxdWFsaXR5IGxldmVsIGlzIGxlc3MgdGhhbiBgYGBtYXhMb2FkaW5nRGVsYXlgYGAgKVxuICAgICAgICAvLyBjYXAgbWF4TG9hZGluZ0RlbGF5IGFuZCBlbnN1cmUgaXQgaXMgbm90IGJpZ2dlciAndGhhbiBiaXRyYXRlIHRlc3QnIGZyYWcgZHVyYXRpb25cbiAgICAgICAgY29uc3QgbWF4TG9hZGluZ0RlbGF5ID0gY3VycmVudEZyYWdEdXJhdGlvbiA/IE1hdGgubWluKGN1cnJlbnRGcmFnRHVyYXRpb24sIGNvbmZpZy5tYXhMb2FkaW5nRGVsYXkpIDogY29uZmlnLm1heExvYWRpbmdEZWxheTtcbiAgICAgICAgbWF4U3RhcnZhdGlvbkRlbGF5ID0gbWF4TG9hZGluZ0RlbGF5IC0gYml0cmF0ZVRlc3REZWxheTtcbiAgICAgICAgbG9nZ2VyLmluZm8oYFthYnJdIGJpdHJhdGUgdGVzdCB0b29rICR7TWF0aC5yb3VuZCgxMDAwICogYml0cmF0ZVRlc3REZWxheSl9bXMsIHNldCBmaXJzdCBmcmFnbWVudCBtYXggZmV0Y2hEdXJhdGlvbiB0byAke01hdGgucm91bmQoMTAwMCAqIG1heFN0YXJ2YXRpb25EZWxheSl9IG1zYCk7XG4gICAgICAgIC8vIGRvbid0IHVzZSBjb25zZXJ2YXRpdmUgZmFjdG9yIG9uIGJpdHJhdGUgdGVzdFxuICAgICAgICBid0ZhY3RvciA9IGJ3VXBGYWN0b3IgPSAxO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBiZXN0TGV2ZWwgPSB0aGlzLmZpbmRCZXN0TGV2ZWwoYXZnYncsIG1pbkF1dG9MZXZlbCwgbWF4QXV0b0xldmVsLCBidWZmZXJTdGFydmF0aW9uRGVsYXksIG1heFN0YXJ2YXRpb25EZWxheSwgYndGYWN0b3IsIGJ3VXBGYWN0b3IpO1xuICAgIGxvZ2dlci5pbmZvKGBbYWJyXSAke2J1ZmZlclN0YXJ2YXRpb25EZWxheSA/ICdyZWJ1ZmZlcmluZyBleHBlY3RlZCcgOiAnYnVmZmVyIGlzIGVtcHR5J30sIG9wdGltYWwgcXVhbGl0eSBsZXZlbCAke2Jlc3RMZXZlbH1gKTtcbiAgICBpZiAoYmVzdExldmVsID4gLTEpIHtcbiAgICAgIHJldHVybiBiZXN0TGV2ZWw7XG4gICAgfVxuICAgIC8vIElmIG5vIG1hdGNoaW5nIGxldmVsIGZvdW5kLCBzZWUgaWYgbWluIGF1dG8gbGV2ZWwgd291bGQgYmUgYSBiZXR0ZXIgb3B0aW9uXG4gICAgY29uc3QgbWluTGV2ZWwgPSBobHMubGV2ZWxzW21pbkF1dG9MZXZlbF07XG4gICAgY29uc3QgYXV0b0xldmVsID0gaGxzLmxldmVsc1tobHMubG9hZExldmVsXTtcbiAgICBpZiAoKG1pbkxldmVsID09IG51bGwgPyB2b2lkIDAgOiBtaW5MZXZlbC5iaXRyYXRlKSA8IChhdXRvTGV2ZWwgPT0gbnVsbCA/IHZvaWQgMCA6IGF1dG9MZXZlbC5iaXRyYXRlKSkge1xuICAgICAgcmV0dXJuIG1pbkF1dG9MZXZlbDtcbiAgICB9XG4gICAgLy8gb3IgaWYgYml0cmF0ZSBpcyBub3QgbG93ZXIsIGNvbnRpbnVlIHRvIHVzZSBsb2FkTGV2ZWxcbiAgICByZXR1cm4gaGxzLmxvYWRMZXZlbDtcbiAgfVxuICBnZXRCd0VzdGltYXRlKCkge1xuICAgIHJldHVybiB0aGlzLmJ3RXN0aW1hdG9yLmNhbkVzdGltYXRlKCkgPyB0aGlzLmJ3RXN0aW1hdG9yLmdldEVzdGltYXRlKCkgOiB0aGlzLmhscy5jb25maWcuYWJyRXdtYURlZmF1bHRFc3RpbWF0ZTtcbiAgfVxuICBmaW5kQmVzdExldmVsKGN1cnJlbnRCdywgbWluQXV0b0xldmVsLCBtYXhBdXRvTGV2ZWwsIGJ1ZmZlclN0YXJ2YXRpb25EZWxheSwgbWF4U3RhcnZhdGlvbkRlbGF5LCBid0ZhY3RvciwgYndVcEZhY3Rvcikge1xuICAgIHZhciBfbGV2ZWwkZGV0YWlscztcbiAgICBjb25zdCBtYXhGZXRjaER1cmF0aW9uID0gYnVmZmVyU3RhcnZhdGlvbkRlbGF5ICsgbWF4U3RhcnZhdGlvbkRlbGF5O1xuICAgIGNvbnN0IGxhc3RMb2FkZWRGcmFnTGV2ZWwgPSB0aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWw7XG4gICAgY29uc3Qgc2VsZWN0aW9uQmFzZUxldmVsID0gbGFzdExvYWRlZEZyYWdMZXZlbCA9PT0gLTEgPyB0aGlzLmhscy5maXJzdExldmVsIDogbGFzdExvYWRlZEZyYWdMZXZlbDtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnQ3VycmVudCxcbiAgICAgIHBhcnRDdXJyZW50XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgbGV2ZWxzLFxuICAgICAgYWxsQXVkaW9UcmFja3MsXG4gICAgICBsb2FkTGV2ZWwsXG4gICAgICBjb25maWdcbiAgICB9ID0gdGhpcy5obHM7XG4gICAgaWYgKGxldmVscy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjb25zdCBsZXZlbCA9IGxldmVsc1tzZWxlY3Rpb25CYXNlTGV2ZWxdO1xuICAgIGNvbnN0IGxpdmUgPSAhIShsZXZlbCAhPSBudWxsICYmIChfbGV2ZWwkZGV0YWlscyA9IGxldmVsLmRldGFpbHMpICE9IG51bGwgJiYgX2xldmVsJGRldGFpbHMubGl2ZSk7XG4gICAgY29uc3QgZmlyc3RTZWxlY3Rpb24gPSBsb2FkTGV2ZWwgPT09IC0xIHx8IGxhc3RMb2FkZWRGcmFnTGV2ZWwgPT09IC0xO1xuICAgIGxldCBjdXJyZW50Q29kZWNTZXQ7XG4gICAgbGV0IGN1cnJlbnRWaWRlb1JhbmdlID0gJ1NEUic7XG4gICAgbGV0IGN1cnJlbnRGcmFtZVJhdGUgPSAobGV2ZWwgPT0gbnVsbCA/IHZvaWQgMCA6IGxldmVsLmZyYW1lUmF0ZSkgfHwgMDtcbiAgICBjb25zdCB7XG4gICAgICBhdWRpb1ByZWZlcmVuY2UsXG4gICAgICB2aWRlb1ByZWZlcmVuY2VcbiAgICB9ID0gY29uZmlnO1xuICAgIGNvbnN0IGF1ZGlvVHJhY2tzQnlHcm91cCA9IHRoaXMuYXVkaW9UcmFja3NCeUdyb3VwIHx8ICh0aGlzLmF1ZGlvVHJhY2tzQnlHcm91cCA9IGdldEF1ZGlvVHJhY2tzQnlHcm91cChhbGxBdWRpb1RyYWNrcykpO1xuICAgIGlmIChmaXJzdFNlbGVjdGlvbikge1xuICAgICAgaWYgKHRoaXMuZmlyc3RTZWxlY3Rpb24gIT09IC0xKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpcnN0U2VsZWN0aW9uO1xuICAgICAgfVxuICAgICAgY29uc3QgY29kZWNUaWVycyA9IHRoaXMuY29kZWNUaWVycyB8fCAodGhpcy5jb2RlY1RpZXJzID0gZ2V0Q29kZWNUaWVycyhsZXZlbHMsIGF1ZGlvVHJhY2tzQnlHcm91cCwgbWluQXV0b0xldmVsLCBtYXhBdXRvTGV2ZWwpKTtcbiAgICAgIGNvbnN0IHN0YXJ0VGllciA9IGdldFN0YXJ0Q29kZWNUaWVyKGNvZGVjVGllcnMsIGN1cnJlbnRWaWRlb1JhbmdlLCBjdXJyZW50QncsIGF1ZGlvUHJlZmVyZW5jZSwgdmlkZW9QcmVmZXJlbmNlKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29kZWNTZXQsXG4gICAgICAgIHZpZGVvUmFuZ2VzLFxuICAgICAgICBtaW5GcmFtZXJhdGUsXG4gICAgICAgIG1pbkJpdHJhdGUsXG4gICAgICAgIHByZWZlckhEUlxuICAgICAgfSA9IHN0YXJ0VGllcjtcbiAgICAgIGN1cnJlbnRDb2RlY1NldCA9IGNvZGVjU2V0O1xuICAgICAgY3VycmVudFZpZGVvUmFuZ2UgPSBwcmVmZXJIRFIgPyB2aWRlb1Jhbmdlc1t2aWRlb1Jhbmdlcy5sZW5ndGggLSAxXSA6IHZpZGVvUmFuZ2VzWzBdO1xuICAgICAgY3VycmVudEZyYW1lUmF0ZSA9IG1pbkZyYW1lcmF0ZTtcbiAgICAgIGN1cnJlbnRCdyA9IE1hdGgubWF4KGN1cnJlbnRCdywgbWluQml0cmF0ZSk7XG4gICAgICBsb2dnZXIubG9nKGBbYWJyXSBwaWNrZWQgc3RhcnQgdGllciAke0pTT04uc3RyaW5naWZ5KHN0YXJ0VGllcil9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRDb2RlY1NldCA9IGxldmVsID09IG51bGwgPyB2b2lkIDAgOiBsZXZlbC5jb2RlY1NldDtcbiAgICAgIGN1cnJlbnRWaWRlb1JhbmdlID0gbGV2ZWwgPT0gbnVsbCA/IHZvaWQgMCA6IGxldmVsLnZpZGVvUmFuZ2U7XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRGcmFnRHVyYXRpb24gPSBwYXJ0Q3VycmVudCA/IHBhcnRDdXJyZW50LmR1cmF0aW9uIDogZnJhZ0N1cnJlbnQgPyBmcmFnQ3VycmVudC5kdXJhdGlvbiA6IDA7XG4gICAgY29uc3QgdHRmYkVzdGltYXRlU2VjID0gdGhpcy5id0VzdGltYXRvci5nZXRFc3RpbWF0ZVRURkIoKSAvIDEwMDA7XG4gICAgY29uc3QgbGV2ZWxzU2tpcHBlZCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSBtYXhBdXRvTGV2ZWw7IGkgPj0gbWluQXV0b0xldmVsOyBpLS0pIHtcbiAgICAgIHZhciBfbGV2ZWxJbmZvJHN1cHBvcnRlZFIsIF9sZXZlbEluZm8kc3VwcG9ydGVkUjI7XG4gICAgICBjb25zdCBsZXZlbEluZm8gPSBsZXZlbHNbaV07XG4gICAgICBjb25zdCB1cFN3aXRjaCA9IGkgPiBzZWxlY3Rpb25CYXNlTGV2ZWw7XG4gICAgICBpZiAoIWxldmVsSW5mbykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjb25maWcudXNlTWVkaWFDYXBhYmlsaXRpZXMgJiYgIWxldmVsSW5mby5zdXBwb3J0ZWRSZXN1bHQgJiYgIWxldmVsSW5mby5zdXBwb3J0ZWRQcm9taXNlKSB7XG4gICAgICAgIGNvbnN0IG1lZGlhQ2FwYWJpbGl0aWVzID0gbmF2aWdhdG9yLm1lZGlhQ2FwYWJpbGl0aWVzO1xuICAgICAgICBpZiAodHlwZW9mIChtZWRpYUNhcGFiaWxpdGllcyA9PSBudWxsID8gdm9pZCAwIDogbWVkaWFDYXBhYmlsaXRpZXMuZGVjb2RpbmdJbmZvKSA9PT0gJ2Z1bmN0aW9uJyAmJiByZXF1aXJlc01lZGlhQ2FwYWJpbGl0aWVzRGVjb2RpbmdJbmZvKGxldmVsSW5mbywgYXVkaW9UcmFja3NCeUdyb3VwLCBjdXJyZW50VmlkZW9SYW5nZSwgY3VycmVudEZyYW1lUmF0ZSwgY3VycmVudEJ3LCBhdWRpb1ByZWZlcmVuY2UpKSB7XG4gICAgICAgICAgbGV2ZWxJbmZvLnN1cHBvcnRlZFByb21pc2UgPSBnZXRNZWRpYURlY29kaW5nSW5mb1Byb21pc2UobGV2ZWxJbmZvLCBhdWRpb1RyYWNrc0J5R3JvdXAsIG1lZGlhQ2FwYWJpbGl0aWVzKTtcbiAgICAgICAgICBsZXZlbEluZm8uc3VwcG9ydGVkUHJvbWlzZS50aGVuKGRlY29kaW5nSW5mbyA9PiB7XG4gICAgICAgICAgICBsZXZlbEluZm8uc3VwcG9ydGVkUmVzdWx0ID0gZGVjb2RpbmdJbmZvO1xuICAgICAgICAgICAgY29uc3QgbGV2ZWxzID0gdGhpcy5obHMubGV2ZWxzO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBsZXZlbHMuaW5kZXhPZihsZXZlbEluZm8pO1xuICAgICAgICAgICAgaWYgKGRlY29kaW5nSW5mby5lcnJvcikge1xuICAgICAgICAgICAgICBsb2dnZXIud2FybihgW2Ficl0gTWVkaWFDYXBhYmlsaXRpZXMgZGVjb2RpbmdJbmZvIGVycm9yOiBcIiR7ZGVjb2RpbmdJbmZvLmVycm9yfVwiIGZvciBsZXZlbCAke2luZGV4fSAke0pTT04uc3RyaW5naWZ5KGRlY29kaW5nSW5mbyl9YCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFkZWNvZGluZ0luZm8uc3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgIGxvZ2dlci53YXJuKGBbYWJyXSBVbnN1cHBvcnRlZCBNZWRpYUNhcGFiaWxpdGllcyBkZWNvZGluZ0luZm8gcmVzdWx0IGZvciBsZXZlbCAke2luZGV4fSAke0pTT04uc3RyaW5naWZ5KGRlY29kaW5nSW5mbyl9YCk7XG4gICAgICAgICAgICAgIGlmIChpbmRleCA+IC0xICYmIGxldmVscy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgW2Ficl0gUmVtb3ZpbmcgdW5zdXBwb3J0ZWQgbGV2ZWwgJHtpbmRleH1gKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhscy5yZW1vdmVMZXZlbChpbmRleCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXZlbEluZm8uc3VwcG9ydGVkUmVzdWx0ID0gU1VQUE9SVEVEX0lORk9fREVGQVVMVDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBza2lwIGNhbmRpZGF0ZXMgd2hpY2ggY2hhbmdlIGNvZGVjLWZhbWlseSBvciB2aWRlby1yYW5nZSxcbiAgICAgIC8vIGFuZCB3aGljaCBkZWNyZWFzZSBvciBpbmNyZWFzZSBmcmFtZS1yYXRlIGZvciB1cCBhbmQgZG93bi1zd2l0Y2ggcmVzcGVjdGZ1bGx5XG4gICAgICBpZiAoY3VycmVudENvZGVjU2V0ICYmIGxldmVsSW5mby5jb2RlY1NldCAhPT0gY3VycmVudENvZGVjU2V0IHx8IGN1cnJlbnRWaWRlb1JhbmdlICYmIGxldmVsSW5mby52aWRlb1JhbmdlICE9PSBjdXJyZW50VmlkZW9SYW5nZSB8fCB1cFN3aXRjaCAmJiBjdXJyZW50RnJhbWVSYXRlID4gbGV2ZWxJbmZvLmZyYW1lUmF0ZSB8fCAhdXBTd2l0Y2ggJiYgY3VycmVudEZyYW1lUmF0ZSA+IDAgJiYgY3VycmVudEZyYW1lUmF0ZSA8IGxldmVsSW5mby5mcmFtZVJhdGUgfHwgISgoX2xldmVsSW5mbyRzdXBwb3J0ZWRSID0gbGV2ZWxJbmZvLnN1cHBvcnRlZFJlc3VsdCkgIT0gbnVsbCAmJiAoX2xldmVsSW5mbyRzdXBwb3J0ZWRSMiA9IF9sZXZlbEluZm8kc3VwcG9ydGVkUi5kZWNvZGluZ0luZm9SZXN1bHRzKSAhPSBudWxsICYmIF9sZXZlbEluZm8kc3VwcG9ydGVkUjJbMF0uc21vb3RoKSkge1xuICAgICAgICBsZXZlbHNTa2lwcGVkLnB1c2goaSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgbGV2ZWxEZXRhaWxzID0gbGV2ZWxJbmZvLmRldGFpbHM7XG4gICAgICBjb25zdCBhdmdEdXJhdGlvbiA9IChwYXJ0Q3VycmVudCA/IGxldmVsRGV0YWlscyA9PSBudWxsID8gdm9pZCAwIDogbGV2ZWxEZXRhaWxzLnBhcnRUYXJnZXQgOiBsZXZlbERldGFpbHMgPT0gbnVsbCA/IHZvaWQgMCA6IGxldmVsRGV0YWlscy5hdmVyYWdldGFyZ2V0ZHVyYXRpb24pIHx8IGN1cnJlbnRGcmFnRHVyYXRpb247XG4gICAgICBsZXQgYWRqdXN0ZWRidztcbiAgICAgIC8vIGZvbGxvdyBhbGdvcml0aG0gY2FwdHVyZWQgZnJvbSBzdGFnZWZyaWdodCA6XG4gICAgICAvLyBodHRwczovL2FuZHJvaWQuZ29vZ2xlc291cmNlLmNvbS9wbGF0Zm9ybS9mcmFtZXdvcmtzL2F2LysvbWFzdGVyL21lZGlhL2xpYnN0YWdlZnJpZ2h0L2h0dHBsaXZlL0xpdmVTZXNzaW9uLmNwcFxuICAgICAgLy8gUGljayB0aGUgaGlnaGVzdCBiYW5kd2lkdGggc3RyZWFtIGJlbG93IG9yIGVxdWFsIHRvIGVzdGltYXRlZCBiYW5kd2lkdGguXG4gICAgICAvLyBjb25zaWRlciBvbmx5IDgwJSBvZiB0aGUgYXZhaWxhYmxlIGJhbmR3aWR0aCwgYnV0IGlmIHdlIGFyZSBzd2l0Y2hpbmcgdXAsXG4gICAgICAvLyBiZSBldmVuIG1vcmUgY29uc2VydmF0aXZlICg3MCUpIHRvIGF2b2lkIG92ZXJlc3RpbWF0aW5nIGFuZCBpbW1lZGlhdGVseVxuICAgICAgLy8gc3dpdGNoaW5nIGJhY2suXG4gICAgICBpZiAoIXVwU3dpdGNoKSB7XG4gICAgICAgIGFkanVzdGVkYncgPSBid0ZhY3RvciAqIGN1cnJlbnRCdztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFkanVzdGVkYncgPSBid1VwRmFjdG9yICogY3VycmVudEJ3O1xuICAgICAgfVxuXG4gICAgICAvLyBVc2UgYXZlcmFnZSBiaXRyYXRlIHdoZW4gc3RhcnZhdGlvbiBkZWxheSAoYnVmZmVyIGxlbmd0aCkgaXMgZ3Qgb3IgZXEgdHdvIHNlZ21lbnQgZHVyYXRpb25zIGFuZCByZWJ1ZmZlcmluZyBpcyBub3QgZXhwZWN0ZWQgKG1heFN0YXJ2YXRpb25EZWxheSA+IDApXG4gICAgICBjb25zdCBiaXRyYXRlID0gY3VycmVudEZyYWdEdXJhdGlvbiAmJiBidWZmZXJTdGFydmF0aW9uRGVsYXkgPj0gY3VycmVudEZyYWdEdXJhdGlvbiAqIDIgJiYgbWF4U3RhcnZhdGlvbkRlbGF5ID09PSAwID8gbGV2ZWxzW2ldLmF2ZXJhZ2VCaXRyYXRlIDogbGV2ZWxzW2ldLm1heEJpdHJhdGU7XG4gICAgICBjb25zdCBmZXRjaER1cmF0aW9uID0gdGhpcy5nZXRUaW1lVG9Mb2FkRnJhZyh0dGZiRXN0aW1hdGVTZWMsIGFkanVzdGVkYncsIGJpdHJhdGUgKiBhdmdEdXJhdGlvbiwgbGV2ZWxEZXRhaWxzID09PSB1bmRlZmluZWQpO1xuICAgICAgY29uc3QgY2FuU3dpdGNoV2l0aGluVG9sZXJhbmNlID1cbiAgICAgIC8vIGlmIGFkanVzdGVkIGJ3IGlzIGdyZWF0ZXIgdGhhbiBsZXZlbCBiaXRyYXRlIEFORFxuICAgICAgYWRqdXN0ZWRidyA+PSBiaXRyYXRlICYmIChcbiAgICAgIC8vIG5vIGxldmVsIGNoYW5nZSwgb3IgbmV3IGxldmVsIGhhcyBubyBlcnJvciBoaXN0b3J5XG4gICAgICBpID09PSBsYXN0TG9hZGVkRnJhZ0xldmVsIHx8IGxldmVsSW5mby5sb2FkRXJyb3IgPT09IDAgJiYgbGV2ZWxJbmZvLmZyYWdtZW50RXJyb3IgPT09IDApICYmIChcbiAgICAgIC8vIGZyYWdtZW50IGZldGNoRHVyYXRpb24gdW5rbm93biBPUiBsaXZlIHN0cmVhbSBPUiBmcmFnbWVudCBmZXRjaER1cmF0aW9uIGxlc3MgdGhhbiBtYXggYWxsb3dlZCBmZXRjaCBkdXJhdGlvbiwgdGhlbiB0aGlzIGxldmVsIG1hdGNoZXNcbiAgICAgIC8vIHdlIGRvbid0IGFjY291bnQgZm9yIG1heCBGZXRjaCBEdXJhdGlvbiBmb3IgbGl2ZSBzdHJlYW1zLCB0aGlzIGlzIHRvIGF2b2lkIHN3aXRjaGluZyBkb3duIHdoZW4gbmVhciB0aGUgZWRnZSBvZiBsaXZlIHNsaWRpbmcgd2luZG93IC4uLlxuICAgICAgLy8gc3BlY2lhbCBjYXNlIHRvIHN1cHBvcnQgc3RhcnRMZXZlbCA9IC0xIChiaXRyYXRlVGVzdCkgb24gbGl2ZSBzdHJlYW1zIDogaW4gdGhhdCBjYXNlIHdlIHNob3VsZCBub3QgZXhpdCBsb29wIHNvIHRoYXQgZmluZEJlc3RMZXZlbCB3aWxsIHJldHVybiAtMVxuICAgICAgZmV0Y2hEdXJhdGlvbiA8PSB0dGZiRXN0aW1hdGVTZWMgfHwgIWlzRmluaXRlTnVtYmVyKGZldGNoRHVyYXRpb24pIHx8IGxpdmUgJiYgIXRoaXMuYml0cmF0ZVRlc3REZWxheSB8fCBmZXRjaER1cmF0aW9uIDwgbWF4RmV0Y2hEdXJhdGlvbik7XG4gICAgICBpZiAoY2FuU3dpdGNoV2l0aGluVG9sZXJhbmNlKSB7XG4gICAgICAgIGNvbnN0IGZvcmNlZEF1dG9MZXZlbCA9IHRoaXMuZm9yY2VkQXV0b0xldmVsO1xuICAgICAgICBpZiAoaSAhPT0gbG9hZExldmVsICYmIChmb3JjZWRBdXRvTGV2ZWwgPT09IC0xIHx8IGZvcmNlZEF1dG9MZXZlbCAhPT0gbG9hZExldmVsKSkge1xuICAgICAgICAgIGlmIChsZXZlbHNTa2lwcGVkLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRyYWNlKGBbYWJyXSBTa2lwcGVkIGxldmVsKHMpICR7bGV2ZWxzU2tpcHBlZC5qb2luKCcsJyl9IG9mICR7bWF4QXV0b0xldmVsfSBtYXggd2l0aCBDT0RFQ1MgYW5kIFZJREVPLVJBTkdFOlwiJHtsZXZlbHNbbGV2ZWxzU2tpcHBlZFswXV0uY29kZWNzfVwiICR7bGV2ZWxzW2xldmVsc1NraXBwZWRbMF1dLnZpZGVvUmFuZ2V9OyBub3QgY29tcGF0aWJsZSB3aXRoIFwiJHtsZXZlbC5jb2RlY3N9XCIgJHtjdXJyZW50VmlkZW9SYW5nZX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbG9nZ2VyLmluZm8oYFthYnJdIHN3aXRjaCBjYW5kaWRhdGU6JHtzZWxlY3Rpb25CYXNlTGV2ZWx9LT4ke2l9IGFkanVzdGVkYncoJHtNYXRoLnJvdW5kKGFkanVzdGVkYncpfSktYml0cmF0ZT0ke01hdGgucm91bmQoYWRqdXN0ZWRidyAtIGJpdHJhdGUpfSB0dGZiOiR7dHRmYkVzdGltYXRlU2VjLnRvRml4ZWQoMSl9IGF2Z0R1cmF0aW9uOiR7YXZnRHVyYXRpb24udG9GaXhlZCgxKX0gbWF4RmV0Y2hEdXJhdGlvbjoke21heEZldGNoRHVyYXRpb24udG9GaXhlZCgxKX0gZmV0Y2hEdXJhdGlvbjoke2ZldGNoRHVyYXRpb24udG9GaXhlZCgxKX0gZmlyc3RTZWxlY3Rpb246JHtmaXJzdFNlbGVjdGlvbn0gY29kZWNTZXQ6JHtjdXJyZW50Q29kZWNTZXR9IHZpZGVvUmFuZ2U6JHtjdXJyZW50VmlkZW9SYW5nZX0gaGxzLmxvYWRMZXZlbDoke2xvYWRMZXZlbH1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlyc3RTZWxlY3Rpb24pIHtcbiAgICAgICAgICB0aGlzLmZpcnN0U2VsZWN0aW9uID0gaTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhcyB3ZSBhcmUgbG9vcGluZyBmcm9tIGhpZ2hlc3QgdG8gbG93ZXN0LCB0aGlzIHdpbGwgcmV0dXJuIHRoZSBiZXN0IGFjaGlldmFibGUgcXVhbGl0eSBsZXZlbFxuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gbm90IGVub3VnaCB0aW1lIGJ1ZGdldCBldmVuIHdpdGggcXVhbGl0eSBsZXZlbCAwIC4uLiByZWJ1ZmZlcmluZyBtaWdodCBoYXBwZW5cbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgc2V0IG5leHRBdXRvTGV2ZWwobmV4dExldmVsKSB7XG4gICAgY29uc3QgdmFsdWUgPSBNYXRoLm1heCh0aGlzLmhscy5taW5BdXRvTGV2ZWwsIG5leHRMZXZlbCk7XG4gICAgaWYgKHRoaXMuX25leHRBdXRvTGV2ZWwgIT0gdmFsdWUpIHtcbiAgICAgIHRoaXMubmV4dEF1dG9MZXZlbEtleSA9ICcnO1xuICAgICAgdGhpcy5fbmV4dEF1dG9MZXZlbCA9IHZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBpZ25vcmVcbiAqIFN1Yi1jbGFzcyBzcGVjaWFsaXphdGlvbiBvZiBFdmVudEhhbmRsZXIgYmFzZSBjbGFzcy5cbiAqXG4gKiBUYXNrTG9vcCBhbGxvd3MgdG8gc2NoZWR1bGUgYSB0YXNrIGZ1bmN0aW9uIGJlaW5nIGNhbGxlZCAob3B0aW9ubmFseSByZXBlYXRlZGx5KSBvbiB0aGUgbWFpbiBsb29wLFxuICogc2NoZWR1bGVkIGFzeW5jaHJvbmVvdXNseSwgYXZvaWRpbmcgcmVjdXJzaXZlIGNhbGxzIGluIHRoZSBzYW1lIHRpY2suXG4gKlxuICogVGhlIHRhc2sgaXRzZWxmIGlzIGltcGxlbWVudGVkIGluIGBkb1RpY2tgLiBJdCBjYW4gYmUgcmVxdWVzdGVkIGFuZCBjYWxsZWQgZm9yIHNpbmdsZSBleGVjdXRpb25cbiAqIHVzaW5nIHRoZSBgdGlja2AgbWV0aG9kLlxuICpcbiAqIEl0IHdpbGwgYmUgYXNzdXJlZCB0aGF0IHRoZSB0YXNrIGV4ZWN1dGlvbiBtZXRob2QgKGB0aWNrYCkgb25seSBnZXRzIGNhbGxlZCBvbmNlIHBlciBtYWluIGxvb3AgXCJ0aWNrXCIsXG4gKiBubyBtYXR0ZXIgaG93IG9mdGVuIGl0IGdldHMgcmVxdWVzdGVkIGZvciBleGVjdXRpb24uIEV4ZWN1dGlvbiBpbiBmdXJ0aGVyIHRpY2tzIHdpbGwgYmUgc2NoZWR1bGVkIGFjY29yZGluZ2x5LlxuICpcbiAqIElmIGZ1cnRoZXIgZXhlY3V0aW9uIHJlcXVlc3RzIGhhdmUgYWxyZWFkeSBiZWVuIHNjaGVkdWxlZCBvbiB0aGUgbmV4dCB0aWNrLCBpdCBjYW4gYmUgY2hlY2tlZCB3aXRoIGBoYXNOZXh0VGlja2AsXG4gKiBhbmQgY2FuY2VsbGVkIHdpdGggYGNsZWFyTmV4dFRpY2tgLlxuICpcbiAqIFRoZSB0YXNrIGNhbiBiZSBzY2hlZHVsZWQgYXMgYW4gaW50ZXJ2YWwgcmVwZWF0ZWRseSB3aXRoIGEgcGVyaW9kIGFzIHBhcmFtZXRlciAoc2VlIGBzZXRJbnRlcnZhbGAsIGBjbGVhckludGVydmFsYCkuXG4gKlxuICogU3ViLWNsYXNzZXMgbmVlZCB0byBpbXBsZW1lbnQgdGhlIGBkb1RpY2tgIG1ldGhvZCB3aGljaCB3aWxsIGVmZmVjdGl2ZWx5IGhhdmUgdGhlIHRhc2sgZXhlY3V0aW9uIHJvdXRpbmUuXG4gKlxuICogRnVydGhlciBleHBsYW5hdGlvbnM6XG4gKlxuICogVGhlIGJhc2VjbGFzcyBoYXMgYSBgdGlja2AgbWV0aG9kIHRoYXQgd2lsbCBzY2hlZHVsZSB0aGUgZG9UaWNrIGNhbGwuIEl0IG1heSBiZSBjYWxsZWQgc3luY2hyb25lb3VzbHlcbiAqIG9ubHkgZm9yIGEgc3RhY2stZGVwdGggb2Ygb25lLiBPbiByZS1lbnRyYW50IGNhbGxzLCBzdWItc2VxdWVudCBjYWxscyBhcmUgc2NoZWR1bGVkIGZvciBuZXh0IG1haW4gbG9vcCB0aWNrcy5cbiAqXG4gKiBXaGVuIHRoZSB0YXNrIGV4ZWN1dGlvbiAoYHRpY2tgIG1ldGhvZCkgaXMgY2FsbGVkIGluIHJlLWVudHJhbnQgd2F5IHRoaXMgaXMgZGV0ZWN0ZWQgYW5kXG4gKiB3ZSBhcmUgbGltaXRpbmcgdGhlIHRhc2sgZXhlY3V0aW9uIHBlciBjYWxsIHN0YWNrIHRvIGV4YWN0bHkgb25lLCBidXQgc2NoZWR1bGluZy9wb3N0LXBvbmluZyBmdXJ0aGVyXG4gKiB0YXNrIHByb2Nlc3Npbmcgb24gdGhlIG5leHQgbWFpbiBsb29wIGl0ZXJhdGlvbiAoYWxzbyBrbm93biBhcyBcIm5leHQgdGlja1wiIGluIHRoZSBOb2RlL0pTIHJ1bnRpbWUgbGluZ28pLlxuICovXG5jbGFzcyBUYXNrTG9vcCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2JvdW5kVGljayA9IHZvaWQgMDtcbiAgICB0aGlzLl90aWNrVGltZXIgPSBudWxsO1xuICAgIHRoaXMuX3RpY2tJbnRlcnZhbCA9IG51bGw7XG4gICAgdGhpcy5fdGlja0NhbGxDb3VudCA9IDA7XG4gICAgdGhpcy5fYm91bmRUaWNrID0gdGhpcy50aWNrLmJpbmQodGhpcyk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLm9uSGFuZGxlckRlc3Ryb3lpbmcoKTtcbiAgICB0aGlzLm9uSGFuZGxlckRlc3Ryb3llZCgpO1xuICB9XG4gIG9uSGFuZGxlckRlc3Ryb3lpbmcoKSB7XG4gICAgLy8gY2xlYXIgYWxsIHRpbWVycyBiZWZvcmUgdW5yZWdpc3RlcmluZyBmcm9tIGV2ZW50IGJ1c1xuICAgIHRoaXMuY2xlYXJOZXh0VGljaygpO1xuICAgIHRoaXMuY2xlYXJJbnRlcnZhbCgpO1xuICB9XG4gIG9uSGFuZGxlckRlc3Ryb3llZCgpIHt9XG4gIGhhc0ludGVydmFsKCkge1xuICAgIHJldHVybiAhIXRoaXMuX3RpY2tJbnRlcnZhbDtcbiAgfVxuICBoYXNOZXh0VGljaygpIHtcbiAgICByZXR1cm4gISF0aGlzLl90aWNrVGltZXI7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIG1pbGxpcyAtIEludGVydmFsIHRpbWUgKG1zKVxuICAgKiBAZXR1cm5zIFRydWUgd2hlbiBpbnRlcnZhbCBoYXMgYmVlbiBzY2hlZHVsZWQsIGZhbHNlIHdoZW4gYWxyZWFkeSBzY2hlZHVsZWQgKG5vIGVmZmVjdClcbiAgICovXG4gIHNldEludGVydmFsKG1pbGxpcykge1xuICAgIGlmICghdGhpcy5fdGlja0ludGVydmFsKSB7XG4gICAgICB0aGlzLl90aWNrQ2FsbENvdW50ID0gMDtcbiAgICAgIHRoaXMuX3RpY2tJbnRlcnZhbCA9IHNlbGYuc2V0SW50ZXJ2YWwodGhpcy5fYm91bmRUaWNrLCBtaWxsaXMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyBUcnVlIHdoZW4gaW50ZXJ2YWwgd2FzIGNsZWFyZWQsIGZhbHNlIHdoZW4gbm9uZSB3YXMgc2V0IChubyBlZmZlY3QpXG4gICAqL1xuICBjbGVhckludGVydmFsKCkge1xuICAgIGlmICh0aGlzLl90aWNrSW50ZXJ2YWwpIHtcbiAgICAgIHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLl90aWNrSW50ZXJ2YWwpO1xuICAgICAgdGhpcy5fdGlja0ludGVydmFsID0gbnVsbDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMgVHJ1ZSB3aGVuIHRpbWVvdXQgd2FzIGNsZWFyZWQsIGZhbHNlIHdoZW4gbm9uZSB3YXMgc2V0IChubyBlZmZlY3QpXG4gICAqL1xuICBjbGVhck5leHRUaWNrKCkge1xuICAgIGlmICh0aGlzLl90aWNrVGltZXIpIHtcbiAgICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMuX3RpY2tUaW1lcik7XG4gICAgICB0aGlzLl90aWNrVGltZXIgPSBudWxsO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaWxsIGNhbGwgdGhlIHN1YmNsYXNzIGRvVGljayBpbXBsZW1lbnRhdGlvbiBpbiB0aGlzIG1haW4gbG9vcCB0aWNrXG4gICAqIG9yIGluIHRoZSBuZXh0IG9uZSAodmlhIHNldFRpbWVvdXQoLDApKSBpbiBjYXNlIGl0IGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkXG4gICAqIGluIHRoaXMgdGljayAoaW4gY2FzZSB0aGlzIGlzIGEgcmUtZW50cmFudCBjYWxsKS5cbiAgICovXG4gIHRpY2soKSB7XG4gICAgdGhpcy5fdGlja0NhbGxDb3VudCsrO1xuICAgIGlmICh0aGlzLl90aWNrQ2FsbENvdW50ID09PSAxKSB7XG4gICAgICB0aGlzLmRvVGljaygpO1xuICAgICAgLy8gcmUtZW50cmFudCBjYWxsIHRvIHRpY2sgZnJvbSBwcmV2aW91cyBkb1RpY2sgY2FsbCBzdGFja1xuICAgICAgLy8gLT4gc2NoZWR1bGUgYSBjYWxsIG9uIHRoZSBuZXh0IG1haW4gbG9vcCBpdGVyYXRpb24gdG8gcHJvY2VzcyB0aGlzIHRhc2sgcHJvY2Vzc2luZyByZXF1ZXN0XG4gICAgICBpZiAodGhpcy5fdGlja0NhbGxDb3VudCA+IDEpIHtcbiAgICAgICAgLy8gbWFrZSBzdXJlIG9ubHkgb25lIHRpbWVyIGV4aXN0cyBhdCBhbnkgdGltZSBhdCBtYXhcbiAgICAgICAgdGhpcy50aWNrSW1tZWRpYXRlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl90aWNrQ2FsbENvdW50ID0gMDtcbiAgICB9XG4gIH1cbiAgdGlja0ltbWVkaWF0ZSgpIHtcbiAgICB0aGlzLmNsZWFyTmV4dFRpY2soKTtcbiAgICB0aGlzLl90aWNrVGltZXIgPSBzZWxmLnNldFRpbWVvdXQodGhpcy5fYm91bmRUaWNrLCAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3Igc3ViY2xhc3MgdG8gaW1wbGVtZW50IHRhc2sgbG9naWNcbiAgICogQGFic3RyYWN0XG4gICAqL1xuICBkb1RpY2soKSB7fVxufVxuXG52YXIgRnJhZ21lbnRTdGF0ZSA9IHtcbiAgTk9UX0xPQURFRDogXCJOT1RfTE9BREVEXCIsXG4gIEFQUEVORElORzogXCJBUFBFTkRJTkdcIixcbiAgUEFSVElBTDogXCJQQVJUSUFMXCIsXG4gIE9LOiBcIk9LXCJcbn07XG5jbGFzcyBGcmFnbWVudFRyYWNrZXIge1xuICBjb25zdHJ1Y3RvcihobHMpIHtcbiAgICB0aGlzLmFjdGl2ZVBhcnRMaXN0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5lbmRMaXN0RnJhZ21lbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmZyYWdtZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy50aW1lUmFuZ2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmJ1ZmZlclBhZGRpbmcgPSAwLjI7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5oYXNHYXBzID0gZmFsc2U7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5fcmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICBfcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfQVBQRU5ERUQsIHRoaXMub25CdWZmZXJBcHBlbmRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5GUkFHX0JVRkZFUkVELCB0aGlzLm9uRnJhZ0J1ZmZlcmVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkZSQUdfTE9BREVELCB0aGlzLm9uRnJhZ0xvYWRlZCwgdGhpcyk7XG4gIH1cbiAgX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0FQUEVOREVELCB0aGlzLm9uQnVmZmVyQXBwZW5kZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkZSQUdfQlVGRkVSRUQsIHRoaXMub25GcmFnQnVmZmVyZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkZSQUdfTE9BREVELCB0aGlzLm9uRnJhZ0xvYWRlZCwgdGhpcyk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl91bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuZnJhZ21lbnRzID1cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5hY3RpdmVQYXJ0TGlzdHMgPVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmVuZExpc3RGcmFnbWVudHMgPSB0aGlzLnRpbWVSYW5nZXMgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIEZyYWdtZW50IG9yIFBhcnQgd2l0aCBhbiBhcHBlbmRlZCByYW5nZSB0aGF0IG1hdGNoZXMgdGhlIHBvc2l0aW9uIGFuZCBsZXZlbFR5cGVcbiAgICogT3RoZXJ3aXNlLCByZXR1cm4gbnVsbFxuICAgKi9cbiAgZ2V0QXBwZW5kZWRGcmFnKHBvc2l0aW9uLCBsZXZlbFR5cGUpIHtcbiAgICBjb25zdCBhY3RpdmVQYXJ0cyA9IHRoaXMuYWN0aXZlUGFydExpc3RzW2xldmVsVHlwZV07XG4gICAgaWYgKGFjdGl2ZVBhcnRzKSB7XG4gICAgICBmb3IgKGxldCBpID0gYWN0aXZlUGFydHMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgIGNvbnN0IGFjdGl2ZVBhcnQgPSBhY3RpdmVQYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFhY3RpdmVQYXJ0KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBwZW5kZWRQVFMgPSBhY3RpdmVQYXJ0LmVuZDtcbiAgICAgICAgaWYgKGFjdGl2ZVBhcnQuc3RhcnQgPD0gcG9zaXRpb24gJiYgYXBwZW5kZWRQVFMgIT09IG51bGwgJiYgcG9zaXRpb24gPD0gYXBwZW5kZWRQVFMpIHtcbiAgICAgICAgICByZXR1cm4gYWN0aXZlUGFydDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXJlZEZyYWcocG9zaXRpb24sIGxldmVsVHlwZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgYnVmZmVyZWQgRnJhZ21lbnQgdGhhdCBtYXRjaGVzIHRoZSBwb3NpdGlvbiBhbmQgbGV2ZWxUeXBlLlxuICAgKiBBIGJ1ZmZlcmVkIEZyYWdtZW50IGlzIG9uZSB3aG9zZSBsb2FkaW5nLCBwYXJzaW5nIGFuZCBhcHBlbmRpbmcgaXMgZG9uZSAoY29tcGxldGVkIG9yIFwicGFydGlhbFwiIG1lYW5pbmcgYWJvcnRlZCkuXG4gICAqIElmIG5vdCBmb3VuZCBhbnkgRnJhZ21lbnQsIHJldHVybiBudWxsXG4gICAqL1xuICBnZXRCdWZmZXJlZEZyYWcocG9zaXRpb24sIGxldmVsVHlwZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGZyYWdtZW50c1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudHMpO1xuICAgIGZvciAobGV0IGkgPSBrZXlzLmxlbmd0aDsgaS0tOykge1xuICAgICAgY29uc3QgZnJhZ21lbnRFbnRpdHkgPSBmcmFnbWVudHNba2V5c1tpXV07XG4gICAgICBpZiAoKGZyYWdtZW50RW50aXR5ID09IG51bGwgPyB2b2lkIDAgOiBmcmFnbWVudEVudGl0eS5ib2R5LnR5cGUpID09PSBsZXZlbFR5cGUgJiYgZnJhZ21lbnRFbnRpdHkuYnVmZmVyZWQpIHtcbiAgICAgICAgY29uc3QgZnJhZyA9IGZyYWdtZW50RW50aXR5LmJvZHk7XG4gICAgICAgIGlmIChmcmFnLnN0YXJ0IDw9IHBvc2l0aW9uICYmIHBvc2l0aW9uIDw9IGZyYWcuZW5kKSB7XG4gICAgICAgICAgcmV0dXJuIGZyYWc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUGFydGlhbCBmcmFnbWVudHMgZWZmZWN0ZWQgYnkgY29kZWQgZnJhbWUgZXZpY3Rpb24gd2lsbCBiZSByZW1vdmVkXG4gICAqIFRoZSBicm93c2VyIHdpbGwgdW5sb2FkIHBhcnRzIG9mIHRoZSBidWZmZXIgdG8gZnJlZSB1cCBtZW1vcnkgZm9yIG5ldyBidWZmZXIgZGF0YVxuICAgKiBGcmFnbWVudHMgd2lsbCBuZWVkIHRvIGJlIHJlbG9hZGVkIHdoZW4gdGhlIGJ1ZmZlciBpcyBmcmVlZCB1cCwgcmVtb3ZpbmcgcGFydGlhbCBmcmFnbWVudHMgd2lsbCBhbGxvdyB0aGVtIHRvIHJlbG9hZChzaW5jZSB0aGVyZSBtaWdodCBiZSBwYXJ0cyB0aGF0IGFyZSBzdGlsbCBwbGF5YWJsZSlcbiAgICovXG4gIGRldGVjdEV2aWN0ZWRGcmFnbWVudHMoZWxlbWVudGFyeVN0cmVhbSwgdGltZVJhbmdlLCBwbGF5bGlzdFR5cGUsIGFwcGVuZGVkUGFydCkge1xuICAgIGlmICh0aGlzLnRpbWVSYW5nZXMpIHtcbiAgICAgIHRoaXMudGltZVJhbmdlc1tlbGVtZW50YXJ5U3RyZWFtXSA9IHRpbWVSYW5nZTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgYW55IGZsYWdnZWQgZnJhZ21lbnRzIGhhdmUgYmVlbiB1bmxvYWRlZFxuICAgIC8vIGV4Y2x1ZGluZyBhbnl0aGluZyBuZXdlciB0aGFuIGFwcGVuZGVkUGFydFNuXG4gICAgY29uc3QgYXBwZW5kZWRQYXJ0U24gPSAoYXBwZW5kZWRQYXJ0ID09IG51bGwgPyB2b2lkIDAgOiBhcHBlbmRlZFBhcnQuZnJhZ21lbnQuc24pIHx8IC0xO1xuICAgIE9iamVjdC5rZXlzKHRoaXMuZnJhZ21lbnRzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBjb25zdCBmcmFnbWVudEVudGl0eSA9IHRoaXMuZnJhZ21lbnRzW2tleV07XG4gICAgICBpZiAoIWZyYWdtZW50RW50aXR5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChhcHBlbmRlZFBhcnRTbiA+PSBmcmFnbWVudEVudGl0eS5ib2R5LnNuKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghZnJhZ21lbnRFbnRpdHkuYnVmZmVyZWQgJiYgIWZyYWdtZW50RW50aXR5LmxvYWRlZCkge1xuICAgICAgICBpZiAoZnJhZ21lbnRFbnRpdHkuYm9keS50eXBlID09PSBwbGF5bGlzdFR5cGUpIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUZyYWdtZW50KGZyYWdtZW50RW50aXR5LmJvZHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVzRGF0YSA9IGZyYWdtZW50RW50aXR5LnJhbmdlW2VsZW1lbnRhcnlTdHJlYW1dO1xuICAgICAgaWYgKCFlc0RhdGEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXNEYXRhLnRpbWUuc29tZSh0aW1lID0+IHtcbiAgICAgICAgY29uc3QgaXNOb3RCdWZmZXJlZCA9ICF0aGlzLmlzVGltZUJ1ZmZlcmVkKHRpbWUuc3RhcnRQVFMsIHRpbWUuZW5kUFRTLCB0aW1lUmFuZ2UpO1xuICAgICAgICBpZiAoaXNOb3RCdWZmZXJlZCkge1xuICAgICAgICAgIC8vIFVucmVnaXN0ZXIgcGFydGlhbCBmcmFnbWVudCBhcyBpdCBuZWVkcyB0byBsb2FkIGFnYWluIHRvIGJlIHJldXNlZFxuICAgICAgICAgIHRoaXMucmVtb3ZlRnJhZ21lbnQoZnJhZ21lbnRFbnRpdHkuYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzTm90QnVmZmVyZWQ7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGZyYWdtZW50IHBhc3NlZCBpbiBpcyBsb2FkZWQgaW4gdGhlIGJ1ZmZlciBwcm9wZXJseVxuICAgKiBQYXJ0aWFsbHkgbG9hZGVkIGZyYWdtZW50cyB3aWxsIGJlIHJlZ2lzdGVyZWQgYXMgYSBwYXJ0aWFsIGZyYWdtZW50XG4gICAqL1xuICBkZXRlY3RQYXJ0aWFsRnJhZ21lbnRzKGRhdGEpIHtcbiAgICBjb25zdCB0aW1lUmFuZ2VzID0gdGhpcy50aW1lUmFuZ2VzO1xuICAgIGNvbnN0IHtcbiAgICAgIGZyYWcsXG4gICAgICBwYXJ0XG4gICAgfSA9IGRhdGE7XG4gICAgaWYgKCF0aW1lUmFuZ2VzIHx8IGZyYWcuc24gPT09ICdpbml0U2VnbWVudCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZnJhZ0tleSA9IGdldEZyYWdtZW50S2V5KGZyYWcpO1xuICAgIGNvbnN0IGZyYWdtZW50RW50aXR5ID0gdGhpcy5mcmFnbWVudHNbZnJhZ0tleV07XG4gICAgaWYgKCFmcmFnbWVudEVudGl0eSB8fCBmcmFnbWVudEVudGl0eS5idWZmZXJlZCAmJiBmcmFnLmdhcCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpc0ZyYWdIaW50ID0gIWZyYWcucmVsdXJsO1xuICAgIE9iamVjdC5rZXlzKHRpbWVSYW5nZXMpLmZvckVhY2goZWxlbWVudGFyeVN0cmVhbSA9PiB7XG4gICAgICBjb25zdCBzdHJlYW1JbmZvID0gZnJhZy5lbGVtZW50YXJ5U3RyZWFtc1tlbGVtZW50YXJ5U3RyZWFtXTtcbiAgICAgIGlmICghc3RyZWFtSW5mbykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB0aW1lUmFuZ2UgPSB0aW1lUmFuZ2VzW2VsZW1lbnRhcnlTdHJlYW1dO1xuICAgICAgY29uc3QgcGFydGlhbCA9IGlzRnJhZ0hpbnQgfHwgc3RyZWFtSW5mby5wYXJ0aWFsID09PSB0cnVlO1xuICAgICAgZnJhZ21lbnRFbnRpdHkucmFuZ2VbZWxlbWVudGFyeVN0cmVhbV0gPSB0aGlzLmdldEJ1ZmZlcmVkVGltZXMoZnJhZywgcGFydCwgcGFydGlhbCwgdGltZVJhbmdlKTtcbiAgICB9KTtcbiAgICBmcmFnbWVudEVudGl0eS5sb2FkZWQgPSBudWxsO1xuICAgIGlmIChPYmplY3Qua2V5cyhmcmFnbWVudEVudGl0eS5yYW5nZSkubGVuZ3RoKSB7XG4gICAgICBmcmFnbWVudEVudGl0eS5idWZmZXJlZCA9IHRydWU7XG4gICAgICBjb25zdCBlbmRMaXN0ID0gZnJhZ21lbnRFbnRpdHkuYm9keS5lbmRMaXN0ID0gZnJhZy5lbmRMaXN0IHx8IGZyYWdtZW50RW50aXR5LmJvZHkuZW5kTGlzdDtcbiAgICAgIGlmIChlbmRMaXN0KSB7XG4gICAgICAgIHRoaXMuZW5kTGlzdEZyYWdtZW50c1tmcmFnbWVudEVudGl0eS5ib2R5LnR5cGVdID0gZnJhZ21lbnRFbnRpdHk7XG4gICAgICB9XG4gICAgICBpZiAoIWlzUGFydGlhbChmcmFnbWVudEVudGl0eSkpIHtcbiAgICAgICAgLy8gUmVtb3ZlIG9sZGVyIGZyYWdtZW50IHBhcnRzIGZyb20gbG9va3VwIGFmdGVyIGZyYWcgaXMgdHJhY2tlZCBhcyBidWZmZXJlZFxuICAgICAgICB0aGlzLnJlbW92ZVBhcnRzKGZyYWcuc24gLSAxLCBmcmFnLnR5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZW1vdmUgZnJhZ21lbnQgaWYgbm90aGluZyB3YXMgYXBwZW5kZWRcbiAgICAgIHRoaXMucmVtb3ZlRnJhZ21lbnQoZnJhZ21lbnRFbnRpdHkuYm9keSk7XG4gICAgfVxuICB9XG4gIHJlbW92ZVBhcnRzKHNuVG9LZWVwLCBsZXZlbFR5cGUpIHtcbiAgICBjb25zdCBhY3RpdmVQYXJ0cyA9IHRoaXMuYWN0aXZlUGFydExpc3RzW2xldmVsVHlwZV07XG4gICAgaWYgKCFhY3RpdmVQYXJ0cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmFjdGl2ZVBhcnRMaXN0c1tsZXZlbFR5cGVdID0gYWN0aXZlUGFydHMuZmlsdGVyKHBhcnQgPT4gcGFydC5mcmFnbWVudC5zbiA+PSBzblRvS2VlcCk7XG4gIH1cbiAgZnJhZ0J1ZmZlcmVkKGZyYWcsIGZvcmNlKSB7XG4gICAgY29uc3QgZnJhZ0tleSA9IGdldEZyYWdtZW50S2V5KGZyYWcpO1xuICAgIGxldCBmcmFnbWVudEVudGl0eSA9IHRoaXMuZnJhZ21lbnRzW2ZyYWdLZXldO1xuICAgIGlmICghZnJhZ21lbnRFbnRpdHkgJiYgZm9yY2UpIHtcbiAgICAgIGZyYWdtZW50RW50aXR5ID0gdGhpcy5mcmFnbWVudHNbZnJhZ0tleV0gPSB7XG4gICAgICAgIGJvZHk6IGZyYWcsXG4gICAgICAgIGFwcGVuZGVkUFRTOiBudWxsLFxuICAgICAgICBsb2FkZWQ6IG51bGwsXG4gICAgICAgIGJ1ZmZlcmVkOiBmYWxzZSxcbiAgICAgICAgcmFuZ2U6IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICAgIH07XG4gICAgICBpZiAoZnJhZy5nYXApIHtcbiAgICAgICAgdGhpcy5oYXNHYXBzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZyYWdtZW50RW50aXR5KSB7XG4gICAgICBmcmFnbWVudEVudGl0eS5sb2FkZWQgPSBudWxsO1xuICAgICAgZnJhZ21lbnRFbnRpdHkuYnVmZmVyZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBnZXRCdWZmZXJlZFRpbWVzKGZyYWdtZW50LCBwYXJ0LCBwYXJ0aWFsLCB0aW1lUmFuZ2UpIHtcbiAgICBjb25zdCBidWZmZXJlZCA9IHtcbiAgICAgIHRpbWU6IFtdLFxuICAgICAgcGFydGlhbFxuICAgIH07XG4gICAgY29uc3Qgc3RhcnRQVFMgPSBmcmFnbWVudC5zdGFydDtcbiAgICBjb25zdCBlbmRQVFMgPSBmcmFnbWVudC5lbmQ7XG4gICAgY29uc3QgbWluRW5kUFRTID0gZnJhZ21lbnQubWluRW5kUFRTIHx8IGVuZFBUUztcbiAgICBjb25zdCBtYXhTdGFydFBUUyA9IGZyYWdtZW50Lm1heFN0YXJ0UFRTIHx8IHN0YXJ0UFRTO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGltZVJhbmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzdGFydFRpbWUgPSB0aW1lUmFuZ2Uuc3RhcnQoaSkgLSB0aGlzLmJ1ZmZlclBhZGRpbmc7XG4gICAgICBjb25zdCBlbmRUaW1lID0gdGltZVJhbmdlLmVuZChpKSArIHRoaXMuYnVmZmVyUGFkZGluZztcbiAgICAgIGlmIChtYXhTdGFydFBUUyA+PSBzdGFydFRpbWUgJiYgbWluRW5kUFRTIDw9IGVuZFRpbWUpIHtcbiAgICAgICAgLy8gRnJhZ21lbnQgaXMgZW50aXJlbHkgY29udGFpbmVkIGluIGJ1ZmZlclxuICAgICAgICAvLyBObyBuZWVkIHRvIGNoZWNrIHRoZSBvdGhlciB0aW1lUmFuZ2UgdGltZXMgc2luY2UgaXQncyBjb21wbGV0ZWx5IHBsYXlhYmxlXG4gICAgICAgIGJ1ZmZlcmVkLnRpbWUucHVzaCh7XG4gICAgICAgICAgc3RhcnRQVFM6IE1hdGgubWF4KHN0YXJ0UFRTLCB0aW1lUmFuZ2Uuc3RhcnQoaSkpLFxuICAgICAgICAgIGVuZFBUUzogTWF0aC5taW4oZW5kUFRTLCB0aW1lUmFuZ2UuZW5kKGkpKVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0UFRTIDwgZW5kVGltZSAmJiBlbmRQVFMgPiBzdGFydFRpbWUpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBNYXRoLm1heChzdGFydFBUUywgdGltZVJhbmdlLnN0YXJ0KGkpKTtcbiAgICAgICAgY29uc3QgZW5kID0gTWF0aC5taW4oZW5kUFRTLCB0aW1lUmFuZ2UuZW5kKGkpKTtcbiAgICAgICAgaWYgKGVuZCA+IHN0YXJ0KSB7XG4gICAgICAgICAgYnVmZmVyZWQucGFydGlhbCA9IHRydWU7XG4gICAgICAgICAgLy8gQ2hlY2sgZm9yIGludGVyc2VjdGlvbiB3aXRoIGJ1ZmZlclxuICAgICAgICAgIC8vIEdldCBwbGF5YWJsZSBzZWN0aW9ucyBvZiB0aGUgZnJhZ21lbnRcbiAgICAgICAgICBidWZmZXJlZC50aW1lLnB1c2goe1xuICAgICAgICAgICAgc3RhcnRQVFM6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kUFRTOiBlbmRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChlbmRQVFMgPD0gc3RhcnRUaW1lKSB7XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgdGhlIHJlc3Qgb2YgdGhlIHRpbWVSYW5nZSBhcyBpdCBpcyBpbiBvcmRlclxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlcmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHBhcnRpYWwgZnJhZ21lbnQgZm9yIGEgY2VydGFpbiB0aW1lXG4gICAqL1xuICBnZXRQYXJ0aWFsRnJhZ21lbnQodGltZSkge1xuICAgIGxldCBiZXN0RnJhZ21lbnQgPSBudWxsO1xuICAgIGxldCB0aW1lUGFkZGluZztcbiAgICBsZXQgc3RhcnRUaW1lO1xuICAgIGxldCBlbmRUaW1lO1xuICAgIGxldCBiZXN0T3ZlcmxhcCA9IDA7XG4gICAgY29uc3Qge1xuICAgICAgYnVmZmVyUGFkZGluZyxcbiAgICAgIGZyYWdtZW50c1xuICAgIH0gPSB0aGlzO1xuICAgIE9iamVjdC5rZXlzKGZyYWdtZW50cykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgY29uc3QgZnJhZ21lbnRFbnRpdHkgPSBmcmFnbWVudHNba2V5XTtcbiAgICAgIGlmICghZnJhZ21lbnRFbnRpdHkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGlzUGFydGlhbChmcmFnbWVudEVudGl0eSkpIHtcbiAgICAgICAgc3RhcnRUaW1lID0gZnJhZ21lbnRFbnRpdHkuYm9keS5zdGFydCAtIGJ1ZmZlclBhZGRpbmc7XG4gICAgICAgIGVuZFRpbWUgPSBmcmFnbWVudEVudGl0eS5ib2R5LmVuZCArIGJ1ZmZlclBhZGRpbmc7XG4gICAgICAgIGlmICh0aW1lID49IHN0YXJ0VGltZSAmJiB0aW1lIDw9IGVuZFRpbWUpIHtcbiAgICAgICAgICAvLyBVc2UgdGhlIGZyYWdtZW50IHRoYXQgaGFzIHRoZSBtb3N0IHBhZGRpbmcgZnJvbSBzdGFydCBhbmQgZW5kIHRpbWVcbiAgICAgICAgICB0aW1lUGFkZGluZyA9IE1hdGgubWluKHRpbWUgLSBzdGFydFRpbWUsIGVuZFRpbWUgLSB0aW1lKTtcbiAgICAgICAgICBpZiAoYmVzdE92ZXJsYXAgPD0gdGltZVBhZGRpbmcpIHtcbiAgICAgICAgICAgIGJlc3RGcmFnbWVudCA9IGZyYWdtZW50RW50aXR5LmJvZHk7XG4gICAgICAgICAgICBiZXN0T3ZlcmxhcCA9IHRpbWVQYWRkaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBiZXN0RnJhZ21lbnQ7XG4gIH1cbiAgaXNFbmRMaXN0QXBwZW5kZWQodHlwZSkge1xuICAgIGNvbnN0IGxhc3RGcmFnbWVudEVudGl0eSA9IHRoaXMuZW5kTGlzdEZyYWdtZW50c1t0eXBlXTtcbiAgICByZXR1cm4gbGFzdEZyYWdtZW50RW50aXR5ICE9PSB1bmRlZmluZWQgJiYgKGxhc3RGcmFnbWVudEVudGl0eS5idWZmZXJlZCB8fCBpc1BhcnRpYWwobGFzdEZyYWdtZW50RW50aXR5KSk7XG4gIH1cbiAgZ2V0U3RhdGUoZnJhZ21lbnQpIHtcbiAgICBjb25zdCBmcmFnS2V5ID0gZ2V0RnJhZ21lbnRLZXkoZnJhZ21lbnQpO1xuICAgIGNvbnN0IGZyYWdtZW50RW50aXR5ID0gdGhpcy5mcmFnbWVudHNbZnJhZ0tleV07XG4gICAgaWYgKGZyYWdtZW50RW50aXR5KSB7XG4gICAgICBpZiAoIWZyYWdtZW50RW50aXR5LmJ1ZmZlcmVkKSB7XG4gICAgICAgIHJldHVybiBGcmFnbWVudFN0YXRlLkFQUEVORElORztcbiAgICAgIH0gZWxzZSBpZiAoaXNQYXJ0aWFsKGZyYWdtZW50RW50aXR5KSkge1xuICAgICAgICByZXR1cm4gRnJhZ21lbnRTdGF0ZS5QQVJUSUFMO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIEZyYWdtZW50U3RhdGUuT0s7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBGcmFnbWVudFN0YXRlLk5PVF9MT0FERUQ7XG4gIH1cbiAgaXNUaW1lQnVmZmVyZWQoc3RhcnRQVFMsIGVuZFBUUywgdGltZVJhbmdlKSB7XG4gICAgbGV0IHN0YXJ0VGltZTtcbiAgICBsZXQgZW5kVGltZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRpbWVSYW5nZS5sZW5ndGg7IGkrKykge1xuICAgICAgc3RhcnRUaW1lID0gdGltZVJhbmdlLnN0YXJ0KGkpIC0gdGhpcy5idWZmZXJQYWRkaW5nO1xuICAgICAgZW5kVGltZSA9IHRpbWVSYW5nZS5lbmQoaSkgKyB0aGlzLmJ1ZmZlclBhZGRpbmc7XG4gICAgICBpZiAoc3RhcnRQVFMgPj0gc3RhcnRUaW1lICYmIGVuZFBUUyA8PSBlbmRUaW1lKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGVuZFBUUyA8PSBzdGFydFRpbWUpIHtcbiAgICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayB0aGUgcmVzdCBvZiB0aGUgdGltZVJhbmdlIGFzIGl0IGlzIGluIG9yZGVyXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIG9uRnJhZ0xvYWRlZChldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGZyYWcsXG4gICAgICBwYXJ0XG4gICAgfSA9IGRhdGE7XG4gICAgLy8gZG9uJ3QgdHJhY2sgaW5pdHNlZ21lbnQgKGZvciB3aGljaCBzbiBpcyBub3QgYSBudW1iZXIpXG4gICAgLy8gZG9uJ3QgdHJhY2sgZnJhZ3MgdXNlZCBmb3IgYml0cmF0ZVRlc3QsIHRoZXkncmUgaXJyZWxldmFudC5cbiAgICBpZiAoZnJhZy5zbiA9PT0gJ2luaXRTZWdtZW50JyB8fCBmcmFnLmJpdHJhdGVUZXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRnJhZ21lbnQgZW50aXR5IGBsb2FkZWRgIEZyYWdMb2FkZWREYXRhIGlzIG51bGwgd2hlbiBsb2FkaW5nIHBhcnRzXG4gICAgY29uc3QgbG9hZGVkID0gcGFydCA/IG51bGwgOiBkYXRhO1xuICAgIGNvbnN0IGZyYWdLZXkgPSBnZXRGcmFnbWVudEtleShmcmFnKTtcbiAgICB0aGlzLmZyYWdtZW50c1tmcmFnS2V5XSA9IHtcbiAgICAgIGJvZHk6IGZyYWcsXG4gICAgICBhcHBlbmRlZFBUUzogbnVsbCxcbiAgICAgIGxvYWRlZCxcbiAgICAgIGJ1ZmZlcmVkOiBmYWxzZSxcbiAgICAgIHJhbmdlOiBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgfTtcbiAgfVxuICBvbkJ1ZmZlckFwcGVuZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZyxcbiAgICAgIHBhcnQsXG4gICAgICB0aW1lUmFuZ2VzXG4gICAgfSA9IGRhdGE7XG4gICAgaWYgKGZyYWcuc24gPT09ICdpbml0U2VnbWVudCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcGxheWxpc3RUeXBlID0gZnJhZy50eXBlO1xuICAgIGlmIChwYXJ0KSB7XG4gICAgICBsZXQgYWN0aXZlUGFydHMgPSB0aGlzLmFjdGl2ZVBhcnRMaXN0c1twbGF5bGlzdFR5cGVdO1xuICAgICAgaWYgKCFhY3RpdmVQYXJ0cykge1xuICAgICAgICB0aGlzLmFjdGl2ZVBhcnRMaXN0c1twbGF5bGlzdFR5cGVdID0gYWN0aXZlUGFydHMgPSBbXTtcbiAgICAgIH1cbiAgICAgIGFjdGl2ZVBhcnRzLnB1c2gocGFydCk7XG4gICAgfVxuICAgIC8vIFN0b3JlIHRoZSBsYXRlc3QgdGltZVJhbmdlcyBsb2FkZWQgaW4gdGhlIGJ1ZmZlclxuICAgIHRoaXMudGltZVJhbmdlcyA9IHRpbWVSYW5nZXM7XG4gICAgT2JqZWN0LmtleXModGltZVJhbmdlcykuZm9yRWFjaChlbGVtZW50YXJ5U3RyZWFtID0+IHtcbiAgICAgIGNvbnN0IHRpbWVSYW5nZSA9IHRpbWVSYW5nZXNbZWxlbWVudGFyeVN0cmVhbV07XG4gICAgICB0aGlzLmRldGVjdEV2aWN0ZWRGcmFnbWVudHMoZWxlbWVudGFyeVN0cmVhbSwgdGltZVJhbmdlLCBwbGF5bGlzdFR5cGUsIHBhcnQpO1xuICAgIH0pO1xuICB9XG4gIG9uRnJhZ0J1ZmZlcmVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5kZXRlY3RQYXJ0aWFsRnJhZ21lbnRzKGRhdGEpO1xuICB9XG4gIGhhc0ZyYWdtZW50KGZyYWdtZW50KSB7XG4gICAgY29uc3QgZnJhZ0tleSA9IGdldEZyYWdtZW50S2V5KGZyYWdtZW50KTtcbiAgICByZXR1cm4gISF0aGlzLmZyYWdtZW50c1tmcmFnS2V5XTtcbiAgfVxuICBoYXNQYXJ0cyh0eXBlKSB7XG4gICAgdmFyIF90aGlzJGFjdGl2ZVBhcnRMaXN0cztcbiAgICByZXR1cm4gISEoKF90aGlzJGFjdGl2ZVBhcnRMaXN0cyA9IHRoaXMuYWN0aXZlUGFydExpc3RzW3R5cGVdKSAhPSBudWxsICYmIF90aGlzJGFjdGl2ZVBhcnRMaXN0cy5sZW5ndGgpO1xuICB9XG4gIHJlbW92ZUZyYWdtZW50c0luUmFuZ2Uoc3RhcnQsIGVuZCwgcGxheWxpc3RUeXBlLCB3aXRoR2FwT25seSwgdW5idWZmZXJlZE9ubHkpIHtcbiAgICBpZiAod2l0aEdhcE9ubHkgJiYgIXRoaXMuaGFzR2Fwcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBPYmplY3Qua2V5cyh0aGlzLmZyYWdtZW50cykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgY29uc3QgZnJhZ21lbnRFbnRpdHkgPSB0aGlzLmZyYWdtZW50c1trZXldO1xuICAgICAgaWYgKCFmcmFnbWVudEVudGl0eSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBmcmFnID0gZnJhZ21lbnRFbnRpdHkuYm9keTtcbiAgICAgIGlmIChmcmFnLnR5cGUgIT09IHBsYXlsaXN0VHlwZSB8fCB3aXRoR2FwT25seSAmJiAhZnJhZy5nYXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGZyYWcuc3RhcnQgPCBlbmQgJiYgZnJhZy5lbmQgPiBzdGFydCAmJiAoZnJhZ21lbnRFbnRpdHkuYnVmZmVyZWQgfHwgdW5idWZmZXJlZE9ubHkpKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmVtb3ZlRnJhZ21lbnQoZnJhZ21lbnQpIHtcbiAgICBjb25zdCBmcmFnS2V5ID0gZ2V0RnJhZ21lbnRLZXkoZnJhZ21lbnQpO1xuICAgIGZyYWdtZW50LnN0YXRzLmxvYWRlZCA9IDA7XG4gICAgZnJhZ21lbnQuY2xlYXJFbGVtZW50YXJ5U3RyZWFtSW5mbygpO1xuICAgIGNvbnN0IGFjdGl2ZVBhcnRzID0gdGhpcy5hY3RpdmVQYXJ0TGlzdHNbZnJhZ21lbnQudHlwZV07XG4gICAgaWYgKGFjdGl2ZVBhcnRzKSB7XG4gICAgICBjb25zdCBzblRvUmVtb3ZlID0gZnJhZ21lbnQuc247XG4gICAgICB0aGlzLmFjdGl2ZVBhcnRMaXN0c1tmcmFnbWVudC50eXBlXSA9IGFjdGl2ZVBhcnRzLmZpbHRlcihwYXJ0ID0+IHBhcnQuZnJhZ21lbnQuc24gIT09IHNuVG9SZW1vdmUpO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy5mcmFnbWVudHNbZnJhZ0tleV07XG4gICAgaWYgKGZyYWdtZW50LmVuZExpc3QpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmVuZExpc3RGcmFnbWVudHNbZnJhZ21lbnQudHlwZV07XG4gICAgfVxuICB9XG4gIHJlbW92ZUFsbEZyYWdtZW50cygpIHtcbiAgICB0aGlzLmZyYWdtZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5lbmRMaXN0RnJhZ21lbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmFjdGl2ZVBhcnRMaXN0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5oYXNHYXBzID0gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzUGFydGlhbChmcmFnbWVudEVudGl0eSkge1xuICB2YXIgX2ZyYWdtZW50RW50aXR5JHJhbmdlLCBfZnJhZ21lbnRFbnRpdHkkcmFuZ2UyLCBfZnJhZ21lbnRFbnRpdHkkcmFuZ2UzO1xuICByZXR1cm4gZnJhZ21lbnRFbnRpdHkuYnVmZmVyZWQgJiYgKGZyYWdtZW50RW50aXR5LmJvZHkuZ2FwIHx8ICgoX2ZyYWdtZW50RW50aXR5JHJhbmdlID0gZnJhZ21lbnRFbnRpdHkucmFuZ2UudmlkZW8pID09IG51bGwgPyB2b2lkIDAgOiBfZnJhZ21lbnRFbnRpdHkkcmFuZ2UucGFydGlhbCkgfHwgKChfZnJhZ21lbnRFbnRpdHkkcmFuZ2UyID0gZnJhZ21lbnRFbnRpdHkucmFuZ2UuYXVkaW8pID09IG51bGwgPyB2b2lkIDAgOiBfZnJhZ21lbnRFbnRpdHkkcmFuZ2UyLnBhcnRpYWwpIHx8ICgoX2ZyYWdtZW50RW50aXR5JHJhbmdlMyA9IGZyYWdtZW50RW50aXR5LnJhbmdlLmF1ZGlvdmlkZW8pID09IG51bGwgPyB2b2lkIDAgOiBfZnJhZ21lbnRFbnRpdHkkcmFuZ2UzLnBhcnRpYWwpKTtcbn1cbmZ1bmN0aW9uIGdldEZyYWdtZW50S2V5KGZyYWdtZW50KSB7XG4gIHJldHVybiBgJHtmcmFnbWVudC50eXBlfV8ke2ZyYWdtZW50LmxldmVsfV8ke2ZyYWdtZW50LnNufWA7XG59XG5cbi8qKlxuICogUHJvdmlkZXMgbWV0aG9kcyBkZWFsaW5nIHdpdGggYnVmZmVyIGxlbmd0aCByZXRyaWV2YWwgZm9yIGV4YW1wbGUuXG4gKlxuICogSW4gZ2VuZXJhbCwgYSBoZWxwZXIgYXJvdW5kIEhUTUw1IE1lZGlhRWxlbWVudCBUaW1lUmFuZ2VzIGdhdGhlcmVkIGZyb20gYGJ1ZmZlcmVkYCBwcm9wZXJ0eS5cbiAqXG4gKiBBbHNvIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxNZWRpYUVsZW1lbnQvYnVmZmVyZWRcbiAqL1xuXG5jb25zdCBub29wQnVmZmVyZWQgPSB7XG4gIGxlbmd0aDogMCxcbiAgc3RhcnQ6ICgpID0+IDAsXG4gIGVuZDogKCkgPT4gMFxufTtcbmNsYXNzIEJ1ZmZlckhlbHBlciB7XG4gIC8qKlxuICAgKiBSZXR1cm4gdHJ1ZSBpZiBgbWVkaWFgJ3MgYnVmZmVyZWQgaW5jbHVkZSBgcG9zaXRpb25gXG4gICAqL1xuICBzdGF0aWMgaXNCdWZmZXJlZChtZWRpYSwgcG9zaXRpb24pIHtcbiAgICB0cnkge1xuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlcmVkID0gQnVmZmVySGVscGVyLmdldEJ1ZmZlcmVkKG1lZGlhKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChwb3NpdGlvbiA+PSBidWZmZXJlZC5zdGFydChpKSAmJiBwb3NpdGlvbiA8PSBidWZmZXJlZC5lbmQoaSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyB0aGlzIGlzIHRvIGNhdGNoXG4gICAgICAvLyBJbnZhbGlkU3RhdGVFcnJvcjogRmFpbGVkIHRvIHJlYWQgdGhlICdidWZmZXJlZCcgcHJvcGVydHkgZnJvbSAnU291cmNlQnVmZmVyJzpcbiAgICAgIC8vIFRoaXMgU291cmNlQnVmZmVyIGhhcyBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgcGFyZW50IG1lZGlhIHNvdXJjZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhdGljIGJ1ZmZlckluZm8obWVkaWEsIHBvcywgbWF4SG9sZUR1cmF0aW9uKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICBjb25zdCB2YnVmZmVyZWQgPSBCdWZmZXJIZWxwZXIuZ2V0QnVmZmVyZWQobWVkaWEpO1xuICAgICAgICBjb25zdCBidWZmZXJlZCA9IFtdO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHZidWZmZXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGJ1ZmZlcmVkLnB1c2goe1xuICAgICAgICAgICAgc3RhcnQ6IHZidWZmZXJlZC5zdGFydChpKSxcbiAgICAgICAgICAgIGVuZDogdmJ1ZmZlcmVkLmVuZChpKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlcmVkSW5mbyhidWZmZXJlZCwgcG9zLCBtYXhIb2xlRHVyYXRpb24pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyB0aGlzIGlzIHRvIGNhdGNoXG4gICAgICAvLyBJbnZhbGlkU3RhdGVFcnJvcjogRmFpbGVkIHRvIHJlYWQgdGhlICdidWZmZXJlZCcgcHJvcGVydHkgZnJvbSAnU291cmNlQnVmZmVyJzpcbiAgICAgIC8vIFRoaXMgU291cmNlQnVmZmVyIGhhcyBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgcGFyZW50IG1lZGlhIHNvdXJjZVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbGVuOiAwLFxuICAgICAgc3RhcnQ6IHBvcyxcbiAgICAgIGVuZDogcG9zLFxuICAgICAgbmV4dFN0YXJ0OiB1bmRlZmluZWRcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBidWZmZXJlZEluZm8oYnVmZmVyZWQsIHBvcywgbWF4SG9sZUR1cmF0aW9uKSB7XG4gICAgcG9zID0gTWF0aC5tYXgoMCwgcG9zKTtcbiAgICAvLyBzb3J0IG9uIGJ1ZmZlci5zdGFydC9zbWFsbGVyIGVuZCAoSUUgZG9lcyBub3QgYWx3YXlzIHJldHVybiBzb3J0ZWQgYnVmZmVyZWQgcmFuZ2UpXG4gICAgYnVmZmVyZWQuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgY29uc3QgZGlmZiA9IGEuc3RhcnQgLSBiLnN0YXJ0O1xuICAgICAgaWYgKGRpZmYpIHtcbiAgICAgICAgcmV0dXJuIGRpZmY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYi5lbmQgLSBhLmVuZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgYnVmZmVyZWQyID0gW107XG4gICAgaWYgKG1heEhvbGVEdXJhdGlvbikge1xuICAgICAgLy8gdGhlcmUgbWlnaHQgYmUgc29tZSBzbWFsbCBob2xlcyBiZXR3ZWVuIGJ1ZmZlciB0aW1lIHJhbmdlXG4gICAgICAvLyBjb25zaWRlciB0aGF0IGhvbGVzIHNtYWxsZXIgdGhhbiBtYXhIb2xlRHVyYXRpb24gYXJlIGlycmVsZXZhbnQgYW5kIGJ1aWxkIGFub3RoZXJcbiAgICAgIC8vIGJ1ZmZlciB0aW1lIHJhbmdlIHJlcHJlc2VudGF0aW9ucyB0aGF0IGRpc2NhcmRzIHRob3NlIGhvbGVzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGJ1ZjJsZW4gPSBidWZmZXJlZDIubGVuZ3RoO1xuICAgICAgICBpZiAoYnVmMmxlbikge1xuICAgICAgICAgIGNvbnN0IGJ1ZjJlbmQgPSBidWZmZXJlZDJbYnVmMmxlbiAtIDFdLmVuZDtcbiAgICAgICAgICAvLyBpZiBzbWFsbCBob2xlICh2YWx1ZSBiZXR3ZWVuIDAgb3IgbWF4SG9sZUR1cmF0aW9uICkgb3Igb3ZlcmxhcHBpbmcgKG5lZ2F0aXZlKVxuICAgICAgICAgIGlmIChidWZmZXJlZFtpXS5zdGFydCAtIGJ1ZjJlbmQgPCBtYXhIb2xlRHVyYXRpb24pIHtcbiAgICAgICAgICAgIC8vIG1lcmdlIG92ZXJsYXBwaW5nIHRpbWUgcmFuZ2VzXG4gICAgICAgICAgICAvLyB1cGRhdGUgbGFzdFJhbmdlLmVuZCBvbmx5IGlmIHNtYWxsZXIgdGhhbiBpdGVtLmVuZFxuICAgICAgICAgICAgLy8gZS5nLiAgWyAxLCAxNV0gd2l0aCAgWyAyLDhdID0+IFsgMSwxNV0gKG5vIG5lZWQgdG8gbW9kaWZ5IGxhc3RSYW5nZS5lbmQpXG4gICAgICAgICAgICAvLyB3aGVyZWFzIFsgMSwgOF0gd2l0aCAgWyAyLDE1XSA9PiBbIDEsMTVdICggbGFzdFJhbmdlIHNob3VsZCBzd2l0Y2ggZnJvbSBbMSw4XSB0byBbMSwxNV0pXG4gICAgICAgICAgICBpZiAoYnVmZmVyZWRbaV0uZW5kID4gYnVmMmVuZCkge1xuICAgICAgICAgICAgICBidWZmZXJlZDJbYnVmMmxlbiAtIDFdLmVuZCA9IGJ1ZmZlcmVkW2ldLmVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gYmlnIGhvbGVcbiAgICAgICAgICAgIGJ1ZmZlcmVkMi5wdXNoKGJ1ZmZlcmVkW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZmlyc3QgdmFsdWVcbiAgICAgICAgICBidWZmZXJlZDIucHVzaChidWZmZXJlZFtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYnVmZmVyZWQyID0gYnVmZmVyZWQ7XG4gICAgfVxuICAgIGxldCBidWZmZXJMZW4gPSAwO1xuXG4gICAgLy8gYnVmZmVyU3RhcnROZXh0IGNhbiBwb3NzaWJseSBiZSB1bmRlZmluZWQgYmFzZWQgb24gdGhlIGNvbmRpdGlvbmFsIGxvZ2ljIGJlbG93XG4gICAgbGV0IGJ1ZmZlclN0YXJ0TmV4dDtcblxuICAgIC8vIGJ1ZmZlclN0YXJ0IGFuZCBidWZmZXJFbmQgYXJlIGJ1ZmZlciBib3VuZGFyaWVzIGFyb3VuZCBjdXJyZW50IHZpZGVvIHBvc2l0aW9uXG4gICAgbGV0IGJ1ZmZlclN0YXJ0ID0gcG9zO1xuICAgIGxldCBidWZmZXJFbmQgPSBwb3M7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXJlZDIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gYnVmZmVyZWQyW2ldLnN0YXJ0O1xuICAgICAgY29uc3QgZW5kID0gYnVmZmVyZWQyW2ldLmVuZDtcbiAgICAgIC8vIGxvZ2dlci5sb2coJ2J1ZiBzdGFydC9lbmQ6JyArIGJ1ZmZlcmVkLnN0YXJ0KGkpICsgJy8nICsgYnVmZmVyZWQuZW5kKGkpKTtcbiAgICAgIGlmIChwb3MgKyBtYXhIb2xlRHVyYXRpb24gPj0gc3RhcnQgJiYgcG9zIDwgZW5kKSB7XG4gICAgICAgIC8vIHBsYXkgcG9zaXRpb24gaXMgaW5zaWRlIHRoaXMgYnVmZmVyIFRpbWVSYW5nZSwgcmV0cmlldmUgZW5kIG9mIGJ1ZmZlciBwb3NpdGlvbiBhbmQgYnVmZmVyIGxlbmd0aFxuICAgICAgICBidWZmZXJTdGFydCA9IHN0YXJ0O1xuICAgICAgICBidWZmZXJFbmQgPSBlbmQ7XG4gICAgICAgIGJ1ZmZlckxlbiA9IGJ1ZmZlckVuZCAtIHBvcztcbiAgICAgIH0gZWxzZSBpZiAocG9zICsgbWF4SG9sZUR1cmF0aW9uIDwgc3RhcnQpIHtcbiAgICAgICAgYnVmZmVyU3RhcnROZXh0ID0gc3RhcnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbGVuOiBidWZmZXJMZW4sXG4gICAgICBzdGFydDogYnVmZmVyU3RhcnQgfHwgMCxcbiAgICAgIGVuZDogYnVmZmVyRW5kIHx8IDAsXG4gICAgICBuZXh0U3RhcnQ6IGJ1ZmZlclN0YXJ0TmV4dFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogU2FmZSBtZXRob2QgdG8gZ2V0IGJ1ZmZlcmVkIHByb3BlcnR5LlxuICAgKiBTb3VyY2VCdWZmZXIuYnVmZmVyZWQgbWF5IHRocm93IGlmIFNvdXJjZUJ1ZmZlciBpcyByZW1vdmVkIGZyb20gaXQncyBNZWRpYVNvdXJjZVxuICAgKi9cbiAgc3RhdGljIGdldEJ1ZmZlcmVkKG1lZGlhKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBtZWRpYS5idWZmZXJlZDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2dnZXIubG9nKCdmYWlsZWQgdG8gZ2V0IG1lZGlhLmJ1ZmZlcmVkJywgZSk7XG4gICAgICByZXR1cm4gbm9vcEJ1ZmZlcmVkO1xuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBDaHVua01ldGFkYXRhIHtcbiAgY29uc3RydWN0b3IobGV2ZWwsIHNuLCBpZCwgc2l6ZSA9IDAsIHBhcnQgPSAtMSwgcGFydGlhbCA9IGZhbHNlKSB7XG4gICAgdGhpcy5sZXZlbCA9IHZvaWQgMDtcbiAgICB0aGlzLnNuID0gdm9pZCAwO1xuICAgIHRoaXMucGFydCA9IHZvaWQgMDtcbiAgICB0aGlzLmlkID0gdm9pZCAwO1xuICAgIHRoaXMuc2l6ZSA9IHZvaWQgMDtcbiAgICB0aGlzLnBhcnRpYWwgPSB2b2lkIDA7XG4gICAgdGhpcy50cmFuc211eGluZyA9IGdldE5ld1BlcmZvcm1hbmNlVGltaW5nKCk7XG4gICAgdGhpcy5idWZmZXJpbmcgPSB7XG4gICAgICBhdWRpbzogZ2V0TmV3UGVyZm9ybWFuY2VUaW1pbmcoKSxcbiAgICAgIHZpZGVvOiBnZXROZXdQZXJmb3JtYW5jZVRpbWluZygpLFxuICAgICAgYXVkaW92aWRlbzogZ2V0TmV3UGVyZm9ybWFuY2VUaW1pbmcoKVxuICAgIH07XG4gICAgdGhpcy5sZXZlbCA9IGxldmVsO1xuICAgIHRoaXMuc24gPSBzbjtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICB0aGlzLnBhcnQgPSBwYXJ0O1xuICAgIHRoaXMucGFydGlhbCA9IHBhcnRpYWw7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldE5ld1BlcmZvcm1hbmNlVGltaW5nKCkge1xuICByZXR1cm4ge1xuICAgIHN0YXJ0OiAwLFxuICAgIGV4ZWN1dGVTdGFydDogMCxcbiAgICBleGVjdXRlRW5kOiAwLFxuICAgIGVuZDogMFxuICB9O1xufVxuXG5mdW5jdGlvbiBmaW5kRmlyc3RGcmFnV2l0aENDKGZyYWdtZW50cywgY2MpIHtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGZyYWdtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBfZnJhZ21lbnRzJGk7XG4gICAgaWYgKCgoX2ZyYWdtZW50cyRpID0gZnJhZ21lbnRzW2ldKSA9PSBudWxsID8gdm9pZCAwIDogX2ZyYWdtZW50cyRpLmNjKSA9PT0gY2MpIHtcbiAgICAgIHJldHVybiBmcmFnbWVudHNbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gc2hvdWxkQWxpZ25PbkRpc2NvbnRpbnVpdGllcyhsYXN0RnJhZywgc3dpdGNoRGV0YWlscywgZGV0YWlscykge1xuICBpZiAoc3dpdGNoRGV0YWlscykge1xuICAgIGlmIChkZXRhaWxzLmVuZENDID4gZGV0YWlscy5zdGFydENDIHx8IGxhc3RGcmFnICYmIGxhc3RGcmFnLmNjIDwgZGV0YWlscy5zdGFydENDKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBGaW5kIHRoZSBmaXJzdCBmcmFnIGluIHRoZSBwcmV2aW91cyBsZXZlbCB3aGljaCBtYXRjaGVzIHRoZSBDQyBvZiB0aGUgZmlyc3QgZnJhZyBvZiB0aGUgbmV3IGxldmVsXG5mdW5jdGlvbiBmaW5kRGlzY29udGludW91c1JlZmVyZW5jZUZyYWcocHJldkRldGFpbHMsIGN1ckRldGFpbHMpIHtcbiAgY29uc3QgcHJldkZyYWdzID0gcHJldkRldGFpbHMuZnJhZ21lbnRzO1xuICBjb25zdCBjdXJGcmFncyA9IGN1ckRldGFpbHMuZnJhZ21lbnRzO1xuICBpZiAoIWN1ckZyYWdzLmxlbmd0aCB8fCAhcHJldkZyYWdzLmxlbmd0aCkge1xuICAgIGxvZ2dlci5sb2coJ05vIGZyYWdtZW50cyB0byBhbGlnbicpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBwcmV2U3RhcnRGcmFnID0gZmluZEZpcnN0RnJhZ1dpdGhDQyhwcmV2RnJhZ3MsIGN1ckZyYWdzWzBdLmNjKTtcbiAgaWYgKCFwcmV2U3RhcnRGcmFnIHx8IHByZXZTdGFydEZyYWcgJiYgIXByZXZTdGFydEZyYWcuc3RhcnRQVFMpIHtcbiAgICBsb2dnZXIubG9nKCdObyBmcmFnIGluIHByZXZpb3VzIGxldmVsIHRvIGFsaWduIG9uJyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJldHVybiBwcmV2U3RhcnRGcmFnO1xufVxuZnVuY3Rpb24gYWRqdXN0RnJhZ21lbnRTdGFydChmcmFnLCBzbGlkaW5nKSB7XG4gIGlmIChmcmFnKSB7XG4gICAgY29uc3Qgc3RhcnQgPSBmcmFnLnN0YXJ0ICsgc2xpZGluZztcbiAgICBmcmFnLnN0YXJ0ID0gZnJhZy5zdGFydFBUUyA9IHN0YXJ0O1xuICAgIGZyYWcuZW5kUFRTID0gc3RhcnQgKyBmcmFnLmR1cmF0aW9uO1xuICB9XG59XG5mdW5jdGlvbiBhZGp1c3RTbGlkaW5nU3RhcnQoc2xpZGluZywgZGV0YWlscykge1xuICAvLyBVcGRhdGUgc2VnbWVudHNcbiAgY29uc3QgZnJhZ21lbnRzID0gZGV0YWlscy5mcmFnbWVudHM7XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBmcmFnbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBhZGp1c3RGcmFnbWVudFN0YXJ0KGZyYWdtZW50c1tpXSwgc2xpZGluZyk7XG4gIH1cbiAgLy8gVXBkYXRlIExMLUhMUyBwYXJ0cyBhdCB0aGUgZW5kIG9mIHRoZSBwbGF5bGlzdFxuICBpZiAoZGV0YWlscy5mcmFnbWVudEhpbnQpIHtcbiAgICBhZGp1c3RGcmFnbWVudFN0YXJ0KGRldGFpbHMuZnJhZ21lbnRIaW50LCBzbGlkaW5nKTtcbiAgfVxuICBkZXRhaWxzLmFsaWduZWRTbGlkaW5nID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBVc2luZyB0aGUgcGFyYW1ldGVycyBvZiB0aGUgbGFzdCBsZXZlbCwgdGhpcyBmdW5jdGlvbiBjb21wdXRlcyBQVFMnIG9mIHRoZSBuZXcgZnJhZ21lbnRzIHNvIHRoYXQgdGhleSBmb3JtIGFcbiAqIGNvbnRpZ3VvdXMgc3RyZWFtIHdpdGggdGhlIGxhc3QgZnJhZ21lbnRzLlxuICogVGhlIFBUUyBvZiBhIGZyYWdtZW50IGxldHMgSGxzLmpzIGtub3cgd2hlcmUgaXQgZml0cyBpbnRvIGEgc3RyZWFtIC0gYnkga25vd2luZyBldmVyeSBQVFMsIHdlIGtub3cgd2hpY2ggZnJhZ21lbnQgdG9cbiAqIGRvd25sb2FkIGF0IGFueSBnaXZlbiB0aW1lLiBQVFMgaXMgbm9ybWFsbHkgY29tcHV0ZWQgd2hlbiB0aGUgZnJhZ21lbnQgaXMgZGVtdXhlZCwgc28gdGFraW5nIHRoaXMgc3RlcCBzYXZlcyB1cyB0aW1lXG4gKiBhbmQgYW4gZXh0cmEgZG93bmxvYWQuXG4gKiBAcGFyYW0gbGFzdEZyYWdcbiAqIEBwYXJhbSBsYXN0TGV2ZWxcbiAqIEBwYXJhbSBkZXRhaWxzXG4gKi9cbmZ1bmN0aW9uIGFsaWduU3RyZWFtKGxhc3RGcmFnLCBzd2l0Y2hEZXRhaWxzLCBkZXRhaWxzKSB7XG4gIGlmICghc3dpdGNoRGV0YWlscykge1xuICAgIHJldHVybjtcbiAgfVxuICBhbGlnbkRpc2NvbnRpbnVpdGllcyhsYXN0RnJhZywgZGV0YWlscywgc3dpdGNoRGV0YWlscyk7XG4gIGlmICghZGV0YWlscy5hbGlnbmVkU2xpZGluZyAmJiBzd2l0Y2hEZXRhaWxzKSB7XG4gICAgLy8gSWYgdGhlIFBUUyB3YXNuJ3QgZmlndXJlZCBvdXQgdmlhIGRpc2NvbnRpbnVpdHkgc2VxdWVuY2UgdGhhdCBtZWFucyB0aGVyZSB3YXMgbm8gQ0MgaW5jcmVhc2Ugd2l0aGluIHRoZSBsZXZlbC5cbiAgICAvLyBBbGlnbmluZyB2aWEgUHJvZ3JhbSBEYXRlIFRpbWUgc2hvdWxkIHRoZXJlZm9yZSBiZSByZWxpYWJsZSwgc2luY2UgUERUIHNob3VsZCBiZSB0aGUgc2FtZSB3aXRoaW4gdGhlIHNhbWVcbiAgICAvLyBkaXNjb250aW51aXR5IHNlcXVlbmNlLlxuICAgIGFsaWduTWVkaWFQbGF5bGlzdEJ5UERUKGRldGFpbHMsIHN3aXRjaERldGFpbHMpO1xuICB9XG4gIGlmICghZGV0YWlscy5hbGlnbmVkU2xpZGluZyAmJiBzd2l0Y2hEZXRhaWxzICYmICFkZXRhaWxzLnNraXBwZWRTZWdtZW50cykge1xuICAgIC8vIFRyeSB0byBhbGlnbiBvbiBzbiBzbyB0aGF0IHdlIHBpY2sgYSBiZXR0ZXIgc3RhcnQgZnJhZ21lbnQuXG4gICAgLy8gRG8gbm90IHBlcmZvcm0gdGhpcyBvbiBwbGF5bGlzdHMgd2l0aCBkZWx0YSB1cGRhdGVzIGFzIHRoaXMgaXMgb25seSB0byBhbGlnbiBsZXZlbHMgb24gc3dpdGNoXG4gICAgLy8gYW5kIGFkanVzdFNsaWRpbmcgb25seSBhZGp1c3RzIGZyYWdtZW50cyBhZnRlciBza2lwcGVkU2VnbWVudHMuXG4gICAgYWRqdXN0U2xpZGluZyhzd2l0Y2hEZXRhaWxzLCBkZXRhaWxzKTtcbiAgfVxufVxuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBQVFMgaWYgYSBuZXcgbGV2ZWwncyBmcmFnbWVudHMgdXNpbmcgdGhlIFBUUyBvZiBhIGZyYWdtZW50IGluIHRoZSBsYXN0IGxldmVsIHdoaWNoIHNoYXJlcyB0aGUgc2FtZVxuICogZGlzY29udGludWl0eSBzZXF1ZW5jZS5cbiAqIEBwYXJhbSBsYXN0RnJhZyAtIFRoZSBsYXN0IEZyYWdtZW50IHdoaWNoIHNoYXJlcyB0aGUgc2FtZSBkaXNjb250aW51aXR5IHNlcXVlbmNlXG4gKiBAcGFyYW0gbGFzdExldmVsIC0gVGhlIGRldGFpbHMgb2YgdGhlIGxhc3QgbG9hZGVkIGxldmVsXG4gKiBAcGFyYW0gZGV0YWlscyAtIFRoZSBkZXRhaWxzIG9mIHRoZSBuZXcgbGV2ZWxcbiAqL1xuZnVuY3Rpb24gYWxpZ25EaXNjb250aW51aXRpZXMobGFzdEZyYWcsIGRldGFpbHMsIHN3aXRjaERldGFpbHMpIHtcbiAgaWYgKHNob3VsZEFsaWduT25EaXNjb250aW51aXRpZXMobGFzdEZyYWcsIHN3aXRjaERldGFpbHMsIGRldGFpbHMpKSB7XG4gICAgY29uc3QgcmVmZXJlbmNlRnJhZyA9IGZpbmREaXNjb250aW51b3VzUmVmZXJlbmNlRnJhZyhzd2l0Y2hEZXRhaWxzLCBkZXRhaWxzKTtcbiAgICBpZiAocmVmZXJlbmNlRnJhZyAmJiBpc0Zpbml0ZU51bWJlcihyZWZlcmVuY2VGcmFnLnN0YXJ0KSkge1xuICAgICAgbG9nZ2VyLmxvZyhgQWRqdXN0aW5nIFBUUyB1c2luZyBsYXN0IGxldmVsIGR1ZSB0byBDQyBpbmNyZWFzZSB3aXRoaW4gY3VycmVudCBsZXZlbCAke2RldGFpbHMudXJsfWApO1xuICAgICAgYWRqdXN0U2xpZGluZ1N0YXJ0KHJlZmVyZW5jZUZyYWcuc3RhcnQsIGRldGFpbHMpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEVuc3VyZXMgYXBwcm9wcmlhdGUgdGltZS1hbGlnbm1lbnQgYmV0d2VlbiByZW5kaXRpb25zIGJhc2VkIG9uIFBEVC5cbiAqIFRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGUgdGltZWxpbmVzIHJlcHJlc2VudGVkIGluIGByZWZEZXRhaWxzYCBhcmUgYWNjdXJhdGUsIGluY2x1ZGluZyB0aGUgUERUc1xuICogZm9yIHRoZSBsYXN0IGRpc2NvbnRpbnVpdHkgc2VxdWVuY2UgbnVtYmVyIHNoYXJlZCBieSBib3RoIHBsYXlsaXN0cyB3aGVuIHByZXNlbnQsXG4gKiBhbmQgdXNlcyB0aGUgXCJ3YWxsY2xvY2tcIi9QRFQgdGltZWxpbmUgYXMgYSBjcm9zcy1yZWZlcmVuY2UgdG8gYGRldGFpbHNgLCBhZGp1c3RpbmcgdGhlIHByZXNlbnRhdGlvblxuICogdGltZXMvdGltZWxpbmVzIG9mIGBkZXRhaWxzYCBhY2NvcmRpbmdseS5cbiAqIEdpdmVuIHRoZSBhc3luY2hyb25vdXMgbmF0dXJlIG9mIGZldGNoZXMgYW5kIGluaXRpYWwgbG9hZHMgb2YgbGl2ZSBgbWFpbmAgYW5kIGF1ZGlvL3N1YnRpdGxlIHRyYWNrcyxcbiAqIHRoZSBwcmltYXJ5IHB1cnBvc2Ugb2YgdGhpcyBmdW5jdGlvbiBpcyB0byBlbnN1cmUgdGhlIFwibG9jYWwgdGltZWxpbmVzXCIgb2YgYXVkaW8vc3VidGl0bGUgdHJhY2tzXG4gKiBhcmUgYWxpZ25lZCB0byB0aGUgbWFpbi92aWRlbyB0aW1lbGluZSwgdXNpbmcgUERUIGFzIHRoZSBjcm9zcy1yZWZlcmVuY2UvXCJhbmNob3JcIiB0aGF0IHNob3VsZFxuICogYmUgY29uc2lzdGVudCBhY3Jvc3MgcGxheWxpc3RzLCBwZXIgdGhlIEhMUyBzcGVjLlxuICogQHBhcmFtIGRldGFpbHMgLSBUaGUgZGV0YWlscyBvZiB0aGUgcmVuZGl0aW9uIHlvdSdkIGxpa2UgdG8gdGltZS1hbGlnbiAoZS5nLiBhbiBhdWRpbyByZW5kaXRpb24pLlxuICogQHBhcmFtIHJlZkRldGFpbHMgLSBUaGUgZGV0YWlscyBvZiB0aGUgcmVmZXJlbmNlIHJlbmRpdGlvbiB3aXRoIHN0YXJ0IGFuZCBQRFQgdGltZXMgZm9yIGFsaWdubWVudC5cbiAqL1xuZnVuY3Rpb24gYWxpZ25NZWRpYVBsYXlsaXN0QnlQRFQoZGV0YWlscywgcmVmRGV0YWlscykge1xuICBpZiAoIWRldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lIHx8ICFyZWZEZXRhaWxzLmhhc1Byb2dyYW1EYXRlVGltZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBmcmFnbWVudHMgPSBkZXRhaWxzLmZyYWdtZW50cztcbiAgY29uc3QgcmVmRnJhZ21lbnRzID0gcmVmRGV0YWlscy5mcmFnbWVudHM7XG4gIGlmICghZnJhZ21lbnRzLmxlbmd0aCB8fCAhcmVmRnJhZ21lbnRzLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIENhbGN1bGF0ZSBhIGRlbHRhIHRvIGFwcGx5IHRvIGFsbCBmcmFnbWVudHMgYWNjb3JkaW5nIHRvIHRoZSBkZWx0YSBpbiBQRFQgdGltZXMgYW5kIHN0YXJ0IHRpbWVzXG4gIC8vIG9mIGEgZnJhZ21lbnQgaW4gdGhlIHJlZmVyZW5jZSBkZXRhaWxzLCBhbmQgYSBmcmFnbWVudCBpbiB0aGUgdGFyZ2V0IGRldGFpbHMgb2YgdGhlIHNhbWUgZGlzY29udGludWl0eS5cbiAgLy8gSWYgYSBmcmFnbWVudCBvZiB0aGUgc2FtZSBkaXNjb250aW51aXR5IHdhcyBub3QgZm91bmQgdXNlIHRoZSBtaWRkbGUgZnJhZ21lbnQgb2YgYm90aC5cbiAgbGV0IHJlZkZyYWc7XG4gIGxldCBmcmFnO1xuICBjb25zdCB0YXJnZXRDQyA9IE1hdGgubWluKHJlZkRldGFpbHMuZW5kQ0MsIGRldGFpbHMuZW5kQ0MpO1xuICBpZiAocmVmRGV0YWlscy5zdGFydENDIDwgdGFyZ2V0Q0MgJiYgZGV0YWlscy5zdGFydENDIDwgdGFyZ2V0Q0MpIHtcbiAgICByZWZGcmFnID0gZmluZEZpcnN0RnJhZ1dpdGhDQyhyZWZGcmFnbWVudHMsIHRhcmdldENDKTtcbiAgICBmcmFnID0gZmluZEZpcnN0RnJhZ1dpdGhDQyhmcmFnbWVudHMsIHRhcmdldENDKTtcbiAgfVxuICBpZiAoIXJlZkZyYWcgfHwgIWZyYWcpIHtcbiAgICByZWZGcmFnID0gcmVmRnJhZ21lbnRzW01hdGguZmxvb3IocmVmRnJhZ21lbnRzLmxlbmd0aCAvIDIpXTtcbiAgICBmcmFnID0gZmluZEZpcnN0RnJhZ1dpdGhDQyhmcmFnbWVudHMsIHJlZkZyYWcuY2MpIHx8IGZyYWdtZW50c1tNYXRoLmZsb29yKGZyYWdtZW50cy5sZW5ndGggLyAyKV07XG4gIH1cbiAgY29uc3QgcmVmUERUID0gcmVmRnJhZy5wcm9ncmFtRGF0ZVRpbWU7XG4gIGNvbnN0IHRhcmdldFBEVCA9IGZyYWcucHJvZ3JhbURhdGVUaW1lO1xuICBpZiAoIXJlZlBEVCB8fCAhdGFyZ2V0UERUKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGRlbHRhID0gKHRhcmdldFBEVCAtIHJlZlBEVCkgLyAxMDAwIC0gKGZyYWcuc3RhcnQgLSByZWZGcmFnLnN0YXJ0KTtcbiAgYWRqdXN0U2xpZGluZ1N0YXJ0KGRlbHRhLCBkZXRhaWxzKTtcbn1cblxuY29uc3QgTUlOX0NIVU5LX1NJWkUgPSBNYXRoLnBvdygyLCAxNyk7IC8vIDEyOGtiXG5cbmNsYXNzIEZyYWdtZW50TG9hZGVyIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy5sb2FkZXIgPSBudWxsO1xuICAgIHRoaXMucGFydExvYWRUaW1lb3V0ID0gLTE7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5sb2FkZXIpIHtcbiAgICAgIHRoaXMubG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMubG9hZGVyID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgYWJvcnQoKSB7XG4gICAgaWYgKHRoaXMubG9hZGVyKSB7XG4gICAgICAvLyBBYm9ydCB0aGUgbG9hZGVyIGZvciBjdXJyZW50IGZyYWdtZW50LiBPbmx5IG9uZSBtYXkgbG9hZCBhdCBhbnkgZ2l2ZW4gdGltZVxuICAgICAgdGhpcy5sb2FkZXIuYWJvcnQoKTtcbiAgICB9XG4gIH1cbiAgbG9hZChmcmFnLCBvblByb2dyZXNzKSB7XG4gICAgY29uc3QgdXJsID0gZnJhZy51cmw7XG4gICAgaWYgKCF1cmwpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgTG9hZEVycm9yKHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19MT0FEX0VSUk9SLFxuICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgIGZyYWcsXG4gICAgICAgIGVycm9yOiBuZXcgRXJyb3IoYEZyYWdtZW50IGRvZXMgbm90IGhhdmUgYSAke3VybCA/ICdwYXJ0IGxpc3QnIDogJ3VybCd9YCksXG4gICAgICAgIG5ldHdvcmtEZXRhaWxzOiBudWxsXG4gICAgICB9KSk7XG4gICAgfVxuICAgIHRoaXMuYWJvcnQoKTtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBjb25zdCBGcmFnbWVudElMb2FkZXIgPSBjb25maWcuZkxvYWRlcjtcbiAgICBjb25zdCBEZWZhdWx0SUxvYWRlciA9IGNvbmZpZy5sb2FkZXI7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICh0aGlzLmxvYWRlcikge1xuICAgICAgICB0aGlzLmxvYWRlci5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgICBpZiAoZnJhZy5nYXApIHtcbiAgICAgICAgaWYgKGZyYWcudGFnTGlzdC5zb21lKHRhZ3MgPT4gdGFnc1swXSA9PT0gJ0dBUCcpKSB7XG4gICAgICAgICAgcmVqZWN0KGNyZWF0ZUdhcExvYWRFcnJvcihmcmFnKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFJlc2V0IHRlbXBvcmFyeSB0cmVhdG1lbnQgYXMgR0FQIHRhZ1xuICAgICAgICAgIGZyYWcuZ2FwID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGxvYWRlciA9IHRoaXMubG9hZGVyID0gZnJhZy5sb2FkZXIgPSBGcmFnbWVudElMb2FkZXIgPyBuZXcgRnJhZ21lbnRJTG9hZGVyKGNvbmZpZykgOiBuZXcgRGVmYXVsdElMb2FkZXIoY29uZmlnKTtcbiAgICAgIGNvbnN0IGxvYWRlckNvbnRleHQgPSBjcmVhdGVMb2FkZXJDb250ZXh0KGZyYWcpO1xuICAgICAgY29uc3QgbG9hZFBvbGljeSA9IGdldExvYWRlckNvbmZpZ1dpdGhvdXRSZXRpZXMoY29uZmlnLmZyYWdMb2FkUG9saWN5LmRlZmF1bHQpO1xuICAgICAgY29uc3QgbG9hZGVyQ29uZmlnID0ge1xuICAgICAgICBsb2FkUG9saWN5LFxuICAgICAgICB0aW1lb3V0OiBsb2FkUG9saWN5Lm1heExvYWRUaW1lTXMsXG4gICAgICAgIG1heFJldHJ5OiAwLFxuICAgICAgICByZXRyeURlbGF5OiAwLFxuICAgICAgICBtYXhSZXRyeURlbGF5OiAwLFxuICAgICAgICBoaWdoV2F0ZXJNYXJrOiBmcmFnLnNuID09PSAnaW5pdFNlZ21lbnQnID8gSW5maW5pdHkgOiBNSU5fQ0hVTktfU0laRVxuICAgICAgfTtcbiAgICAgIC8vIEFzc2lnbiBmcmFnIHN0YXRzIHRvIHRoZSBsb2FkZXIncyBzdGF0cyByZWZlcmVuY2VcbiAgICAgIGZyYWcuc3RhdHMgPSBsb2FkZXIuc3RhdHM7XG4gICAgICBsb2FkZXIubG9hZChsb2FkZXJDb250ZXh0LCBsb2FkZXJDb25maWcsIHtcbiAgICAgICAgb25TdWNjZXNzOiAocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykgPT4ge1xuICAgICAgICAgIHRoaXMucmVzZXRMb2FkZXIoZnJhZywgbG9hZGVyKTtcbiAgICAgICAgICBsZXQgcGF5bG9hZCA9IHJlc3BvbnNlLmRhdGE7XG4gICAgICAgICAgaWYgKGNvbnRleHQucmVzZXRJViAmJiBmcmFnLmRlY3J5cHRkYXRhKSB7XG4gICAgICAgICAgICBmcmFnLmRlY3J5cHRkYXRhLml2ID0gbmV3IFVpbnQ4QXJyYXkocGF5bG9hZC5zbGljZSgwLCAxNikpO1xuICAgICAgICAgICAgcGF5bG9hZCA9IHBheWxvYWQuc2xpY2UoMTYpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICBwYXJ0OiBudWxsLFxuICAgICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRXJyb3I6IChyZXNwb25zZSwgY29udGV4dCwgbmV0d29ya0RldGFpbHMsIHN0YXRzKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZXNldExvYWRlcihmcmFnLCBsb2FkZXIpO1xuICAgICAgICAgIHJlamVjdChuZXcgTG9hZEVycm9yKHtcbiAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1IsXG4gICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgcmVzcG9uc2U6IF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICBkYXRhOiB1bmRlZmluZWRcbiAgICAgICAgICAgIH0sIHJlc3BvbnNlKSxcbiAgICAgICAgICAgIGVycm9yOiBuZXcgRXJyb3IoYEhUVFAgRXJyb3IgJHtyZXNwb25zZS5jb2RlfSAke3Jlc3BvbnNlLnRleHR9YCksXG4gICAgICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICAgIHN0YXRzXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9LFxuICAgICAgICBvbkFib3J0OiAoc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZXNldExvYWRlcihmcmFnLCBsb2FkZXIpO1xuICAgICAgICAgIHJlamVjdChuZXcgTG9hZEVycm9yKHtcbiAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5JTlRFUk5BTF9BQk9SVEVELFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgIGVycm9yOiBuZXcgRXJyb3IoJ0Fib3J0ZWQnKSxcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgICAgc3RhdHNcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uVGltZW91dDogKHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykgPT4ge1xuICAgICAgICAgIHRoaXMucmVzZXRMb2FkZXIoZnJhZywgbG9hZGVyKTtcbiAgICAgICAgICByZWplY3QobmV3IExvYWRFcnJvcih7XG4gICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19MT0FEX1RJTUVPVVQsXG4gICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcihgVGltZW91dCBhZnRlciAke2xvYWRlckNvbmZpZy50aW1lb3V0fW1zYCksXG4gICAgICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICAgIHN0YXRzXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9LFxuICAgICAgICBvblByb2dyZXNzOiAoc3RhdHMsIGNvbnRleHQsIGRhdGEsIG5ldHdvcmtEZXRhaWxzKSA9PiB7XG4gICAgICAgICAgaWYgKG9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIG9uUHJvZ3Jlc3Moe1xuICAgICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgICBwYXJ0OiBudWxsLFxuICAgICAgICAgICAgICBwYXlsb2FkOiBkYXRhLFxuICAgICAgICAgICAgICBuZXR3b3JrRGV0YWlsc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBsb2FkUGFydChmcmFnLCBwYXJ0LCBvblByb2dyZXNzKSB7XG4gICAgdGhpcy5hYm9ydCgpO1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIGNvbnN0IEZyYWdtZW50SUxvYWRlciA9IGNvbmZpZy5mTG9hZGVyO1xuICAgIGNvbnN0IERlZmF1bHRJTG9hZGVyID0gY29uZmlnLmxvYWRlcjtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHRoaXMubG9hZGVyKSB7XG4gICAgICAgIHRoaXMubG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICAgIGlmIChmcmFnLmdhcCB8fCBwYXJ0LmdhcCkge1xuICAgICAgICByZWplY3QoY3JlYXRlR2FwTG9hZEVycm9yKGZyYWcsIHBhcnQpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbG9hZGVyID0gdGhpcy5sb2FkZXIgPSBmcmFnLmxvYWRlciA9IEZyYWdtZW50SUxvYWRlciA/IG5ldyBGcmFnbWVudElMb2FkZXIoY29uZmlnKSA6IG5ldyBEZWZhdWx0SUxvYWRlcihjb25maWcpO1xuICAgICAgY29uc3QgbG9hZGVyQ29udGV4dCA9IGNyZWF0ZUxvYWRlckNvbnRleHQoZnJhZywgcGFydCk7XG4gICAgICAvLyBTaG91bGQgd2UgZGVmaW5lIGFub3RoZXIgbG9hZCBwb2xpY3kgZm9yIHBhcnRzP1xuICAgICAgY29uc3QgbG9hZFBvbGljeSA9IGdldExvYWRlckNvbmZpZ1dpdGhvdXRSZXRpZXMoY29uZmlnLmZyYWdMb2FkUG9saWN5LmRlZmF1bHQpO1xuICAgICAgY29uc3QgbG9hZGVyQ29uZmlnID0ge1xuICAgICAgICBsb2FkUG9saWN5LFxuICAgICAgICB0aW1lb3V0OiBsb2FkUG9saWN5Lm1heExvYWRUaW1lTXMsXG4gICAgICAgIG1heFJldHJ5OiAwLFxuICAgICAgICByZXRyeURlbGF5OiAwLFxuICAgICAgICBtYXhSZXRyeURlbGF5OiAwLFxuICAgICAgICBoaWdoV2F0ZXJNYXJrOiBNSU5fQ0hVTktfU0laRVxuICAgICAgfTtcbiAgICAgIC8vIEFzc2lnbiBwYXJ0IHN0YXRzIHRvIHRoZSBsb2FkZXIncyBzdGF0cyByZWZlcmVuY2VcbiAgICAgIHBhcnQuc3RhdHMgPSBsb2FkZXIuc3RhdHM7XG4gICAgICBsb2FkZXIubG9hZChsb2FkZXJDb250ZXh0LCBsb2FkZXJDb25maWcsIHtcbiAgICAgICAgb25TdWNjZXNzOiAocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykgPT4ge1xuICAgICAgICAgIHRoaXMucmVzZXRMb2FkZXIoZnJhZywgbG9hZGVyKTtcbiAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRzRnJvbVBhcnQoZnJhZywgcGFydCk7XG4gICAgICAgICAgY29uc3QgcGFydExvYWRlZERhdGEgPSB7XG4gICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgcGFydCxcbiAgICAgICAgICAgIHBheWxvYWQ6IHJlc3BvbnNlLmRhdGEsXG4gICAgICAgICAgICBuZXR3b3JrRGV0YWlsc1xuICAgICAgICAgIH07XG4gICAgICAgICAgb25Qcm9ncmVzcyhwYXJ0TG9hZGVkRGF0YSk7XG4gICAgICAgICAgcmVzb2x2ZShwYXJ0TG9hZGVkRGF0YSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRXJyb3I6IChyZXNwb25zZSwgY29udGV4dCwgbmV0d29ya0RldGFpbHMsIHN0YXRzKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZXNldExvYWRlcihmcmFnLCBsb2FkZXIpO1xuICAgICAgICAgIHJlamVjdChuZXcgTG9hZEVycm9yKHtcbiAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1IsXG4gICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgcGFydCxcbiAgICAgICAgICAgIHJlc3BvbnNlOiBfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAgICAgIHVybDogbG9hZGVyQ29udGV4dC51cmwsXG4gICAgICAgICAgICAgIGRhdGE6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfSwgcmVzcG9uc2UpLFxuICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcihgSFRUUCBFcnJvciAke3Jlc3BvbnNlLmNvZGV9ICR7cmVzcG9uc2UudGV4dH1gKSxcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgICAgc3RhdHNcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQWJvcnQ6IChzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpID0+IHtcbiAgICAgICAgICBmcmFnLnN0YXRzLmFib3J0ZWQgPSBwYXJ0LnN0YXRzLmFib3J0ZWQ7XG4gICAgICAgICAgdGhpcy5yZXNldExvYWRlcihmcmFnLCBsb2FkZXIpO1xuICAgICAgICAgIHJlamVjdChuZXcgTG9hZEVycm9yKHtcbiAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTkVUV09SS19FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5JTlRFUk5BTF9BQk9SVEVELFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgIHBhcnQsXG4gICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKCdBYm9ydGVkJyksXG4gICAgICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICAgIHN0YXRzXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9LFxuICAgICAgICBvblRpbWVvdXQ6IChzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpID0+IHtcbiAgICAgICAgICB0aGlzLnJlc2V0TG9hZGVyKGZyYWcsIGxvYWRlcik7XG4gICAgICAgICAgcmVqZWN0KG5ldyBMb2FkRXJyb3Ioe1xuICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5ORVRXT1JLX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfTE9BRF9USU1FT1VULFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgIHBhcnQsXG4gICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKGBUaW1lb3V0IGFmdGVyICR7bG9hZGVyQ29uZmlnLnRpbWVvdXR9bXNgKSxcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzLFxuICAgICAgICAgICAgc3RhdHNcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHVwZGF0ZVN0YXRzRnJvbVBhcnQoZnJhZywgcGFydCkge1xuICAgIGNvbnN0IGZyYWdTdGF0cyA9IGZyYWcuc3RhdHM7XG4gICAgY29uc3QgcGFydFN0YXRzID0gcGFydC5zdGF0cztcbiAgICBjb25zdCBwYXJ0VG90YWwgPSBwYXJ0U3RhdHMudG90YWw7XG4gICAgZnJhZ1N0YXRzLmxvYWRlZCArPSBwYXJ0U3RhdHMubG9hZGVkO1xuICAgIGlmIChwYXJ0VG90YWwpIHtcbiAgICAgIGNvbnN0IGVzdFRvdGFsUGFydHMgPSBNYXRoLnJvdW5kKGZyYWcuZHVyYXRpb24gLyBwYXJ0LmR1cmF0aW9uKTtcbiAgICAgIGNvbnN0IGVzdExvYWRlZFBhcnRzID0gTWF0aC5taW4oTWF0aC5yb3VuZChmcmFnU3RhdHMubG9hZGVkIC8gcGFydFRvdGFsKSwgZXN0VG90YWxQYXJ0cyk7XG4gICAgICBjb25zdCBlc3RSZW1haW5pbmdQYXJ0cyA9IGVzdFRvdGFsUGFydHMgLSBlc3RMb2FkZWRQYXJ0cztcbiAgICAgIGNvbnN0IGVzdFJlbWFpbmluZ0J5dGVzID0gZXN0UmVtYWluaW5nUGFydHMgKiBNYXRoLnJvdW5kKGZyYWdTdGF0cy5sb2FkZWQgLyBlc3RMb2FkZWRQYXJ0cyk7XG4gICAgICBmcmFnU3RhdHMudG90YWwgPSBmcmFnU3RhdHMubG9hZGVkICsgZXN0UmVtYWluaW5nQnl0ZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyYWdTdGF0cy50b3RhbCA9IE1hdGgubWF4KGZyYWdTdGF0cy5sb2FkZWQsIGZyYWdTdGF0cy50b3RhbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyYWdMb2FkaW5nID0gZnJhZ1N0YXRzLmxvYWRpbmc7XG4gICAgY29uc3QgcGFydExvYWRpbmcgPSBwYXJ0U3RhdHMubG9hZGluZztcbiAgICBpZiAoZnJhZ0xvYWRpbmcuc3RhcnQpIHtcbiAgICAgIC8vIGFkZCB0byBmcmFnbWVudCBsb2FkZXIgbGF0ZW5jeVxuICAgICAgZnJhZ0xvYWRpbmcuZmlyc3QgKz0gcGFydExvYWRpbmcuZmlyc3QgLSBwYXJ0TG9hZGluZy5zdGFydDtcbiAgICB9IGVsc2Uge1xuICAgICAgZnJhZ0xvYWRpbmcuc3RhcnQgPSBwYXJ0TG9hZGluZy5zdGFydDtcbiAgICAgIGZyYWdMb2FkaW5nLmZpcnN0ID0gcGFydExvYWRpbmcuZmlyc3Q7XG4gICAgfVxuICAgIGZyYWdMb2FkaW5nLmVuZCA9IHBhcnRMb2FkaW5nLmVuZDtcbiAgfVxuICByZXNldExvYWRlcihmcmFnLCBsb2FkZXIpIHtcbiAgICBmcmFnLmxvYWRlciA9IG51bGw7XG4gICAgaWYgKHRoaXMubG9hZGVyID09PSBsb2FkZXIpIHtcbiAgICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucGFydExvYWRUaW1lb3V0KTtcbiAgICAgIHRoaXMubG9hZGVyID0gbnVsbDtcbiAgICB9XG4gICAgbG9hZGVyLmRlc3Ryb3koKTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlTG9hZGVyQ29udGV4dChmcmFnLCBwYXJ0ID0gbnVsbCkge1xuICBjb25zdCBzZWdtZW50ID0gcGFydCB8fCBmcmFnO1xuICBjb25zdCBsb2FkZXJDb250ZXh0ID0ge1xuICAgIGZyYWcsXG4gICAgcGFydCxcbiAgICByZXNwb25zZVR5cGU6ICdhcnJheWJ1ZmZlcicsXG4gICAgdXJsOiBzZWdtZW50LnVybCxcbiAgICBoZWFkZXJzOiB7fSxcbiAgICByYW5nZVN0YXJ0OiAwLFxuICAgIHJhbmdlRW5kOiAwXG4gIH07XG4gIGNvbnN0IHN0YXJ0ID0gc2VnbWVudC5ieXRlUmFuZ2VTdGFydE9mZnNldDtcbiAgY29uc3QgZW5kID0gc2VnbWVudC5ieXRlUmFuZ2VFbmRPZmZzZXQ7XG4gIGlmIChpc0Zpbml0ZU51bWJlcihzdGFydCkgJiYgaXNGaW5pdGVOdW1iZXIoZW5kKSkge1xuICAgIHZhciBfZnJhZyRkZWNyeXB0ZGF0YTtcbiAgICBsZXQgYnl0ZVJhbmdlU3RhcnQgPSBzdGFydDtcbiAgICBsZXQgYnl0ZVJhbmdlRW5kID0gZW5kO1xuICAgIGlmIChmcmFnLnNuID09PSAnaW5pdFNlZ21lbnQnICYmICgoX2ZyYWckZGVjcnlwdGRhdGEgPSBmcmFnLmRlY3J5cHRkYXRhKSA9PSBudWxsID8gdm9pZCAwIDogX2ZyYWckZGVjcnlwdGRhdGEubWV0aG9kKSA9PT0gJ0FFUy0xMjgnKSB7XG4gICAgICAvLyBNQVAgc2VnbWVudCBlbmNyeXB0ZWQgd2l0aCBtZXRob2QgJ0FFUy0xMjgnLCB3aGVuIHNlcnZlZCB3aXRoIEhUVFAgUmFuZ2UsXG4gICAgICAvLyBoYXMgdGhlIHVuZW5jcnlwdGVkIHNpemUgc3BlY2lmaWVkIGluIHRoZSByYW5nZS5cbiAgICAgIC8vIFJlZjogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LXBhbnRvcy1obHMtcmZjODIxNmJpcy0wOCNzZWN0aW9uLTYuMy42XG4gICAgICBjb25zdCBmcmFnbWVudExlbiA9IGVuZCAtIHN0YXJ0O1xuICAgICAgaWYgKGZyYWdtZW50TGVuICUgMTYpIHtcbiAgICAgICAgYnl0ZVJhbmdlRW5kID0gZW5kICsgKDE2IC0gZnJhZ21lbnRMZW4gJSAxNik7XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnQgIT09IDApIHtcbiAgICAgICAgbG9hZGVyQ29udGV4dC5yZXNldElWID0gdHJ1ZTtcbiAgICAgICAgYnl0ZVJhbmdlU3RhcnQgPSBzdGFydCAtIDE2O1xuICAgICAgfVxuICAgIH1cbiAgICBsb2FkZXJDb250ZXh0LnJhbmdlU3RhcnQgPSBieXRlUmFuZ2VTdGFydDtcbiAgICBsb2FkZXJDb250ZXh0LnJhbmdlRW5kID0gYnl0ZVJhbmdlRW5kO1xuICB9XG4gIHJldHVybiBsb2FkZXJDb250ZXh0O1xufVxuZnVuY3Rpb24gY3JlYXRlR2FwTG9hZEVycm9yKGZyYWcsIHBhcnQpIHtcbiAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYEdBUCAke2ZyYWcuZ2FwID8gJ3RhZycgOiAnYXR0cmlidXRlJ30gZm91bmRgKTtcbiAgY29uc3QgZXJyb3JEYXRhID0ge1xuICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfR0FQLFxuICAgIGZhdGFsOiBmYWxzZSxcbiAgICBmcmFnLFxuICAgIGVycm9yLFxuICAgIG5ldHdvcmtEZXRhaWxzOiBudWxsXG4gIH07XG4gIGlmIChwYXJ0KSB7XG4gICAgZXJyb3JEYXRhLnBhcnQgPSBwYXJ0O1xuICB9XG4gIChwYXJ0ID8gcGFydCA6IGZyYWcpLnN0YXRzLmFib3J0ZWQgPSB0cnVlO1xuICByZXR1cm4gbmV3IExvYWRFcnJvcihlcnJvckRhdGEpO1xufVxuY2xhc3MgTG9hZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoZGF0YS5lcnJvci5tZXNzYWdlKTtcbiAgICB0aGlzLmRhdGEgPSB2b2lkIDA7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgfVxufVxuXG5jbGFzcyBBRVNDcnlwdG8ge1xuICBjb25zdHJ1Y3RvcihzdWJ0bGUsIGl2KSB7XG4gICAgdGhpcy5zdWJ0bGUgPSB2b2lkIDA7XG4gICAgdGhpcy5hZXNJViA9IHZvaWQgMDtcbiAgICB0aGlzLnN1YnRsZSA9IHN1YnRsZTtcbiAgICB0aGlzLmFlc0lWID0gaXY7XG4gIH1cbiAgZGVjcnlwdChkYXRhLCBrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5zdWJ0bGUuZGVjcnlwdCh7XG4gICAgICBuYW1lOiAnQUVTLUNCQycsXG4gICAgICBpdjogdGhpcy5hZXNJVlxuICAgIH0sIGtleSwgZGF0YSk7XG4gIH1cbn1cblxuY2xhc3MgRmFzdEFFU0tleSB7XG4gIGNvbnN0cnVjdG9yKHN1YnRsZSwga2V5KSB7XG4gICAgdGhpcy5zdWJ0bGUgPSB2b2lkIDA7XG4gICAgdGhpcy5rZXkgPSB2b2lkIDA7XG4gICAgdGhpcy5zdWJ0bGUgPSBzdWJ0bGU7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gIH1cbiAgZXhwYW5kS2V5KCkge1xuICAgIHJldHVybiB0aGlzLnN1YnRsZS5pbXBvcnRLZXkoJ3JhdycsIHRoaXMua2V5LCB7XG4gICAgICBuYW1lOiAnQUVTLUNCQydcbiAgICB9LCBmYWxzZSwgWydlbmNyeXB0JywgJ2RlY3J5cHQnXSk7XG4gIH1cbn1cblxuLy8gUEtDUzdcbmZ1bmN0aW9uIHJlbW92ZVBhZGRpbmcoYXJyYXkpIHtcbiAgY29uc3Qgb3V0cHV0Qnl0ZXMgPSBhcnJheS5ieXRlTGVuZ3RoO1xuICBjb25zdCBwYWRkaW5nQnl0ZXMgPSBvdXRwdXRCeXRlcyAmJiBuZXcgRGF0YVZpZXcoYXJyYXkuYnVmZmVyKS5nZXRVaW50OChvdXRwdXRCeXRlcyAtIDEpO1xuICBpZiAocGFkZGluZ0J5dGVzKSB7XG4gICAgcmV0dXJuIHNsaWNlVWludDgoYXJyYXksIDAsIG91dHB1dEJ5dGVzIC0gcGFkZGluZ0J5dGVzKTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5jbGFzcyBBRVNEZWNyeXB0b3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnJjb24gPSBbMHgwLCAweDEsIDB4MiwgMHg0LCAweDgsIDB4MTAsIDB4MjAsIDB4NDAsIDB4ODAsIDB4MWIsIDB4MzZdO1xuICAgIHRoaXMuc3ViTWl4ID0gW25ldyBVaW50MzJBcnJheSgyNTYpLCBuZXcgVWludDMyQXJyYXkoMjU2KSwgbmV3IFVpbnQzMkFycmF5KDI1NiksIG5ldyBVaW50MzJBcnJheSgyNTYpXTtcbiAgICB0aGlzLmludlN1Yk1peCA9IFtuZXcgVWludDMyQXJyYXkoMjU2KSwgbmV3IFVpbnQzMkFycmF5KDI1NiksIG5ldyBVaW50MzJBcnJheSgyNTYpLCBuZXcgVWludDMyQXJyYXkoMjU2KV07XG4gICAgdGhpcy5zQm94ID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG4gICAgdGhpcy5pbnZTQm94ID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG4gICAgdGhpcy5rZXkgPSBuZXcgVWludDMyQXJyYXkoMCk7XG4gICAgdGhpcy5rc1Jvd3MgPSAwO1xuICAgIHRoaXMua2V5U2l6ZSA9IDA7XG4gICAgdGhpcy5rZXlTY2hlZHVsZSA9IHZvaWQgMDtcbiAgICB0aGlzLmludktleVNjaGVkdWxlID0gdm9pZCAwO1xuICAgIHRoaXMuaW5pdFRhYmxlKCk7XG4gIH1cblxuICAvLyBVc2luZyB2aWV3LmdldFVpbnQzMigpIGFsc28gc3dhcHMgdGhlIGJ5dGUgb3JkZXIuXG4gIHVpbnQ4QXJyYXlUb1VpbnQzMkFycmF5XyhhcnJheUJ1ZmZlcikge1xuICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYXJyYXlCdWZmZXIpO1xuICAgIGNvbnN0IG5ld0FycmF5ID0gbmV3IFVpbnQzMkFycmF5KDQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICBuZXdBcnJheVtpXSA9IHZpZXcuZ2V0VWludDMyKGkgKiA0KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0FycmF5O1xuICB9XG4gIGluaXRUYWJsZSgpIHtcbiAgICBjb25zdCBzQm94ID0gdGhpcy5zQm94O1xuICAgIGNvbnN0IGludlNCb3ggPSB0aGlzLmludlNCb3g7XG4gICAgY29uc3Qgc3ViTWl4ID0gdGhpcy5zdWJNaXg7XG4gICAgY29uc3Qgc3ViTWl4MCA9IHN1Yk1peFswXTtcbiAgICBjb25zdCBzdWJNaXgxID0gc3ViTWl4WzFdO1xuICAgIGNvbnN0IHN1Yk1peDIgPSBzdWJNaXhbMl07XG4gICAgY29uc3Qgc3ViTWl4MyA9IHN1Yk1peFszXTtcbiAgICBjb25zdCBpbnZTdWJNaXggPSB0aGlzLmludlN1Yk1peDtcbiAgICBjb25zdCBpbnZTdWJNaXgwID0gaW52U3ViTWl4WzBdO1xuICAgIGNvbnN0IGludlN1Yk1peDEgPSBpbnZTdWJNaXhbMV07XG4gICAgY29uc3QgaW52U3ViTWl4MiA9IGludlN1Yk1peFsyXTtcbiAgICBjb25zdCBpbnZTdWJNaXgzID0gaW52U3ViTWl4WzNdO1xuICAgIGNvbnN0IGQgPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbiAgICBsZXQgeCA9IDA7XG4gICAgbGV0IHhpID0gMDtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICBpZiAoaSA8IDEyOCkge1xuICAgICAgICBkW2ldID0gaSA8PCAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZFtpXSA9IGkgPDwgMSBeIDB4MTFiO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgIGxldCBzeCA9IHhpIF4geGkgPDwgMSBeIHhpIDw8IDIgXiB4aSA8PCAzIF4geGkgPDwgNDtcbiAgICAgIHN4ID0gc3ggPj4+IDggXiBzeCAmIDB4ZmYgXiAweDYzO1xuICAgICAgc0JveFt4XSA9IHN4O1xuICAgICAgaW52U0JveFtzeF0gPSB4O1xuXG4gICAgICAvLyBDb21wdXRlIG11bHRpcGxpY2F0aW9uXG4gICAgICBjb25zdCB4MiA9IGRbeF07XG4gICAgICBjb25zdCB4NCA9IGRbeDJdO1xuICAgICAgY29uc3QgeDggPSBkW3g0XTtcblxuICAgICAgLy8gQ29tcHV0ZSBzdWIvaW52U3ViIGJ5dGVzLCBtaXggY29sdW1ucyB0YWJsZXNcbiAgICAgIGxldCB0ID0gZFtzeF0gKiAweDEwMSBeIHN4ICogMHgxMDEwMTAwO1xuICAgICAgc3ViTWl4MFt4XSA9IHQgPDwgMjQgfCB0ID4+PiA4O1xuICAgICAgc3ViTWl4MVt4XSA9IHQgPDwgMTYgfCB0ID4+PiAxNjtcbiAgICAgIHN1Yk1peDJbeF0gPSB0IDw8IDggfCB0ID4+PiAyNDtcbiAgICAgIHN1Yk1peDNbeF0gPSB0O1xuXG4gICAgICAvLyBDb21wdXRlIGludiBzdWIgYnl0ZXMsIGludiBtaXggY29sdW1ucyB0YWJsZXNcbiAgICAgIHQgPSB4OCAqIDB4MTAxMDEwMSBeIHg0ICogMHgxMDAwMSBeIHgyICogMHgxMDEgXiB4ICogMHgxMDEwMTAwO1xuICAgICAgaW52U3ViTWl4MFtzeF0gPSB0IDw8IDI0IHwgdCA+Pj4gODtcbiAgICAgIGludlN1Yk1peDFbc3hdID0gdCA8PCAxNiB8IHQgPj4+IDE2O1xuICAgICAgaW52U3ViTWl4MltzeF0gPSB0IDw8IDggfCB0ID4+PiAyNDtcbiAgICAgIGludlN1Yk1peDNbc3hdID0gdDtcblxuICAgICAgLy8gQ29tcHV0ZSBuZXh0IGNvdW50ZXJcbiAgICAgIGlmICgheCkge1xuICAgICAgICB4ID0geGkgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IHgyIF4gZFtkW2RbeDggXiB4Ml1dXTtcbiAgICAgICAgeGkgXj0gZFtkW3hpXV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGV4cGFuZEtleShrZXlCdWZmZXIpIHtcbiAgICAvLyBjb252ZXJ0IGtleUJ1ZmZlciB0byBVaW50MzJBcnJheVxuICAgIGNvbnN0IGtleSA9IHRoaXMudWludDhBcnJheVRvVWludDMyQXJyYXlfKGtleUJ1ZmZlcik7XG4gICAgbGV0IHNhbWVLZXkgPSB0cnVlO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIHdoaWxlIChvZmZzZXQgPCBrZXkubGVuZ3RoICYmIHNhbWVLZXkpIHtcbiAgICAgIHNhbWVLZXkgPSBrZXlbb2Zmc2V0XSA9PT0gdGhpcy5rZXlbb2Zmc2V0XTtcbiAgICAgIG9mZnNldCsrO1xuICAgIH1cbiAgICBpZiAoc2FtZUtleSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICBjb25zdCBrZXlTaXplID0gdGhpcy5rZXlTaXplID0ga2V5Lmxlbmd0aDtcbiAgICBpZiAoa2V5U2l6ZSAhPT0gNCAmJiBrZXlTaXplICE9PSA2ICYmIGtleVNpemUgIT09IDgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhZXMga2V5IHNpemU9JyArIGtleVNpemUpO1xuICAgIH1cbiAgICBjb25zdCBrc1Jvd3MgPSB0aGlzLmtzUm93cyA9IChrZXlTaXplICsgNiArIDEpICogNDtcbiAgICBsZXQga3NSb3c7XG4gICAgbGV0IGludktzUm93O1xuICAgIGNvbnN0IGtleVNjaGVkdWxlID0gdGhpcy5rZXlTY2hlZHVsZSA9IG5ldyBVaW50MzJBcnJheShrc1Jvd3MpO1xuICAgIGNvbnN0IGludktleVNjaGVkdWxlID0gdGhpcy5pbnZLZXlTY2hlZHVsZSA9IG5ldyBVaW50MzJBcnJheShrc1Jvd3MpO1xuICAgIGNvbnN0IHNib3ggPSB0aGlzLnNCb3g7XG4gICAgY29uc3QgcmNvbiA9IHRoaXMucmNvbjtcbiAgICBjb25zdCBpbnZTdWJNaXggPSB0aGlzLmludlN1Yk1peDtcbiAgICBjb25zdCBpbnZTdWJNaXgwID0gaW52U3ViTWl4WzBdO1xuICAgIGNvbnN0IGludlN1Yk1peDEgPSBpbnZTdWJNaXhbMV07XG4gICAgY29uc3QgaW52U3ViTWl4MiA9IGludlN1Yk1peFsyXTtcbiAgICBjb25zdCBpbnZTdWJNaXgzID0gaW52U3ViTWl4WzNdO1xuICAgIGxldCBwcmV2O1xuICAgIGxldCB0O1xuICAgIGZvciAoa3NSb3cgPSAwOyBrc1JvdyA8IGtzUm93czsga3NSb3crKykge1xuICAgICAgaWYgKGtzUm93IDwga2V5U2l6ZSkge1xuICAgICAgICBwcmV2ID0ga2V5U2NoZWR1bGVba3NSb3ddID0ga2V5W2tzUm93XTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0ID0gcHJldjtcbiAgICAgIGlmIChrc1JvdyAlIGtleVNpemUgPT09IDApIHtcbiAgICAgICAgLy8gUm90IHdvcmRcbiAgICAgICAgdCA9IHQgPDwgOCB8IHQgPj4+IDI0O1xuXG4gICAgICAgIC8vIFN1YiB3b3JkXG4gICAgICAgIHQgPSBzYm94W3QgPj4+IDI0XSA8PCAyNCB8IHNib3hbdCA+Pj4gMTYgJiAweGZmXSA8PCAxNiB8IHNib3hbdCA+Pj4gOCAmIDB4ZmZdIDw8IDggfCBzYm94W3QgJiAweGZmXTtcblxuICAgICAgICAvLyBNaXggUmNvblxuICAgICAgICB0IF49IHJjb25ba3NSb3cgLyBrZXlTaXplIHwgMF0gPDwgMjQ7XG4gICAgICB9IGVsc2UgaWYgKGtleVNpemUgPiA2ICYmIGtzUm93ICUga2V5U2l6ZSA9PT0gNCkge1xuICAgICAgICAvLyBTdWIgd29yZFxuICAgICAgICB0ID0gc2JveFt0ID4+PiAyNF0gPDwgMjQgfCBzYm94W3QgPj4+IDE2ICYgMHhmZl0gPDwgMTYgfCBzYm94W3QgPj4+IDggJiAweGZmXSA8PCA4IHwgc2JveFt0ICYgMHhmZl07XG4gICAgICB9XG4gICAgICBrZXlTY2hlZHVsZVtrc1Jvd10gPSBwcmV2ID0gKGtleVNjaGVkdWxlW2tzUm93IC0ga2V5U2l6ZV0gXiB0KSA+Pj4gMDtcbiAgICB9XG4gICAgZm9yIChpbnZLc1JvdyA9IDA7IGludktzUm93IDwga3NSb3dzOyBpbnZLc1JvdysrKSB7XG4gICAgICBrc1JvdyA9IGtzUm93cyAtIGludktzUm93O1xuICAgICAgaWYgKGludktzUm93ICYgMykge1xuICAgICAgICB0ID0ga2V5U2NoZWR1bGVba3NSb3ddO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdCA9IGtleVNjaGVkdWxlW2tzUm93IC0gNF07XG4gICAgICB9XG4gICAgICBpZiAoaW52S3NSb3cgPCA0IHx8IGtzUm93IDw9IDQpIHtcbiAgICAgICAgaW52S2V5U2NoZWR1bGVbaW52S3NSb3ddID0gdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IGludlN1Yk1peDBbc2JveFt0ID4+PiAyNF1dIF4gaW52U3ViTWl4MVtzYm94W3QgPj4+IDE2ICYgMHhmZl1dIF4gaW52U3ViTWl4MltzYm94W3QgPj4+IDggJiAweGZmXV0gXiBpbnZTdWJNaXgzW3Nib3hbdCAmIDB4ZmZdXTtcbiAgICAgIH1cbiAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IGludktleVNjaGVkdWxlW2ludktzUm93XSA+Pj4gMDtcbiAgICB9XG4gIH1cblxuICAvLyBBZGRpbmcgdGhpcyBhcyBhIG1ldGhvZCBncmVhdGx5IGltcHJvdmVzIHBlcmZvcm1hbmNlLlxuICBuZXR3b3JrVG9Ib3N0T3JkZXJTd2FwKHdvcmQpIHtcbiAgICByZXR1cm4gd29yZCA8PCAyNCB8ICh3b3JkICYgMHhmZjAwKSA8PCA4IHwgKHdvcmQgJiAweGZmMDAwMCkgPj4gOCB8IHdvcmQgPj4+IDI0O1xuICB9XG4gIGRlY3J5cHQoaW5wdXRBcnJheUJ1ZmZlciwgb2Zmc2V0LCBhZXNJVikge1xuICAgIGNvbnN0IG5Sb3VuZHMgPSB0aGlzLmtleVNpemUgKyA2O1xuICAgIGNvbnN0IGludktleVNjaGVkdWxlID0gdGhpcy5pbnZLZXlTY2hlZHVsZTtcbiAgICBjb25zdCBpbnZTQk9YID0gdGhpcy5pbnZTQm94O1xuICAgIGNvbnN0IGludlN1Yk1peCA9IHRoaXMuaW52U3ViTWl4O1xuICAgIGNvbnN0IGludlN1Yk1peDAgPSBpbnZTdWJNaXhbMF07XG4gICAgY29uc3QgaW52U3ViTWl4MSA9IGludlN1Yk1peFsxXTtcbiAgICBjb25zdCBpbnZTdWJNaXgyID0gaW52U3ViTWl4WzJdO1xuICAgIGNvbnN0IGludlN1Yk1peDMgPSBpbnZTdWJNaXhbM107XG4gICAgY29uc3QgaW5pdFZlY3RvciA9IHRoaXMudWludDhBcnJheVRvVWludDMyQXJyYXlfKGFlc0lWKTtcbiAgICBsZXQgaW5pdFZlY3RvcjAgPSBpbml0VmVjdG9yWzBdO1xuICAgIGxldCBpbml0VmVjdG9yMSA9IGluaXRWZWN0b3JbMV07XG4gICAgbGV0IGluaXRWZWN0b3IyID0gaW5pdFZlY3RvclsyXTtcbiAgICBsZXQgaW5pdFZlY3RvcjMgPSBpbml0VmVjdG9yWzNdO1xuICAgIGNvbnN0IGlucHV0SW50MzIgPSBuZXcgSW50MzJBcnJheShpbnB1dEFycmF5QnVmZmVyKTtcbiAgICBjb25zdCBvdXRwdXRJbnQzMiA9IG5ldyBJbnQzMkFycmF5KGlucHV0SW50MzIubGVuZ3RoKTtcbiAgICBsZXQgdDAsIHQxLCB0MiwgdDM7XG4gICAgbGV0IHMwLCBzMSwgczIsIHMzO1xuICAgIGxldCBpbnB1dFdvcmRzMCwgaW5wdXRXb3JkczEsIGlucHV0V29yZHMyLCBpbnB1dFdvcmRzMztcbiAgICBsZXQga3NSb3csIGk7XG4gICAgY29uc3Qgc3dhcFdvcmQgPSB0aGlzLm5ldHdvcmtUb0hvc3RPcmRlclN3YXA7XG4gICAgd2hpbGUgKG9mZnNldCA8IGlucHV0SW50MzIubGVuZ3RoKSB7XG4gICAgICBpbnB1dFdvcmRzMCA9IHN3YXBXb3JkKGlucHV0SW50MzJbb2Zmc2V0XSk7XG4gICAgICBpbnB1dFdvcmRzMSA9IHN3YXBXb3JkKGlucHV0SW50MzJbb2Zmc2V0ICsgMV0pO1xuICAgICAgaW5wdXRXb3JkczIgPSBzd2FwV29yZChpbnB1dEludDMyW29mZnNldCArIDJdKTtcbiAgICAgIGlucHV0V29yZHMzID0gc3dhcFdvcmQoaW5wdXRJbnQzMltvZmZzZXQgKyAzXSk7XG4gICAgICBzMCA9IGlucHV0V29yZHMwIF4gaW52S2V5U2NoZWR1bGVbMF07XG4gICAgICBzMSA9IGlucHV0V29yZHMzIF4gaW52S2V5U2NoZWR1bGVbMV07XG4gICAgICBzMiA9IGlucHV0V29yZHMyIF4gaW52S2V5U2NoZWR1bGVbMl07XG4gICAgICBzMyA9IGlucHV0V29yZHMxIF4gaW52S2V5U2NoZWR1bGVbM107XG4gICAgICBrc1JvdyA9IDQ7XG5cbiAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgcm91bmRzIG9mIGRlY3J5cHRpb25cbiAgICAgIGZvciAoaSA9IDE7IGkgPCBuUm91bmRzOyBpKyspIHtcbiAgICAgICAgdDAgPSBpbnZTdWJNaXgwW3MwID4+PiAyNF0gXiBpbnZTdWJNaXgxW3MxID4+IDE2ICYgMHhmZl0gXiBpbnZTdWJNaXgyW3MyID4+IDggJiAweGZmXSBeIGludlN1Yk1peDNbczMgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93XTtcbiAgICAgICAgdDEgPSBpbnZTdWJNaXgwW3MxID4+PiAyNF0gXiBpbnZTdWJNaXgxW3MyID4+IDE2ICYgMHhmZl0gXiBpbnZTdWJNaXgyW3MzID4+IDggJiAweGZmXSBeIGludlN1Yk1peDNbczAgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgMV07XG4gICAgICAgIHQyID0gaW52U3ViTWl4MFtzMiA+Pj4gMjRdIF4gaW52U3ViTWl4MVtzMyA+PiAxNiAmIDB4ZmZdIF4gaW52U3ViTWl4MltzMCA+PiA4ICYgMHhmZl0gXiBpbnZTdWJNaXgzW3MxICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDJdO1xuICAgICAgICB0MyA9IGludlN1Yk1peDBbczMgPj4+IDI0XSBeIGludlN1Yk1peDFbczAgPj4gMTYgJiAweGZmXSBeIGludlN1Yk1peDJbczEgPj4gOCAmIDB4ZmZdIF4gaW52U3ViTWl4M1tzMiAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAzXTtcbiAgICAgICAgLy8gVXBkYXRlIHN0YXRlXG4gICAgICAgIHMwID0gdDA7XG4gICAgICAgIHMxID0gdDE7XG4gICAgICAgIHMyID0gdDI7XG4gICAgICAgIHMzID0gdDM7XG4gICAgICAgIGtzUm93ID0ga3NSb3cgKyA0O1xuICAgICAgfVxuXG4gICAgICAvLyBTaGlmdCByb3dzLCBzdWIgYnl0ZXMsIGFkZCByb3VuZCBrZXlcbiAgICAgIHQwID0gaW52U0JPWFtzMCA+Pj4gMjRdIDw8IDI0IF4gaW52U0JPWFtzMSA+PiAxNiAmIDB4ZmZdIDw8IDE2IF4gaW52U0JPWFtzMiA+PiA4ICYgMHhmZl0gPDwgOCBeIGludlNCT1hbczMgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93XTtcbiAgICAgIHQxID0gaW52U0JPWFtzMSA+Pj4gMjRdIDw8IDI0IF4gaW52U0JPWFtzMiA+PiAxNiAmIDB4ZmZdIDw8IDE2IF4gaW52U0JPWFtzMyA+PiA4ICYgMHhmZl0gPDwgOCBeIGludlNCT1hbczAgJiAweGZmXSBeIGludktleVNjaGVkdWxlW2tzUm93ICsgMV07XG4gICAgICB0MiA9IGludlNCT1hbczIgPj4+IDI0XSA8PCAyNCBeIGludlNCT1hbczMgPj4gMTYgJiAweGZmXSA8PCAxNiBeIGludlNCT1hbczAgPj4gOCAmIDB4ZmZdIDw8IDggXiBpbnZTQk9YW3MxICYgMHhmZl0gXiBpbnZLZXlTY2hlZHVsZVtrc1JvdyArIDJdO1xuICAgICAgdDMgPSBpbnZTQk9YW3MzID4+PiAyNF0gPDwgMjQgXiBpbnZTQk9YW3MwID4+IDE2ICYgMHhmZl0gPDwgMTYgXiBpbnZTQk9YW3MxID4+IDggJiAweGZmXSA8PCA4IF4gaW52U0JPWFtzMiAmIDB4ZmZdIF4gaW52S2V5U2NoZWR1bGVba3NSb3cgKyAzXTtcblxuICAgICAgLy8gV3JpdGVcbiAgICAgIG91dHB1dEludDMyW29mZnNldF0gPSBzd2FwV29yZCh0MCBeIGluaXRWZWN0b3IwKTtcbiAgICAgIG91dHB1dEludDMyW29mZnNldCArIDFdID0gc3dhcFdvcmQodDMgXiBpbml0VmVjdG9yMSk7XG4gICAgICBvdXRwdXRJbnQzMltvZmZzZXQgKyAyXSA9IHN3YXBXb3JkKHQyIF4gaW5pdFZlY3RvcjIpO1xuICAgICAgb3V0cHV0SW50MzJbb2Zmc2V0ICsgM10gPSBzd2FwV29yZCh0MSBeIGluaXRWZWN0b3IzKTtcblxuICAgICAgLy8gcmVzZXQgaW5pdFZlY3RvciB0byBsYXN0IDQgdW5zaWduZWQgaW50XG4gICAgICBpbml0VmVjdG9yMCA9IGlucHV0V29yZHMwO1xuICAgICAgaW5pdFZlY3RvcjEgPSBpbnB1dFdvcmRzMTtcbiAgICAgIGluaXRWZWN0b3IyID0gaW5wdXRXb3JkczI7XG4gICAgICBpbml0VmVjdG9yMyA9IGlucHV0V29yZHMzO1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0ICsgNDtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dEludDMyLmJ1ZmZlcjtcbiAgfVxufVxuXG5jb25zdCBDSFVOS19TSVpFID0gMTY7IC8vIDE2IGJ5dGVzLCAxMjggYml0c1xuXG5jbGFzcyBEZWNyeXB0ZXIge1xuICBjb25zdHJ1Y3Rvcihjb25maWcsIHtcbiAgICByZW1vdmVQS0NTN1BhZGRpbmcgPSB0cnVlXG4gIH0gPSB7fSkge1xuICAgIHRoaXMubG9nRW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5yZW1vdmVQS0NTN1BhZGRpbmcgPSB2b2lkIDA7XG4gICAgdGhpcy5zdWJ0bGUgPSBudWxsO1xuICAgIHRoaXMuc29mdHdhcmVEZWNyeXB0ZXIgPSBudWxsO1xuICAgIHRoaXMua2V5ID0gbnVsbDtcbiAgICB0aGlzLmZhc3RBZXNLZXkgPSBudWxsO1xuICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG4gICAgdGhpcy5jdXJyZW50SVYgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudFJlc3VsdCA9IG51bGw7XG4gICAgdGhpcy51c2VTb2Z0d2FyZSA9IHZvaWQgMDtcbiAgICB0aGlzLnVzZVNvZnR3YXJlID0gY29uZmlnLmVuYWJsZVNvZnR3YXJlQUVTO1xuICAgIHRoaXMucmVtb3ZlUEtDUzdQYWRkaW5nID0gcmVtb3ZlUEtDUzdQYWRkaW5nO1xuICAgIC8vIGJ1aWx0IGluIGRlY3J5cHRvciBleHBlY3RzIFBLQ1M3IHBhZGRpbmdcbiAgICBpZiAocmVtb3ZlUEtDUzdQYWRkaW5nKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBicm93c2VyQ3J5cHRvID0gc2VsZi5jcnlwdG87XG4gICAgICAgIGlmIChicm93c2VyQ3J5cHRvKSB7XG4gICAgICAgICAgdGhpcy5zdWJ0bGUgPSBicm93c2VyQ3J5cHRvLnN1YnRsZSB8fCBicm93c2VyQ3J5cHRvLndlYmtpdFN1YnRsZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvKiBuby1vcCAqL1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5zdWJ0bGUgPT09IG51bGwpIHtcbiAgICAgIHRoaXMudXNlU29mdHdhcmUgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuc3VidGxlID0gbnVsbDtcbiAgICB0aGlzLnNvZnR3YXJlRGVjcnlwdGVyID0gbnVsbDtcbiAgICB0aGlzLmtleSA9IG51bGw7XG4gICAgdGhpcy5mYXN0QWVzS2V5ID0gbnVsbDtcbiAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudElWID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnRSZXN1bHQgPSBudWxsO1xuICB9XG4gIGlzU3luYygpIHtcbiAgICByZXR1cm4gdGhpcy51c2VTb2Z0d2FyZTtcbiAgfVxuICBmbHVzaCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBjdXJyZW50UmVzdWx0LFxuICAgICAgcmVtYWluZGVyRGF0YVxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghY3VycmVudFJlc3VsdCB8fCByZW1haW5kZXJEYXRhKSB7XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KGN1cnJlbnRSZXN1bHQpO1xuICAgIHRoaXMucmVzZXQoKTtcbiAgICBpZiAodGhpcy5yZW1vdmVQS0NTN1BhZGRpbmcpIHtcbiAgICAgIHJldHVybiByZW1vdmVQYWRkaW5nKGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLmN1cnJlbnRSZXN1bHQgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudElWID0gbnVsbDtcbiAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgIGlmICh0aGlzLnNvZnR3YXJlRGVjcnlwdGVyKSB7XG4gICAgICB0aGlzLnNvZnR3YXJlRGVjcnlwdGVyID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgZGVjcnlwdChkYXRhLCBrZXksIGl2KSB7XG4gICAgaWYgKHRoaXMudXNlU29mdHdhcmUpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRoaXMuc29mdHdhcmVEZWNyeXB0KG5ldyBVaW50OEFycmF5KGRhdGEpLCBrZXksIGl2KTtcbiAgICAgICAgY29uc3QgZGVjcnlwdFJlc3VsdCA9IHRoaXMuZmx1c2goKTtcbiAgICAgICAgaWYgKGRlY3J5cHRSZXN1bHQpIHtcbiAgICAgICAgICByZXNvbHZlKGRlY3J5cHRSZXN1bHQuYnVmZmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdbc29mdHdhcmVEZWNyeXB0XSBGYWlsZWQgdG8gZGVjcnlwdCBkYXRhJykpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMud2ViQ3J5cHRvRGVjcnlwdChuZXcgVWludDhBcnJheShkYXRhKSwga2V5LCBpdik7XG4gIH1cblxuICAvLyBTb2Z0d2FyZSBkZWNyeXB0aW9uIGlzIHByb2dyZXNzaXZlLiBQcm9ncmVzc2l2ZSBkZWNyeXB0aW9uIG1heSBub3QgcmV0dXJuIGEgcmVzdWx0IG9uIGVhY2ggY2FsbC4gQW55IGNhY2hlZFxuICAvLyBkYXRhIGlzIGhhbmRsZWQgaW4gdGhlIGZsdXNoKCkgY2FsbFxuICBzb2Z0d2FyZURlY3J5cHQoZGF0YSwga2V5LCBpdikge1xuICAgIGNvbnN0IHtcbiAgICAgIGN1cnJlbnRJVixcbiAgICAgIGN1cnJlbnRSZXN1bHQsXG4gICAgICByZW1haW5kZXJEYXRhXG4gICAgfSA9IHRoaXM7XG4gICAgdGhpcy5sb2dPbmNlKCdKUyBBRVMgZGVjcnlwdCcpO1xuICAgIC8vIFRoZSBvdXRwdXQgaXMgc3RhZ2dlcmVkIGR1cmluZyBwcm9ncmVzc2l2ZSBwYXJzaW5nIC0gdGhlIGN1cnJlbnQgcmVzdWx0IGlzIGNhY2hlZCwgYW5kIGVtaXR0ZWQgb24gdGhlIG5leHQgY2FsbFxuICAgIC8vIFRoaXMgaXMgZG9uZSBpbiBvcmRlciB0byBzdHJpcCBQS0NTNyBwYWRkaW5nLCB3aGljaCBpcyBmb3VuZCBhdCB0aGUgZW5kIG9mIGVhY2ggc2VnbWVudC4gV2Ugb25seSBrbm93IHdlJ3ZlIHJlYWNoZWRcbiAgICAvLyB0aGUgZW5kIG9uIGZsdXNoKCksIGJ1dCBieSB0aGF0IHRpbWUgd2UgaGF2ZSBhbHJlYWR5IHJlY2VpdmVkIGFsbCBieXRlcyBmb3IgdGhlIHNlZ21lbnQuXG4gICAgLy8gUHJvZ3Jlc3NpdmUgZGVjcnlwdGlvbiBkb2VzIG5vdCB3b3JrIHdpdGggV2ViQ3J5cHRvXG5cbiAgICBpZiAocmVtYWluZGVyRGF0YSkge1xuICAgICAgZGF0YSA9IGFwcGVuZFVpbnQ4QXJyYXkocmVtYWluZGVyRGF0YSwgZGF0YSk7XG4gICAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIEJ5dGUgbGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNiAoQUVTLTEyOCA9IDEyOCBiaXQgYmxvY2tzID0gMTYgYnl0ZXMpXG4gICAgY29uc3QgY3VycmVudENodW5rID0gdGhpcy5nZXRWYWxpZENodW5rKGRhdGEpO1xuICAgIGlmICghY3VycmVudENodW5rLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChjdXJyZW50SVYpIHtcbiAgICAgIGl2ID0gY3VycmVudElWO1xuICAgIH1cbiAgICBsZXQgc29mdHdhcmVEZWNyeXB0ZXIgPSB0aGlzLnNvZnR3YXJlRGVjcnlwdGVyO1xuICAgIGlmICghc29mdHdhcmVEZWNyeXB0ZXIpIHtcbiAgICAgIHNvZnR3YXJlRGVjcnlwdGVyID0gdGhpcy5zb2Z0d2FyZURlY3J5cHRlciA9IG5ldyBBRVNEZWNyeXB0b3IoKTtcbiAgICB9XG4gICAgc29mdHdhcmVEZWNyeXB0ZXIuZXhwYW5kS2V5KGtleSk7XG4gICAgY29uc3QgcmVzdWx0ID0gY3VycmVudFJlc3VsdDtcbiAgICB0aGlzLmN1cnJlbnRSZXN1bHQgPSBzb2Z0d2FyZURlY3J5cHRlci5kZWNyeXB0KGN1cnJlbnRDaHVuay5idWZmZXIsIDAsIGl2KTtcbiAgICB0aGlzLmN1cnJlbnRJViA9IHNsaWNlVWludDgoY3VycmVudENodW5rLCAtMTYpLmJ1ZmZlcjtcbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgd2ViQ3J5cHRvRGVjcnlwdChkYXRhLCBrZXksIGl2KSB7XG4gICAgY29uc3Qgc3VidGxlID0gdGhpcy5zdWJ0bGU7XG4gICAgaWYgKHRoaXMua2V5ICE9PSBrZXkgfHwgIXRoaXMuZmFzdEFlc0tleSkge1xuICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICB0aGlzLmZhc3RBZXNLZXkgPSBuZXcgRmFzdEFFU0tleShzdWJ0bGUsIGtleSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZhc3RBZXNLZXkuZXhwYW5kS2V5KCkudGhlbihhZXNLZXkgPT4ge1xuICAgICAgLy8gZGVjcnlwdCB1c2luZyB3ZWIgY3J5cHRvXG4gICAgICBpZiAoIXN1YnRsZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCd3ZWIgY3J5cHRvIG5vdCBpbml0aWFsaXplZCcpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nT25jZSgnV2ViQ3J5cHRvIEFFUyBkZWNyeXB0Jyk7XG4gICAgICBjb25zdCBjcnlwdG8gPSBuZXcgQUVTQ3J5cHRvKHN1YnRsZSwgbmV3IFVpbnQ4QXJyYXkoaXYpKTtcbiAgICAgIHJldHVybiBjcnlwdG8uZGVjcnlwdChkYXRhLmJ1ZmZlciwgYWVzS2V5KTtcbiAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgbG9nZ2VyLndhcm4oYFtkZWNyeXB0ZXJdOiBXZWJDcnlwdG8gRXJyb3IsIGRpc2FibGUgV2ViQ3J5cHRvIEFQSSwgJHtlcnIubmFtZX06ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICByZXR1cm4gdGhpcy5vbldlYkNyeXB0b0Vycm9yKGRhdGEsIGtleSwgaXYpO1xuICAgIH0pO1xuICB9XG4gIG9uV2ViQ3J5cHRvRXJyb3IoZGF0YSwga2V5LCBpdikge1xuICAgIHRoaXMudXNlU29mdHdhcmUgPSB0cnVlO1xuICAgIHRoaXMubG9nRW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5zb2Z0d2FyZURlY3J5cHQoZGF0YSwga2V5LCBpdik7XG4gICAgY29uc3QgZGVjcnlwdFJlc3VsdCA9IHRoaXMuZmx1c2goKTtcbiAgICBpZiAoZGVjcnlwdFJlc3VsdCkge1xuICAgICAgcmV0dXJuIGRlY3J5cHRSZXN1bHQuYnVmZmVyO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYkNyeXB0byBhbmQgc29mdHdhcmVEZWNyeXB0OiBmYWlsZWQgdG8gZGVjcnlwdCBkYXRhJyk7XG4gIH1cbiAgZ2V0VmFsaWRDaHVuayhkYXRhKSB7XG4gICAgbGV0IGN1cnJlbnRDaHVuayA9IGRhdGE7XG4gICAgY29uc3Qgc3BsaXRQb2ludCA9IGRhdGEubGVuZ3RoIC0gZGF0YS5sZW5ndGggJSBDSFVOS19TSVpFO1xuICAgIGlmIChzcGxpdFBvaW50ICE9PSBkYXRhLmxlbmd0aCkge1xuICAgICAgY3VycmVudENodW5rID0gc2xpY2VVaW50OChkYXRhLCAwLCBzcGxpdFBvaW50KTtcbiAgICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IHNsaWNlVWludDgoZGF0YSwgc3BsaXRQb2ludCk7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50Q2h1bms7XG4gIH1cbiAgbG9nT25jZShtc2cpIHtcbiAgICBpZiAoIXRoaXMubG9nRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsb2dnZXIubG9nKGBbZGVjcnlwdGVyXTogJHttc2d9YCk7XG4gICAgdGhpcy5sb2dFbmFibGVkID0gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiAgVGltZVJhbmdlcyB0byBzdHJpbmcgaGVscGVyXG4gKi9cblxuY29uc3QgVGltZVJhbmdlcyA9IHtcbiAgdG9TdHJpbmc6IGZ1bmN0aW9uIChyKSB7XG4gICAgbGV0IGxvZyA9ICcnO1xuICAgIGNvbnN0IGxlbiA9IHIubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGxvZyArPSBgWyR7ci5zdGFydChpKS50b0ZpeGVkKDMpfS0ke3IuZW5kKGkpLnRvRml4ZWQoMyl9XWA7XG4gICAgfVxuICAgIHJldHVybiBsb2c7XG4gIH1cbn07XG5cbmNvbnN0IFN0YXRlID0ge1xuICBTVE9QUEVEOiAnU1RPUFBFRCcsXG4gIElETEU6ICdJRExFJyxcbiAgS0VZX0xPQURJTkc6ICdLRVlfTE9BRElORycsXG4gIEZSQUdfTE9BRElORzogJ0ZSQUdfTE9BRElORycsXG4gIEZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZOiAnRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlknLFxuICBXQUlUSU5HX1RSQUNLOiAnV0FJVElOR19UUkFDSycsXG4gIFBBUlNJTkc6ICdQQVJTSU5HJyxcbiAgUEFSU0VEOiAnUEFSU0VEJyxcbiAgRU5ERUQ6ICdFTkRFRCcsXG4gIEVSUk9SOiAnRVJST1InLFxuICBXQUlUSU5HX0lOSVRfUFRTOiAnV0FJVElOR19JTklUX1BUUycsXG4gIFdBSVRJTkdfTEVWRUw6ICdXQUlUSU5HX0xFVkVMJ1xufTtcbmNsYXNzIEJhc2VTdHJlYW1Db250cm9sbGVyIGV4dGVuZHMgVGFza0xvb3Age1xuICBjb25zdHJ1Y3RvcihobHMsIGZyYWdtZW50VHJhY2tlciwga2V5TG9hZGVyLCBsb2dQcmVmaXgsIHBsYXlsaXN0VHlwZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyID0gdm9pZCAwO1xuICAgIHRoaXMudHJhbnNtdXhlciA9IG51bGw7XG4gICAgdGhpcy5fc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xuICAgIHRoaXMucGxheWxpc3RUeXBlID0gdm9pZCAwO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIHRoaXMubWVkaWFCdWZmZXIgPSBudWxsO1xuICAgIHRoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgIHRoaXMuYml0cmF0ZVRlc3QgPSBmYWxzZTtcbiAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9IDA7XG4gICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gMDtcbiAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSAwO1xuICAgIHRoaXMuc3RhcnRUaW1lT2Zmc2V0ID0gbnVsbDtcbiAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gZmFsc2U7XG4gICAgdGhpcy5yZXRyeURhdGUgPSAwO1xuICAgIHRoaXMubGV2ZWxzID0gbnVsbDtcbiAgICB0aGlzLmZyYWdtZW50TG9hZGVyID0gdm9pZCAwO1xuICAgIHRoaXMua2V5TG9hZGVyID0gdm9pZCAwO1xuICAgIHRoaXMubGV2ZWxMYXN0TG9hZGVkID0gbnVsbDtcbiAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuZGVjcnlwdGVyID0gdm9pZCAwO1xuICAgIHRoaXMuaW5pdFBUUyA9IFtdO1xuICAgIHRoaXMub252c2Vla2luZyA9IG51bGw7XG4gICAgdGhpcy5vbnZlbmRlZCA9IG51bGw7XG4gICAgdGhpcy5sb2dQcmVmaXggPSAnJztcbiAgICB0aGlzLmxvZyA9IHZvaWQgMDtcbiAgICB0aGlzLndhcm4gPSB2b2lkIDA7XG4gICAgdGhpcy5wbGF5bGlzdFR5cGUgPSBwbGF5bGlzdFR5cGU7XG4gICAgdGhpcy5sb2dQcmVmaXggPSBsb2dQcmVmaXg7XG4gICAgdGhpcy5sb2cgPSBsb2dnZXIubG9nLmJpbmQobG9nZ2VyLCBgJHtsb2dQcmVmaXh9OmApO1xuICAgIHRoaXMud2FybiA9IGxvZ2dlci53YXJuLmJpbmQobG9nZ2VyLCBgJHtsb2dQcmVmaXh9OmApO1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMuZnJhZ21lbnRMb2FkZXIgPSBuZXcgRnJhZ21lbnRMb2FkZXIoaGxzLmNvbmZpZyk7XG4gICAgdGhpcy5rZXlMb2FkZXIgPSBrZXlMb2FkZXI7XG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIgPSBmcmFnbWVudFRyYWNrZXI7XG4gICAgdGhpcy5jb25maWcgPSBobHMuY29uZmlnO1xuICAgIHRoaXMuZGVjcnlwdGVyID0gbmV3IERlY3J5cHRlcihobHMuY29uZmlnKTtcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURFRCwgdGhpcy5vbk1hbmlmZXN0TG9hZGVkLCB0aGlzKTtcbiAgfVxuICBkb1RpY2soKSB7XG4gICAgdGhpcy5vblRpY2tFbmQoKTtcbiAgfVxuICBvblRpY2tFbmQoKSB7fVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgc3RhcnRMb2FkKHN0YXJ0UG9zaXRpb24pIHt9XG4gIHN0b3BMb2FkKCkge1xuICAgIHRoaXMuZnJhZ21lbnRMb2FkZXIuYWJvcnQoKTtcbiAgICB0aGlzLmtleUxvYWRlci5hYm9ydCh0aGlzLnBsYXlsaXN0VHlwZSk7XG4gICAgY29uc3QgZnJhZyA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgaWYgKGZyYWcgIT0gbnVsbCAmJiBmcmFnLmxvYWRlcikge1xuICAgICAgZnJhZy5hYm9ydFJlcXVlc3RzKCk7XG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnKTtcbiAgICB9XG4gICAgdGhpcy5yZXNldFRyYW5zbXV4ZXIoKTtcbiAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gICAgdGhpcy5jbGVhckludGVydmFsKCk7XG4gICAgdGhpcy5jbGVhck5leHRUaWNrKCk7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gIH1cbiAgX3N0cmVhbUVuZGVkKGJ1ZmZlckluZm8sIGxldmVsRGV0YWlscykge1xuICAgIC8vIElmIHBsYXlsaXN0IGlzIGxpdmUsIHRoZXJlIGlzIGFub3RoZXIgYnVmZmVyZWQgcmFuZ2UgYWZ0ZXIgdGhlIGN1cnJlbnQgcmFuZ2UsIG5vdGhpbmcgYnVmZmVyZWQsIG1lZGlhIGlzIGRldGFjaGVkLFxuICAgIC8vIG9mIG5vdGhpbmcgbG9hZGluZy9sb2FkZWQgcmV0dXJuIGZhbHNlXG4gICAgaWYgKGxldmVsRGV0YWlscy5saXZlIHx8IGJ1ZmZlckluZm8ubmV4dFN0YXJ0IHx8ICFidWZmZXJJbmZvLmVuZCB8fCAhdGhpcy5tZWRpYSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBwYXJ0TGlzdCA9IGxldmVsRGV0YWlscy5wYXJ0TGlzdDtcbiAgICAvLyBTaW5jZSB0aGUgbGFzdCBwYXJ0IGlzbid0IGd1YXJhbnRlZWQgdG8gY29ycmVzcG9uZCB0byB0aGUgbGFzdCBwbGF5bGlzdCBzZWdtZW50IGZvciBMb3ctTGF0ZW5jeSBITFMsXG4gICAgLy8gY2hlY2sgaW5zdGVhZCBpZiB0aGUgbGFzdCBwYXJ0IGlzIGJ1ZmZlcmVkLlxuICAgIGlmIChwYXJ0TGlzdCAhPSBudWxsICYmIHBhcnRMaXN0Lmxlbmd0aCkge1xuICAgICAgY29uc3QgbGFzdFBhcnQgPSBwYXJ0TGlzdFtwYXJ0TGlzdC5sZW5ndGggLSAxXTtcblxuICAgICAgLy8gQ2hlY2tpbmcgdGhlIG1pZHBvaW50IG9mIHRoZSBwYXJ0IGZvciBwb3RlbnRpYWwgbWFyZ2luIG9mIGVycm9yIGFuZCByZWxhdGVkIGlzc3Vlcy5cbiAgICAgIC8vIE5PVEU6IFRlY2huaWNhbGx5IEkgYmVsaWV2ZSBwYXJ0cyBjb3VsZCB5aWVsZCBjb250ZW50IHRoYXQgaXMgPCB0aGUgY29tcHV0ZWQgZHVyYXRpb24gKGluY2x1ZGluZyBwb3RlbnRpYWwgYSBkdXJhdGlvbiBvZiAwKVxuICAgICAgLy8gYW5kIHN0aWxsIGJlIHNwZWMtY29tcGxpYW50LCBzbyB0aGVyZSBtYXkgc3RpbGwgYmUgZWRnZSBjYXNlcyBoZXJlLiBMaWtld2lzZSwgdGhlcmUgY291bGQgYmUgaXNzdWVzIGluIGVuZCBvZiBzdHJlYW1cbiAgICAgIC8vIHBhcnQgbWlzbWF0Y2hlcyBmb3IgaW5kZXBlbmRlbnQgYXVkaW8gYW5kIHZpZGVvIHBsYXlsaXN0cy9zZWdtZW50cy5cbiAgICAgIGNvbnN0IGxhc3RQYXJ0QnVmZmVyZWQgPSBCdWZmZXJIZWxwZXIuaXNCdWZmZXJlZCh0aGlzLm1lZGlhLCBsYXN0UGFydC5zdGFydCArIGxhc3RQYXJ0LmR1cmF0aW9uIC8gMik7XG4gICAgICByZXR1cm4gbGFzdFBhcnRCdWZmZXJlZDtcbiAgICB9XG4gICAgY29uc3QgcGxheWxpc3RUeXBlID0gbGV2ZWxEZXRhaWxzLmZyYWdtZW50c1tsZXZlbERldGFpbHMuZnJhZ21lbnRzLmxlbmd0aCAtIDFdLnR5cGU7XG4gICAgcmV0dXJuIHRoaXMuZnJhZ21lbnRUcmFja2VyLmlzRW5kTGlzdEFwcGVuZGVkKHBsYXlsaXN0VHlwZSk7XG4gIH1cbiAgZ2V0TGV2ZWxEZXRhaWxzKCkge1xuICAgIGlmICh0aGlzLmxldmVscyAmJiB0aGlzLmxldmVsTGFzdExvYWRlZCAhPT0gbnVsbCkge1xuICAgICAgdmFyIF90aGlzJGxldmVsTGFzdExvYWRlZDtcbiAgICAgIHJldHVybiAoX3RoaXMkbGV2ZWxMYXN0TG9hZGVkID0gdGhpcy5sZXZlbExhc3RMb2FkZWQpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRsZXZlbExhc3RMb2FkZWQuZGV0YWlscztcbiAgICB9XG4gIH1cbiAgb25NZWRpYUF0dGFjaGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA9IGRhdGEubWVkaWE7XG4gICAgdGhpcy5vbnZzZWVraW5nID0gdGhpcy5vbk1lZGlhU2Vla2luZy5iaW5kKHRoaXMpO1xuICAgIHRoaXMub252ZW5kZWQgPSB0aGlzLm9uTWVkaWFFbmRlZC5iaW5kKHRoaXMpO1xuICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ3NlZWtpbmcnLCB0aGlzLm9udnNlZWtpbmcpO1xuICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy5vbnZlbmRlZCk7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgaWYgKHRoaXMubGV2ZWxzICYmIGNvbmZpZy5hdXRvU3RhcnRMb2FkICYmIHRoaXMuc3RhdGUgPT09IFN0YXRlLlNUT1BQRUQpIHtcbiAgICAgIHRoaXMuc3RhcnRMb2FkKGNvbmZpZy5zdGFydFBvc2l0aW9uKTtcbiAgICB9XG4gIH1cbiAgb25NZWRpYURldGFjaGluZygpIHtcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgaWYgKG1lZGlhICE9IG51bGwgJiYgbWVkaWEuZW5kZWQpIHtcbiAgICAgIHRoaXMubG9nKCdNU0UgZGV0YWNoaW5nIGFuZCB2aWRlbyBlbmRlZCwgcmVzZXQgc3RhcnRQb3NpdGlvbicpO1xuICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSB2aWRlbyBsaXN0ZW5lcnNcbiAgICBpZiAobWVkaWEgJiYgdGhpcy5vbnZzZWVraW5nICYmIHRoaXMub252ZW5kZWQpIHtcbiAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlZWtpbmcnLCB0aGlzLm9udnNlZWtpbmcpO1xuICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLm9udmVuZGVkKTtcbiAgICAgIHRoaXMub252c2Vla2luZyA9IHRoaXMub252ZW5kZWQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5rZXlMb2FkZXIpIHtcbiAgICAgIHRoaXMua2V5TG9hZGVyLmRldGFjaCgpO1xuICAgIH1cbiAgICB0aGlzLm1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5sb2FkZWRtZXRhZGF0YSA9IGZhbHNlO1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUFsbEZyYWdtZW50cygpO1xuICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgfVxuICBvbk1lZGlhU2Vla2luZygpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb25maWcsXG4gICAgICBmcmFnQ3VycmVudCxcbiAgICAgIG1lZGlhLFxuICAgICAgbWVkaWFCdWZmZXIsXG4gICAgICBzdGF0ZVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbWVkaWEgPyBtZWRpYS5jdXJyZW50VGltZSA6IDA7XG4gICAgY29uc3QgYnVmZmVySW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKG1lZGlhQnVmZmVyID8gbWVkaWFCdWZmZXIgOiBtZWRpYSwgY3VycmVudFRpbWUsIGNvbmZpZy5tYXhCdWZmZXJIb2xlKTtcbiAgICB0aGlzLmxvZyhgbWVkaWEgc2Vla2luZyB0byAke2lzRmluaXRlTnVtYmVyKGN1cnJlbnRUaW1lKSA/IGN1cnJlbnRUaW1lLnRvRml4ZWQoMykgOiBjdXJyZW50VGltZX0sIHN0YXRlOiAke3N0YXRlfWApO1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5FTkRFRCkge1xuICAgICAgdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpO1xuICAgIH0gZWxzZSBpZiAoZnJhZ0N1cnJlbnQpIHtcbiAgICAgIC8vIFNlZWtpbmcgd2hpbGUgZnJhZyBsb2FkIGlzIGluIHByb2dyZXNzXG4gICAgICBjb25zdCB0b2xlcmFuY2UgPSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZTtcbiAgICAgIGNvbnN0IGZyYWdTdGFydE9mZnNldCA9IGZyYWdDdXJyZW50LnN0YXJ0IC0gdG9sZXJhbmNlO1xuICAgICAgY29uc3QgZnJhZ0VuZE9mZnNldCA9IGZyYWdDdXJyZW50LnN0YXJ0ICsgZnJhZ0N1cnJlbnQuZHVyYXRpb24gKyB0b2xlcmFuY2U7XG4gICAgICAvLyBpZiBzZWVraW5nIG91dCBvZiBidWZmZXJlZCByYW5nZSBvciBpbnRvIG5ldyBvbmVcbiAgICAgIGlmICghYnVmZmVySW5mby5sZW4gfHwgZnJhZ0VuZE9mZnNldCA8IGJ1ZmZlckluZm8uc3RhcnQgfHwgZnJhZ1N0YXJ0T2Zmc2V0ID4gYnVmZmVySW5mby5lbmQpIHtcbiAgICAgICAgY29uc3QgcGFzdEZyYWdtZW50ID0gY3VycmVudFRpbWUgPiBmcmFnRW5kT2Zmc2V0O1xuICAgICAgICAvLyBpZiB0aGUgc2VlayBwb3NpdGlvbiBpcyBvdXRzaWRlIHRoZSBjdXJyZW50IGZyYWdtZW50IHJhbmdlXG4gICAgICAgIGlmIChjdXJyZW50VGltZSA8IGZyYWdTdGFydE9mZnNldCB8fCBwYXN0RnJhZ21lbnQpIHtcbiAgICAgICAgICBpZiAocGFzdEZyYWdtZW50ICYmIGZyYWdDdXJyZW50LmxvYWRlcikge1xuICAgICAgICAgICAgdGhpcy5sb2coJ3NlZWtpbmcgb3V0c2lkZSBvZiBidWZmZXIgd2hpbGUgZnJhZ21lbnQgbG9hZCBpbiBwcm9ncmVzcywgY2FuY2VsIGZyYWdtZW50IGxvYWQnKTtcbiAgICAgICAgICAgIGZyYWdDdXJyZW50LmFib3J0UmVxdWVzdHMoKTtcbiAgICAgICAgICAgIHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtZWRpYSkge1xuICAgICAgLy8gUmVtb3ZlIGdhcCBmcmFnbWVudHNcbiAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50c0luUmFuZ2UoY3VycmVudFRpbWUsIEluZmluaXR5LCB0aGlzLnBsYXlsaXN0VHlwZSwgdHJ1ZSk7XG4gICAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIH1cblxuICAgIC8vIGluIGNhc2Ugc2Vla2luZyBvY2N1cnMgYWx0aG91Z2ggbm8gbWVkaWEgYnVmZmVyZWQsIGFkanVzdCBzdGFydFBvc2l0aW9uIGFuZCBuZXh0TG9hZFBvc2l0aW9uIHRvIHNlZWsgdGFyZ2V0XG4gICAgaWYgKCF0aGlzLmxvYWRlZG1ldGFkYXRhICYmICFidWZmZXJJbmZvLmxlbikge1xuICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uID0gY3VycmVudFRpbWU7XG4gICAgfVxuXG4gICAgLy8gQXN5bmMgdGljayB0byBzcGVlZCB1cCBwcm9jZXNzaW5nXG4gICAgdGhpcy50aWNrSW1tZWRpYXRlKCk7XG4gIH1cbiAgb25NZWRpYUVuZGVkKCkge1xuICAgIC8vIHJlc2V0IHN0YXJ0UG9zaXRpb24gYW5kIGxhc3RDdXJyZW50VGltZSB0byByZXN0YXJ0IHBsYXliYWNrIEAgc3RyZWFtIGJlZ2lubmluZ1xuICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gMDtcbiAgfVxuICBvbk1hbmlmZXN0TG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5zdGFydFRpbWVPZmZzZXQgPSBkYXRhLnN0YXJ0VGltZU9mZnNldDtcbiAgICB0aGlzLmluaXRQVFMgPSBbXTtcbiAgfVxuICBvbkhhbmRsZXJEZXN0cm95aW5nKCkge1xuICAgIHRoaXMuaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BREVELCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQsIHRoaXMpO1xuICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICBzdXBlci5vbkhhbmRsZXJEZXN0cm95aW5nKCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuaGxzID0gbnVsbDtcbiAgfVxuICBvbkhhbmRsZXJEZXN0cm95ZWQoKSB7XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlNUT1BQRUQ7XG4gICAgaWYgKHRoaXMuZnJhZ21lbnRMb2FkZXIpIHtcbiAgICAgIHRoaXMuZnJhZ21lbnRMb2FkZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5rZXlMb2FkZXIpIHtcbiAgICAgIHRoaXMua2V5TG9hZGVyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGVjcnlwdGVyKSB7XG4gICAgICB0aGlzLmRlY3J5cHRlci5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuaGxzID0gdGhpcy5sb2cgPSB0aGlzLndhcm4gPSB0aGlzLmRlY3J5cHRlciA9IHRoaXMua2V5TG9hZGVyID0gdGhpcy5mcmFnbWVudExvYWRlciA9IHRoaXMuZnJhZ21lbnRUcmFja2VyID0gbnVsbDtcbiAgICBzdXBlci5vbkhhbmRsZXJEZXN0cm95ZWQoKTtcbiAgfVxuICBsb2FkRnJhZ21lbnQoZnJhZywgbGV2ZWwsIHRhcmdldEJ1ZmZlclRpbWUpIHtcbiAgICB0aGlzLl9sb2FkRnJhZ0ZvclBsYXliYWNrKGZyYWcsIGxldmVsLCB0YXJnZXRCdWZmZXJUaW1lKTtcbiAgfVxuICBfbG9hZEZyYWdGb3JQbGF5YmFjayhmcmFnLCBsZXZlbCwgdGFyZ2V0QnVmZmVyVGltZSkge1xuICAgIGNvbnN0IHByb2dyZXNzQ2FsbGJhY2sgPSBkYXRhID0+IHtcbiAgICAgIGlmICh0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSkge1xuICAgICAgICB0aGlzLndhcm4oYEZyYWdtZW50ICR7ZnJhZy5zbn0ke2RhdGEucGFydCA/ICcgcDogJyArIGRhdGEucGFydC5pbmRleCA6ICcnfSBvZiBsZXZlbCAke2ZyYWcubGV2ZWx9IHdhcyBkcm9wcGVkIGR1cmluZyBkb3dubG9hZC5gKTtcbiAgICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZyYWcuc3RhdHMuY2h1bmtDb3VudCsrO1xuICAgICAgdGhpcy5faGFuZGxlRnJhZ21lbnRMb2FkUHJvZ3Jlc3MoZGF0YSk7XG4gICAgfTtcbiAgICB0aGlzLl9kb0ZyYWdMb2FkKGZyYWcsIGxldmVsLCB0YXJnZXRCdWZmZXJUaW1lLCBwcm9ncmVzc0NhbGxiYWNrKS50aGVuKGRhdGEgPT4ge1xuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIC8vIGlmIHdlJ3JlIGhlcmUgd2UgcHJvYmFibHkgbmVlZGVkIHRvIGJhY2t0cmFjayBvciBhcmUgd2FpdGluZyBmb3IgbW9yZSBwYXJ0c1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICBpZiAodGhpcy5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykpIHtcbiAgICAgICAgaWYgKHN0YXRlID09PSBTdGF0ZS5GUkFHX0xPQURJTkcgfHwgIXRoaXMuZnJhZ0N1cnJlbnQgJiYgc3RhdGUgPT09IFN0YXRlLlBBUlNJTkcpIHtcbiAgICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnKTtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoJ3BheWxvYWQnIGluIGRhdGEpIHtcbiAgICAgICAgdGhpcy5sb2coYExvYWRlZCBmcmFnbWVudCAke2ZyYWcuc259IG9mIGxldmVsICR7ZnJhZy5sZXZlbH1gKTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRlJBR19MT0FERUQsIGRhdGEpO1xuICAgICAgfVxuXG4gICAgICAvLyBQYXNzIHRocm91Z2ggdGhlIHdob2xlIHBheWxvYWQ7IGNvbnRyb2xsZXJzIG5vdCBpbXBsZW1lbnRpbmcgcHJvZ3Jlc3NpdmUgbG9hZGluZyByZWNlaXZlIGRhdGEgZnJvbSB0aGlzIGNhbGxiYWNrXG4gICAgICB0aGlzLl9oYW5kbGVGcmFnbWVudExvYWRDb21wbGV0ZShkYXRhKTtcbiAgICB9KS5jYXRjaChyZWFzb24gPT4ge1xuICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLlNUT1BQRUQgfHwgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuRVJST1IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy53YXJuKHJlYXNvbik7XG4gICAgICB0aGlzLnJlc2V0RnJhZ21lbnRMb2FkaW5nKGZyYWcpO1xuICAgIH0pO1xuICB9XG4gIGNsZWFyVHJhY2tlcklmTmVlZGVkKGZyYWcpIHtcbiAgICB2YXIgX3RoaXMkbWVkaWFCdWZmZXI7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZ21lbnRUcmFja2VyXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgZnJhZ1N0YXRlID0gZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKGZyYWcpO1xuICAgIGlmIChmcmFnU3RhdGUgPT09IEZyYWdtZW50U3RhdGUuQVBQRU5ESU5HKSB7XG4gICAgICAvLyBMb3dlciB0aGUgYnVmZmVyIHNpemUgYW5kIHRyeSBhZ2FpblxuICAgICAgY29uc3QgcGxheWxpc3RUeXBlID0gZnJhZy50eXBlO1xuICAgICAgY29uc3QgYnVmZmVyZWRJbmZvID0gdGhpcy5nZXRGd2RCdWZmZXJJbmZvKHRoaXMubWVkaWFCdWZmZXIsIHBsYXlsaXN0VHlwZSk7XG4gICAgICBjb25zdCBtaW5Gb3J3YXJkQnVmZmVyTGVuZ3RoID0gTWF0aC5tYXgoZnJhZy5kdXJhdGlvbiwgYnVmZmVyZWRJbmZvID8gYnVmZmVyZWRJbmZvLmxlbiA6IHRoaXMuY29uZmlnLm1heEJ1ZmZlckxlbmd0aCk7XG4gICAgICBpZiAodGhpcy5yZWR1Y2VNYXhCdWZmZXJMZW5ndGgobWluRm9yd2FyZEJ1ZmZlckxlbmd0aCkpIHtcbiAgICAgICAgZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWcpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoKChfdGhpcyRtZWRpYUJ1ZmZlciA9IHRoaXMubWVkaWFCdWZmZXIpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRtZWRpYUJ1ZmZlci5idWZmZXJlZC5sZW5ndGgpID09PSAwKSB7XG4gICAgICAvLyBTdG9wIGdhcCBmb3IgYmFkIHRyYWNrZXIgLyBidWZmZXIgZmx1c2ggYmVoYXZpb3JcbiAgICAgIGZyYWdtZW50VHJhY2tlci5yZW1vdmVBbGxGcmFnbWVudHMoKTtcbiAgICB9IGVsc2UgaWYgKGZyYWdtZW50VHJhY2tlci5oYXNQYXJ0cyhmcmFnLnR5cGUpKSB7XG4gICAgICAvLyBJbiBsb3cgbGF0ZW5jeSBtb2RlLCByZW1vdmUgZnJhZ21lbnRzIGZvciB3aGljaCBvbmx5IHNvbWUgcGFydHMgd2VyZSBidWZmZXJlZFxuICAgICAgZnJhZ21lbnRUcmFja2VyLmRldGVjdFBhcnRpYWxGcmFnbWVudHMoe1xuICAgICAgICBmcmFnLFxuICAgICAgICBwYXJ0OiBudWxsLFxuICAgICAgICBzdGF0czogZnJhZy5zdGF0cyxcbiAgICAgICAgaWQ6IGZyYWcudHlwZVxuICAgICAgfSk7XG4gICAgICBpZiAoZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKGZyYWcpID09PSBGcmFnbWVudFN0YXRlLlBBUlRJQUwpIHtcbiAgICAgICAgZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjaGVja0xpdmVVcGRhdGUoZGV0YWlscykge1xuICAgIGlmIChkZXRhaWxzLnVwZGF0ZWQgJiYgIWRldGFpbHMubGl2ZSkge1xuICAgICAgLy8gTGl2ZSBzdHJlYW0gZW5kZWQsIHVwZGF0ZSBmcmFnbWVudCB0cmFja2VyXG4gICAgICBjb25zdCBsYXN0RnJhZ21lbnQgPSBkZXRhaWxzLmZyYWdtZW50c1tkZXRhaWxzLmZyYWdtZW50cy5sZW5ndGggLSAxXTtcbiAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLmRldGVjdFBhcnRpYWxGcmFnbWVudHMoe1xuICAgICAgICBmcmFnOiBsYXN0RnJhZ21lbnQsXG4gICAgICAgIHBhcnQ6IG51bGwsXG4gICAgICAgIHN0YXRzOiBsYXN0RnJhZ21lbnQuc3RhdHMsXG4gICAgICAgIGlkOiBsYXN0RnJhZ21lbnQudHlwZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghZGV0YWlscy5mcmFnbWVudHNbMF0pIHtcbiAgICAgIGRldGFpbHMuZGVsdGFVcGRhdGVGYWlsZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBmbHVzaE1haW5CdWZmZXIoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCwgdHlwZSA9IG51bGwpIHtcbiAgICBpZiAoIShzdGFydE9mZnNldCAtIGVuZE9mZnNldCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gV2hlbiBhbHRlcm5hdGUgYXVkaW8gaXMgcGxheWluZywgdGhlIGF1ZGlvLXN0cmVhbS1jb250cm9sbGVyIGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgYXVkaW8gYnVmZmVyLiBPdGhlcndpc2UsXG4gICAgLy8gcGFzc2luZyBhIG51bGwgdHlwZSBmbHVzaGVzIGJvdGggYnVmZmVyc1xuICAgIGNvbnN0IGZsdXNoU2NvcGUgPSB7XG4gICAgICBzdGFydE9mZnNldCxcbiAgICAgIGVuZE9mZnNldCxcbiAgICAgIHR5cGVcbiAgICB9O1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9GTFVTSElORywgZmx1c2hTY29wZSk7XG4gIH1cbiAgX2xvYWRJbml0U2VnbWVudChmcmFnLCBsZXZlbCkge1xuICAgIHRoaXMuX2RvRnJhZ0xvYWQoZnJhZywgbGV2ZWwpLnRoZW4oZGF0YSA9PiB7XG4gICAgICBpZiAoIWRhdGEgfHwgdGhpcy5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykgfHwgIXRoaXMubGV2ZWxzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW5pdCBsb2FkIGFib3J0ZWQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0pLnRoZW4oZGF0YSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGhsc1xuICAgICAgfSA9IHRoaXM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBheWxvYWRcbiAgICAgIH0gPSBkYXRhO1xuICAgICAgY29uc3QgZGVjcnlwdERhdGEgPSBmcmFnLmRlY3J5cHRkYXRhO1xuXG4gICAgICAvLyBjaGVjayB0byBzZWUgaWYgdGhlIHBheWxvYWQgbmVlZHMgdG8gYmUgZGVjcnlwdGVkXG4gICAgICBpZiAocGF5bG9hZCAmJiBwYXlsb2FkLmJ5dGVMZW5ndGggPiAwICYmIGRlY3J5cHREYXRhICE9IG51bGwgJiYgZGVjcnlwdERhdGEua2V5ICYmIGRlY3J5cHREYXRhLml2ICYmIGRlY3J5cHREYXRhLm1ldGhvZCA9PT0gJ0FFUy0xMjgnKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIC8vIGRlY3J5cHQgaW5pdCBzZWdtZW50IGRhdGFcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjcnlwdGVyLmRlY3J5cHQobmV3IFVpbnQ4QXJyYXkocGF5bG9hZCksIGRlY3J5cHREYXRhLmtleS5idWZmZXIsIGRlY3J5cHREYXRhLml2LmJ1ZmZlcikuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19ERUNSWVBUX0VSUk9SLFxuICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IGVycixcbiAgICAgICAgICAgIHJlYXNvbjogZXJyLm1lc3NhZ2UsXG4gICAgICAgICAgICBmcmFnXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9KS50aGVuKGRlY3J5cHRlZERhdGEgPT4ge1xuICAgICAgICAgIGNvbnN0IGVuZFRpbWUgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX0RFQ1JZUFRFRCwge1xuICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgIHBheWxvYWQ6IGRlY3J5cHRlZERhdGEsXG4gICAgICAgICAgICBzdGF0czoge1xuICAgICAgICAgICAgICB0c3RhcnQ6IHN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgdGRlY3J5cHQ6IGVuZFRpbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkYXRhLnBheWxvYWQgPSBkZWNyeXB0ZWREYXRhO1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlSW5pdFNlZ21lbnRMb2FkKGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlSW5pdFNlZ21lbnRMb2FkKGRhdGEpO1xuICAgIH0pLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuU1RPUFBFRCB8fCB0aGlzLnN0YXRlID09PSBTdGF0ZS5FUlJPUikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLndhcm4ocmVhc29uKTtcbiAgICAgIHRoaXMucmVzZXRGcmFnbWVudExvYWRpbmcoZnJhZyk7XG4gICAgfSk7XG4gIH1cbiAgY29tcGxldGVJbml0U2VnbWVudExvYWQoZGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGxldmVsc1xuICAgIH0gPSB0aGlzO1xuICAgIGlmICghbGV2ZWxzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luaXQgbG9hZCBhYm9ydGVkLCBtaXNzaW5nIGxldmVscycpO1xuICAgIH1cbiAgICBjb25zdCBzdGF0cyA9IGRhdGEuZnJhZy5zdGF0cztcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICBkYXRhLmZyYWcuZGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGEucGF5bG9hZCk7XG4gICAgc3RhdHMucGFyc2luZy5zdGFydCA9IHN0YXRzLmJ1ZmZlcmluZy5zdGFydCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgc3RhdHMucGFyc2luZy5lbmQgPSBzdGF0cy5idWZmZXJpbmcuZW5kID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICB0aGlzLnRpY2soKTtcbiAgfVxuICBmcmFnQ29udGV4dENoYW5nZWQoZnJhZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGZyYWdDdXJyZW50XG4gICAgfSA9IHRoaXM7XG4gICAgcmV0dXJuICFmcmFnIHx8ICFmcmFnQ3VycmVudCB8fCBmcmFnLnNuICE9PSBmcmFnQ3VycmVudC5zbiB8fCBmcmFnLmxldmVsICE9PSBmcmFnQ3VycmVudC5sZXZlbDtcbiAgfVxuICBmcmFnQnVmZmVyZWRDb21wbGV0ZShmcmFnLCBwYXJ0KSB7XG4gICAgdmFyIF9mcmFnJHN0YXJ0UFRTLCBfZnJhZyRlbmRQVFMsIF90aGlzJGZyYWdDdXJyZW50LCBfdGhpcyRmcmFnUHJldmlvdXM7XG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IHRoaXMubWVkaWE7XG4gICAgdGhpcy5sb2coYEJ1ZmZlcmVkICR7ZnJhZy50eXBlfSBzbjogJHtmcmFnLnNufSR7cGFydCA/ICcgcGFydDogJyArIHBhcnQuaW5kZXggOiAnJ30gb2YgJHt0aGlzLnBsYXlsaXN0VHlwZSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTiA/ICdsZXZlbCcgOiAndHJhY2snfSAke2ZyYWcubGV2ZWx9IChmcmFnOlskeygoX2ZyYWckc3RhcnRQVFMgPSBmcmFnLnN0YXJ0UFRTKSAhPSBudWxsID8gX2ZyYWckc3RhcnRQVFMgOiBOYU4pLnRvRml4ZWQoMyl9LSR7KChfZnJhZyRlbmRQVFMgPSBmcmFnLmVuZFBUUykgIT0gbnVsbCA/IF9mcmFnJGVuZFBUUyA6IE5hTikudG9GaXhlZCgzKX1dID4gYnVmZmVyOiR7bWVkaWEgPyBUaW1lUmFuZ2VzLnRvU3RyaW5nKEJ1ZmZlckhlbHBlci5nZXRCdWZmZXJlZChtZWRpYSkpIDogJyhkZXRhY2hlZCknfSlgKTtcbiAgICBpZiAoZnJhZy5zbiAhPT0gJ2luaXRTZWdtZW50Jykge1xuICAgICAgdmFyIF90aGlzJGxldmVscztcbiAgICAgIGlmIChmcmFnLnR5cGUgIT09IFBsYXlsaXN0TGV2ZWxUeXBlLlNVQlRJVExFKSB7XG4gICAgICAgIGNvbnN0IGVsID0gZnJhZy5lbGVtZW50YXJ5U3RyZWFtcztcbiAgICAgICAgaWYgKCFPYmplY3Qua2V5cyhlbCkuc29tZSh0eXBlID0+ICEhZWxbdHlwZV0pKSB7XG4gICAgICAgICAgLy8gZW1wdHkgc2VnbWVudFxuICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgbGV2ZWwgPSAoX3RoaXMkbGV2ZWxzID0gdGhpcy5sZXZlbHMpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRsZXZlbHNbZnJhZy5sZXZlbF07XG4gICAgICBpZiAobGV2ZWwgIT0gbnVsbCAmJiBsZXZlbC5mcmFnbWVudEVycm9yKSB7XG4gICAgICAgIHRoaXMubG9nKGBSZXNldHRpbmcgbGV2ZWwgZnJhZ21lbnQgZXJyb3IgY291bnQgb2YgJHtsZXZlbC5mcmFnbWVudEVycm9yfSBvbiBmcmFnIGJ1ZmZlcmVkYCk7XG4gICAgICAgIGxldmVsLmZyYWdtZW50RXJyb3IgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICBpZiAoIW1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5sb2FkZWRtZXRhZGF0YSAmJiBmcmFnLnR5cGUgPT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTiAmJiBtZWRpYS5idWZmZXJlZC5sZW5ndGggJiYgKChfdGhpcyRmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRmcmFnQ3VycmVudC5zbikgPT09ICgoX3RoaXMkZnJhZ1ByZXZpb3VzID0gdGhpcy5mcmFnUHJldmlvdXMpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRmcmFnUHJldmlvdXMuc24pKSB7XG4gICAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gdHJ1ZTtcbiAgICAgIHRoaXMuc2Vla1RvU3RhcnRQb3MoKTtcbiAgICB9XG4gICAgdGhpcy50aWNrKCk7XG4gIH1cbiAgc2Vla1RvU3RhcnRQb3MoKSB7fVxuICBfaGFuZGxlRnJhZ21lbnRMb2FkQ29tcGxldGUoZnJhZ0xvYWRlZEVuZERhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICB0cmFuc211eGVyXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCF0cmFuc211eGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGZyYWcsXG4gICAgICBwYXJ0LFxuICAgICAgcGFydHNMb2FkZWRcbiAgICB9ID0gZnJhZ0xvYWRlZEVuZERhdGE7XG4gICAgLy8gSWYgd2UgZGlkIG5vdCBsb2FkIHBhcnRzLCBvciBsb2FkZWQgYWxsIHBhcnRzLCB3ZSBoYXZlIGNvbXBsZXRlIChub3QgcGFydGlhbCkgZnJhZ21lbnQgZGF0YVxuICAgIGNvbnN0IGNvbXBsZXRlID0gIXBhcnRzTG9hZGVkIHx8IHBhcnRzTG9hZGVkLmxlbmd0aCA9PT0gMCB8fCBwYXJ0c0xvYWRlZC5zb21lKGZyYWdMb2FkZWQgPT4gIWZyYWdMb2FkZWQpO1xuICAgIGNvbnN0IGNodW5rTWV0YSA9IG5ldyBDaHVua01ldGFkYXRhKGZyYWcubGV2ZWwsIGZyYWcuc24sIGZyYWcuc3RhdHMuY2h1bmtDb3VudCArIDEsIDAsIHBhcnQgPyBwYXJ0LmluZGV4IDogLTEsICFjb21wbGV0ZSk7XG4gICAgdHJhbnNtdXhlci5mbHVzaChjaHVua01ldGEpO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICBfaGFuZGxlRnJhZ21lbnRMb2FkUHJvZ3Jlc3MoZnJhZykge31cbiAgX2RvRnJhZ0xvYWQoZnJhZywgbGV2ZWwsIHRhcmdldEJ1ZmZlclRpbWUgPSBudWxsLCBwcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgdmFyIF9mcmFnJGRlY3J5cHRkYXRhO1xuICAgIGNvbnN0IGRldGFpbHMgPSBsZXZlbCA9PSBudWxsID8gdm9pZCAwIDogbGV2ZWwuZGV0YWlscztcbiAgICBpZiAoIXRoaXMubGV2ZWxzIHx8ICFkZXRhaWxzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGZyYWcgbG9hZCBhYm9ydGVkLCBtaXNzaW5nIGxldmVsJHtkZXRhaWxzID8gJycgOiAnIGRldGFpbCd9c2ApO1xuICAgIH1cbiAgICBsZXQga2V5TG9hZGluZ1Byb21pc2UgPSBudWxsO1xuICAgIGlmIChmcmFnLmVuY3J5cHRlZCAmJiAhKChfZnJhZyRkZWNyeXB0ZGF0YSA9IGZyYWcuZGVjcnlwdGRhdGEpICE9IG51bGwgJiYgX2ZyYWckZGVjcnlwdGRhdGEua2V5KSkge1xuICAgICAgdGhpcy5sb2coYExvYWRpbmcga2V5IGZvciAke2ZyYWcuc259IG9mIFske2RldGFpbHMuc3RhcnRTTn0tJHtkZXRhaWxzLmVuZFNOfV0sICR7dGhpcy5sb2dQcmVmaXggPT09ICdbc3RyZWFtLWNvbnRyb2xsZXJdJyA/ICdsZXZlbCcgOiAndHJhY2snfSAke2ZyYWcubGV2ZWx9YCk7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuS0VZX0xPQURJTkc7XG4gICAgICB0aGlzLmZyYWdDdXJyZW50ID0gZnJhZztcbiAgICAgIGtleUxvYWRpbmdQcm9taXNlID0gdGhpcy5rZXlMb2FkZXIubG9hZChmcmFnKS50aGVuKGtleUxvYWRlZERhdGEgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGtleUxvYWRlZERhdGEuZnJhZykpIHtcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5LRVlfTE9BREVELCBrZXlMb2FkZWREYXRhKTtcbiAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuS0VZX0xPQURJTkcpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ga2V5TG9hZGVkRGF0YTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5LRVlfTE9BRElORywge1xuICAgICAgICBmcmFnXG4gICAgICB9KTtcbiAgICAgIGlmICh0aGlzLmZyYWdDdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgIGtleUxvYWRpbmdQcm9taXNlID0gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBmcmFnIGxvYWQgYWJvcnRlZCwgY29udGV4dCBjaGFuZ2VkIGluIEtFWV9MT0FESU5HYCkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWZyYWcuZW5jcnlwdGVkICYmIGRldGFpbHMuZW5jcnlwdGVkRnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgdGhpcy5rZXlMb2FkZXIubG9hZENsZWFyKGZyYWcsIGRldGFpbHMuZW5jcnlwdGVkRnJhZ21lbnRzKTtcbiAgICB9XG4gICAgdGFyZ2V0QnVmZmVyVGltZSA9IE1hdGgubWF4KGZyYWcuc3RhcnQsIHRhcmdldEJ1ZmZlclRpbWUgfHwgMCk7XG4gICAgaWYgKHRoaXMuY29uZmlnLmxvd0xhdGVuY3lNb2RlICYmIGZyYWcuc24gIT09ICdpbml0U2VnbWVudCcpIHtcbiAgICAgIGNvbnN0IHBhcnRMaXN0ID0gZGV0YWlscy5wYXJ0TGlzdDtcbiAgICAgIGlmIChwYXJ0TGlzdCAmJiBwcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0YXJnZXRCdWZmZXJUaW1lID4gZnJhZy5lbmQgJiYgZGV0YWlscy5mcmFnbWVudEhpbnQpIHtcbiAgICAgICAgICBmcmFnID0gZGV0YWlscy5mcmFnbWVudEhpbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFydEluZGV4ID0gdGhpcy5nZXROZXh0UGFydChwYXJ0TGlzdCwgZnJhZywgdGFyZ2V0QnVmZmVyVGltZSk7XG4gICAgICAgIGlmIChwYXJ0SW5kZXggPiAtMSkge1xuICAgICAgICAgIGNvbnN0IHBhcnQgPSBwYXJ0TGlzdFtwYXJ0SW5kZXhdO1xuICAgICAgICAgIHRoaXMubG9nKGBMb2FkaW5nIHBhcnQgc246ICR7ZnJhZy5zbn0gcDogJHtwYXJ0LmluZGV4fSBjYzogJHtmcmFnLmNjfSBvZiBwbGF5bGlzdCBbJHtkZXRhaWxzLnN0YXJ0U059LSR7ZGV0YWlscy5lbmRTTn1dIHBhcnRzIFswLSR7cGFydEluZGV4fS0ke3BhcnRMaXN0Lmxlbmd0aCAtIDF9XSAke3RoaXMubG9nUHJlZml4ID09PSAnW3N0cmVhbS1jb250cm9sbGVyXScgPyAnbGV2ZWwnIDogJ3RyYWNrJ306ICR7ZnJhZy5sZXZlbH0sIHRhcmdldDogJHtwYXJzZUZsb2F0KHRhcmdldEJ1ZmZlclRpbWUudG9GaXhlZCgzKSl9YCk7XG4gICAgICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gcGFydC5zdGFydCArIHBhcnQuZHVyYXRpb247XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkZSQUdfTE9BRElORztcbiAgICAgICAgICBsZXQgX3Jlc3VsdDtcbiAgICAgICAgICBpZiAoa2V5TG9hZGluZ1Byb21pc2UpIHtcbiAgICAgICAgICAgIF9yZXN1bHQgPSBrZXlMb2FkaW5nUHJvbWlzZS50aGVuKGtleUxvYWRlZERhdGEgPT4ge1xuICAgICAgICAgICAgICBpZiAoIWtleUxvYWRlZERhdGEgfHwgdGhpcy5mcmFnQ29udGV4dENoYW5nZWQoa2V5TG9hZGVkRGF0YS5mcmFnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmRvRnJhZ1BhcnRzTG9hZChmcmFnLCBwYXJ0LCBsZXZlbCwgcHJvZ3Jlc3NDYWxsYmFjayk7XG4gICAgICAgICAgICB9KS5jYXRjaChlcnJvciA9PiB0aGlzLmhhbmRsZUZyYWdMb2FkRXJyb3IoZXJyb3IpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3Jlc3VsdCA9IHRoaXMuZG9GcmFnUGFydHNMb2FkKGZyYWcsIHBhcnQsIGxldmVsLCBwcm9ncmVzc0NhbGxiYWNrKS5jYXRjaChlcnJvciA9PiB0aGlzLmhhbmRsZUZyYWdMb2FkRXJyb3IoZXJyb3IpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRlJBR19MT0FESU5HLCB7XG4gICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgcGFydCxcbiAgICAgICAgICAgIHRhcmdldEJ1ZmZlclRpbWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAodGhpcy5mcmFnQ3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgZnJhZyBsb2FkIGFib3J0ZWQsIGNvbnRleHQgY2hhbmdlZCBpbiBGUkFHX0xPQURJTkcgcGFydHNgKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBfcmVzdWx0O1xuICAgICAgICB9IGVsc2UgaWYgKCFmcmFnLnVybCB8fCB0aGlzLmxvYWRlZEVuZE9mUGFydHMocGFydExpc3QsIHRhcmdldEJ1ZmZlclRpbWUpKSB7XG4gICAgICAgICAgLy8gRnJhZ21lbnQgaGludCBoYXMgbm8gcGFydHNcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubG9nKGBMb2FkaW5nIGZyYWdtZW50ICR7ZnJhZy5zbn0gY2M6ICR7ZnJhZy5jY30gJHtkZXRhaWxzID8gJ29mIFsnICsgZGV0YWlscy5zdGFydFNOICsgJy0nICsgZGV0YWlscy5lbmRTTiArICddICcgOiAnJ30ke3RoaXMubG9nUHJlZml4ID09PSAnW3N0cmVhbS1jb250cm9sbGVyXScgPyAnbGV2ZWwnIDogJ3RyYWNrJ306ICR7ZnJhZy5sZXZlbH0sIHRhcmdldDogJHtwYXJzZUZsb2F0KHRhcmdldEJ1ZmZlclRpbWUudG9GaXhlZCgzKSl9YCk7XG4gICAgLy8gRG9uJ3QgdXBkYXRlIG5leHRMb2FkUG9zaXRpb24gZm9yIGZyYWdtZW50cyB3aGljaCBhcmUgbm90IGJ1ZmZlcmVkXG4gICAgaWYgKGlzRmluaXRlTnVtYmVyKGZyYWcuc24pICYmICF0aGlzLmJpdHJhdGVUZXN0KSB7XG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBmcmFnLnN0YXJ0ICsgZnJhZy5kdXJhdGlvbjtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkZSQUdfTE9BRElORztcblxuICAgIC8vIExvYWQga2V5IGJlZm9yZSBzdHJlYW1pbmcgZnJhZ21lbnQgZGF0YVxuICAgIGNvbnN0IGRhdGFPblByb2dyZXNzID0gdGhpcy5jb25maWcucHJvZ3Jlc3NpdmU7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBpZiAoZGF0YU9uUHJvZ3Jlc3MgJiYga2V5TG9hZGluZ1Byb21pc2UpIHtcbiAgICAgIHJlc3VsdCA9IGtleUxvYWRpbmdQcm9taXNlLnRoZW4oa2V5TG9hZGVkRGF0YSA9PiB7XG4gICAgICAgIGlmICgha2V5TG9hZGVkRGF0YSB8fCB0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChrZXlMb2FkZWREYXRhID09IG51bGwgPyB2b2lkIDAgOiBrZXlMb2FkZWREYXRhLmZyYWcpKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZnJhZ21lbnRMb2FkZXIubG9hZChmcmFnLCBwcm9ncmVzc0NhbGxiYWNrKTtcbiAgICAgIH0pLmNhdGNoKGVycm9yID0+IHRoaXMuaGFuZGxlRnJhZ0xvYWRFcnJvcihlcnJvcikpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBsb2FkIHVuZW5jcnlwdGVkIGZyYWdtZW50IGRhdGEgd2l0aCBwcm9ncmVzcyBldmVudCxcbiAgICAgIC8vIG9yIGhhbmRsZSBmcmFnbWVudCByZXN1bHQgYWZ0ZXIga2V5IGFuZCBmcmFnbWVudCBhcmUgZmluaXNoZWQgbG9hZGluZ1xuICAgICAgcmVzdWx0ID0gUHJvbWlzZS5hbGwoW3RoaXMuZnJhZ21lbnRMb2FkZXIubG9hZChmcmFnLCBkYXRhT25Qcm9ncmVzcyA/IHByb2dyZXNzQ2FsbGJhY2sgOiB1bmRlZmluZWQpLCBrZXlMb2FkaW5nUHJvbWlzZV0pLnRoZW4oKFtmcmFnTG9hZGVkRGF0YV0pID0+IHtcbiAgICAgICAgaWYgKCFkYXRhT25Qcm9ncmVzcyAmJiBmcmFnTG9hZGVkRGF0YSAmJiBwcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgICAgICAgcHJvZ3Jlc3NDYWxsYmFjayhmcmFnTG9hZGVkRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZyYWdMb2FkZWREYXRhO1xuICAgICAgfSkuY2F0Y2goZXJyb3IgPT4gdGhpcy5oYW5kbGVGcmFnTG9hZEVycm9yKGVycm9yKSk7XG4gICAgfVxuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfTE9BRElORywge1xuICAgICAgZnJhZyxcbiAgICAgIHRhcmdldEJ1ZmZlclRpbWVcbiAgICB9KTtcbiAgICBpZiAodGhpcy5mcmFnQ3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgZnJhZyBsb2FkIGFib3J0ZWQsIGNvbnRleHQgY2hhbmdlZCBpbiBGUkFHX0xPQURJTkdgKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZG9GcmFnUGFydHNMb2FkKGZyYWcsIGZyb21QYXJ0LCBsZXZlbCwgcHJvZ3Jlc3NDYWxsYmFjaykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB2YXIgX2xldmVsJGRldGFpbHM7XG4gICAgICBjb25zdCBwYXJ0c0xvYWRlZCA9IFtdO1xuICAgICAgY29uc3QgaW5pdGlhbFBhcnRMaXN0ID0gKF9sZXZlbCRkZXRhaWxzID0gbGV2ZWwuZGV0YWlscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9sZXZlbCRkZXRhaWxzLnBhcnRMaXN0O1xuICAgICAgY29uc3QgbG9hZFBhcnQgPSBwYXJ0ID0+IHtcbiAgICAgICAgdGhpcy5mcmFnbWVudExvYWRlci5sb2FkUGFydChmcmFnLCBwYXJ0LCBwcm9ncmVzc0NhbGxiYWNrKS50aGVuKHBhcnRMb2FkZWREYXRhID0+IHtcbiAgICAgICAgICBwYXJ0c0xvYWRlZFtwYXJ0LmluZGV4XSA9IHBhcnRMb2FkZWREYXRhO1xuICAgICAgICAgIGNvbnN0IGxvYWRlZFBhcnQgPSBwYXJ0TG9hZGVkRGF0YS5wYXJ0O1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfTE9BREVELCBwYXJ0TG9hZGVkRGF0YSk7XG4gICAgICAgICAgY29uc3QgbmV4dFBhcnQgPSBnZXRQYXJ0V2l0aChsZXZlbCwgZnJhZy5zbiwgcGFydC5pbmRleCArIDEpIHx8IGZpbmRQYXJ0KGluaXRpYWxQYXJ0TGlzdCwgZnJhZy5zbiwgcGFydC5pbmRleCArIDEpO1xuICAgICAgICAgIGlmIChuZXh0UGFydCkge1xuICAgICAgICAgICAgbG9hZFBhcnQobmV4dFBhcnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh7XG4gICAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICAgIHBhcnQ6IGxvYWRlZFBhcnQsXG4gICAgICAgICAgICAgIHBhcnRzTG9hZGVkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XG4gICAgICB9O1xuICAgICAgbG9hZFBhcnQoZnJvbVBhcnQpO1xuICAgIH0pO1xuICB9XG4gIGhhbmRsZUZyYWdMb2FkRXJyb3IoZXJyb3IpIHtcbiAgICBpZiAoJ2RhdGEnIGluIGVycm9yKSB7XG4gICAgICBjb25zdCBkYXRhID0gZXJyb3IuZGF0YTtcbiAgICAgIGlmIChlcnJvci5kYXRhICYmIGRhdGEuZGV0YWlscyA9PT0gRXJyb3JEZXRhaWxzLklOVEVSTkFMX0FCT1JURUQpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVGcmFnTG9hZEFib3J0ZWQoZGF0YS5mcmFnLCBkYXRhLnBhcnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIGRhdGEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk9USEVSX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuSU5URVJOQUxfRVhDRVBUSU9OLFxuICAgICAgICBlcnI6IGVycm9yLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBfaGFuZGxlVHJhbnNtdXhlckZsdXNoKGNodW5rTWV0YSkge1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmdldEN1cnJlbnRDb250ZXh0KGNodW5rTWV0YSk7XG4gICAgaWYgKCFjb250ZXh0IHx8IHRoaXMuc3RhdGUgIT09IFN0YXRlLlBBUlNJTkcpIHtcbiAgICAgIGlmICghdGhpcy5mcmFnQ3VycmVudCAmJiB0aGlzLnN0YXRlICE9PSBTdGF0ZS5TVE9QUEVEICYmIHRoaXMuc3RhdGUgIT09IFN0YXRlLkVSUk9SKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBmcmFnLFxuICAgICAgcGFydCxcbiAgICAgIGxldmVsXG4gICAgfSA9IGNvbnRleHQ7XG4gICAgY29uc3Qgbm93ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICBmcmFnLnN0YXRzLnBhcnNpbmcuZW5kID0gbm93O1xuICAgIGlmIChwYXJ0KSB7XG4gICAgICBwYXJ0LnN0YXRzLnBhcnNpbmcuZW5kID0gbm93O1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUxldmVsVGltaW5nKGZyYWcsIHBhcnQsIGxldmVsLCBjaHVua01ldGEucGFydGlhbCk7XG4gIH1cbiAgZ2V0Q3VycmVudENvbnRleHQoY2h1bmtNZXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgbGV2ZWxzLFxuICAgICAgZnJhZ0N1cnJlbnRcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICBsZXZlbDogbGV2ZWxJbmRleCxcbiAgICAgIHNuLFxuICAgICAgcGFydDogcGFydEluZGV4XG4gICAgfSA9IGNodW5rTWV0YTtcbiAgICBpZiAoIShsZXZlbHMgIT0gbnVsbCAmJiBsZXZlbHNbbGV2ZWxJbmRleF0pKSB7XG4gICAgICB0aGlzLndhcm4oYExldmVscyBvYmplY3Qgd2FzIHVuc2V0IHdoaWxlIGJ1ZmZlcmluZyBmcmFnbWVudCAke3NufSBvZiBsZXZlbCAke2xldmVsSW5kZXh9LiBUaGUgY3VycmVudCBjaHVuayB3aWxsIG5vdCBiZSBidWZmZXJlZC5gKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBsZXZlbCA9IGxldmVsc1tsZXZlbEluZGV4XTtcbiAgICBjb25zdCBwYXJ0ID0gcGFydEluZGV4ID4gLTEgPyBnZXRQYXJ0V2l0aChsZXZlbCwgc24sIHBhcnRJbmRleCkgOiBudWxsO1xuICAgIGNvbnN0IGZyYWcgPSBwYXJ0ID8gcGFydC5mcmFnbWVudCA6IGdldEZyYWdtZW50V2l0aFNOKGxldmVsLCBzbiwgZnJhZ0N1cnJlbnQpO1xuICAgIGlmICghZnJhZykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChmcmFnQ3VycmVudCAmJiBmcmFnQ3VycmVudCAhPT0gZnJhZykge1xuICAgICAgZnJhZy5zdGF0cyA9IGZyYWdDdXJyZW50LnN0YXRzO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZnJhZyxcbiAgICAgIHBhcnQsXG4gICAgICBsZXZlbFxuICAgIH07XG4gIH1cbiAgYnVmZmVyRnJhZ21lbnREYXRhKGRhdGEsIGZyYWcsIHBhcnQsIGNodW5rTWV0YSwgbm9CYWNrdHJhY2tpbmcpIHtcbiAgICB2YXIgX2J1ZmZlcjtcbiAgICBpZiAoIWRhdGEgfHwgdGhpcy5zdGF0ZSAhPT0gU3RhdGUuUEFSU0lORykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBkYXRhMSxcbiAgICAgIGRhdGEyXG4gICAgfSA9IGRhdGE7XG4gICAgbGV0IGJ1ZmZlciA9IGRhdGExO1xuICAgIGlmIChkYXRhMSAmJiBkYXRhMikge1xuICAgICAgLy8gQ29tYmluZSB0aGUgbW9vZiArIG1kYXQgc28gdGhhdCB3ZSBidWZmZXIgd2l0aCBhIHNpbmdsZSBhcHBlbmRcbiAgICAgIGJ1ZmZlciA9IGFwcGVuZFVpbnQ4QXJyYXkoZGF0YTEsIGRhdGEyKTtcbiAgICB9XG4gICAgaWYgKCEoKF9idWZmZXIgPSBidWZmZXIpICE9IG51bGwgJiYgX2J1ZmZlci5sZW5ndGgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNlZ21lbnQgPSB7XG4gICAgICB0eXBlOiBkYXRhLnR5cGUsXG4gICAgICBmcmFnLFxuICAgICAgcGFydCxcbiAgICAgIGNodW5rTWV0YSxcbiAgICAgIHBhcmVudDogZnJhZy50eXBlLFxuICAgICAgZGF0YTogYnVmZmVyXG4gICAgfTtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfQVBQRU5ESU5HLCBzZWdtZW50KTtcbiAgICBpZiAoZGF0YS5kcm9wcGVkICYmIGRhdGEuaW5kZXBlbmRlbnQgJiYgIXBhcnQpIHtcbiAgICAgIGlmIChub0JhY2t0cmFja2luZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBDbGVhciBidWZmZXIgc28gdGhhdCB3ZSByZWxvYWQgcHJldmlvdXMgc2VnbWVudHMgc2VxdWVudGlhbGx5IGlmIHJlcXVpcmVkXG4gICAgICB0aGlzLmZsdXNoQnVmZmVyR2FwKGZyYWcpO1xuICAgIH1cbiAgfVxuICBmbHVzaEJ1ZmZlckdhcChmcmFnKSB7XG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIGlmICghbWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSWYgY3VycmVudFRpbWUgaXMgbm90IGJ1ZmZlcmVkLCBjbGVhciB0aGUgYmFjayBidWZmZXIgc28gdGhhdCB3ZSBjYW4gYmFja3RyYWNrIGFzIG11Y2ggYXMgbmVlZGVkXG4gICAgaWYgKCFCdWZmZXJIZWxwZXIuaXNCdWZmZXJlZChtZWRpYSwgbWVkaWEuY3VycmVudFRpbWUpKSB7XG4gICAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcigwLCBmcmFnLnN0YXJ0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIGJhY2stYnVmZmVyIHdpdGhvdXQgaW50ZXJydXB0aW5nIHBsYXliYWNrIHRvIGFsbG93IGJhY2sgdHJhY2tpbmdcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIGNvbnN0IGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhtZWRpYSwgY3VycmVudFRpbWUsIDApO1xuICAgIGNvbnN0IGZyYWdEdXJhdGlvbiA9IGZyYWcuZHVyYXRpb247XG4gICAgY29uc3Qgc2VnbWVudEZyYWN0aW9uID0gTWF0aC5taW4odGhpcy5jb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSAqIDIsIGZyYWdEdXJhdGlvbiAqIDAuMjUpO1xuICAgIGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgoTWF0aC5taW4oZnJhZy5zdGFydCAtIHNlZ21lbnRGcmFjdGlvbiwgYnVmZmVySW5mby5lbmQgLSBzZWdtZW50RnJhY3Rpb24pLCBjdXJyZW50VGltZSArIHNlZ21lbnRGcmFjdGlvbik7XG4gICAgaWYgKGZyYWcuc3RhcnQgLSBzdGFydCA+IHNlZ21lbnRGcmFjdGlvbikge1xuICAgICAgdGhpcy5mbHVzaE1haW5CdWZmZXIoc3RhcnQsIGZyYWcuc3RhcnQpO1xuICAgIH1cbiAgfVxuICBnZXRGd2RCdWZmZXJJbmZvKGJ1ZmZlcmFibGUsIHR5cGUpIHtcbiAgICBjb25zdCBwb3MgPSB0aGlzLmdldExvYWRQb3NpdGlvbigpO1xuICAgIGlmICghaXNGaW5pdGVOdW1iZXIocG9zKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldEZ3ZEJ1ZmZlckluZm9BdFBvcyhidWZmZXJhYmxlLCBwb3MsIHR5cGUpO1xuICB9XG4gIGdldEZ3ZEJ1ZmZlckluZm9BdFBvcyhidWZmZXJhYmxlLCBwb3MsIHR5cGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb25maWc6IHtcbiAgICAgICAgbWF4QnVmZmVySG9sZVxuICAgICAgfVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhidWZmZXJhYmxlLCBwb3MsIG1heEJ1ZmZlckhvbGUpO1xuICAgIC8vIFdvcmthcm91bmQgZmxhdyBpbiBnZXR0aW5nIGZvcndhcmQgYnVmZmVyIHdoZW4gbWF4QnVmZmVySG9sZSBpcyBzbWFsbGVyIHRoYW4gZ2FwIGF0IGN1cnJlbnQgcG9zXG4gICAgaWYgKGJ1ZmZlckluZm8ubGVuID09PSAwICYmIGJ1ZmZlckluZm8ubmV4dFN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGJ1ZmZlcmVkRnJhZ0F0UG9zID0gdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0QnVmZmVyZWRGcmFnKHBvcywgdHlwZSk7XG4gICAgICBpZiAoYnVmZmVyZWRGcmFnQXRQb3MgJiYgYnVmZmVySW5mby5uZXh0U3RhcnQgPCBidWZmZXJlZEZyYWdBdFBvcy5lbmQpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlckhlbHBlci5idWZmZXJJbmZvKGJ1ZmZlcmFibGUsIHBvcywgTWF0aC5tYXgoYnVmZmVySW5mby5uZXh0U3RhcnQsIG1heEJ1ZmZlckhvbGUpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlckluZm87XG4gIH1cbiAgZ2V0TWF4QnVmZmVyTGVuZ3RoKGxldmVsQml0cmF0ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSB0aGlzO1xuICAgIGxldCBtYXhCdWZMZW47XG4gICAgaWYgKGxldmVsQml0cmF0ZSkge1xuICAgICAgbWF4QnVmTGVuID0gTWF0aC5tYXgoOCAqIGNvbmZpZy5tYXhCdWZmZXJTaXplIC8gbGV2ZWxCaXRyYXRlLCBjb25maWcubWF4QnVmZmVyTGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWF4QnVmTGVuID0gY29uZmlnLm1heEJ1ZmZlckxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgubWluKG1heEJ1ZkxlbiwgY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCk7XG4gIH1cbiAgcmVkdWNlTWF4QnVmZmVyTGVuZ3RoKHRocmVzaG9sZCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIGNvbnN0IG1pbkxlbmd0aCA9IHRocmVzaG9sZCB8fCBjb25maWcubWF4QnVmZmVyTGVuZ3RoO1xuICAgIGlmIChjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoID49IG1pbkxlbmd0aCkge1xuICAgICAgLy8gcmVkdWNlIG1heCBidWZmZXIgbGVuZ3RoIGFzIGl0IG1pZ2h0IGJlIHRvbyBoaWdoLiB3ZSBkbyB0aGlzIHRvIGF2b2lkIGxvb3AgZmx1c2hpbmcgLi4uXG4gICAgICBjb25maWcubWF4TWF4QnVmZmVyTGVuZ3RoIC89IDI7XG4gICAgICB0aGlzLndhcm4oYFJlZHVjZSBtYXggYnVmZmVyIGxlbmd0aCB0byAke2NvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGh9c2ApO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBnZXRBcHBlbmRlZEZyYWcocG9zaXRpb24sIHBsYXlsaXN0VHlwZSA9IFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pIHtcbiAgICBjb25zdCBmcmFnT3JQYXJ0ID0gdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0QXBwZW5kZWRGcmFnKHBvc2l0aW9uLCBQbGF5bGlzdExldmVsVHlwZS5NQUlOKTtcbiAgICBpZiAoZnJhZ09yUGFydCAmJiAnZnJhZ21lbnQnIGluIGZyYWdPclBhcnQpIHtcbiAgICAgIHJldHVybiBmcmFnT3JQYXJ0LmZyYWdtZW50O1xuICAgIH1cbiAgICByZXR1cm4gZnJhZ09yUGFydDtcbiAgfVxuICBnZXROZXh0RnJhZ21lbnQocG9zLCBsZXZlbERldGFpbHMpIHtcbiAgICBjb25zdCBmcmFnbWVudHMgPSBsZXZlbERldGFpbHMuZnJhZ21lbnRzO1xuICAgIGNvbnN0IGZyYWdMZW4gPSBmcmFnbWVudHMubGVuZ3RoO1xuICAgIGlmICghZnJhZ0xlbikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gZmluZCBmcmFnbWVudCBpbmRleCwgY29udGlndW91cyB3aXRoIGVuZCBvZiBidWZmZXIgcG9zaXRpb25cbiAgICBjb25zdCB7XG4gICAgICBjb25maWdcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBzdGFydCA9IGZyYWdtZW50c1swXS5zdGFydDtcbiAgICBsZXQgZnJhZztcbiAgICBpZiAobGV2ZWxEZXRhaWxzLmxpdmUpIHtcbiAgICAgIGNvbnN0IGluaXRpYWxMaXZlTWFuaWZlc3RTaXplID0gY29uZmlnLmluaXRpYWxMaXZlTWFuaWZlc3RTaXplO1xuICAgICAgaWYgKGZyYWdMZW4gPCBpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZSkge1xuICAgICAgICB0aGlzLndhcm4oYE5vdCBlbm91Z2ggZnJhZ21lbnRzIHRvIHN0YXJ0IHBsYXliYWNrIChoYXZlOiAke2ZyYWdMZW59LCBuZWVkOiAke2luaXRpYWxMaXZlTWFuaWZlc3RTaXplfSlgKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICAvLyBUaGUgcmVhbCBmcmFnbWVudCBzdGFydCB0aW1lcyBmb3IgYSBsaXZlIHN0cmVhbSBhcmUgb25seSBrbm93biBhZnRlciB0aGUgUFRTIHJhbmdlIGZvciB0aGF0IGxldmVsIGlzIGtub3duLlxuICAgICAgLy8gSW4gb3JkZXIgdG8gZGlzY292ZXIgdGhlIHJhbmdlLCB3ZSBsb2FkIHRoZSBiZXN0IG1hdGNoaW5nIGZyYWdtZW50IGZvciB0aGF0IGxldmVsIGFuZCBkZW11eCBpdC5cbiAgICAgIC8vIERvIG5vdCBsb2FkIHVzaW5nIGxpdmUgbG9naWMgaWYgdGhlIHN0YXJ0aW5nIGZyYWcgaXMgcmVxdWVzdGVkIC0gd2Ugd2FudCB0byB1c2UgZ2V0RnJhZ21lbnRBdFBvc2l0aW9uKCkgc28gdGhhdFxuICAgICAgLy8gd2UgZ2V0IHRoZSBmcmFnbWVudCBtYXRjaGluZyB0aGF0IHN0YXJ0IHRpbWVcbiAgICAgIGlmICghbGV2ZWxEZXRhaWxzLlBUU0tub3duICYmICF0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCAmJiB0aGlzLnN0YXJ0UG9zaXRpb24gPT09IC0xIHx8IHBvcyA8IHN0YXJ0KSB7XG4gICAgICAgIGZyYWcgPSB0aGlzLmdldEluaXRpYWxMaXZlRnJhZ21lbnQobGV2ZWxEZXRhaWxzLCBmcmFnbWVudHMpO1xuICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBmcmFnID8gdGhpcy5obHMubGl2ZVN5bmNQb3NpdGlvbiB8fCBmcmFnLnN0YXJ0IDogcG9zO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocG9zIDw9IHN0YXJ0KSB7XG4gICAgICAvLyBWb0QgcGxheWxpc3Q6IGlmIGxvYWRQb3NpdGlvbiBiZWZvcmUgc3RhcnQgb2YgcGxheWxpc3QsIGxvYWQgZmlyc3QgZnJhZ21lbnRcbiAgICAgIGZyYWcgPSBmcmFnbWVudHNbMF07XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgaGF2ZW4ndCBydW4gaW50byBhbnkgc3BlY2lhbCBjYXNlcyBhbHJlYWR5LCBqdXN0IGxvYWQgdGhlIGZyYWdtZW50IG1vc3QgY2xvc2VseSBtYXRjaGluZyB0aGUgcmVxdWVzdGVkIHBvc2l0aW9uXG4gICAgaWYgKCFmcmFnKSB7XG4gICAgICBjb25zdCBlbmQgPSBjb25maWcubG93TGF0ZW5jeU1vZGUgPyBsZXZlbERldGFpbHMucGFydEVuZCA6IGxldmVsRGV0YWlscy5mcmFnbWVudEVuZDtcbiAgICAgIGZyYWcgPSB0aGlzLmdldEZyYWdtZW50QXRQb3NpdGlvbihwb3MsIGVuZCwgbGV2ZWxEZXRhaWxzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubWFwVG9Jbml0RnJhZ1doZW5SZXF1aXJlZChmcmFnKTtcbiAgfVxuICBpc0xvb3BMb2FkaW5nKGZyYWcsIHRhcmdldEJ1ZmZlclRpbWUpIHtcbiAgICBjb25zdCB0cmFja2VyU3RhdGUgPSB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShmcmFnKTtcbiAgICByZXR1cm4gKHRyYWNrZXJTdGF0ZSA9PT0gRnJhZ21lbnRTdGF0ZS5PSyB8fCB0cmFja2VyU3RhdGUgPT09IEZyYWdtZW50U3RhdGUuUEFSVElBTCAmJiAhIWZyYWcuZ2FwKSAmJiB0aGlzLm5leHRMb2FkUG9zaXRpb24gPiB0YXJnZXRCdWZmZXJUaW1lO1xuICB9XG4gIGdldE5leHRGcmFnbWVudExvb3BMb2FkaW5nKGZyYWcsIGxldmVsRGV0YWlscywgYnVmZmVySW5mbywgcGxheWxpc3RUeXBlLCBtYXhCdWZMZW4pIHtcbiAgICBjb25zdCBnYXBTdGFydCA9IGZyYWcuZ2FwO1xuICAgIGNvbnN0IG5leHRGcmFnbWVudCA9IHRoaXMuZ2V0TmV4dEZyYWdtZW50KHRoaXMubmV4dExvYWRQb3NpdGlvbiwgbGV2ZWxEZXRhaWxzKTtcbiAgICBpZiAobmV4dEZyYWdtZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbmV4dEZyYWdtZW50O1xuICAgIH1cbiAgICBmcmFnID0gbmV4dEZyYWdtZW50O1xuICAgIGlmIChnYXBTdGFydCAmJiBmcmFnICYmICFmcmFnLmdhcCAmJiBidWZmZXJJbmZvLm5leHRTdGFydCkge1xuICAgICAgLy8gTWVkaWEgYnVmZmVyZWQgYWZ0ZXIgR0FQIHRhZ3Mgc2hvdWxkIG5vdCBtYWtlIHRoZSBuZXh0IGJ1ZmZlciB0aW1lcmFuZ2UgZXhjZWVkIGZvcndhcmQgYnVmZmVyIGxlbmd0aFxuICAgICAgY29uc3QgbmV4dGJ1ZmZlckluZm8gPSB0aGlzLmdldEZ3ZEJ1ZmZlckluZm9BdFBvcyh0aGlzLm1lZGlhQnVmZmVyID8gdGhpcy5tZWRpYUJ1ZmZlciA6IHRoaXMubWVkaWEsIGJ1ZmZlckluZm8ubmV4dFN0YXJ0LCBwbGF5bGlzdFR5cGUpO1xuICAgICAgaWYgKG5leHRidWZmZXJJbmZvICE9PSBudWxsICYmIGJ1ZmZlckluZm8ubGVuICsgbmV4dGJ1ZmZlckluZm8ubGVuID49IG1heEJ1Zkxlbikge1xuICAgICAgICAvLyBSZXR1cm5pbmcgaGVyZSBtaWdodCByZXN1bHQgaW4gbm90IGZpbmRpbmcgYW4gYXVkaW8gYW5kIHZpZGVvIGNhbmRpYXRlIHRvIHNraXAgdG9cbiAgICAgICAgdGhpcy5sb2coYGJ1ZmZlciBmdWxsIGFmdGVyIGdhcHMgaW4gXCIke3BsYXlsaXN0VHlwZX1cIiBwbGF5bGlzdCBzdGFydGluZyBhdCBzbjogJHtmcmFnLnNufWApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZyYWc7XG4gIH1cbiAgbWFwVG9Jbml0RnJhZ1doZW5SZXF1aXJlZChmcmFnKSB7XG4gICAgLy8gSWYgYW4gaW5pdFNlZ21lbnQgaXMgcHJlc2VudCwgaXQgbXVzdCBiZSBidWZmZXJlZCBmaXJzdFxuICAgIGlmIChmcmFnICE9IG51bGwgJiYgZnJhZy5pbml0U2VnbWVudCAmJiAhKGZyYWcgIT0gbnVsbCAmJiBmcmFnLmluaXRTZWdtZW50LmRhdGEpICYmICF0aGlzLmJpdHJhdGVUZXN0KSB7XG4gICAgICByZXR1cm4gZnJhZy5pbml0U2VnbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIGZyYWc7XG4gIH1cbiAgZ2V0TmV4dFBhcnQocGFydExpc3QsIGZyYWcsIHRhcmdldEJ1ZmZlclRpbWUpIHtcbiAgICBsZXQgbmV4dFBhcnQgPSAtMTtcbiAgICBsZXQgY29udGlndW91cyA9IGZhbHNlO1xuICAgIGxldCBpbmRlcGVuZGVudEF0dHJPbWl0dGVkID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gcGFydExpc3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IHBhcnQgPSBwYXJ0TGlzdFtpXTtcbiAgICAgIGluZGVwZW5kZW50QXR0ck9taXR0ZWQgPSBpbmRlcGVuZGVudEF0dHJPbWl0dGVkICYmICFwYXJ0LmluZGVwZW5kZW50O1xuICAgICAgaWYgKG5leHRQYXJ0ID4gLTEgJiYgdGFyZ2V0QnVmZmVyVGltZSA8IHBhcnQuc3RhcnQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb25zdCBsb2FkZWQgPSBwYXJ0LmxvYWRlZDtcbiAgICAgIGlmIChsb2FkZWQpIHtcbiAgICAgICAgbmV4dFBhcnQgPSAtMTtcbiAgICAgIH0gZWxzZSBpZiAoKGNvbnRpZ3VvdXMgfHwgcGFydC5pbmRlcGVuZGVudCB8fCBpbmRlcGVuZGVudEF0dHJPbWl0dGVkKSAmJiBwYXJ0LmZyYWdtZW50ID09PSBmcmFnKSB7XG4gICAgICAgIG5leHRQYXJ0ID0gaTtcbiAgICAgIH1cbiAgICAgIGNvbnRpZ3VvdXMgPSBsb2FkZWQ7XG4gICAgfVxuICAgIHJldHVybiBuZXh0UGFydDtcbiAgfVxuICBsb2FkZWRFbmRPZlBhcnRzKHBhcnRMaXN0LCB0YXJnZXRCdWZmZXJUaW1lKSB7XG4gICAgY29uc3QgbGFzdFBhcnQgPSBwYXJ0TGlzdFtwYXJ0TGlzdC5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gbGFzdFBhcnQgJiYgdGFyZ2V0QnVmZmVyVGltZSA+IGxhc3RQYXJ0LnN0YXJ0ICYmIGxhc3RQYXJ0LmxvYWRlZDtcbiAgfVxuXG4gIC8qXG4gICBUaGlzIG1ldGhvZCBpcyB1c2VkIGZpbmQgdGhlIGJlc3QgbWF0Y2hpbmcgZmlyc3QgZnJhZ21lbnQgZm9yIGEgbGl2ZSBwbGF5bGlzdC4gVGhpcyBmcmFnbWVudCBpcyB1c2VkIHRvIGNhbGN1bGF0ZSB0aGVcbiAgIFwic2xpZGluZ1wiIG9mIHRoZSBwbGF5bGlzdCwgd2hpY2ggaXMgaXRzIG9mZnNldCBmcm9tIHRoZSBzdGFydCBvZiBwbGF5YmFjay4gQWZ0ZXIgc2xpZGluZyB3ZSBjYW4gY29tcHV0ZSB0aGUgcmVhbFxuICAgc3RhcnQgYW5kIGVuZCB0aW1lcyBmb3IgZWFjaCBmcmFnbWVudCBpbiB0aGUgcGxheWxpc3QgKGFmdGVyIHdoaWNoIHRoaXMgbWV0aG9kIHdpbGwgbm90IG5lZWQgdG8gYmUgY2FsbGVkKS5cbiAgKi9cbiAgZ2V0SW5pdGlhbExpdmVGcmFnbWVudChsZXZlbERldGFpbHMsIGZyYWdtZW50cykge1xuICAgIGNvbnN0IGZyYWdQcmV2aW91cyA9IHRoaXMuZnJhZ1ByZXZpb3VzO1xuICAgIGxldCBmcmFnID0gbnVsbDtcbiAgICBpZiAoZnJhZ1ByZXZpb3VzKSB7XG4gICAgICBpZiAobGV2ZWxEZXRhaWxzLmhhc1Byb2dyYW1EYXRlVGltZSkge1xuICAgICAgICAvLyBQcmVmZXIgdXNpbmcgUERULCBiZWNhdXNlIGl0IGNhbiBiZSBhY2N1cmF0ZSBlbm91Z2ggdG8gY2hvb3NlIHRoZSBjb3JyZWN0IGZyYWdtZW50IHdpdGhvdXQga25vd2luZyB0aGUgbGV2ZWwgc2xpZGluZ1xuICAgICAgICB0aGlzLmxvZyhgTGl2ZSBwbGF5bGlzdCwgc3dpdGNoaW5nIHBsYXlsaXN0LCBsb2FkIGZyYWcgd2l0aCBzYW1lIFBEVDogJHtmcmFnUHJldmlvdXMucHJvZ3JhbURhdGVUaW1lfWApO1xuICAgICAgICBmcmFnID0gZmluZEZyYWdtZW50QnlQRFQoZnJhZ21lbnRzLCBmcmFnUHJldmlvdXMuZW5kUHJvZ3JhbURhdGVUaW1lLCB0aGlzLmNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlKTtcbiAgICAgIH1cbiAgICAgIGlmICghZnJhZykge1xuICAgICAgICAvLyBTTiBkb2VzIG5vdCBuZWVkIHRvIGJlIGFjY3VyYXRlIGJldHdlZW4gcmVuZGl0aW9ucywgYnV0IGRlcGVuZGluZyBvbiB0aGUgcGFja2FnaW5nIGl0IG1heSBiZSBzby5cbiAgICAgICAgY29uc3QgdGFyZ2V0U04gPSBmcmFnUHJldmlvdXMuc24gKyAxO1xuICAgICAgICBpZiAodGFyZ2V0U04gPj0gbGV2ZWxEZXRhaWxzLnN0YXJ0U04gJiYgdGFyZ2V0U04gPD0gbGV2ZWxEZXRhaWxzLmVuZFNOKSB7XG4gICAgICAgICAgY29uc3QgZnJhZ05leHQgPSBmcmFnbWVudHNbdGFyZ2V0U04gLSBsZXZlbERldGFpbHMuc3RhcnRTTl07XG4gICAgICAgICAgLy8gRW5zdXJlIHRoYXQgd2UncmUgc3RheWluZyB3aXRoaW4gdGhlIGNvbnRpbnVpdHkgcmFuZ2UsIHNpbmNlIFBUUyByZXNldHMgdXBvbiBhIG5ldyByYW5nZVxuICAgICAgICAgIGlmIChmcmFnUHJldmlvdXMuY2MgPT09IGZyYWdOZXh0LmNjKSB7XG4gICAgICAgICAgICBmcmFnID0gZnJhZ05leHQ7XG4gICAgICAgICAgICB0aGlzLmxvZyhgTGl2ZSBwbGF5bGlzdCwgc3dpdGNoaW5nIHBsYXlsaXN0LCBsb2FkIGZyYWcgd2l0aCBuZXh0IFNOOiAke2ZyYWcuc259YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEl0J3MgaW1wb3J0YW50IHRvIHN0YXkgd2l0aGluIHRoZSBjb250aW51aXR5IHJhbmdlIGlmIGF2YWlsYWJsZTsgb3RoZXJ3aXNlIHRoZSBmcmFnbWVudHMgaW4gdGhlIHBsYXlsaXN0XG4gICAgICAgIC8vIHdpbGwgaGF2ZSB0aGUgd3Jvbmcgc3RhcnQgdGltZXNcbiAgICAgICAgaWYgKCFmcmFnKSB7XG4gICAgICAgICAgZnJhZyA9IGZpbmRGcmFnV2l0aENDKGZyYWdtZW50cywgZnJhZ1ByZXZpb3VzLmNjKTtcbiAgICAgICAgICBpZiAoZnJhZykge1xuICAgICAgICAgICAgdGhpcy5sb2coYExpdmUgcGxheWxpc3QsIHN3aXRjaGluZyBwbGF5bGlzdCwgbG9hZCBmcmFnIHdpdGggc2FtZSBDQzogJHtmcmFnLnNufWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGaW5kIGEgbmV3IHN0YXJ0IGZyYWdtZW50IHdoZW4gZnJhZ1ByZXZpb3VzIGlzIG51bGxcbiAgICAgIGNvbnN0IGxpdmVTdGFydCA9IHRoaXMuaGxzLmxpdmVTeW5jUG9zaXRpb247XG4gICAgICBpZiAobGl2ZVN0YXJ0ICE9PSBudWxsKSB7XG4gICAgICAgIGZyYWcgPSB0aGlzLmdldEZyYWdtZW50QXRQb3NpdGlvbihsaXZlU3RhcnQsIHRoaXMuYml0cmF0ZVRlc3QgPyBsZXZlbERldGFpbHMuZnJhZ21lbnRFbmQgOiBsZXZlbERldGFpbHMuZWRnZSwgbGV2ZWxEZXRhaWxzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZyYWc7XG4gIH1cblxuICAvKlxuICBUaGlzIG1ldGhvZCBmaW5kcyB0aGUgYmVzdCBtYXRjaGluZyBmcmFnbWVudCBnaXZlbiB0aGUgcHJvdmlkZWQgcG9zaXRpb24uXG4gICAqL1xuICBnZXRGcmFnbWVudEF0UG9zaXRpb24oYnVmZmVyRW5kLCBlbmQsIGxldmVsRGV0YWlscykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSB0aGlzO1xuICAgIGxldCB7XG4gICAgICBmcmFnUHJldmlvdXNcbiAgICB9ID0gdGhpcztcbiAgICBsZXQge1xuICAgICAgZnJhZ21lbnRzLFxuICAgICAgZW5kU05cbiAgICB9ID0gbGV2ZWxEZXRhaWxzO1xuICAgIGNvbnN0IHtcbiAgICAgIGZyYWdtZW50SGludFxuICAgIH0gPSBsZXZlbERldGFpbHM7XG4gICAgY29uc3QgdG9sZXJhbmNlID0gY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2U7XG4gICAgY29uc3QgcGFydExpc3QgPSBsZXZlbERldGFpbHMucGFydExpc3Q7XG4gICAgY29uc3QgbG9hZGluZ1BhcnRzID0gISEoY29uZmlnLmxvd0xhdGVuY3lNb2RlICYmIHBhcnRMaXN0ICE9IG51bGwgJiYgcGFydExpc3QubGVuZ3RoICYmIGZyYWdtZW50SGludCk7XG4gICAgaWYgKGxvYWRpbmdQYXJ0cyAmJiBmcmFnbWVudEhpbnQgJiYgIXRoaXMuYml0cmF0ZVRlc3QpIHtcbiAgICAgIC8vIEluY2x1ZGUgaW5jb21wbGV0ZSBmcmFnbWVudCB3aXRoIHBhcnRzIGF0IGVuZFxuICAgICAgZnJhZ21lbnRzID0gZnJhZ21lbnRzLmNvbmNhdChmcmFnbWVudEhpbnQpO1xuICAgICAgZW5kU04gPSBmcmFnbWVudEhpbnQuc247XG4gICAgfVxuICAgIGxldCBmcmFnO1xuICAgIGlmIChidWZmZXJFbmQgPCBlbmQpIHtcbiAgICAgIGNvbnN0IGxvb2t1cFRvbGVyYW5jZSA9IGJ1ZmZlckVuZCA+IGVuZCAtIHRvbGVyYW5jZSA/IDAgOiB0b2xlcmFuY2U7XG4gICAgICAvLyBSZW1vdmUgdGhlIHRvbGVyYW5jZSBpZiBpdCB3b3VsZCBwdXQgdGhlIGJ1ZmZlckVuZCBwYXN0IHRoZSBhY3R1YWwgZW5kIG9mIHN0cmVhbVxuICAgICAgLy8gVXNlcyBidWZmZXIgYW5kIHNlcXVlbmNlIG51bWJlciB0byBjYWxjdWxhdGUgc3dpdGNoIHNlZ21lbnQgKHJlcXVpcmVkIGlmIHVzaW5nIEVYVC1YLURJU0NPTlRJTlVJVFktU0VRVUVOQ0UpXG4gICAgICBmcmFnID0gZmluZEZyYWdtZW50QnlQVFMoZnJhZ1ByZXZpb3VzLCBmcmFnbWVudHMsIGJ1ZmZlckVuZCwgbG9va3VwVG9sZXJhbmNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmVhY2ggZW5kIG9mIHBsYXlsaXN0XG4gICAgICBmcmFnID0gZnJhZ21lbnRzW2ZyYWdtZW50cy5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgaWYgKGZyYWcpIHtcbiAgICAgIGNvbnN0IGN1clNOSWR4ID0gZnJhZy5zbiAtIGxldmVsRGV0YWlscy5zdGFydFNOO1xuICAgICAgLy8gTW92ZSBmcmFnUHJldmlvdXMgZm9yd2FyZCB0byBzdXBwb3J0IGZvcmNpbmcgdGhlIG5leHQgZnJhZ21lbnQgdG8gbG9hZFxuICAgICAgLy8gd2hlbiB0aGUgYnVmZmVyIGNhdGNoZXMgdXAgdG8gYSBwcmV2aW91c2x5IGJ1ZmZlcmVkIHJhbmdlLlxuICAgICAgY29uc3QgZnJhZ1N0YXRlID0gdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZnJhZyk7XG4gICAgICBpZiAoZnJhZ1N0YXRlID09PSBGcmFnbWVudFN0YXRlLk9LIHx8IGZyYWdTdGF0ZSA9PT0gRnJhZ21lbnRTdGF0ZS5QQVJUSUFMICYmIGZyYWcuZ2FwKSB7XG4gICAgICAgIGZyYWdQcmV2aW91cyA9IGZyYWc7XG4gICAgICB9XG4gICAgICBpZiAoZnJhZ1ByZXZpb3VzICYmIGZyYWcuc24gPT09IGZyYWdQcmV2aW91cy5zbiAmJiAoIWxvYWRpbmdQYXJ0cyB8fCBwYXJ0TGlzdFswXS5mcmFnbWVudC5zbiA+IGZyYWcuc24pKSB7XG4gICAgICAgIC8vIEZvcmNlIHRoZSBuZXh0IGZyYWdtZW50IHRvIGxvYWQgaWYgdGhlIHByZXZpb3VzIG9uZSB3YXMgYWxyZWFkeSBzZWxlY3RlZC4gVGhpcyBjYW4gb2NjYXNpb25hbGx5IGhhcHBlbiB3aXRoXG4gICAgICAgIC8vIG5vbi11bmlmb3JtIGZyYWdtZW50IGR1cmF0aW9uc1xuICAgICAgICBjb25zdCBzYW1lTGV2ZWwgPSBmcmFnUHJldmlvdXMgJiYgZnJhZy5sZXZlbCA9PT0gZnJhZ1ByZXZpb3VzLmxldmVsO1xuICAgICAgICBpZiAoc2FtZUxldmVsKSB7XG4gICAgICAgICAgY29uc3QgbmV4dEZyYWcgPSBmcmFnbWVudHNbY3VyU05JZHggKyAxXTtcbiAgICAgICAgICBpZiAoZnJhZy5zbiA8IGVuZFNOICYmIHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKG5leHRGcmFnKSAhPT0gRnJhZ21lbnRTdGF0ZS5PSykge1xuICAgICAgICAgICAgZnJhZyA9IG5leHRGcmFnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmcmFnID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZyYWc7XG4gIH1cbiAgc3luY2hyb25pemVUb0xpdmVFZGdlKGxldmVsRGV0YWlscykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbmZpZyxcbiAgICAgIG1lZGlhXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFtZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsaXZlU3luY1Bvc2l0aW9uID0gdGhpcy5obHMubGl2ZVN5bmNQb3NpdGlvbjtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIGNvbnN0IHN0YXJ0ID0gbGV2ZWxEZXRhaWxzLmZyYWdtZW50c1swXS5zdGFydDtcbiAgICBjb25zdCBlbmQgPSBsZXZlbERldGFpbHMuZWRnZTtcbiAgICBjb25zdCB3aXRoaW5TbGlkaW5nV2luZG93ID0gY3VycmVudFRpbWUgPj0gc3RhcnQgLSBjb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSAmJiBjdXJyZW50VGltZSA8PSBlbmQ7XG4gICAgLy8gQ29udGludWUgaWYgd2UgY2FuIHNlZWsgZm9yd2FyZCB0byBzeW5jIHBvc2l0aW9uIG9yIGlmIGN1cnJlbnQgdGltZSBpcyBvdXRzaWRlIG9mIHNsaWRpbmcgd2luZG93XG4gICAgaWYgKGxpdmVTeW5jUG9zaXRpb24gIT09IG51bGwgJiYgbWVkaWEuZHVyYXRpb24gPiBsaXZlU3luY1Bvc2l0aW9uICYmIChjdXJyZW50VGltZSA8IGxpdmVTeW5jUG9zaXRpb24gfHwgIXdpdGhpblNsaWRpbmdXaW5kb3cpKSB7XG4gICAgICAvLyBDb250aW51ZSBpZiBidWZmZXIgaXMgc3RhcnZpbmcgb3IgaWYgY3VycmVudCB0aW1lIGlzIGJlaGluZCBtYXggbGF0ZW5jeVxuICAgICAgY29uc3QgbWF4TGF0ZW5jeSA9IGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBjb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbiA6IGNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQgKiBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb247XG4gICAgICBpZiAoIXdpdGhpblNsaWRpbmdXaW5kb3cgJiYgbWVkaWEucmVhZHlTdGF0ZSA8IDQgfHwgY3VycmVudFRpbWUgPCBlbmQgLSBtYXhMYXRlbmN5KSB7XG4gICAgICAgIGlmICghdGhpcy5sb2FkZWRtZXRhZGF0YSkge1xuICAgICAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IGxpdmVTeW5jUG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgLy8gT25seSBzZWVrIGlmIHJlYWR5IGFuZCB0aGVyZSBpcyBub3QgYSBzaWduaWZpY2FudCBmb3J3YXJkIGJ1ZmZlciBhdmFpbGFibGUgZm9yIHBsYXliYWNrXG4gICAgICAgIGlmIChtZWRpYS5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgdGhpcy53YXJuKGBQbGF5YmFjazogJHtjdXJyZW50VGltZS50b0ZpeGVkKDMpfSBpcyBsb2NhdGVkIHRvbyBmYXIgZnJvbSB0aGUgZW5kIG9mIGxpdmUgc2xpZGluZyBwbGF5bGlzdDogJHtlbmR9LCByZXNldCBjdXJyZW50VGltZSB0byA6ICR7bGl2ZVN5bmNQb3NpdGlvbi50b0ZpeGVkKDMpfWApO1xuICAgICAgICAgIG1lZGlhLmN1cnJlbnRUaW1lID0gbGl2ZVN5bmNQb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBhbGlnblBsYXlsaXN0cyhkZXRhaWxzLCBwcmV2aW91c0RldGFpbHMsIHN3aXRjaERldGFpbHMpIHtcbiAgICAvLyBGSVhNRTogSWYgbm90IGZvciBgc2hvdWxkQWxpZ25PbkRpc2NvbnRpbnVpdGllc2AgcmVxdWlyaW5nIGZyYWdQcmV2aW91cy5jYyxcbiAgICAvLyAgdGhpcyBjb3VsZCBhbGwgZ28gaW4gbGV2ZWwtaGVscGVyIG1lcmdlRGV0YWlscygpXG4gICAgY29uc3QgbGVuZ3RoID0gZGV0YWlscy5mcmFnbWVudHMubGVuZ3RoO1xuICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICB0aGlzLndhcm4oYE5vIGZyYWdtZW50cyBpbiBsaXZlIHBsYXlsaXN0YCk7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY29uc3Qgc2xpZGluZ1N0YXJ0ID0gZGV0YWlscy5mcmFnbWVudHNbMF0uc3RhcnQ7XG4gICAgY29uc3QgZmlyc3RMZXZlbExvYWQgPSAhcHJldmlvdXNEZXRhaWxzO1xuICAgIGNvbnN0IGFsaWduZWQgPSBkZXRhaWxzLmFsaWduZWRTbGlkaW5nICYmIGlzRmluaXRlTnVtYmVyKHNsaWRpbmdTdGFydCk7XG4gICAgaWYgKGZpcnN0TGV2ZWxMb2FkIHx8ICFhbGlnbmVkICYmICFzbGlkaW5nU3RhcnQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZnJhZ1ByZXZpb3VzXG4gICAgICB9ID0gdGhpcztcbiAgICAgIGFsaWduU3RyZWFtKGZyYWdQcmV2aW91cywgc3dpdGNoRGV0YWlscywgZGV0YWlscyk7XG4gICAgICBjb25zdCBhbGlnbmVkU2xpZGluZ1N0YXJ0ID0gZGV0YWlscy5mcmFnbWVudHNbMF0uc3RhcnQ7XG4gICAgICB0aGlzLmxvZyhgTGl2ZSBwbGF5bGlzdCBzbGlkaW5nOiAke2FsaWduZWRTbGlkaW5nU3RhcnQudG9GaXhlZCgyKX0gc3RhcnQtc246ICR7cHJldmlvdXNEZXRhaWxzID8gcHJldmlvdXNEZXRhaWxzLnN0YXJ0U04gOiAnbmEnfS0+JHtkZXRhaWxzLnN0YXJ0U059IHByZXYtc246ICR7ZnJhZ1ByZXZpb3VzID8gZnJhZ1ByZXZpb3VzLnNuIDogJ25hJ30gZnJhZ21lbnRzOiAke2xlbmd0aH1gKTtcbiAgICAgIHJldHVybiBhbGlnbmVkU2xpZGluZ1N0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4gc2xpZGluZ1N0YXJ0O1xuICB9XG4gIHdhaXRGb3JDZG5UdW5lSW4oZGV0YWlscykge1xuICAgIC8vIFdhaXQgZm9yIExvdy1MYXRlbmN5IENETiBUdW5lLWluIHRvIGdldCBhbiB1cGRhdGVkIHBsYXlsaXN0XG4gICAgY29uc3QgYWR2YW5jZVBhcnRMaW1pdCA9IDM7XG4gICAgcmV0dXJuIGRldGFpbHMubGl2ZSAmJiBkZXRhaWxzLmNhbkJsb2NrUmVsb2FkICYmIGRldGFpbHMucGFydFRhcmdldCAmJiBkZXRhaWxzLnR1bmVJbkdvYWwgPiBNYXRoLm1heChkZXRhaWxzLnBhcnRIb2xkQmFjaywgZGV0YWlscy5wYXJ0VGFyZ2V0ICogYWR2YW5jZVBhcnRMaW1pdCk7XG4gIH1cbiAgc2V0U3RhcnRQb3NpdGlvbihkZXRhaWxzLCBzbGlkaW5nKSB7XG4gICAgLy8gY29tcHV0ZSBzdGFydCBwb3NpdGlvbiBpZiBzZXQgdG8gLTEuIHVzZSBpdCBzdHJhaWdodCBhd2F5IGlmIHZhbHVlIGlzIGRlZmluZWRcbiAgICBsZXQgc3RhcnRQb3NpdGlvbiA9IHRoaXMuc3RhcnRQb3NpdGlvbjtcbiAgICBpZiAoc3RhcnRQb3NpdGlvbiA8IHNsaWRpbmcpIHtcbiAgICAgIHN0YXJ0UG9zaXRpb24gPSAtMTtcbiAgICB9XG4gICAgaWYgKHN0YXJ0UG9zaXRpb24gPT09IC0xIHx8IHRoaXMubGFzdEN1cnJlbnRUaW1lID09PSAtMSkge1xuICAgICAgLy8gVXNlIFBsYXlsaXN0IEVYVC1YLVNUQVJUOlRJTUUtT0ZGU0VUIHdoZW4gc2V0XG4gICAgICAvLyBQcmlvcml0aXplIE11bHRpdmFyaWFudCBQbGF5bGlzdCBvZmZzZXQgc28gdGhhdCBtYWluLCBhdWRpbywgYW5kIHN1YnRpdGxlIHN0cmVhbS1jb250cm9sbGVyIHN0YXJ0IHRpbWVzIG1hdGNoXG4gICAgICBjb25zdCBvZmZzZXRJbk11bHRpdmFyaWFudFBsYXlsaXN0ID0gdGhpcy5zdGFydFRpbWVPZmZzZXQgIT09IG51bGw7XG4gICAgICBjb25zdCBzdGFydFRpbWVPZmZzZXQgPSBvZmZzZXRJbk11bHRpdmFyaWFudFBsYXlsaXN0ID8gdGhpcy5zdGFydFRpbWVPZmZzZXQgOiBkZXRhaWxzLnN0YXJ0VGltZU9mZnNldDtcbiAgICAgIGlmIChzdGFydFRpbWVPZmZzZXQgIT09IG51bGwgJiYgaXNGaW5pdGVOdW1iZXIoc3RhcnRUaW1lT2Zmc2V0KSkge1xuICAgICAgICBzdGFydFBvc2l0aW9uID0gc2xpZGluZyArIHN0YXJ0VGltZU9mZnNldDtcbiAgICAgICAgaWYgKHN0YXJ0VGltZU9mZnNldCA8IDApIHtcbiAgICAgICAgICBzdGFydFBvc2l0aW9uICs9IGRldGFpbHMudG90YWxkdXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBzdGFydFBvc2l0aW9uID0gTWF0aC5taW4oTWF0aC5tYXgoc2xpZGluZywgc3RhcnRQb3NpdGlvbiksIHNsaWRpbmcgKyBkZXRhaWxzLnRvdGFsZHVyYXRpb24pO1xuICAgICAgICB0aGlzLmxvZyhgU3RhcnQgdGltZSBvZmZzZXQgJHtzdGFydFRpbWVPZmZzZXR9IGZvdW5kIGluICR7b2Zmc2V0SW5NdWx0aXZhcmlhbnRQbGF5bGlzdCA/ICdtdWx0aXZhcmlhbnQnIDogJ21lZGlhJ30gcGxheWxpc3QsIGFkanVzdCBzdGFydFBvc2l0aW9uIHRvICR7c3RhcnRQb3NpdGlvbn1gKTtcbiAgICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gc3RhcnRQb3NpdGlvbjtcbiAgICAgIH0gZWxzZSBpZiAoZGV0YWlscy5saXZlKSB7XG4gICAgICAgIC8vIExlYXZlIHRoaXMuc3RhcnRQb3NpdGlvbiBhdCAtMSwgc28gdGhhdCB3ZSBjYW4gdXNlIGBnZXRJbml0aWFsTGl2ZUZyYWdtZW50YCBsb2dpYyB3aGVuIHN0YXJ0UG9zaXRpb24gaGFzXG4gICAgICAgIC8vIG5vdCBiZWVuIHNwZWNpZmllZCB2aWEgdGhlIGNvbmZpZyBvciBhbiBhcyBhbiBhcmd1bWVudCB0byBzdGFydExvYWQgKCMzNzM2KS5cbiAgICAgICAgc3RhcnRQb3NpdGlvbiA9IHRoaXMuaGxzLmxpdmVTeW5jUG9zaXRpb24gfHwgc2xpZGluZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHN0YXJ0UG9zaXRpb24gPSAwO1xuICAgICAgfVxuICAgICAgdGhpcy5sYXN0Q3VycmVudFRpbWUgPSBzdGFydFBvc2l0aW9uO1xuICAgIH1cbiAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBzdGFydFBvc2l0aW9uO1xuICB9XG4gIGdldExvYWRQb3NpdGlvbigpIHtcbiAgICBjb25zdCB7XG4gICAgICBtZWRpYVxuICAgIH0gPSB0aGlzO1xuICAgIC8vIGlmIHdlIGhhdmUgbm90IHlldCBsb2FkZWQgYW55IGZyYWdtZW50LCBzdGFydCBsb2FkaW5nIGZyb20gc3RhcnQgcG9zaXRpb25cbiAgICBsZXQgcG9zID0gMDtcbiAgICBpZiAodGhpcy5sb2FkZWRtZXRhZGF0YSAmJiBtZWRpYSkge1xuICAgICAgcG9zID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLm5leHRMb2FkUG9zaXRpb24pIHtcbiAgICAgIHBvcyA9IHRoaXMubmV4dExvYWRQb3NpdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIHBvcztcbiAgfVxuICBoYW5kbGVGcmFnTG9hZEFib3J0ZWQoZnJhZywgcGFydCkge1xuICAgIGlmICh0aGlzLnRyYW5zbXV4ZXIgJiYgZnJhZy5zbiAhPT0gJ2luaXRTZWdtZW50JyAmJiBmcmFnLnN0YXRzLmFib3J0ZWQpIHtcbiAgICAgIHRoaXMud2FybihgRnJhZ21lbnQgJHtmcmFnLnNufSR7cGFydCA/ICcgcGFydCAnICsgcGFydC5pbmRleCA6ICcnfSBvZiBsZXZlbCAke2ZyYWcubGV2ZWx9IHdhcyBhYm9ydGVkYCk7XG4gICAgICB0aGlzLnJlc2V0RnJhZ21lbnRMb2FkaW5nKGZyYWcpO1xuICAgIH1cbiAgfVxuICByZXNldEZyYWdtZW50TG9hZGluZyhmcmFnKSB7XG4gICAgaWYgKCF0aGlzLmZyYWdDdXJyZW50IHx8ICF0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSAmJiB0aGlzLnN0YXRlICE9PSBTdGF0ZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgfVxuICB9XG4gIG9uRnJhZ21lbnRPcktleUxvYWRFcnJvcihmaWx0ZXJUeXBlLCBkYXRhKSB7XG4gICAgaWYgKGRhdGEuY2h1bmtNZXRhICYmICFkYXRhLmZyYWcpIHtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmdldEN1cnJlbnRDb250ZXh0KGRhdGEuY2h1bmtNZXRhKTtcbiAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgIGRhdGEuZnJhZyA9IGNvbnRleHQuZnJhZztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZnJhZyA9IGRhdGEuZnJhZztcbiAgICAvLyBIYW5kbGUgZnJhZyBlcnJvciByZWxhdGVkIHRvIGNhbGxlcidzIGZpbHRlclR5cGVcbiAgICBpZiAoIWZyYWcgfHwgZnJhZy50eXBlICE9PSBmaWx0ZXJUeXBlIHx8ICF0aGlzLmxldmVscykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykpIHtcbiAgICAgIHZhciBfdGhpcyRmcmFnQ3VycmVudDI7XG4gICAgICB0aGlzLndhcm4oYEZyYWcgbG9hZCBlcnJvciBtdXN0IG1hdGNoIGN1cnJlbnQgZnJhZyB0byByZXRyeSAke2ZyYWcudXJsfSA+ICR7KF90aGlzJGZyYWdDdXJyZW50MiA9IHRoaXMuZnJhZ0N1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRmcmFnQ3VycmVudDIudXJsfWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBnYXBUYWdFbmNvdW50ZXJlZCA9IGRhdGEuZGV0YWlscyA9PT0gRXJyb3JEZXRhaWxzLkZSQUdfR0FQO1xuICAgIGlmIChnYXBUYWdFbmNvdW50ZXJlZCkge1xuICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIuZnJhZ0J1ZmZlcmVkKGZyYWcsIHRydWUpO1xuICAgIH1cbiAgICAvLyBrZWVwIHJldHJ5aW5nIHVudGlsIHRoZSBsaW1pdCB3aWxsIGJlIHJlYWNoZWRcbiAgICBjb25zdCBlcnJvckFjdGlvbiA9IGRhdGEuZXJyb3JBY3Rpb247XG4gICAgY29uc3Qge1xuICAgICAgYWN0aW9uLFxuICAgICAgcmV0cnlDb3VudCA9IDAsXG4gICAgICByZXRyeUNvbmZpZ1xuICAgIH0gPSBlcnJvckFjdGlvbiB8fCB7fTtcbiAgICBpZiAoZXJyb3JBY3Rpb24gJiYgYWN0aW9uID09PSBOZXR3b3JrRXJyb3JBY3Rpb24uUmV0cnlSZXF1ZXN0ICYmIHJldHJ5Q29uZmlnKSB7XG4gICAgICB0aGlzLnJlc2V0U3RhcnRXaGVuTm90TG9hZGVkKHRoaXMubGV2ZWxMYXN0TG9hZGVkKTtcbiAgICAgIGNvbnN0IGRlbGF5ID0gZ2V0UmV0cnlEZWxheShyZXRyeUNvbmZpZywgcmV0cnlDb3VudCk7XG4gICAgICB0aGlzLndhcm4oYEZyYWdtZW50ICR7ZnJhZy5zbn0gb2YgJHtmaWx0ZXJUeXBlfSAke2ZyYWcubGV2ZWx9IGVycm9yZWQgd2l0aCAke2RhdGEuZGV0YWlsc30sIHJldHJ5aW5nIGxvYWRpbmcgJHtyZXRyeUNvdW50ICsgMX0vJHtyZXRyeUNvbmZpZy5tYXhOdW1SZXRyeX0gaW4gJHtkZWxheX1tc2ApO1xuICAgICAgZXJyb3JBY3Rpb24ucmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5yZXRyeURhdGUgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpICsgZGVsYXk7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk7XG4gICAgfSBlbHNlIGlmIChyZXRyeUNvbmZpZyAmJiBlcnJvckFjdGlvbikge1xuICAgICAgdGhpcy5yZXNldEZyYWdtZW50RXJyb3JzKGZpbHRlclR5cGUpO1xuICAgICAgaWYgKHJldHJ5Q291bnQgPCByZXRyeUNvbmZpZy5tYXhOdW1SZXRyeSkge1xuICAgICAgICAvLyBOZXR3b3JrIHJldHJ5IGlzIHNraXBwZWQgd2hlbiBsZXZlbCBzd2l0Y2ggaXMgcHJlZmVycmVkXG4gICAgICAgIGlmICghZ2FwVGFnRW5jb3VudGVyZWQgJiYgYWN0aW9uICE9PSBOZXR3b3JrRXJyb3JBY3Rpb24uUmVtb3ZlQWx0ZXJuYXRlUGVybWFuZW50bHkpIHtcbiAgICAgICAgICBlcnJvckFjdGlvbi5yZXNvbHZlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ2dlci53YXJuKGAke2RhdGEuZGV0YWlsc30gcmVhY2hlZCBvciBleGNlZWRlZCBtYXggcmV0cnkgKCR7cmV0cnlDb3VudH0pYCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKChlcnJvckFjdGlvbiA9PSBudWxsID8gdm9pZCAwIDogZXJyb3JBY3Rpb24uYWN0aW9uKSA9PT0gTmV0d29ya0Vycm9yQWN0aW9uLlNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3gpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5XQUlUSU5HX0xFVkVMO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRVJST1I7XG4gICAgfVxuICAgIC8vIFBlcmZvcm0gbmV4dCBhc3luYyB0aWNrIHNvb25lciB0byBzcGVlZCB1cCBlcnJvciBhY3Rpb24gcmVzb2x1dGlvblxuICAgIHRoaXMudGlja0ltbWVkaWF0ZSgpO1xuICB9XG4gIHJlZHVjZUxlbmd0aEFuZEZsdXNoQnVmZmVyKGRhdGEpIHtcbiAgICAvLyBpZiBpbiBhcHBlbmRpbmcgc3RhdGVcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU3RhdGUuUEFSU0lORyB8fCB0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTRUQpIHtcbiAgICAgIGNvbnN0IHBsYXlsaXN0VHlwZSA9IGRhdGEucGFyZW50O1xuICAgICAgY29uc3QgYnVmZmVyZWRJbmZvID0gdGhpcy5nZXRGd2RCdWZmZXJJbmZvKHRoaXMubWVkaWFCdWZmZXIsIHBsYXlsaXN0VHlwZSk7XG4gICAgICAvLyAwLjUgOiB0b2xlcmFuY2UgbmVlZGVkIGFzIHNvbWUgYnJvd3NlcnMgc3RhbGxzIHBsYXliYWNrIGJlZm9yZSByZWFjaGluZyBidWZmZXJlZCBlbmRcbiAgICAgIC8vIHJlZHVjZSBtYXggYnVmIGxlbiBpZiBjdXJyZW50IHBvc2l0aW9uIGlzIGJ1ZmZlcmVkXG4gICAgICBjb25zdCBidWZmZXJlZCA9IGJ1ZmZlcmVkSW5mbyAmJiBidWZmZXJlZEluZm8ubGVuID4gMC41O1xuICAgICAgaWYgKGJ1ZmZlcmVkKSB7XG4gICAgICAgIHRoaXMucmVkdWNlTWF4QnVmZmVyTGVuZ3RoKGJ1ZmZlcmVkSW5mby5sZW4pO1xuICAgICAgfVxuICAgICAgY29uc3QgZmx1c2hCdWZmZXIgPSAhYnVmZmVyZWQ7XG4gICAgICBpZiAoZmx1c2hCdWZmZXIpIHtcbiAgICAgICAgLy8gY3VycmVudCBwb3NpdGlvbiBpcyBub3QgYnVmZmVyZWQsIGJ1dCBicm93c2VyIGlzIHN0aWxsIGNvbXBsYWluaW5nIGFib3V0IGJ1ZmZlciBmdWxsIGVycm9yXG4gICAgICAgIC8vIHRoaXMgaGFwcGVucyBvbiBJRS9FZGdlLCByZWZlciB0byBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9wdWxsLzcwOFxuICAgICAgICAvLyBpbiB0aGF0IGNhc2UgZmx1c2ggdGhlIHdob2xlIGF1ZGlvIGJ1ZmZlciB0byByZWNvdmVyXG4gICAgICAgIHRoaXMud2FybihgQnVmZmVyIGZ1bGwgZXJyb3Igd2hpbGUgbWVkaWEuY3VycmVudFRpbWUgaXMgbm90IGJ1ZmZlcmVkLCBmbHVzaCAke3BsYXlsaXN0VHlwZX0gYnVmZmVyYCk7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YS5mcmFnKSB7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGRhdGEuZnJhZyk7XG4gICAgICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IGRhdGEuZnJhZy5zdGFydDtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKTtcbiAgICAgIHJldHVybiBmbHVzaEJ1ZmZlcjtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJlc2V0RnJhZ21lbnRFcnJvcnMoZmlsdGVyVHlwZSkge1xuICAgIGlmIChmaWx0ZXJUeXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5BVURJTykge1xuICAgICAgLy8gUmVzZXQgY3VycmVudCBmcmFnbWVudCBzaW5jZSBhdWRpbyB0cmFjayBhdWRpbyBpcyBlc3NlbnRpYWwgYW5kIG1heSBub3QgaGF2ZSBhIGZhaWwtb3ZlciB0cmFja1xuICAgICAgdGhpcy5mcmFnQ3VycmVudCA9IG51bGw7XG4gICAgfVxuICAgIC8vIEZyYWdtZW50IGVycm9ycyB0aGF0IHJlc3VsdCBpbiBhIGxldmVsIHN3aXRjaCBvciByZWR1bmRhbnQgZmFpbC1vdmVyXG4gICAgLy8gc2hvdWxkIHJlc2V0IHRoZSBzdHJlYW0gY29udHJvbGxlciBzdGF0ZSB0byBpZGxlXG4gICAgaWYgKCF0aGlzLmxvYWRlZG1ldGFkYXRhKSB7XG4gICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU3RhdGUuU1RPUFBFRCkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgfVxuICB9XG4gIGFmdGVyQnVmZmVyRmx1c2hlZChtZWRpYSwgYnVmZmVyVHlwZSwgcGxheWxpc3RUeXBlKSB7XG4gICAgaWYgKCFtZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBBZnRlciBzdWNjZXNzZnVsIGJ1ZmZlciBmbHVzaGluZywgZmlsdGVyIGZsdXNoZWQgZnJhZ21lbnRzIGZyb20gYnVmZmVyZWRGcmFncyB1c2UgbWVkaWFCdWZmZXJlZCBpbnN0ZWFkIG9mIG1lZGlhXG4gICAgLy8gKHNvIHRoYXQgd2Ugd2lsbCBjaGVjayBhZ2FpbnN0IHZpZGVvLmJ1ZmZlcmVkIHJhbmdlcyBpbiBjYXNlIG9mIGFsdCBhdWRpbyB0cmFjaylcbiAgICBjb25zdCBidWZmZXJlZFRpbWVSYW5nZXMgPSBCdWZmZXJIZWxwZXIuZ2V0QnVmZmVyZWQobWVkaWEpO1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLmRldGVjdEV2aWN0ZWRGcmFnbWVudHMoYnVmZmVyVHlwZSwgYnVmZmVyZWRUaW1lUmFuZ2VzLCBwbGF5bGlzdFR5cGUpO1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5FTkRFRCkge1xuICAgICAgdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpO1xuICAgIH1cbiAgfVxuICByZXNldExvYWRpbmdTdGF0ZSgpIHtcbiAgICB0aGlzLmxvZygnUmVzZXQgbG9hZGluZyBzdGF0ZScpO1xuICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsO1xuICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gbnVsbDtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgfVxuICByZXNldFN0YXJ0V2hlbk5vdExvYWRlZChsZXZlbCkge1xuICAgIC8vIGlmIGxvYWRlZG1ldGFkYXRhIGlzIG5vdCBzZXQsIGl0IG1lYW5zIHRoYXQgZmlyc3QgZnJhZyByZXF1ZXN0IGZhaWxlZFxuICAgIC8vIGluIHRoYXQgY2FzZSwgcmVzZXQgc3RhcnRGcmFnUmVxdWVzdGVkIGZsYWdcbiAgICBpZiAoIXRoaXMubG9hZGVkbWV0YWRhdGEpIHtcbiAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICBjb25zdCBkZXRhaWxzID0gbGV2ZWwgPyBsZXZlbC5kZXRhaWxzIDogbnVsbDtcbiAgICAgIGlmIChkZXRhaWxzICE9IG51bGwgJiYgZGV0YWlscy5saXZlKSB7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgc3RhcnQgcG9zaXRpb24gYW5kIHJldHVybiB0byBJRExFIHRvIHJlY292ZXIgbGl2ZSBzdGFydFxuICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSAtMTtcbiAgICAgICAgdGhpcy5zZXRTdGFydFBvc2l0aW9uKGRldGFpbHMsIDApO1xuICAgICAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb247XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJlc2V0V2hlbk1pc3NpbmdDb250ZXh0KGNodW5rTWV0YSkge1xuICAgIHRoaXMud2FybihgVGhlIGxvYWRpbmcgY29udGV4dCBjaGFuZ2VkIHdoaWxlIGJ1ZmZlcmluZyBmcmFnbWVudCAke2NodW5rTWV0YS5zbn0gb2YgbGV2ZWwgJHtjaHVua01ldGEubGV2ZWx9LiBUaGlzIGNodW5rIHdpbGwgbm90IGJlIGJ1ZmZlcmVkLmApO1xuICAgIHRoaXMucmVtb3ZlVW5idWZmZXJlZEZyYWdzKCk7XG4gICAgdGhpcy5yZXNldFN0YXJ0V2hlbk5vdExvYWRlZCh0aGlzLmxldmVsTGFzdExvYWRlZCk7XG4gICAgdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpO1xuICB9XG4gIHJlbW92ZVVuYnVmZmVyZWRGcmFncyhzdGFydCA9IDApIHtcbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudHNJblJhbmdlKHN0YXJ0LCBJbmZpbml0eSwgdGhpcy5wbGF5bGlzdFR5cGUsIGZhbHNlLCB0cnVlKTtcbiAgfVxuICB1cGRhdGVMZXZlbFRpbWluZyhmcmFnLCBwYXJ0LCBsZXZlbCwgcGFydGlhbCkge1xuICAgIHZhciBfdGhpcyR0cmFuc211eGVyO1xuICAgIGNvbnN0IGRldGFpbHMgPSBsZXZlbC5kZXRhaWxzO1xuICAgIGlmICghZGV0YWlscykge1xuICAgICAgdGhpcy53YXJuKCdsZXZlbC5kZXRhaWxzIHVuZGVmaW5lZCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZWQgPSBPYmplY3Qua2V5cyhmcmFnLmVsZW1lbnRhcnlTdHJlYW1zKS5yZWR1Y2UoKHJlc3VsdCwgdHlwZSkgPT4ge1xuICAgICAgY29uc3QgaW5mbyA9IGZyYWcuZWxlbWVudGFyeVN0cmVhbXNbdHlwZV07XG4gICAgICBpZiAoaW5mbykge1xuICAgICAgICBjb25zdCBwYXJzZWREdXJhdGlvbiA9IGluZm8uZW5kUFRTIC0gaW5mby5zdGFydFBUUztcbiAgICAgICAgaWYgKHBhcnNlZER1cmF0aW9uIDw9IDApIHtcbiAgICAgICAgICAvLyBEZXN0cm95IHRoZSB0cmFuc211eGVyIGFmdGVyIGl0J3MgbmV4dCB0aW1lIG9mZnNldCBmYWlsZWQgdG8gYWR2YW5jZSBiZWNhdXNlIGR1cmF0aW9uIHdhcyA8PSAwLlxuICAgICAgICAgIC8vIFRoZSBuZXcgdHJhbnNtdXhlciB3aWxsIGJlIGNvbmZpZ3VyZWQgd2l0aCBhIHRpbWUgb2Zmc2V0IG1hdGNoaW5nIHRoZSBuZXh0IGZyYWdtZW50IHN0YXJ0LFxuICAgICAgICAgIC8vIHByZXZlbnRpbmcgdGhlIHRpbWVsaW5lIGZyb20gc2hpZnRpbmcuXG4gICAgICAgICAgdGhpcy53YXJuKGBDb3VsZCBub3QgcGFyc2UgZnJhZ21lbnQgJHtmcmFnLnNufSAke3R5cGV9IGR1cmF0aW9uIHJlbGlhYmx5ICgke3BhcnNlZER1cmF0aW9ufSlgKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0IHx8IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRyaWZ0ID0gcGFydGlhbCA/IDAgOiB1cGRhdGVGcmFnUFRTRFRTKGRldGFpbHMsIGZyYWcsIGluZm8uc3RhcnRQVFMsIGluZm8uZW5kUFRTLCBpbmZvLnN0YXJ0RFRTLCBpbmZvLmVuZERUUyk7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkxFVkVMX1BUU19VUERBVEVELCB7XG4gICAgICAgICAgZGV0YWlscyxcbiAgICAgICAgICBsZXZlbCxcbiAgICAgICAgICBkcmlmdCxcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgc3RhcnQ6IGluZm8uc3RhcnRQVFMsXG4gICAgICAgICAgZW5kOiBpbmZvLmVuZFBUU1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIGZhbHNlKTtcbiAgICBpZiAoIXBhcnNlZCAmJiAoKF90aGlzJHRyYW5zbXV4ZXIgPSB0aGlzLnRyYW5zbXV4ZXIpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyR0cmFuc211eGVyLmVycm9yKSA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYEZvdW5kIG5vIG1lZGlhIGluIGZyYWdtZW50ICR7ZnJhZy5zbn0gb2YgbGV2ZWwgJHtmcmFnLmxldmVsfSByZXNldHRpbmcgdHJhbnNtdXhlciB0byBmYWxsYmFjayB0byBwbGF5bGlzdCB0aW1pbmdgKTtcbiAgICAgIGlmIChsZXZlbC5mcmFnbWVudEVycm9yID09PSAwKSB7XG4gICAgICAgIC8vIE1hcmsgYW5kIHRyYWNrIHRoZSBvZGQgZW1wdHkgc2VnbWVudCBhcyBhIGdhcCB0byBhdm9pZCByZWxvYWRpbmdcbiAgICAgICAgbGV2ZWwuZnJhZ21lbnRFcnJvcisrO1xuICAgICAgICBmcmFnLmdhcCA9IHRydWU7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWcpO1xuICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5mcmFnQnVmZmVyZWQoZnJhZywgdHJ1ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLndhcm4oZXJyb3IubWVzc2FnZSk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLFxuICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgIGVycm9yLFxuICAgICAgICBmcmFnLFxuICAgICAgICByZWFzb246IGBGb3VuZCBubyBtZWRpYSBpbiBtc24gJHtmcmFnLnNufSBvZiBsZXZlbCBcIiR7bGV2ZWwudXJsfVwiYFxuICAgICAgfSk7XG4gICAgICBpZiAoIXRoaXMuaGxzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVzZXRUcmFuc211eGVyKCk7XG4gICAgICAvLyBGb3IgdGhpcyBlcnJvciBmYWxsdGhyb3VnaC4gTWFya2luZyBwYXJzZWQgd2lsbCBhbGxvdyBhZHZhbmNpbmcgdG8gbmV4dCBmcmFnbWVudC5cbiAgICB9XG4gICAgdGhpcy5zdGF0ZSA9IFN0YXRlLlBBUlNFRDtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX1BBUlNFRCwge1xuICAgICAgZnJhZyxcbiAgICAgIHBhcnRcbiAgICB9KTtcbiAgfVxuICByZXNldFRyYW5zbXV4ZXIoKSB7XG4gICAgaWYgKHRoaXMudHJhbnNtdXhlcikge1xuICAgICAgdGhpcy50cmFuc211eGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMudHJhbnNtdXhlciA9IG51bGw7XG4gICAgfVxuICB9XG4gIHJlY292ZXJXb3JrZXJFcnJvcihkYXRhKSB7XG4gICAgaWYgKGRhdGEuZXZlbnQgPT09ICdkZW11eGVyV29ya2VyJykge1xuICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlQWxsRnJhZ21lbnRzKCk7XG4gICAgICB0aGlzLnJlc2V0VHJhbnNtdXhlcigpO1xuICAgICAgdGhpcy5yZXNldFN0YXJ0V2hlbk5vdExvYWRlZCh0aGlzLmxldmVsTGFzdExvYWRlZCk7XG4gICAgICB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gICAgfVxuICB9XG4gIHNldCBzdGF0ZShuZXh0U3RhdGUpIHtcbiAgICBjb25zdCBwcmV2aW91c1N0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgaWYgKHByZXZpb3VzU3RhdGUgIT09IG5leHRTdGF0ZSkge1xuICAgICAgdGhpcy5fc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgICB0aGlzLmxvZyhgJHtwcmV2aW91c1N0YXRlfS0+JHtuZXh0U3RhdGV9YCk7XG4gICAgfVxuICB9XG4gIGdldCBzdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gIH1cbn1cblxuY2xhc3MgQ2h1bmtDYWNoZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgdGhpcy5kYXRhTGVuZ3RoID0gMDtcbiAgfVxuICBwdXNoKGNodW5rKSB7XG4gICAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7XG4gICAgdGhpcy5kYXRhTGVuZ3RoICs9IGNodW5rLmxlbmd0aDtcbiAgfVxuICBmbHVzaCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBjaHVua3MsXG4gICAgICBkYXRhTGVuZ3RoXG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBpZiAoIWNodW5rcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgwKTtcbiAgICB9IGVsc2UgaWYgKGNodW5rcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJlc3VsdCA9IGNodW5rc1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gY29uY2F0VWludDhBcnJheXMoY2h1bmtzLCBkYXRhTGVuZ3RoKTtcbiAgICB9XG4gICAgdGhpcy5yZXNldCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5jaHVua3MubGVuZ3RoID0gMDtcbiAgICB0aGlzLmRhdGFMZW5ndGggPSAwO1xuICB9XG59XG5mdW5jdGlvbiBjb25jYXRVaW50OEFycmF5cyhjaHVua3MsIGRhdGFMZW5ndGgpIHtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YUxlbmd0aCk7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNodW5rcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNodW5rID0gY2h1bmtzW2ldO1xuICAgIHJlc3VsdC5zZXQoY2h1bmssIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IGNodW5rLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBlbnN1cmUgdGhlIHdvcmtlciBlbmRzIHVwIGluIHRoZSBidW5kbGVcbi8vIElmIHRoZSB3b3JrZXIgc2hvdWxkIG5vdCBiZSBpbmNsdWRlZCB0aGlzIGdldHMgYWxpYXNlZCB0byBlbXB0eS5qc1xuZnVuY3Rpb24gaGFzVU1EV29ya2VyKCkge1xuICByZXR1cm4gdHlwZW9mIF9fSExTX1dPUktFUl9CVU5ETEVfXyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmZ1bmN0aW9uIGluamVjdFdvcmtlcigpIHtcbiAgY29uc3QgYmxvYiA9IG5ldyBzZWxmLkJsb2IoW2B2YXIgZXhwb3J0cz17fTt2YXIgbW9kdWxlPXtleHBvcnRzOmV4cG9ydHN9O2Z1bmN0aW9uIGRlZmluZShmKXtmKCl9O2RlZmluZS5hbWQ9dHJ1ZTsoJHtfX0hMU19XT1JLRVJfQlVORExFX18udG9TdHJpbmcoKX0pKHRydWUpO2BdLCB7XG4gICAgdHlwZTogJ3RleHQvamF2YXNjcmlwdCdcbiAgfSk7XG4gIGNvbnN0IG9iamVjdFVSTCA9IHNlbGYuVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgY29uc3Qgd29ya2VyID0gbmV3IHNlbGYuV29ya2VyKG9iamVjdFVSTCk7XG4gIHJldHVybiB7XG4gICAgd29ya2VyLFxuICAgIG9iamVjdFVSTFxuICB9O1xufVxuZnVuY3Rpb24gbG9hZFdvcmtlcihwYXRoKSB7XG4gIGNvbnN0IHNjcmlwdFVSTCA9IG5ldyBzZWxmLlVSTChwYXRoLCBzZWxmLmxvY2F0aW9uLmhyZWYpLmhyZWY7XG4gIGNvbnN0IHdvcmtlciA9IG5ldyBzZWxmLldvcmtlcihzY3JpcHRVUkwpO1xuICByZXR1cm4ge1xuICAgIHdvcmtlcixcbiAgICBzY3JpcHRVUkxcbiAgfTtcbn1cblxuZnVuY3Rpb24gZHVtbXlUcmFjayh0eXBlID0gJycsIGlucHV0VGltZVNjYWxlID0gOTAwMDApIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlLFxuICAgIGlkOiAtMSxcbiAgICBwaWQ6IC0xLFxuICAgIGlucHV0VGltZVNjYWxlLFxuICAgIHNlcXVlbmNlTnVtYmVyOiAtMSxcbiAgICBzYW1wbGVzOiBbXSxcbiAgICBkcm9wcGVkOiAwXG4gIH07XG59XG5cbmNsYXNzIEJhc2VBdWRpb0RlbXV4ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9hdWRpb1RyYWNrID0gdm9pZCAwO1xuICAgIHRoaXMuX2lkM1RyYWNrID0gdm9pZCAwO1xuICAgIHRoaXMuZnJhbWVJbmRleCA9IDA7XG4gICAgdGhpcy5jYWNoZWREYXRhID0gbnVsbDtcbiAgICB0aGlzLmJhc2VQVFMgPSBudWxsO1xuICAgIHRoaXMuaW5pdFBUUyA9IG51bGw7XG4gICAgdGhpcy5sYXN0UFRTID0gbnVsbDtcbiAgfVxuICByZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0cmFja0R1cmF0aW9uKSB7XG4gICAgdGhpcy5faWQzVHJhY2sgPSB7XG4gICAgICB0eXBlOiAnaWQzJyxcbiAgICAgIGlkOiAzLFxuICAgICAgcGlkOiAtMSxcbiAgICAgIGlucHV0VGltZVNjYWxlOiA5MDAwMCxcbiAgICAgIHNlcXVlbmNlTnVtYmVyOiAwLFxuICAgICAgc2FtcGxlczogW10sXG4gICAgICBkcm9wcGVkOiAwXG4gICAgfTtcbiAgfVxuICByZXNldFRpbWVTdGFtcChkZWF1bHRUaW1lc3RhbXApIHtcbiAgICB0aGlzLmluaXRQVFMgPSBkZWF1bHRUaW1lc3RhbXA7XG4gICAgdGhpcy5yZXNldENvbnRpZ3VpdHkoKTtcbiAgfVxuICByZXNldENvbnRpZ3VpdHkoKSB7XG4gICAgdGhpcy5iYXNlUFRTID0gbnVsbDtcbiAgICB0aGlzLmxhc3RQVFMgPSBudWxsO1xuICAgIHRoaXMuZnJhbWVJbmRleCA9IDA7XG4gIH1cbiAgY2FuUGFyc2UoZGF0YSwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGFwcGVuZEZyYW1lKHRyYWNrLCBkYXRhLCBvZmZzZXQpIHt9XG5cbiAgLy8gZmVlZCBpbmNvbWluZyBkYXRhIHRvIHRoZSBmcm9udCBvZiB0aGUgcGFyc2luZyBwaXBlbGluZVxuICBkZW11eChkYXRhLCB0aW1lT2Zmc2V0KSB7XG4gICAgaWYgKHRoaXMuY2FjaGVkRGF0YSkge1xuICAgICAgZGF0YSA9IGFwcGVuZFVpbnQ4QXJyYXkodGhpcy5jYWNoZWREYXRhLCBkYXRhKTtcbiAgICAgIHRoaXMuY2FjaGVkRGF0YSA9IG51bGw7XG4gICAgfVxuICAgIGxldCBpZDNEYXRhID0gZ2V0SUQzRGF0YShkYXRhLCAwKTtcbiAgICBsZXQgb2Zmc2V0ID0gaWQzRGF0YSA/IGlkM0RhdGEubGVuZ3RoIDogMDtcbiAgICBsZXQgbGFzdERhdGFJbmRleDtcbiAgICBjb25zdCB0cmFjayA9IHRoaXMuX2F1ZGlvVHJhY2s7XG4gICAgY29uc3QgaWQzVHJhY2sgPSB0aGlzLl9pZDNUcmFjaztcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBpZDNEYXRhID8gZ2V0VGltZVN0YW1wKGlkM0RhdGEpIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgIGlmICh0aGlzLmJhc2VQVFMgPT09IG51bGwgfHwgdGhpcy5mcmFtZUluZGV4ID09PSAwICYmIGlzRmluaXRlTnVtYmVyKHRpbWVzdGFtcCkpIHtcbiAgICAgIHRoaXMuYmFzZVBUUyA9IGluaXRQVFNGbih0aW1lc3RhbXAsIHRpbWVPZmZzZXQsIHRoaXMuaW5pdFBUUyk7XG4gICAgICB0aGlzLmxhc3RQVFMgPSB0aGlzLmJhc2VQVFM7XG4gICAgfVxuICAgIGlmICh0aGlzLmxhc3RQVFMgPT09IG51bGwpIHtcbiAgICAgIHRoaXMubGFzdFBUUyA9IHRoaXMuYmFzZVBUUztcbiAgICB9XG5cbiAgICAvLyBtb3JlIGV4cHJlc3NpdmUgdGhhbiBhbHRlcm5hdGl2ZTogaWQzRGF0YT8ubGVuZ3RoXG4gICAgaWYgKGlkM0RhdGEgJiYgaWQzRGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICBpZDNUcmFjay5zYW1wbGVzLnB1c2goe1xuICAgICAgICBwdHM6IHRoaXMubGFzdFBUUyxcbiAgICAgICAgZHRzOiB0aGlzLmxhc3RQVFMsXG4gICAgICAgIGRhdGE6IGlkM0RhdGEsXG4gICAgICAgIHR5cGU6IE1ldGFkYXRhU2NoZW1hLmF1ZGlvSWQzLFxuICAgICAgICBkdXJhdGlvbjogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXG4gICAgICB9KTtcbiAgICB9XG4gICAgd2hpbGUgKG9mZnNldCA8IGxlbmd0aCkge1xuICAgICAgaWYgKHRoaXMuY2FuUGFyc2UoZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICBjb25zdCBmcmFtZSA9IHRoaXMuYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCk7XG4gICAgICAgIGlmIChmcmFtZSkge1xuICAgICAgICAgIHRoaXMuZnJhbWVJbmRleCsrO1xuICAgICAgICAgIHRoaXMubGFzdFBUUyA9IGZyYW1lLnNhbXBsZS5wdHM7XG4gICAgICAgICAgb2Zmc2V0ICs9IGZyYW1lLmxlbmd0aDtcbiAgICAgICAgICBsYXN0RGF0YUluZGV4ID0gb2Zmc2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZnNldCA9IGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjYW5QYXJzZSQyKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgLy8gYWZ0ZXIgYSBJRDMuY2FuUGFyc2UsIGEgY2FsbCB0byBJRDMuZ2V0SUQzRGF0YSAqc2hvdWxkKiBhbHdheXMgcmV0dXJucyBzb21lIGRhdGFcbiAgICAgICAgaWQzRGF0YSA9IGdldElEM0RhdGEoZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgaWQzVHJhY2suc2FtcGxlcy5wdXNoKHtcbiAgICAgICAgICBwdHM6IHRoaXMubGFzdFBUUyxcbiAgICAgICAgICBkdHM6IHRoaXMubGFzdFBUUyxcbiAgICAgICAgICBkYXRhOiBpZDNEYXRhLFxuICAgICAgICAgIHR5cGU6IE1ldGFkYXRhU2NoZW1hLmF1ZGlvSWQzLFxuICAgICAgICAgIGR1cmF0aW9uOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFlcbiAgICAgICAgfSk7XG4gICAgICAgIG9mZnNldCArPSBpZDNEYXRhLmxlbmd0aDtcbiAgICAgICAgbGFzdERhdGFJbmRleCA9IG9mZnNldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgfVxuICAgICAgaWYgKG9mZnNldCA9PT0gbGVuZ3RoICYmIGxhc3REYXRhSW5kZXggIT09IGxlbmd0aCkge1xuICAgICAgICBjb25zdCBwYXJ0aWFsRGF0YSA9IHNsaWNlVWludDgoZGF0YSwgbGFzdERhdGFJbmRleCk7XG4gICAgICAgIGlmICh0aGlzLmNhY2hlZERhdGEpIHtcbiAgICAgICAgICB0aGlzLmNhY2hlZERhdGEgPSBhcHBlbmRVaW50OEFycmF5KHRoaXMuY2FjaGVkRGF0YSwgcGFydGlhbERhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY2FjaGVkRGF0YSA9IHBhcnRpYWxEYXRhO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBhdWRpb1RyYWNrOiB0cmFjayxcbiAgICAgIHZpZGVvVHJhY2s6IGR1bW15VHJhY2soKSxcbiAgICAgIGlkM1RyYWNrLFxuICAgICAgdGV4dFRyYWNrOiBkdW1teVRyYWNrKClcbiAgICB9O1xuICB9XG4gIGRlbXV4U2FtcGxlQWVzKGRhdGEsIGtleURhdGEsIHRpbWVPZmZzZXQpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBbJHt0aGlzfV0gVGhpcyBkZW11eGVyIGRvZXMgbm90IHN1cHBvcnQgU2FtcGxlLUFFUyBkZWNyeXB0aW9uYCkpO1xuICB9XG4gIGZsdXNoKHRpbWVPZmZzZXQpIHtcbiAgICAvLyBQYXJzZSBjYWNoZSBpbiBjYXNlIG9mIHJlbWFpbmluZyBmcmFtZXMuXG4gICAgY29uc3QgY2FjaGVkRGF0YSA9IHRoaXMuY2FjaGVkRGF0YTtcbiAgICBpZiAoY2FjaGVkRGF0YSkge1xuICAgICAgdGhpcy5jYWNoZWREYXRhID0gbnVsbDtcbiAgICAgIHRoaXMuZGVtdXgoY2FjaGVkRGF0YSwgMCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBhdWRpb1RyYWNrOiB0aGlzLl9hdWRpb1RyYWNrLFxuICAgICAgdmlkZW9UcmFjazogZHVtbXlUcmFjaygpLFxuICAgICAgaWQzVHJhY2s6IHRoaXMuX2lkM1RyYWNrLFxuICAgICAgdGV4dFRyYWNrOiBkdW1teVRyYWNrKClcbiAgICB9O1xuICB9XG4gIGRlc3Ryb3koKSB7fVxufVxuXG4vKipcbiAqIEluaXRpYWxpemUgUFRTXG4gKiA8cD5cbiAqICAgIHVzZSB0aW1lc3RhbXAgdW5sZXNzIGl0IGlzIHVuZGVmaW5lZCwgTmFOIG9yIEluZmluaXR5XG4gKiA8L3A+XG4gKi9cbmNvbnN0IGluaXRQVFNGbiA9ICh0aW1lc3RhbXAsIHRpbWVPZmZzZXQsIGluaXRQVFMpID0+IHtcbiAgaWYgKGlzRmluaXRlTnVtYmVyKHRpbWVzdGFtcCkpIHtcbiAgICByZXR1cm4gdGltZXN0YW1wICogOTA7XG4gIH1cbiAgY29uc3QgaW5pdDkwa0h6ID0gaW5pdFBUUyA/IGluaXRQVFMuYmFzZVRpbWUgKiA5MDAwMCAvIGluaXRQVFMudGltZXNjYWxlIDogMDtcbiAgcmV0dXJuIHRpbWVPZmZzZXQgKiA5MDAwMCArIGluaXQ5MGtIejtcbn07XG5cbi8qKlxuICogQURUUyBwYXJzZXIgaGVscGVyXG4gKiBAbGluayBodHRwczovL3dpa2kubXVsdGltZWRpYS5jeC9pbmRleC5waHA/dGl0bGU9QURUU1xuICovXG5mdW5jdGlvbiBnZXRBdWRpb0NvbmZpZyhvYnNlcnZlciwgZGF0YSwgb2Zmc2V0LCBhdWRpb0NvZGVjKSB7XG4gIGxldCBhZHRzT2JqZWN0VHlwZTtcbiAgbGV0IGFkdHNFeHRlbnNpb25TYW1wbGluZ0luZGV4O1xuICBsZXQgYWR0c0NoYW5uZWxDb25maWc7XG4gIGxldCBjb25maWc7XG4gIGNvbnN0IHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbiAgY29uc3QgbWFuaWZlc3RDb2RlYyA9IGF1ZGlvQ29kZWM7XG4gIGNvbnN0IGFkdHNTYW1wbGluZ1JhdGVzID0gWzk2MDAwLCA4ODIwMCwgNjQwMDAsIDQ4MDAwLCA0NDEwMCwgMzIwMDAsIDI0MDAwLCAyMjA1MCwgMTYwMDAsIDEyMDAwLCAxMTAyNSwgODAwMCwgNzM1MF07XG4gIC8vIGJ5dGUgMlxuICBhZHRzT2JqZWN0VHlwZSA9ICgoZGF0YVtvZmZzZXQgKyAyXSAmIDB4YzApID4+PiA2KSArIDE7XG4gIGNvbnN0IGFkdHNTYW1wbGluZ0luZGV4ID0gKGRhdGFbb2Zmc2V0ICsgMl0gJiAweDNjKSA+Pj4gMjtcbiAgaWYgKGFkdHNTYW1wbGluZ0luZGV4ID4gYWR0c1NhbXBsaW5nUmF0ZXMubGVuZ3RoIC0gMSkge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBpbnZhbGlkIEFEVFMgc2FtcGxpbmcgaW5kZXg6JHthZHRzU2FtcGxpbmdJbmRleH1gKTtcbiAgICBvYnNlcnZlci5lbWl0KEV2ZW50cy5FUlJPUiwgRXZlbnRzLkVSUk9SLCB7XG4gICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUixcbiAgICAgIGZhdGFsOiB0cnVlLFxuICAgICAgZXJyb3IsXG4gICAgICByZWFzb246IGVycm9yLm1lc3NhZ2VcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cbiAgYWR0c0NoYW5uZWxDb25maWcgPSAoZGF0YVtvZmZzZXQgKyAyXSAmIDB4MDEpIDw8IDI7XG4gIC8vIGJ5dGUgM1xuICBhZHRzQ2hhbm5lbENvbmZpZyB8PSAoZGF0YVtvZmZzZXQgKyAzXSAmIDB4YzApID4+PiA2O1xuICBsb2dnZXIubG9nKGBtYW5pZmVzdCBjb2RlYzoke2F1ZGlvQ29kZWN9LCBBRFRTIHR5cGU6JHthZHRzT2JqZWN0VHlwZX0sIHNhbXBsaW5nSW5kZXg6JHthZHRzU2FtcGxpbmdJbmRleH1gKTtcbiAgLy8gZmlyZWZveDogZnJlcSBsZXNzIHRoYW4gMjRrSHogPSBBQUMgU0JSIChIRS1BQUMpXG4gIGlmICgvZmlyZWZveC9pLnRlc3QodXNlckFnZW50KSkge1xuICAgIGlmIChhZHRzU2FtcGxpbmdJbmRleCA+PSA2KSB7XG4gICAgICBhZHRzT2JqZWN0VHlwZSA9IDU7XG4gICAgICBjb25maWcgPSBuZXcgQXJyYXkoNCk7XG4gICAgICAvLyBIRS1BQUMgdXNlcyBTQlIgKFNwZWN0cmFsIEJhbmQgUmVwbGljYXRpb24pICwgaGlnaCBmcmVxdWVuY2llcyBhcmUgY29uc3RydWN0ZWQgZnJvbSBsb3cgZnJlcXVlbmNpZXNcbiAgICAgIC8vIHRoZXJlIGlzIGEgZmFjdG9yIDIgYmV0d2VlbiBmcmFtZSBzYW1wbGUgcmF0ZSBhbmQgb3V0cHV0IHNhbXBsZSByYXRlXG4gICAgICAvLyBtdWx0aXBseSBmcmVxdWVuY3kgYnkgMiAoc2VlIHRhYmxlIGJlbG93LCBlcXVpdmFsZW50IHRvIHN1YnN0cmFjdCAzKVxuICAgICAgYWR0c0V4dGVuc2lvblNhbXBsaW5nSW5kZXggPSBhZHRzU2FtcGxpbmdJbmRleCAtIDM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFkdHNPYmplY3RUeXBlID0gMjtcbiAgICAgIGNvbmZpZyA9IG5ldyBBcnJheSgyKTtcbiAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGluZ0luZGV4ID0gYWR0c1NhbXBsaW5nSW5kZXg7XG4gICAgfVxuICAgIC8vIEFuZHJvaWQgOiBhbHdheXMgdXNlIEFBQ1xuICB9IGVsc2UgaWYgKHVzZXJBZ2VudC5pbmRleE9mKCdhbmRyb2lkJykgIT09IC0xKSB7XG4gICAgYWR0c09iamVjdFR5cGUgPSAyO1xuICAgIGNvbmZpZyA9IG5ldyBBcnJheSgyKTtcbiAgICBhZHRzRXh0ZW5zaW9uU2FtcGxpbmdJbmRleCA9IGFkdHNTYW1wbGluZ0luZGV4O1xuICB9IGVsc2Uge1xuICAgIC8qICBmb3Igb3RoZXIgYnJvd3NlcnMgKENocm9tZS9WaXZhbGRpL09wZXJhIC4uLilcbiAgICAgICAgYWx3YXlzIGZvcmNlIGF1ZGlvIHR5cGUgdG8gYmUgSEUtQUFDIFNCUiwgYXMgc29tZSBicm93c2VycyBkbyBub3Qgc3VwcG9ydCBhdWRpbyBjb2RlYyBzd2l0Y2ggcHJvcGVybHkgKGxpa2UgQ2hyb21lIC4uLilcbiAgICAqL1xuICAgIGFkdHNPYmplY3RUeXBlID0gNTtcbiAgICBjb25maWcgPSBuZXcgQXJyYXkoNCk7XG4gICAgLy8gaWYgKG1hbmlmZXN0IGNvZGVjIGlzIEhFLUFBQyBvciBIRS1BQUN2MikgT1IgKG1hbmlmZXN0IGNvZGVjIG5vdCBzcGVjaWZpZWQgQU5EIGZyZXF1ZW5jeSBsZXNzIHRoYW4gMjRrSHopXG4gICAgaWYgKGF1ZGlvQ29kZWMgJiYgKGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC4yOScpICE9PSAtMSB8fCBhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PSAtMSkgfHwgIWF1ZGlvQ29kZWMgJiYgYWR0c1NhbXBsaW5nSW5kZXggPj0gNikge1xuICAgICAgLy8gSEUtQUFDIHVzZXMgU0JSIChTcGVjdHJhbCBCYW5kIFJlcGxpY2F0aW9uKSAsIGhpZ2ggZnJlcXVlbmNpZXMgYXJlIGNvbnN0cnVjdGVkIGZyb20gbG93IGZyZXF1ZW5jaWVzXG4gICAgICAvLyB0aGVyZSBpcyBhIGZhY3RvciAyIGJldHdlZW4gZnJhbWUgc2FtcGxlIHJhdGUgYW5kIG91dHB1dCBzYW1wbGUgcmF0ZVxuICAgICAgLy8gbXVsdGlwbHkgZnJlcXVlbmN5IGJ5IDIgKHNlZSB0YWJsZSBiZWxvdywgZXF1aXZhbGVudCB0byBzdWJzdHJhY3QgMylcbiAgICAgIGFkdHNFeHRlbnNpb25TYW1wbGluZ0luZGV4ID0gYWR0c1NhbXBsaW5nSW5kZXggLSAzO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiAobWFuaWZlc3QgY29kZWMgaXMgQUFDKSBBTkQgKGZyZXF1ZW5jeSBsZXNzIHRoYW4gMjRrSHogQU5EIG5iIGNoYW5uZWwgaXMgMSkgT1IgKG1hbmlmZXN0IGNvZGVjIG5vdCBzcGVjaWZpZWQgYW5kIG1vbm8gYXVkaW8pXG4gICAgICAvLyBDaHJvbWUgZmFpbHMgdG8gcGxheSBiYWNrIHdpdGggbG93IGZyZXF1ZW5jeSBBQUMgTEMgbW9ubyB3aGVuIGluaXRpYWxpemVkIHdpdGggSEUtQUFDLiAgVGhpcyBpcyBub3QgYSBwcm9ibGVtIHdpdGggc3RlcmVvLlxuICAgICAgaWYgKGF1ZGlvQ29kZWMgJiYgYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjInKSAhPT0gLTEgJiYgKGFkdHNTYW1wbGluZ0luZGV4ID49IDYgJiYgYWR0c0NoYW5uZWxDb25maWcgPT09IDEgfHwgL3ZpdmFsZGkvaS50ZXN0KHVzZXJBZ2VudCkpIHx8ICFhdWRpb0NvZGVjICYmIGFkdHNDaGFubmVsQ29uZmlnID09PSAxKSB7XG4gICAgICAgIGFkdHNPYmplY3RUeXBlID0gMjtcbiAgICAgICAgY29uZmlnID0gbmV3IEFycmF5KDIpO1xuICAgICAgfVxuICAgICAgYWR0c0V4dGVuc2lvblNhbXBsaW5nSW5kZXggPSBhZHRzU2FtcGxpbmdJbmRleDtcbiAgICB9XG4gIH1cbiAgLyogcmVmZXIgdG8gaHR0cDovL3dpa2kubXVsdGltZWRpYS5jeC9pbmRleC5waHA/dGl0bGU9TVBFRy00X0F1ZGlvI0F1ZGlvX1NwZWNpZmljX0NvbmZpZ1xuICAgICAgSVNPIDE0NDk2LTMgKEFBQykucGRmIC0gVGFibGUgMS4xMyDigJQgU3ludGF4IG9mIEF1ZGlvU3BlY2lmaWNDb25maWcoKVxuICAgIEF1ZGlvIFByb2ZpbGUgLyBBdWRpbyBPYmplY3QgVHlwZVxuICAgIDA6IE51bGxcbiAgICAxOiBBQUMgTWFpblxuICAgIDI6IEFBQyBMQyAoTG93IENvbXBsZXhpdHkpXG4gICAgMzogQUFDIFNTUiAoU2NhbGFibGUgU2FtcGxlIFJhdGUpXG4gICAgNDogQUFDIExUUCAoTG9uZyBUZXJtIFByZWRpY3Rpb24pXG4gICAgNTogU0JSIChTcGVjdHJhbCBCYW5kIFJlcGxpY2F0aW9uKVxuICAgIDY6IEFBQyBTY2FsYWJsZVxuICAgc2FtcGxpbmcgZnJlcVxuICAgIDA6IDk2MDAwIEh6XG4gICAgMTogODgyMDAgSHpcbiAgICAyOiA2NDAwMCBIelxuICAgIDM6IDQ4MDAwIEh6XG4gICAgNDogNDQxMDAgSHpcbiAgICA1OiAzMjAwMCBIelxuICAgIDY6IDI0MDAwIEh6XG4gICAgNzogMjIwNTAgSHpcbiAgICA4OiAxNjAwMCBIelxuICAgIDk6IDEyMDAwIEh6XG4gICAgMTA6IDExMDI1IEh6XG4gICAgMTE6IDgwMDAgSHpcbiAgICAxMjogNzM1MCBIelxuICAgIDEzOiBSZXNlcnZlZFxuICAgIDE0OiBSZXNlcnZlZFxuICAgIDE1OiBmcmVxdWVuY3kgaXMgd3JpdHRlbiBleHBsaWN0bHlcbiAgICBDaGFubmVsIENvbmZpZ3VyYXRpb25zXG4gICAgVGhlc2UgYXJlIHRoZSBjaGFubmVsIGNvbmZpZ3VyYXRpb25zOlxuICAgIDA6IERlZmluZWQgaW4gQU9UIFNwZWNpZmMgQ29uZmlnXG4gICAgMTogMSBjaGFubmVsOiBmcm9udC1jZW50ZXJcbiAgICAyOiAyIGNoYW5uZWxzOiBmcm9udC1sZWZ0LCBmcm9udC1yaWdodFxuICAqL1xuICAvLyBhdWRpb09iamVjdFR5cGUgPSBwcm9maWxlID0+IHByb2ZpbGUsIHRoZSBNUEVHLTQgQXVkaW8gT2JqZWN0IFR5cGUgbWludXMgMVxuICBjb25maWdbMF0gPSBhZHRzT2JqZWN0VHlwZSA8PCAzO1xuICAvLyBzYW1wbGluZ0ZyZXF1ZW5jeUluZGV4XG4gIGNvbmZpZ1swXSB8PSAoYWR0c1NhbXBsaW5nSW5kZXggJiAweDBlKSA+PiAxO1xuICBjb25maWdbMV0gfD0gKGFkdHNTYW1wbGluZ0luZGV4ICYgMHgwMSkgPDwgNztcbiAgLy8gY2hhbm5lbENvbmZpZ3VyYXRpb25cbiAgY29uZmlnWzFdIHw9IGFkdHNDaGFubmVsQ29uZmlnIDw8IDM7XG4gIGlmIChhZHRzT2JqZWN0VHlwZSA9PT0gNSkge1xuICAgIC8vIGFkdHNFeHRlbnNpb25TYW1wbGluZ0luZGV4XG4gICAgY29uZmlnWzFdIHw9IChhZHRzRXh0ZW5zaW9uU2FtcGxpbmdJbmRleCAmIDB4MGUpID4+IDE7XG4gICAgY29uZmlnWzJdID0gKGFkdHNFeHRlbnNpb25TYW1wbGluZ0luZGV4ICYgMHgwMSkgPDwgNztcbiAgICAvLyBhZHRzT2JqZWN0VHlwZSAoZm9yY2UgdG8gMiwgY2hyb21lIGlzIGNoZWNraW5nIHRoYXQgb2JqZWN0IHR5cGUgaXMgbGVzcyB0aGFuIDUgPz8/XG4gICAgLy8gICAgaHR0cHM6Ly9jaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2Nocm9taXVtL3NyYy5naXQvKy9tYXN0ZXIvbWVkaWEvZm9ybWF0cy9tcDQvYWFjLmNjXG4gICAgY29uZmlnWzJdIHw9IDIgPDwgMjtcbiAgICBjb25maWdbM10gPSAwO1xuICB9XG4gIHJldHVybiB7XG4gICAgY29uZmlnLFxuICAgIHNhbXBsZXJhdGU6IGFkdHNTYW1wbGluZ1JhdGVzW2FkdHNTYW1wbGluZ0luZGV4XSxcbiAgICBjaGFubmVsQ291bnQ6IGFkdHNDaGFubmVsQ29uZmlnLFxuICAgIGNvZGVjOiAnbXA0YS40MC4nICsgYWR0c09iamVjdFR5cGUsXG4gICAgbWFuaWZlc3RDb2RlY1xuICB9O1xufVxuZnVuY3Rpb24gaXNIZWFkZXJQYXR0ZXJuJDEoZGF0YSwgb2Zmc2V0KSB7XG4gIHJldHVybiBkYXRhW29mZnNldF0gPT09IDB4ZmYgJiYgKGRhdGFbb2Zmc2V0ICsgMV0gJiAweGY2KSA9PT0gMHhmMDtcbn1cbmZ1bmN0aW9uIGdldEhlYWRlckxlbmd0aChkYXRhLCBvZmZzZXQpIHtcbiAgcmV0dXJuIGRhdGFbb2Zmc2V0ICsgMV0gJiAweDAxID8gNyA6IDk7XG59XG5mdW5jdGlvbiBnZXRGdWxsRnJhbWVMZW5ndGgoZGF0YSwgb2Zmc2V0KSB7XG4gIHJldHVybiAoZGF0YVtvZmZzZXQgKyAzXSAmIDB4MDMpIDw8IDExIHwgZGF0YVtvZmZzZXQgKyA0XSA8PCAzIHwgKGRhdGFbb2Zmc2V0ICsgNV0gJiAweGUwKSA+Pj4gNTtcbn1cbmZ1bmN0aW9uIGNhbkdldEZyYW1lTGVuZ3RoKGRhdGEsIG9mZnNldCkge1xuICByZXR1cm4gb2Zmc2V0ICsgNSA8IGRhdGEubGVuZ3RoO1xufVxuZnVuY3Rpb24gaXNIZWFkZXIkMShkYXRhLCBvZmZzZXQpIHtcbiAgLy8gTG9vayBmb3IgQURUUyBoZWFkZXIgfCAxMTExIDExMTEgfCAxMTExIFgwMFggfCB3aGVyZSBYIGNhbiBiZSBlaXRoZXIgMCBvciAxXG4gIC8vIExheWVyIGJpdHMgKHBvc2l0aW9uIDE0IGFuZCAxNSkgaW4gaGVhZGVyIHNob3VsZCBiZSBhbHdheXMgMCBmb3IgQURUU1xuICAvLyBNb3JlIGluZm8gaHR0cHM6Ly93aWtpLm11bHRpbWVkaWEuY3gvaW5kZXgucGhwP3RpdGxlPUFEVFNcbiAgcmV0dXJuIG9mZnNldCArIDEgPCBkYXRhLmxlbmd0aCAmJiBpc0hlYWRlclBhdHRlcm4kMShkYXRhLCBvZmZzZXQpO1xufVxuZnVuY3Rpb24gY2FuUGFyc2UkMShkYXRhLCBvZmZzZXQpIHtcbiAgcmV0dXJuIGNhbkdldEZyYW1lTGVuZ3RoKGRhdGEsIG9mZnNldCkgJiYgaXNIZWFkZXJQYXR0ZXJuJDEoZGF0YSwgb2Zmc2V0KSAmJiBnZXRGdWxsRnJhbWVMZW5ndGgoZGF0YSwgb2Zmc2V0KSA8PSBkYXRhLmxlbmd0aCAtIG9mZnNldDtcbn1cbmZ1bmN0aW9uIHByb2JlJDEoZGF0YSwgb2Zmc2V0KSB7XG4gIC8vIHNhbWUgYXMgaXNIZWFkZXIgYnV0IHdlIGFsc28gY2hlY2sgdGhhdCBBRFRTIGZyYW1lIGZvbGxvd3MgbGFzdCBBRFRTIGZyYW1lXG4gIC8vIG9yIGVuZCBvZiBkYXRhIGlzIHJlYWNoZWRcbiAgaWYgKGlzSGVhZGVyJDEoZGF0YSwgb2Zmc2V0KSkge1xuICAgIC8vIEFEVFMgaGVhZGVyIExlbmd0aFxuICAgIGNvbnN0IGhlYWRlckxlbmd0aCA9IGdldEhlYWRlckxlbmd0aChkYXRhLCBvZmZzZXQpO1xuICAgIGlmIChvZmZzZXQgKyBoZWFkZXJMZW5ndGggPj0gZGF0YS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gQURUUyBmcmFtZSBMZW5ndGhcbiAgICBjb25zdCBmcmFtZUxlbmd0aCA9IGdldEZ1bGxGcmFtZUxlbmd0aChkYXRhLCBvZmZzZXQpO1xuICAgIGlmIChmcmFtZUxlbmd0aCA8PSBoZWFkZXJMZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbmV3T2Zmc2V0ID0gb2Zmc2V0ICsgZnJhbWVMZW5ndGg7XG4gICAgcmV0dXJuIG5ld09mZnNldCA9PT0gZGF0YS5sZW5ndGggfHwgaXNIZWFkZXIkMShkYXRhLCBuZXdPZmZzZXQpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGluaXRUcmFja0NvbmZpZyh0cmFjaywgb2JzZXJ2ZXIsIGRhdGEsIG9mZnNldCwgYXVkaW9Db2RlYykge1xuICBpZiAoIXRyYWNrLnNhbXBsZXJhdGUpIHtcbiAgICBjb25zdCBjb25maWcgPSBnZXRBdWRpb0NvbmZpZyhvYnNlcnZlciwgZGF0YSwgb2Zmc2V0LCBhdWRpb0NvZGVjKTtcbiAgICBpZiAoIWNvbmZpZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cmFjay5jb25maWcgPSBjb25maWcuY29uZmlnO1xuICAgIHRyYWNrLnNhbXBsZXJhdGUgPSBjb25maWcuc2FtcGxlcmF0ZTtcbiAgICB0cmFjay5jaGFubmVsQ291bnQgPSBjb25maWcuY2hhbm5lbENvdW50O1xuICAgIHRyYWNrLmNvZGVjID0gY29uZmlnLmNvZGVjO1xuICAgIHRyYWNrLm1hbmlmZXN0Q29kZWMgPSBjb25maWcubWFuaWZlc3RDb2RlYztcbiAgICBsb2dnZXIubG9nKGBwYXJzZWQgY29kZWM6JHt0cmFjay5jb2RlY30sIHJhdGU6JHtjb25maWcuc2FtcGxlcmF0ZX0sIGNoYW5uZWxzOiR7Y29uZmlnLmNoYW5uZWxDb3VudH1gKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0RnJhbWVEdXJhdGlvbihzYW1wbGVyYXRlKSB7XG4gIHJldHVybiAxMDI0ICogOTAwMDAgLyBzYW1wbGVyYXRlO1xufVxuZnVuY3Rpb24gcGFyc2VGcmFtZUhlYWRlcihkYXRhLCBvZmZzZXQpIHtcbiAgLy8gVGhlIHByb3RlY3Rpb24gc2tpcCBiaXQgdGVsbHMgdXMgaWYgd2UgaGF2ZSAyIGJ5dGVzIG9mIENSQyBkYXRhIGF0IHRoZSBlbmQgb2YgdGhlIEFEVFMgaGVhZGVyXG4gIGNvbnN0IGhlYWRlckxlbmd0aCA9IGdldEhlYWRlckxlbmd0aChkYXRhLCBvZmZzZXQpO1xuICBpZiAob2Zmc2V0ICsgaGVhZGVyTGVuZ3RoIDw9IGRhdGEubGVuZ3RoKSB7XG4gICAgLy8gcmV0cmlldmUgZnJhbWUgc2l6ZVxuICAgIGNvbnN0IGZyYW1lTGVuZ3RoID0gZ2V0RnVsbEZyYW1lTGVuZ3RoKGRhdGEsIG9mZnNldCkgLSBoZWFkZXJMZW5ndGg7XG4gICAgaWYgKGZyYW1lTGVuZ3RoID4gMCkge1xuICAgICAgLy8gbG9nZ2VyLmxvZyhgQUFDIGZyYW1lLCBvZmZzZXQvbGVuZ3RoL3RvdGFsL3B0czoke29mZnNldCtoZWFkZXJMZW5ndGh9LyR7ZnJhbWVMZW5ndGh9LyR7ZGF0YS5ieXRlTGVuZ3RofWApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaGVhZGVyTGVuZ3RoLFxuICAgICAgICBmcmFtZUxlbmd0aFxuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFwcGVuZEZyYW1lJDIodHJhY2ssIGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4KSB7XG4gIGNvbnN0IGZyYW1lRHVyYXRpb24gPSBnZXRGcmFtZUR1cmF0aW9uKHRyYWNrLnNhbXBsZXJhdGUpO1xuICBjb25zdCBzdGFtcCA9IHB0cyArIGZyYW1lSW5kZXggKiBmcmFtZUR1cmF0aW9uO1xuICBjb25zdCBoZWFkZXIgPSBwYXJzZUZyYW1lSGVhZGVyKGRhdGEsIG9mZnNldCk7XG4gIGxldCB1bml0O1xuICBpZiAoaGVhZGVyKSB7XG4gICAgY29uc3Qge1xuICAgICAgZnJhbWVMZW5ndGgsXG4gICAgICBoZWFkZXJMZW5ndGhcbiAgICB9ID0gaGVhZGVyO1xuICAgIGNvbnN0IF9sZW5ndGggPSBoZWFkZXJMZW5ndGggKyBmcmFtZUxlbmd0aDtcbiAgICBjb25zdCBtaXNzaW5nID0gTWF0aC5tYXgoMCwgb2Zmc2V0ICsgX2xlbmd0aCAtIGRhdGEubGVuZ3RoKTtcbiAgICAvLyBsb2dnZXIubG9nKGBBQUMgZnJhbWUgJHtmcmFtZUluZGV4fSwgcHRzOiR7c3RhbXB9IGxlbmd0aEBvZmZzZXQvdG90YWw6ICR7ZnJhbWVMZW5ndGh9QCR7b2Zmc2V0K2hlYWRlckxlbmd0aH0vJHtkYXRhLmJ5dGVMZW5ndGh9IG1pc3Npbmc6ICR7bWlzc2luZ31gKTtcbiAgICBpZiAobWlzc2luZykge1xuICAgICAgdW5pdCA9IG5ldyBVaW50OEFycmF5KF9sZW5ndGggLSBoZWFkZXJMZW5ndGgpO1xuICAgICAgdW5pdC5zZXQoZGF0YS5zdWJhcnJheShvZmZzZXQgKyBoZWFkZXJMZW5ndGgsIGRhdGEubGVuZ3RoKSwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVuaXQgPSBkYXRhLnN1YmFycmF5KG9mZnNldCArIGhlYWRlckxlbmd0aCwgb2Zmc2V0ICsgX2xlbmd0aCk7XG4gICAgfVxuICAgIGNvbnN0IF9zYW1wbGUgPSB7XG4gICAgICB1bml0LFxuICAgICAgcHRzOiBzdGFtcFxuICAgIH07XG4gICAgaWYgKCFtaXNzaW5nKSB7XG4gICAgICB0cmFjay5zYW1wbGVzLnB1c2goX3NhbXBsZSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzYW1wbGU6IF9zYW1wbGUsXG4gICAgICBsZW5ndGg6IF9sZW5ndGgsXG4gICAgICBtaXNzaW5nXG4gICAgfTtcbiAgfVxuICAvLyBvdmVyZmxvdyBpbmNvbXBsZXRlIGhlYWRlclxuICBjb25zdCBsZW5ndGggPSBkYXRhLmxlbmd0aCAtIG9mZnNldDtcbiAgdW5pdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gIHVuaXQuc2V0KGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBkYXRhLmxlbmd0aCksIDApO1xuICBjb25zdCBzYW1wbGUgPSB7XG4gICAgdW5pdCxcbiAgICBwdHM6IHN0YW1wXG4gIH07XG4gIHJldHVybiB7XG4gICAgc2FtcGxlLFxuICAgIGxlbmd0aCxcbiAgICBtaXNzaW5nOiAtMVxuICB9O1xufVxuXG4vKipcbiAqICBNUEVHIHBhcnNlciBoZWxwZXJcbiAqL1xuXG5sZXQgY2hyb21lVmVyc2lvbiQxID0gbnVsbDtcbmNvbnN0IEJpdHJhdGVzTWFwID0gWzMyLCA2NCwgOTYsIDEyOCwgMTYwLCAxOTIsIDIyNCwgMjU2LCAyODgsIDMyMCwgMzUyLCAzODQsIDQxNiwgNDQ4LCAzMiwgNDgsIDU2LCA2NCwgODAsIDk2LCAxMTIsIDEyOCwgMTYwLCAxOTIsIDIyNCwgMjU2LCAzMjAsIDM4NCwgMzIsIDQwLCA0OCwgNTYsIDY0LCA4MCwgOTYsIDExMiwgMTI4LCAxNjAsIDE5MiwgMjI0LCAyNTYsIDMyMCwgMzIsIDQ4LCA1NiwgNjQsIDgwLCA5NiwgMTEyLCAxMjgsIDE0NCwgMTYwLCAxNzYsIDE5MiwgMjI0LCAyNTYsIDgsIDE2LCAyNCwgMzIsIDQwLCA0OCwgNTYsIDY0LCA4MCwgOTYsIDExMiwgMTI4LCAxNDQsIDE2MF07XG5jb25zdCBTYW1wbGluZ1JhdGVNYXAgPSBbNDQxMDAsIDQ4MDAwLCAzMjAwMCwgMjIwNTAsIDI0MDAwLCAxNjAwMCwgMTEwMjUsIDEyMDAwLCA4MDAwXTtcbmNvbnN0IFNhbXBsZXNDb2VmZmljaWVudHMgPSBbXG4vLyBNUEVHIDIuNVxuWzAsXG4vLyBSZXNlcnZlZFxuNzIsXG4vLyBMYXllcjNcbjE0NCxcbi8vIExheWVyMlxuMTIgLy8gTGF5ZXIxXG5dLFxuLy8gUmVzZXJ2ZWRcblswLFxuLy8gUmVzZXJ2ZWRcbjAsXG4vLyBMYXllcjNcbjAsXG4vLyBMYXllcjJcbjAgLy8gTGF5ZXIxXG5dLFxuLy8gTVBFRyAyXG5bMCxcbi8vIFJlc2VydmVkXG43Mixcbi8vIExheWVyM1xuMTQ0LFxuLy8gTGF5ZXIyXG4xMiAvLyBMYXllcjFcbl0sXG4vLyBNUEVHIDFcblswLFxuLy8gUmVzZXJ2ZWRcbjE0NCxcbi8vIExheWVyM1xuMTQ0LFxuLy8gTGF5ZXIyXG4xMiAvLyBMYXllcjFcbl1dO1xuY29uc3QgQnl0ZXNJblNsb3QgPSBbMCxcbi8vIFJlc2VydmVkXG4xLFxuLy8gTGF5ZXIzXG4xLFxuLy8gTGF5ZXIyXG40IC8vIExheWVyMVxuXTtcbmZ1bmN0aW9uIGFwcGVuZEZyYW1lJDEodHJhY2ssIGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4KSB7XG4gIC8vIFVzaW5nIGh0dHA6Ly93d3cuZGF0YXZveWFnZS5jb20vbXBnc2NyaXB0L21wZWdoZHIuaHRtIGFzIGEgcmVmZXJlbmNlXG4gIGlmIChvZmZzZXQgKyAyNCA+IGRhdGEubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGhlYWRlciA9IHBhcnNlSGVhZGVyKGRhdGEsIG9mZnNldCk7XG4gIGlmIChoZWFkZXIgJiYgb2Zmc2V0ICsgaGVhZGVyLmZyYW1lTGVuZ3RoIDw9IGRhdGEubGVuZ3RoKSB7XG4gICAgY29uc3QgZnJhbWVEdXJhdGlvbiA9IGhlYWRlci5zYW1wbGVzUGVyRnJhbWUgKiA5MDAwMCAvIGhlYWRlci5zYW1wbGVSYXRlO1xuICAgIGNvbnN0IHN0YW1wID0gcHRzICsgZnJhbWVJbmRleCAqIGZyYW1lRHVyYXRpb247XG4gICAgY29uc3Qgc2FtcGxlID0ge1xuICAgICAgdW5pdDogZGF0YS5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGhlYWRlci5mcmFtZUxlbmd0aCksXG4gICAgICBwdHM6IHN0YW1wLFxuICAgICAgZHRzOiBzdGFtcFxuICAgIH07XG4gICAgdHJhY2suY29uZmlnID0gW107XG4gICAgdHJhY2suY2hhbm5lbENvdW50ID0gaGVhZGVyLmNoYW5uZWxDb3VudDtcbiAgICB0cmFjay5zYW1wbGVyYXRlID0gaGVhZGVyLnNhbXBsZVJhdGU7XG4gICAgdHJhY2suc2FtcGxlcy5wdXNoKHNhbXBsZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNhbXBsZSxcbiAgICAgIGxlbmd0aDogaGVhZGVyLmZyYW1lTGVuZ3RoLFxuICAgICAgbWlzc2luZzogMFxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlSGVhZGVyKGRhdGEsIG9mZnNldCkge1xuICBjb25zdCBtcGVnVmVyc2lvbiA9IGRhdGFbb2Zmc2V0ICsgMV0gPj4gMyAmIDM7XG4gIGNvbnN0IG1wZWdMYXllciA9IGRhdGFbb2Zmc2V0ICsgMV0gPj4gMSAmIDM7XG4gIGNvbnN0IGJpdFJhdGVJbmRleCA9IGRhdGFbb2Zmc2V0ICsgMl0gPj4gNCAmIDE1O1xuICBjb25zdCBzYW1wbGVSYXRlSW5kZXggPSBkYXRhW29mZnNldCArIDJdID4+IDIgJiAzO1xuICBpZiAobXBlZ1ZlcnNpb24gIT09IDEgJiYgYml0UmF0ZUluZGV4ICE9PSAwICYmIGJpdFJhdGVJbmRleCAhPT0gMTUgJiYgc2FtcGxlUmF0ZUluZGV4ICE9PSAzKSB7XG4gICAgY29uc3QgcGFkZGluZ0JpdCA9IGRhdGFbb2Zmc2V0ICsgMl0gPj4gMSAmIDE7XG4gICAgY29uc3QgY2hhbm5lbE1vZGUgPSBkYXRhW29mZnNldCArIDNdID4+IDY7XG4gICAgY29uc3QgY29sdW1uSW5CaXRyYXRlcyA9IG1wZWdWZXJzaW9uID09PSAzID8gMyAtIG1wZWdMYXllciA6IG1wZWdMYXllciA9PT0gMyA/IDMgOiA0O1xuICAgIGNvbnN0IGJpdFJhdGUgPSBCaXRyYXRlc01hcFtjb2x1bW5JbkJpdHJhdGVzICogMTQgKyBiaXRSYXRlSW5kZXggLSAxXSAqIDEwMDA7XG4gICAgY29uc3QgY29sdW1uSW5TYW1wbGVSYXRlcyA9IG1wZWdWZXJzaW9uID09PSAzID8gMCA6IG1wZWdWZXJzaW9uID09PSAyID8gMSA6IDI7XG4gICAgY29uc3Qgc2FtcGxlUmF0ZSA9IFNhbXBsaW5nUmF0ZU1hcFtjb2x1bW5JblNhbXBsZVJhdGVzICogMyArIHNhbXBsZVJhdGVJbmRleF07XG4gICAgY29uc3QgY2hhbm5lbENvdW50ID0gY2hhbm5lbE1vZGUgPT09IDMgPyAxIDogMjsgLy8gSWYgYml0cyBvZiBjaGFubmVsIG1vZGUgYXJlIGAxMWAgdGhlbiBpdCBpcyBhIHNpbmdsZSBjaGFubmVsIChNb25vKVxuICAgIGNvbnN0IHNhbXBsZUNvZWZmaWNpZW50ID0gU2FtcGxlc0NvZWZmaWNpZW50c1ttcGVnVmVyc2lvbl1bbXBlZ0xheWVyXTtcbiAgICBjb25zdCBieXRlc0luU2xvdCA9IEJ5dGVzSW5TbG90W21wZWdMYXllcl07XG4gICAgY29uc3Qgc2FtcGxlc1BlckZyYW1lID0gc2FtcGxlQ29lZmZpY2llbnQgKiA4ICogYnl0ZXNJblNsb3Q7XG4gICAgY29uc3QgZnJhbWVMZW5ndGggPSBNYXRoLmZsb29yKHNhbXBsZUNvZWZmaWNpZW50ICogYml0UmF0ZSAvIHNhbXBsZVJhdGUgKyBwYWRkaW5nQml0KSAqIGJ5dGVzSW5TbG90O1xuICAgIGlmIChjaHJvbWVWZXJzaW9uJDEgPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQgfHwgJyc7XG4gICAgICBjb25zdCByZXN1bHQgPSB1c2VyQWdlbnQubWF0Y2goL0Nocm9tZVxcLyhcXGQrKS9pKTtcbiAgICAgIGNocm9tZVZlcnNpb24kMSA9IHJlc3VsdCA/IHBhcnNlSW50KHJlc3VsdFsxXSkgOiAwO1xuICAgIH1cbiAgICBjb25zdCBuZWVkQ2hyb21lRml4ID0gISFjaHJvbWVWZXJzaW9uJDEgJiYgY2hyb21lVmVyc2lvbiQxIDw9IDg3O1xuICAgIGlmIChuZWVkQ2hyb21lRml4ICYmIG1wZWdMYXllciA9PT0gMiAmJiBiaXRSYXRlID49IDIyNDAwMCAmJiBjaGFubmVsTW9kZSA9PT0gMCkge1xuICAgICAgLy8gV29yayBhcm91bmQgYnVnIGluIENocm9taXVtIGJ5IHNldHRpbmcgY2hhbm5lbE1vZGUgdG8gZHVhbC1jaGFubmVsICgwMSkgaW5zdGVhZCBvZiBzdGVyZW8gKDAwKVxuICAgICAgZGF0YVtvZmZzZXQgKyAzXSA9IGRhdGFbb2Zmc2V0ICsgM10gfCAweDgwO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc2FtcGxlUmF0ZSxcbiAgICAgIGNoYW5uZWxDb3VudCxcbiAgICAgIGZyYW1lTGVuZ3RoLFxuICAgICAgc2FtcGxlc1BlckZyYW1lXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gaXNIZWFkZXJQYXR0ZXJuKGRhdGEsIG9mZnNldCkge1xuICByZXR1cm4gZGF0YVtvZmZzZXRdID09PSAweGZmICYmIChkYXRhW29mZnNldCArIDFdICYgMHhlMCkgPT09IDB4ZTAgJiYgKGRhdGFbb2Zmc2V0ICsgMV0gJiAweDA2KSAhPT0gMHgwMDtcbn1cbmZ1bmN0aW9uIGlzSGVhZGVyKGRhdGEsIG9mZnNldCkge1xuICAvLyBMb29rIGZvciBNUEVHIGhlYWRlciB8IDExMTEgMTExMSB8IDExMVggWFlaWCB8IHdoZXJlIFggY2FuIGJlIGVpdGhlciAwIG9yIDEgYW5kIFkgb3IgWiBzaG91bGQgYmUgMVxuICAvLyBMYXllciBiaXRzIChwb3NpdGlvbiAxNCBhbmQgMTUpIGluIGhlYWRlciBzaG91bGQgYmUgYWx3YXlzIGRpZmZlcmVudCBmcm9tIDAgKExheWVyIEkgb3IgTGF5ZXIgSUkgb3IgTGF5ZXIgSUlJKVxuICAvLyBNb3JlIGluZm8gaHR0cDovL3d3dy5tcDMtdGVjaC5vcmcvcHJvZ3JhbW1lci9mcmFtZV9oZWFkZXIuaHRtbFxuICByZXR1cm4gb2Zmc2V0ICsgMSA8IGRhdGEubGVuZ3RoICYmIGlzSGVhZGVyUGF0dGVybihkYXRhLCBvZmZzZXQpO1xufVxuZnVuY3Rpb24gY2FuUGFyc2UoZGF0YSwgb2Zmc2V0KSB7XG4gIGNvbnN0IGhlYWRlclNpemUgPSA0O1xuICByZXR1cm4gaXNIZWFkZXJQYXR0ZXJuKGRhdGEsIG9mZnNldCkgJiYgaGVhZGVyU2l6ZSA8PSBkYXRhLmxlbmd0aCAtIG9mZnNldDtcbn1cbmZ1bmN0aW9uIHByb2JlKGRhdGEsIG9mZnNldCkge1xuICAvLyBzYW1lIGFzIGlzSGVhZGVyIGJ1dCB3ZSBhbHNvIGNoZWNrIHRoYXQgTVBFRyBmcmFtZSBmb2xsb3dzIGxhc3QgTVBFRyBmcmFtZVxuICAvLyBvciBlbmQgb2YgZGF0YSBpcyByZWFjaGVkXG4gIGlmIChvZmZzZXQgKyAxIDwgZGF0YS5sZW5ndGggJiYgaXNIZWFkZXJQYXR0ZXJuKGRhdGEsIG9mZnNldCkpIHtcbiAgICAvLyBNUEVHIGhlYWRlciBMZW5ndGhcbiAgICBjb25zdCBoZWFkZXJMZW5ndGggPSA0O1xuICAgIC8vIE1QRUcgZnJhbWUgTGVuZ3RoXG4gICAgY29uc3QgaGVhZGVyID0gcGFyc2VIZWFkZXIoZGF0YSwgb2Zmc2V0KTtcbiAgICBsZXQgZnJhbWVMZW5ndGggPSBoZWFkZXJMZW5ndGg7XG4gICAgaWYgKGhlYWRlciAhPSBudWxsICYmIGhlYWRlci5mcmFtZUxlbmd0aCkge1xuICAgICAgZnJhbWVMZW5ndGggPSBoZWFkZXIuZnJhbWVMZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IG5ld09mZnNldCA9IG9mZnNldCArIGZyYW1lTGVuZ3RoO1xuICAgIHJldHVybiBuZXdPZmZzZXQgPT09IGRhdGEubGVuZ3RoIHx8IGlzSGVhZGVyKGRhdGEsIG5ld09mZnNldCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEFBQyBkZW11eGVyXG4gKi9cbmNsYXNzIEFBQ0RlbXV4ZXIgZXh0ZW5kcyBCYXNlQXVkaW9EZW11eGVyIHtcbiAgY29uc3RydWN0b3Iob2JzZXJ2ZXIsIGNvbmZpZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vYnNlcnZlciA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gIH1cbiAgcmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdHJhY2tEdXJhdGlvbikge1xuICAgIHN1cGVyLnJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRyYWNrRHVyYXRpb24pO1xuICAgIHRoaXMuX2F1ZGlvVHJhY2sgPSB7XG4gICAgICBjb250YWluZXI6ICdhdWRpby9hZHRzJyxcbiAgICAgIHR5cGU6ICdhdWRpbycsXG4gICAgICBpZDogMixcbiAgICAgIHBpZDogLTEsXG4gICAgICBzZXF1ZW5jZU51bWJlcjogMCxcbiAgICAgIHNlZ21lbnRDb2RlYzogJ2FhYycsXG4gICAgICBzYW1wbGVzOiBbXSxcbiAgICAgIG1hbmlmZXN0Q29kZWM6IGF1ZGlvQ29kZWMsXG4gICAgICBkdXJhdGlvbjogdHJhY2tEdXJhdGlvbixcbiAgICAgIGlucHV0VGltZVNjYWxlOiA5MDAwMCxcbiAgICAgIGRyb3BwZWQ6IDBcbiAgICB9O1xuICB9XG5cbiAgLy8gU291cmNlIGZvciBwcm9iZSBpbmZvIC0gaHR0cHM6Ly93aWtpLm11bHRpbWVkaWEuY3gvaW5kZXgucGhwP3RpdGxlPUFEVFNcbiAgc3RhdGljIHByb2JlKGRhdGEpIHtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgdGhlIEFEVFMgc3luYyB3b3JkXG4gICAgLy8gTG9vayBmb3IgQURUUyBoZWFkZXIgfCAxMTExIDExMTEgfCAxMTExIFgwMFggfCB3aGVyZSBYIGNhbiBiZSBlaXRoZXIgMCBvciAxXG4gICAgLy8gTGF5ZXIgYml0cyAocG9zaXRpb24gMTQgYW5kIDE1KSBpbiBoZWFkZXIgc2hvdWxkIGJlIGFsd2F5cyAwIGZvciBBRFRTXG4gICAgLy8gTW9yZSBpbmZvIGh0dHBzOi8vd2lraS5tdWx0aW1lZGlhLmN4L2luZGV4LnBocD90aXRsZT1BRFRTXG4gICAgY29uc3QgaWQzRGF0YSA9IGdldElEM0RhdGEoZGF0YSwgMCk7XG4gICAgbGV0IG9mZnNldCA9IChpZDNEYXRhID09IG51bGwgPyB2b2lkIDAgOiBpZDNEYXRhLmxlbmd0aCkgfHwgMDtcbiAgICBpZiAocHJvYmUoZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBsZW5ndGggPSBkYXRhLmxlbmd0aDsgb2Zmc2V0IDwgbGVuZ3RoOyBvZmZzZXQrKykge1xuICAgICAgaWYgKHByb2JlJDEoZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICBsb2dnZXIubG9nKCdBRFRTIHN5bmMgd29yZCBmb3VuZCAhJyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY2FuUGFyc2UoZGF0YSwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIGNhblBhcnNlJDEoZGF0YSwgb2Zmc2V0KTtcbiAgfVxuICBhcHBlbmRGcmFtZSh0cmFjaywgZGF0YSwgb2Zmc2V0KSB7XG4gICAgaW5pdFRyYWNrQ29uZmlnKHRyYWNrLCB0aGlzLm9ic2VydmVyLCBkYXRhLCBvZmZzZXQsIHRyYWNrLm1hbmlmZXN0Q29kZWMpO1xuICAgIGNvbnN0IGZyYW1lID0gYXBwZW5kRnJhbWUkMih0cmFjaywgZGF0YSwgb2Zmc2V0LCB0aGlzLmJhc2VQVFMsIHRoaXMuZnJhbWVJbmRleCk7XG4gICAgaWYgKGZyYW1lICYmIGZyYW1lLm1pc3NpbmcgPT09IDApIHtcbiAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgZW1zZ1NjaGVtZVBhdHRlcm4gPSAvXFwvZW1zZ1stL11JRDMvaTtcbmNsYXNzIE1QNERlbXV4ZXIge1xuICBjb25zdHJ1Y3RvcihvYnNlcnZlciwgY29uZmlnKSB7XG4gICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcbiAgICB0aGlzLnRpbWVPZmZzZXQgPSAwO1xuICAgIHRoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgIHRoaXMudmlkZW9UcmFjayA9IHZvaWQgMDtcbiAgICB0aGlzLmF1ZGlvVHJhY2sgPSB2b2lkIDA7XG4gICAgdGhpcy5pZDNUcmFjayA9IHZvaWQgMDtcbiAgICB0aGlzLnR4dFRyYWNrID0gdm9pZCAwO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICB9XG4gIHJlc2V0VGltZVN0YW1wKCkge31cbiAgcmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdHJhY2tEdXJhdGlvbikge1xuICAgIGNvbnN0IHZpZGVvVHJhY2sgPSB0aGlzLnZpZGVvVHJhY2sgPSBkdW1teVRyYWNrKCd2aWRlbycsIDEpO1xuICAgIGNvbnN0IGF1ZGlvVHJhY2sgPSB0aGlzLmF1ZGlvVHJhY2sgPSBkdW1teVRyYWNrKCdhdWRpbycsIDEpO1xuICAgIGNvbnN0IGNhcHRpb25UcmFjayA9IHRoaXMudHh0VHJhY2sgPSBkdW1teVRyYWNrKCd0ZXh0JywgMSk7XG4gICAgdGhpcy5pZDNUcmFjayA9IGR1bW15VHJhY2soJ2lkMycsIDEpO1xuICAgIHRoaXMudGltZU9mZnNldCA9IDA7XG4gICAgaWYgKCEoaW5pdFNlZ21lbnQgIT0gbnVsbCAmJiBpbml0U2VnbWVudC5ieXRlTGVuZ3RoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbml0RGF0YSA9IHBhcnNlSW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQpO1xuICAgIGlmIChpbml0RGF0YS52aWRlbykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBpZCxcbiAgICAgICAgdGltZXNjYWxlLFxuICAgICAgICBjb2RlY1xuICAgICAgfSA9IGluaXREYXRhLnZpZGVvO1xuICAgICAgdmlkZW9UcmFjay5pZCA9IGlkO1xuICAgICAgdmlkZW9UcmFjay50aW1lc2NhbGUgPSBjYXB0aW9uVHJhY2sudGltZXNjYWxlID0gdGltZXNjYWxlO1xuICAgICAgdmlkZW9UcmFjay5jb2RlYyA9IGNvZGVjO1xuICAgIH1cbiAgICBpZiAoaW5pdERhdGEuYXVkaW8pIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaWQsXG4gICAgICAgIHRpbWVzY2FsZSxcbiAgICAgICAgY29kZWNcbiAgICAgIH0gPSBpbml0RGF0YS5hdWRpbztcbiAgICAgIGF1ZGlvVHJhY2suaWQgPSBpZDtcbiAgICAgIGF1ZGlvVHJhY2sudGltZXNjYWxlID0gdGltZXNjYWxlO1xuICAgICAgYXVkaW9UcmFjay5jb2RlYyA9IGNvZGVjO1xuICAgIH1cbiAgICBjYXB0aW9uVHJhY2suaWQgPSBSZW11eGVyVHJhY2tJZENvbmZpZy50ZXh0O1xuICAgIHZpZGVvVHJhY2suc2FtcGxlRHVyYXRpb24gPSAwO1xuICAgIHZpZGVvVHJhY2suZHVyYXRpb24gPSBhdWRpb1RyYWNrLmR1cmF0aW9uID0gdHJhY2tEdXJhdGlvbjtcbiAgfVxuICByZXNldENvbnRpZ3VpdHkoKSB7XG4gICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcbiAgfVxuICBzdGF0aWMgcHJvYmUoZGF0YSkge1xuICAgIHJldHVybiBoYXNNb29mRGF0YShkYXRhKTtcbiAgfVxuICBkZW11eChkYXRhLCB0aW1lT2Zmc2V0KSB7XG4gICAgdGhpcy50aW1lT2Zmc2V0ID0gdGltZU9mZnNldDtcbiAgICAvLyBMb2FkIGFsbCBkYXRhIGludG8gdGhlIGF2YyB0cmFjay4gVGhlIENNQUYgcmVtdXhlciB3aWxsIGxvb2sgZm9yIHRoZSBkYXRhIGluIHRoZSBzYW1wbGVzIG9iamVjdDsgdGhlIHJlc3Qgb2YgdGhlIGZpZWxkcyBkbyBub3QgbWF0dGVyXG4gICAgbGV0IHZpZGVvU2FtcGxlcyA9IGRhdGE7XG4gICAgY29uc3QgdmlkZW9UcmFjayA9IHRoaXMudmlkZW9UcmFjaztcbiAgICBjb25zdCB0ZXh0VHJhY2sgPSB0aGlzLnR4dFRyYWNrO1xuICAgIGlmICh0aGlzLmNvbmZpZy5wcm9ncmVzc2l2ZSkge1xuICAgICAgLy8gU3BsaXQgdGhlIGJ5dGVzdHJlYW0gaW50byB0d28gcmFuZ2VzOiBvbmUgZW5jb21wYXNzaW5nIGFsbCBkYXRhIHVwIHVudGlsIHRoZSBzdGFydCBvZiB0aGUgbGFzdCBtb29mLCBhbmQgZXZlcnl0aGluZyBlbHNlLlxuICAgICAgLy8gVGhpcyBpcyBkb25lIHRvIGd1YXJhbnRlZSB0aGF0IHdlJ3JlIHNlbmRpbmcgdmFsaWQgZGF0YSB0byBNU0UgLSB3aGVuIGRlbXV4aW5nIHByb2dyZXNzaXZlbHksIHdlIGhhdmUgbm8gZ3VhcmFudGVlXG4gICAgICAvLyB0aGF0IHRoZSBmZXRjaCBsb2FkZXIgZ2l2ZXMgdXMgZmx1c2ggbW9vZittZGF0IHBhaXJzLiBJZiB3ZSBwdXNoIGphZ2dlZCBkYXRhIHRvIE1TRSwgaXQgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24uXG4gICAgICBpZiAodGhpcy5yZW1haW5kZXJEYXRhKSB7XG4gICAgICAgIHZpZGVvU2FtcGxlcyA9IGFwcGVuZFVpbnQ4QXJyYXkodGhpcy5yZW1haW5kZXJEYXRhLCBkYXRhKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNlZ21lbnRlZERhdGEgPSBzZWdtZW50VmFsaWRSYW5nZSh2aWRlb1NhbXBsZXMpO1xuICAgICAgdGhpcy5yZW1haW5kZXJEYXRhID0gc2VnbWVudGVkRGF0YS5yZW1haW5kZXI7XG4gICAgICB2aWRlb1RyYWNrLnNhbXBsZXMgPSBzZWdtZW50ZWREYXRhLnZhbGlkIHx8IG5ldyBVaW50OEFycmF5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpZGVvVHJhY2suc2FtcGxlcyA9IHZpZGVvU2FtcGxlcztcbiAgICB9XG4gICAgY29uc3QgaWQzVHJhY2sgPSB0aGlzLmV4dHJhY3RJRDNUcmFjayh2aWRlb1RyYWNrLCB0aW1lT2Zmc2V0KTtcbiAgICB0ZXh0VHJhY2suc2FtcGxlcyA9IHBhcnNlU2FtcGxlcyh0aW1lT2Zmc2V0LCB2aWRlb1RyYWNrKTtcbiAgICByZXR1cm4ge1xuICAgICAgdmlkZW9UcmFjayxcbiAgICAgIGF1ZGlvVHJhY2s6IHRoaXMuYXVkaW9UcmFjayxcbiAgICAgIGlkM1RyYWNrLFxuICAgICAgdGV4dFRyYWNrOiB0aGlzLnR4dFRyYWNrXG4gICAgfTtcbiAgfVxuICBmbHVzaCgpIHtcbiAgICBjb25zdCB0aW1lT2Zmc2V0ID0gdGhpcy50aW1lT2Zmc2V0O1xuICAgIGNvbnN0IHZpZGVvVHJhY2sgPSB0aGlzLnZpZGVvVHJhY2s7XG4gICAgY29uc3QgdGV4dFRyYWNrID0gdGhpcy50eHRUcmFjaztcbiAgICB2aWRlb1RyYWNrLnNhbXBsZXMgPSB0aGlzLnJlbWFpbmRlckRhdGEgfHwgbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgIGNvbnN0IGlkM1RyYWNrID0gdGhpcy5leHRyYWN0SUQzVHJhY2sodmlkZW9UcmFjaywgdGhpcy50aW1lT2Zmc2V0KTtcbiAgICB0ZXh0VHJhY2suc2FtcGxlcyA9IHBhcnNlU2FtcGxlcyh0aW1lT2Zmc2V0LCB2aWRlb1RyYWNrKTtcbiAgICByZXR1cm4ge1xuICAgICAgdmlkZW9UcmFjayxcbiAgICAgIGF1ZGlvVHJhY2s6IGR1bW15VHJhY2soKSxcbiAgICAgIGlkM1RyYWNrLFxuICAgICAgdGV4dFRyYWNrOiBkdW1teVRyYWNrKClcbiAgICB9O1xuICB9XG4gIGV4dHJhY3RJRDNUcmFjayh2aWRlb1RyYWNrLCB0aW1lT2Zmc2V0KSB7XG4gICAgY29uc3QgaWQzVHJhY2sgPSB0aGlzLmlkM1RyYWNrO1xuICAgIGlmICh2aWRlb1RyYWNrLnNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBlbXNncyA9IGZpbmRCb3godmlkZW9UcmFjay5zYW1wbGVzLCBbJ2Vtc2cnXSk7XG4gICAgICBpZiAoZW1zZ3MpIHtcbiAgICAgICAgZW1zZ3MuZm9yRWFjaChkYXRhID0+IHtcbiAgICAgICAgICBjb25zdCBlbXNnSW5mbyA9IHBhcnNlRW1zZyhkYXRhKTtcbiAgICAgICAgICBpZiAoZW1zZ1NjaGVtZVBhdHRlcm4udGVzdChlbXNnSW5mby5zY2hlbWVJZFVyaSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHB0cyA9IGlzRmluaXRlTnVtYmVyKGVtc2dJbmZvLnByZXNlbnRhdGlvblRpbWUpID8gZW1zZ0luZm8ucHJlc2VudGF0aW9uVGltZSAvIGVtc2dJbmZvLnRpbWVTY2FsZSA6IHRpbWVPZmZzZXQgKyBlbXNnSW5mby5wcmVzZW50YXRpb25UaW1lRGVsdGEgLyBlbXNnSW5mby50aW1lU2NhbGU7XG4gICAgICAgICAgICBsZXQgZHVyYXRpb24gPSBlbXNnSW5mby5ldmVudER1cmF0aW9uID09PSAweGZmZmZmZmZmID8gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIDogZW1zZ0luZm8uZXZlbnREdXJhdGlvbiAvIGVtc2dJbmZvLnRpbWVTY2FsZTtcbiAgICAgICAgICAgIC8vIFNhZmFyaSB0YWtlcyBhbnl0aGluZyA8PSAwLjAwMSBzZWNvbmRzIGFuZCBtYXBzIGl0IHRvIEluZmluaXR5XG4gICAgICAgICAgICBpZiAoZHVyYXRpb24gPD0gMC4wMDEpIHtcbiAgICAgICAgICAgICAgZHVyYXRpb24gPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gZW1zZ0luZm8ucGF5bG9hZDtcbiAgICAgICAgICAgIGlkM1RyYWNrLnNhbXBsZXMucHVzaCh7XG4gICAgICAgICAgICAgIGRhdGE6IHBheWxvYWQsXG4gICAgICAgICAgICAgIGxlbjogcGF5bG9hZC5ieXRlTGVuZ3RoLFxuICAgICAgICAgICAgICBkdHM6IHB0cyxcbiAgICAgICAgICAgICAgcHRzOiBwdHMsXG4gICAgICAgICAgICAgIHR5cGU6IE1ldGFkYXRhU2NoZW1hLmVtc2csXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGlkM1RyYWNrO1xuICB9XG4gIGRlbXV4U2FtcGxlQWVzKGRhdGEsIGtleURhdGEsIHRpbWVPZmZzZXQpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdUaGUgTVA0IGRlbXV4ZXIgZG9lcyBub3Qgc3VwcG9ydCBTQU1QTEUtQUVTIGRlY3J5cHRpb24nKSk7XG4gIH1cbiAgZGVzdHJveSgpIHt9XG59XG5cbmNvbnN0IGdldEF1ZGlvQlNJRCA9IChkYXRhLCBvZmZzZXQpID0+IHtcbiAgLy8gY2hlY2sgdGhlIGJzaWQgdG8gY29uZmlybSBhYy0zIHwgZWMtM1xuICBsZXQgYnNpZCA9IDA7XG4gIGxldCBudW1CaXRzID0gNTtcbiAgb2Zmc2V0ICs9IG51bUJpdHM7XG4gIGNvbnN0IHRlbXAgPSBuZXcgVWludDMyQXJyYXkoMSk7IC8vIHVuc2lnbmVkIDMyIGJpdCBmb3IgdGVtcG9yYXJ5IHN0b3JhZ2VcbiAgY29uc3QgbWFzayA9IG5ldyBVaW50MzJBcnJheSgxKTsgLy8gdW5zaWduZWQgMzIgYml0IG1hc2sgdmFsdWVcbiAgY29uc3QgYnl0ZSA9IG5ldyBVaW50OEFycmF5KDEpOyAvLyB1bnNpZ25lZCA4IGJpdCBmb3IgdGVtcG9yYXJ5IHN0b3JhZ2VcbiAgd2hpbGUgKG51bUJpdHMgPiAwKSB7XG4gICAgYnl0ZVswXSA9IGRhdGFbb2Zmc2V0XTtcbiAgICAvLyByZWFkIHJlbWFpbmluZyBiaXRzLCB1cHRvIDggYml0cyBhdCBhIHRpbWVcbiAgICBjb25zdCBiaXRzID0gTWF0aC5taW4obnVtQml0cywgOCk7XG4gICAgY29uc3Qgc2hpZnQgPSA4IC0gYml0cztcbiAgICBtYXNrWzBdID0gMHhmZjAwMDAwMCA+Pj4gMjQgKyBzaGlmdCA8PCBzaGlmdDtcbiAgICB0ZW1wWzBdID0gKGJ5dGVbMF0gJiBtYXNrWzBdKSA+PiBzaGlmdDtcbiAgICBic2lkID0gIWJzaWQgPyB0ZW1wWzBdIDogYnNpZCA8PCBiaXRzIHwgdGVtcFswXTtcbiAgICBvZmZzZXQgKz0gMTtcbiAgICBudW1CaXRzIC09IGJpdHM7XG4gIH1cbiAgcmV0dXJuIGJzaWQ7XG59O1xuXG5jbGFzcyBBQzNEZW11eGVyIGV4dGVuZHMgQmFzZUF1ZGlvRGVtdXhlciB7XG4gIGNvbnN0cnVjdG9yKG9ic2VydmVyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm9ic2VydmVyID0gdm9pZCAwO1xuICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgfVxuICByZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCB0cmFja0R1cmF0aW9uKSB7XG4gICAgc3VwZXIucmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdHJhY2tEdXJhdGlvbik7XG4gICAgdGhpcy5fYXVkaW9UcmFjayA9IHtcbiAgICAgIGNvbnRhaW5lcjogJ2F1ZGlvL2FjLTMnLFxuICAgICAgdHlwZTogJ2F1ZGlvJyxcbiAgICAgIGlkOiAyLFxuICAgICAgcGlkOiAtMSxcbiAgICAgIHNlcXVlbmNlTnVtYmVyOiAwLFxuICAgICAgc2VnbWVudENvZGVjOiAnYWMzJyxcbiAgICAgIHNhbXBsZXM6IFtdLFxuICAgICAgbWFuaWZlc3RDb2RlYzogYXVkaW9Db2RlYyxcbiAgICAgIGR1cmF0aW9uOiB0cmFja0R1cmF0aW9uLFxuICAgICAgaW5wdXRUaW1lU2NhbGU6IDkwMDAwLFxuICAgICAgZHJvcHBlZDogMFxuICAgIH07XG4gIH1cbiAgY2FuUGFyc2UoZGF0YSwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIG9mZnNldCArIDY0IDwgZGF0YS5sZW5ndGg7XG4gIH1cbiAgYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCkge1xuICAgIGNvbnN0IGZyYW1lTGVuZ3RoID0gYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCwgdGhpcy5iYXNlUFRTLCB0aGlzLmZyYW1lSW5kZXgpO1xuICAgIGlmIChmcmFtZUxlbmd0aCAhPT0gLTEpIHtcbiAgICAgIGNvbnN0IHNhbXBsZSA9IHRyYWNrLnNhbXBsZXNbdHJhY2suc2FtcGxlcy5sZW5ndGggLSAxXTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNhbXBsZSxcbiAgICAgICAgbGVuZ3RoOiBmcmFtZUxlbmd0aCxcbiAgICAgICAgbWlzc2luZzogMFxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIHByb2JlKGRhdGEpIHtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgaWQzRGF0YSA9IGdldElEM0RhdGEoZGF0YSwgMCk7XG4gICAgaWYgKCFpZDNEYXRhKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gbG9vayBmb3IgdGhlIGFjLTMgc3luYyBieXRlc1xuICAgIGNvbnN0IG9mZnNldCA9IGlkM0RhdGEubGVuZ3RoO1xuICAgIGlmIChkYXRhW29mZnNldF0gPT09IDB4MGIgJiYgZGF0YVtvZmZzZXQgKyAxXSA9PT0gMHg3NyAmJiBnZXRUaW1lU3RhbXAoaWQzRGF0YSkgIT09IHVuZGVmaW5lZCAmJlxuICAgIC8vIGNoZWNrIHRoZSBic2lkIHRvIGNvbmZpcm0gYWMtM1xuICAgIGdldEF1ZGlvQlNJRChkYXRhLCBvZmZzZXQpIDwgMTYpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGFwcGVuZEZyYW1lKHRyYWNrLCBkYXRhLCBzdGFydCwgcHRzLCBmcmFtZUluZGV4KSB7XG4gIGlmIChzdGFydCArIDggPiBkYXRhLmxlbmd0aCkge1xuICAgIHJldHVybiAtMTsgLy8gbm90IGVub3VnaCBieXRlcyBsZWZ0XG4gIH1cbiAgaWYgKGRhdGFbc3RhcnRdICE9PSAweDBiIHx8IGRhdGFbc3RhcnQgKyAxXSAhPT0gMHg3Nykge1xuICAgIHJldHVybiAtMTsgLy8gaW52YWxpZCBtYWdpY1xuICB9XG5cbiAgLy8gZ2V0IHNhbXBsZSByYXRlXG4gIGNvbnN0IHNhbXBsaW5nUmF0ZUNvZGUgPSBkYXRhW3N0YXJ0ICsgNF0gPj4gNjtcbiAgaWYgKHNhbXBsaW5nUmF0ZUNvZGUgPj0gMykge1xuICAgIHJldHVybiAtMTsgLy8gaW52YWxpZCBzYW1wbGluZyByYXRlXG4gIH1cbiAgY29uc3Qgc2FtcGxpbmdSYXRlTWFwID0gWzQ4MDAwLCA0NDEwMCwgMzIwMDBdO1xuICBjb25zdCBzYW1wbGVSYXRlID0gc2FtcGxpbmdSYXRlTWFwW3NhbXBsaW5nUmF0ZUNvZGVdO1xuXG4gIC8vIGdldCBmcmFtZSBzaXplXG4gIGNvbnN0IGZyYW1lU2l6ZUNvZGUgPSBkYXRhW3N0YXJ0ICsgNF0gJiAweDNmO1xuICBjb25zdCBmcmFtZVNpemVNYXAgPSBbNjQsIDY5LCA5NiwgNjQsIDcwLCA5NiwgODAsIDg3LCAxMjAsIDgwLCA4OCwgMTIwLCA5NiwgMTA0LCAxNDQsIDk2LCAxMDUsIDE0NCwgMTEyLCAxMjEsIDE2OCwgMTEyLCAxMjIsIDE2OCwgMTI4LCAxMzksIDE5MiwgMTI4LCAxNDAsIDE5MiwgMTYwLCAxNzQsIDI0MCwgMTYwLCAxNzUsIDI0MCwgMTkyLCAyMDgsIDI4OCwgMTkyLCAyMDksIDI4OCwgMjI0LCAyNDMsIDMzNiwgMjI0LCAyNDQsIDMzNiwgMjU2LCAyNzgsIDM4NCwgMjU2LCAyNzksIDM4NCwgMzIwLCAzNDgsIDQ4MCwgMzIwLCAzNDksIDQ4MCwgMzg0LCA0MTcsIDU3NiwgMzg0LCA0MTgsIDU3NiwgNDQ4LCA0ODcsIDY3MiwgNDQ4LCA0ODgsIDY3MiwgNTEyLCA1NTcsIDc2OCwgNTEyLCA1NTgsIDc2OCwgNjQwLCA2OTYsIDk2MCwgNjQwLCA2OTcsIDk2MCwgNzY4LCA4MzUsIDExNTIsIDc2OCwgODM2LCAxMTUyLCA4OTYsIDk3NSwgMTM0NCwgODk2LCA5NzYsIDEzNDQsIDEwMjQsIDExMTQsIDE1MzYsIDEwMjQsIDExMTUsIDE1MzYsIDExNTIsIDEyNTMsIDE3MjgsIDExNTIsIDEyNTQsIDE3MjgsIDEyODAsIDEzOTMsIDE5MjAsIDEyODAsIDEzOTQsIDE5MjBdO1xuICBjb25zdCBmcmFtZUxlbmd0aCA9IGZyYW1lU2l6ZU1hcFtmcmFtZVNpemVDb2RlICogMyArIHNhbXBsaW5nUmF0ZUNvZGVdICogMjtcbiAgaWYgKHN0YXJ0ICsgZnJhbWVMZW5ndGggPiBkYXRhLmxlbmd0aCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8vIGdldCBjaGFubmVsIGNvdW50XG4gIGNvbnN0IGNoYW5uZWxNb2RlID0gZGF0YVtzdGFydCArIDZdID4+IDU7XG4gIGxldCBza2lwQ291bnQgPSAwO1xuICBpZiAoY2hhbm5lbE1vZGUgPT09IDIpIHtcbiAgICBza2lwQ291bnQgKz0gMjtcbiAgfSBlbHNlIHtcbiAgICBpZiAoY2hhbm5lbE1vZGUgJiAxICYmIGNoYW5uZWxNb2RlICE9PSAxKSB7XG4gICAgICBza2lwQ291bnQgKz0gMjtcbiAgICB9XG4gICAgaWYgKGNoYW5uZWxNb2RlICYgNCkge1xuICAgICAgc2tpcENvdW50ICs9IDI7XG4gICAgfVxuICB9XG4gIGNvbnN0IGxmZW9uID0gKGRhdGFbc3RhcnQgKyA2XSA8PCA4IHwgZGF0YVtzdGFydCArIDddKSA+PiAxMiAtIHNraXBDb3VudCAmIDE7XG4gIGNvbnN0IGNoYW5uZWxzTWFwID0gWzIsIDEsIDIsIDMsIDMsIDQsIDQsIDVdO1xuICBjb25zdCBjaGFubmVsQ291bnQgPSBjaGFubmVsc01hcFtjaGFubmVsTW9kZV0gKyBsZmVvbjtcblxuICAvLyBidWlsZCBkYWMzIGJveFxuICBjb25zdCBic2lkID0gZGF0YVtzdGFydCArIDVdID4+IDM7XG4gIGNvbnN0IGJzbW9kID0gZGF0YVtzdGFydCArIDVdICYgNztcbiAgY29uc3QgY29uZmlnID0gbmV3IFVpbnQ4QXJyYXkoW3NhbXBsaW5nUmF0ZUNvZGUgPDwgNiB8IGJzaWQgPDwgMSB8IGJzbW9kID4+IDIsIChic21vZCAmIDMpIDw8IDYgfCBjaGFubmVsTW9kZSA8PCAzIHwgbGZlb24gPDwgMiB8IGZyYW1lU2l6ZUNvZGUgPj4gNCwgZnJhbWVTaXplQ29kZSA8PCA0ICYgMHhlMF0pO1xuICBjb25zdCBmcmFtZUR1cmF0aW9uID0gMTUzNiAvIHNhbXBsZVJhdGUgKiA5MDAwMDtcbiAgY29uc3Qgc3RhbXAgPSBwdHMgKyBmcmFtZUluZGV4ICogZnJhbWVEdXJhdGlvbjtcbiAgY29uc3QgdW5pdCA9IGRhdGEuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgZnJhbWVMZW5ndGgpO1xuICB0cmFjay5jb25maWcgPSBjb25maWc7XG4gIHRyYWNrLmNoYW5uZWxDb3VudCA9IGNoYW5uZWxDb3VudDtcbiAgdHJhY2suc2FtcGxlcmF0ZSA9IHNhbXBsZVJhdGU7XG4gIHRyYWNrLnNhbXBsZXMucHVzaCh7XG4gICAgdW5pdCxcbiAgICBwdHM6IHN0YW1wXG4gIH0pO1xuICByZXR1cm4gZnJhbWVMZW5ndGg7XG59XG5cbmNsYXNzIEJhc2VWaWRlb1BhcnNlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuVmlkZW9TYW1wbGUgPSBudWxsO1xuICB9XG4gIGNyZWF0ZVZpZGVvU2FtcGxlKGtleSwgcHRzLCBkdHMsIGRlYnVnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleSxcbiAgICAgIGZyYW1lOiBmYWxzZSxcbiAgICAgIHB0cyxcbiAgICAgIGR0cyxcbiAgICAgIHVuaXRzOiBbXSxcbiAgICAgIGRlYnVnLFxuICAgICAgbGVuZ3RoOiAwXG4gICAgfTtcbiAgfVxuICBnZXRMYXN0TmFsVW5pdChzYW1wbGVzKSB7XG4gICAgdmFyIF9WaWRlb1NhbXBsZTtcbiAgICBsZXQgVmlkZW9TYW1wbGUgPSB0aGlzLlZpZGVvU2FtcGxlO1xuICAgIGxldCBsYXN0VW5pdDtcbiAgICAvLyB0cnkgdG8gZmFsbGJhY2sgdG8gcHJldmlvdXMgc2FtcGxlIGlmIGN1cnJlbnQgb25lIGlzIGVtcHR5XG4gICAgaWYgKCFWaWRlb1NhbXBsZSB8fCBWaWRlb1NhbXBsZS51bml0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIFZpZGVvU2FtcGxlID0gc2FtcGxlc1tzYW1wbGVzLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBpZiAoKF9WaWRlb1NhbXBsZSA9IFZpZGVvU2FtcGxlKSAhPSBudWxsICYmIF9WaWRlb1NhbXBsZS51bml0cykge1xuICAgICAgY29uc3QgdW5pdHMgPSBWaWRlb1NhbXBsZS51bml0cztcbiAgICAgIGxhc3RVbml0ID0gdW5pdHNbdW5pdHMubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIHJldHVybiBsYXN0VW5pdDtcbiAgfVxuICBwdXNoQWNjZXNzVW5pdChWaWRlb1NhbXBsZSwgdmlkZW9UcmFjaykge1xuICAgIGlmIChWaWRlb1NhbXBsZS51bml0cy5sZW5ndGggJiYgVmlkZW9TYW1wbGUuZnJhbWUpIHtcbiAgICAgIC8vIGlmIHNhbXBsZSBkb2VzIG5vdCBoYXZlIFBUUy9EVFMsIHBhdGNoIHdpdGggbGFzdCBzYW1wbGUgUFRTL0RUU1xuICAgICAgaWYgKFZpZGVvU2FtcGxlLnB0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHNhbXBsZXMgPSB2aWRlb1RyYWNrLnNhbXBsZXM7XG4gICAgICAgIGNvbnN0IG5iU2FtcGxlcyA9IHNhbXBsZXMubGVuZ3RoO1xuICAgICAgICBpZiAobmJTYW1wbGVzKSB7XG4gICAgICAgICAgY29uc3QgbGFzdFNhbXBsZSA9IHNhbXBsZXNbbmJTYW1wbGVzIC0gMV07XG4gICAgICAgICAgVmlkZW9TYW1wbGUucHRzID0gbGFzdFNhbXBsZS5wdHM7XG4gICAgICAgICAgVmlkZW9TYW1wbGUuZHRzID0gbGFzdFNhbXBsZS5kdHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZHJvcHBpbmcgc2FtcGxlcywgbm8gdGltZXN0YW1wIGZvdW5kXG4gICAgICAgICAgdmlkZW9UcmFjay5kcm9wcGVkKys7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2aWRlb1RyYWNrLnNhbXBsZXMucHVzaChWaWRlb1NhbXBsZSk7XG4gICAgfVxuICAgIGlmIChWaWRlb1NhbXBsZS5kZWJ1Zy5sZW5ndGgpIHtcbiAgICAgIGxvZ2dlci5sb2coVmlkZW9TYW1wbGUucHRzICsgJy8nICsgVmlkZW9TYW1wbGUuZHRzICsgJzonICsgVmlkZW9TYW1wbGUuZGVidWcpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlciBmb3IgZXhwb25lbnRpYWwgR29sb21iIGNvZGVzLCBhIHZhcmlhYmxlLWJpdHdpZHRoIG51bWJlciBlbmNvZGluZyBzY2hlbWUgdXNlZCBieSBoMjY0LlxuICovXG5cbmNsYXNzIEV4cEdvbG9tYiB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICB0aGlzLmRhdGEgPSB2b2lkIDA7XG4gICAgdGhpcy5ieXRlc0F2YWlsYWJsZSA9IHZvaWQgMDtcbiAgICB0aGlzLndvcmQgPSB2b2lkIDA7XG4gICAgdGhpcy5iaXRzQXZhaWxhYmxlID0gdm9pZCAwO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgLy8gdGhlIG51bWJlciBvZiBieXRlcyBsZWZ0IHRvIGV4YW1pbmUgaW4gdGhpcy5kYXRhXG4gICAgdGhpcy5ieXRlc0F2YWlsYWJsZSA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAvLyB0aGUgY3VycmVudCB3b3JkIGJlaW5nIGV4YW1pbmVkXG4gICAgdGhpcy53b3JkID0gMDsgLy8gOnVpbnRcbiAgICAvLyB0aGUgbnVtYmVyIG9mIGJpdHMgbGVmdCB0byBleGFtaW5lIGluIHRoZSBjdXJyZW50IHdvcmRcbiAgICB0aGlzLmJpdHNBdmFpbGFibGUgPSAwOyAvLyA6dWludFxuICB9XG5cbiAgLy8gKCk6dm9pZFxuICBsb2FkV29yZCgpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xuICAgIGNvbnN0IGJ5dGVzQXZhaWxhYmxlID0gdGhpcy5ieXRlc0F2YWlsYWJsZTtcbiAgICBjb25zdCBwb3NpdGlvbiA9IGRhdGEuYnl0ZUxlbmd0aCAtIGJ5dGVzQXZhaWxhYmxlO1xuICAgIGNvbnN0IHdvcmtpbmdCeXRlcyA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgIGNvbnN0IGF2YWlsYWJsZUJ5dGVzID0gTWF0aC5taW4oNCwgYnl0ZXNBdmFpbGFibGUpO1xuICAgIGlmIChhdmFpbGFibGVCeXRlcyA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBieXRlcyBhdmFpbGFibGUnKTtcbiAgICB9XG4gICAgd29ya2luZ0J5dGVzLnNldChkYXRhLnN1YmFycmF5KHBvc2l0aW9uLCBwb3NpdGlvbiArIGF2YWlsYWJsZUJ5dGVzKSk7XG4gICAgdGhpcy53b3JkID0gbmV3IERhdGFWaWV3KHdvcmtpbmdCeXRlcy5idWZmZXIpLmdldFVpbnQzMigwKTtcbiAgICAvLyB0cmFjayB0aGUgYW1vdW50IG9mIHRoaXMuZGF0YSB0aGF0IGhhcyBiZWVuIHByb2Nlc3NlZFxuICAgIHRoaXMuYml0c0F2YWlsYWJsZSA9IGF2YWlsYWJsZUJ5dGVzICogODtcbiAgICB0aGlzLmJ5dGVzQXZhaWxhYmxlIC09IGF2YWlsYWJsZUJ5dGVzO1xuICB9XG5cbiAgLy8gKGNvdW50OmludCk6dm9pZFxuICBza2lwQml0cyhjb3VudCkge1xuICAgIGxldCBza2lwQnl0ZXM7IC8vIDppbnRcbiAgICBjb3VudCA9IE1hdGgubWluKGNvdW50LCB0aGlzLmJ5dGVzQXZhaWxhYmxlICogOCArIHRoaXMuYml0c0F2YWlsYWJsZSk7XG4gICAgaWYgKHRoaXMuYml0c0F2YWlsYWJsZSA+IGNvdW50KSB7XG4gICAgICB0aGlzLndvcmQgPDw9IGNvdW50O1xuICAgICAgdGhpcy5iaXRzQXZhaWxhYmxlIC09IGNvdW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCAtPSB0aGlzLmJpdHNBdmFpbGFibGU7XG4gICAgICBza2lwQnl0ZXMgPSBjb3VudCA+PiAzO1xuICAgICAgY291bnQgLT0gc2tpcEJ5dGVzIDw8IDM7XG4gICAgICB0aGlzLmJ5dGVzQXZhaWxhYmxlIC09IHNraXBCeXRlcztcbiAgICAgIHRoaXMubG9hZFdvcmQoKTtcbiAgICAgIHRoaXMud29yZCA8PD0gY291bnQ7XG4gICAgICB0aGlzLmJpdHNBdmFpbGFibGUgLT0gY291bnQ7XG4gICAgfVxuICB9XG5cbiAgLy8gKHNpemU6aW50KTp1aW50XG4gIHJlYWRCaXRzKHNpemUpIHtcbiAgICBsZXQgYml0cyA9IE1hdGgubWluKHRoaXMuYml0c0F2YWlsYWJsZSwgc2l6ZSk7IC8vIDp1aW50XG4gICAgY29uc3QgdmFsdSA9IHRoaXMud29yZCA+Pj4gMzIgLSBiaXRzOyAvLyA6dWludFxuICAgIGlmIChzaXplID4gMzIpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignQ2Fubm90IHJlYWQgbW9yZSB0aGFuIDMyIGJpdHMgYXQgYSB0aW1lJyk7XG4gICAgfVxuICAgIHRoaXMuYml0c0F2YWlsYWJsZSAtPSBiaXRzO1xuICAgIGlmICh0aGlzLmJpdHNBdmFpbGFibGUgPiAwKSB7XG4gICAgICB0aGlzLndvcmQgPDw9IGJpdHM7XG4gICAgfSBlbHNlIGlmICh0aGlzLmJ5dGVzQXZhaWxhYmxlID4gMCkge1xuICAgICAgdGhpcy5sb2FkV29yZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIGJpdHMgYXZhaWxhYmxlJyk7XG4gICAgfVxuICAgIGJpdHMgPSBzaXplIC0gYml0cztcbiAgICBpZiAoYml0cyA+IDAgJiYgdGhpcy5iaXRzQXZhaWxhYmxlKSB7XG4gICAgICByZXR1cm4gdmFsdSA8PCBiaXRzIHwgdGhpcy5yZWFkQml0cyhiaXRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZhbHU7XG4gICAgfVxuICB9XG5cbiAgLy8gKCk6dWludFxuICBza2lwTFooKSB7XG4gICAgbGV0IGxlYWRpbmdaZXJvQ291bnQ7IC8vIDp1aW50XG4gICAgZm9yIChsZWFkaW5nWmVyb0NvdW50ID0gMDsgbGVhZGluZ1plcm9Db3VudCA8IHRoaXMuYml0c0F2YWlsYWJsZTsgKytsZWFkaW5nWmVyb0NvdW50KSB7XG4gICAgICBpZiAoKHRoaXMud29yZCAmIDB4ODAwMDAwMDAgPj4+IGxlYWRpbmdaZXJvQ291bnQpICE9PSAwKSB7XG4gICAgICAgIC8vIHRoZSBmaXJzdCBiaXQgb2Ygd29ya2luZyB3b3JkIGlzIDFcbiAgICAgICAgdGhpcy53b3JkIDw8PSBsZWFkaW5nWmVyb0NvdW50O1xuICAgICAgICB0aGlzLmJpdHNBdmFpbGFibGUgLT0gbGVhZGluZ1plcm9Db3VudDtcbiAgICAgICAgcmV0dXJuIGxlYWRpbmdaZXJvQ291bnQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHdlIGV4aGF1c3RlZCB3b3JkIGFuZCBzdGlsbCBoYXZlIG5vdCBmb3VuZCBhIDFcbiAgICB0aGlzLmxvYWRXb3JkKCk7XG4gICAgcmV0dXJuIGxlYWRpbmdaZXJvQ291bnQgKyB0aGlzLnNraXBMWigpO1xuICB9XG5cbiAgLy8gKCk6dm9pZFxuICBza2lwVUVHKCkge1xuICAgIHRoaXMuc2tpcEJpdHMoMSArIHRoaXMuc2tpcExaKCkpO1xuICB9XG5cbiAgLy8gKCk6dm9pZFxuICBza2lwRUcoKSB7XG4gICAgdGhpcy5za2lwQml0cygxICsgdGhpcy5za2lwTFooKSk7XG4gIH1cblxuICAvLyAoKTp1aW50XG4gIHJlYWRVRUcoKSB7XG4gICAgY29uc3QgY2x6ID0gdGhpcy5za2lwTFooKTsgLy8gOnVpbnRcbiAgICByZXR1cm4gdGhpcy5yZWFkQml0cyhjbHogKyAxKSAtIDE7XG4gIH1cblxuICAvLyAoKTppbnRcbiAgcmVhZEVHKCkge1xuICAgIGNvbnN0IHZhbHUgPSB0aGlzLnJlYWRVRUcoKTsgLy8gOmludFxuICAgIGlmICgweDAxICYgdmFsdSkge1xuICAgICAgLy8gdGhlIG51bWJlciBpcyBvZGQgaWYgdGhlIGxvdyBvcmRlciBiaXQgaXMgc2V0XG4gICAgICByZXR1cm4gMSArIHZhbHUgPj4+IDE7IC8vIGFkZCAxIHRvIG1ha2UgaXQgZXZlbiwgYW5kIGRpdmlkZSBieSAyXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAtMSAqICh2YWx1ID4+PiAxKTsgLy8gZGl2aWRlIGJ5IHR3byB0aGVuIG1ha2UgaXQgbmVnYXRpdmVcbiAgICB9XG4gIH1cblxuICAvLyBTb21lIGNvbnZlbmllbmNlIGZ1bmN0aW9uc1xuICAvLyA6Qm9vbGVhblxuICByZWFkQm9vbGVhbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkQml0cygxKSA9PT0gMTtcbiAgfVxuXG4gIC8vICgpOmludFxuICByZWFkVUJ5dGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoOCk7XG4gIH1cblxuICAvLyAoKTppbnRcbiAgcmVhZFVTaG9ydCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkQml0cygxNik7XG4gIH1cblxuICAvLyAoKTppbnRcbiAgcmVhZFVJbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoMzIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkdmFuY2UgdGhlIEV4cEdvbG9tYiBkZWNvZGVyIHBhc3QgYSBzY2FsaW5nIGxpc3QuIFRoZSBzY2FsaW5nXG4gICAqIGxpc3QgaXMgb3B0aW9uYWxseSB0cmFuc21pdHRlZCBhcyBwYXJ0IG9mIGEgc2VxdWVuY2UgcGFyYW1ldGVyXG4gICAqIHNldCBhbmQgaXMgbm90IHJlbGV2YW50IHRvIHRyYW5zbXV4aW5nLlxuICAgKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiBlbnRyaWVzIGluIHRoaXMgc2NhbGluZyBsaXN0XG4gICAqIEBzZWUgUmVjb21tZW5kYXRpb24gSVRVLVQgSC4yNjQsIFNlY3Rpb24gNy4zLjIuMS4xLjFcbiAgICovXG4gIHNraXBTY2FsaW5nTGlzdChjb3VudCkge1xuICAgIGxldCBsYXN0U2NhbGUgPSA4O1xuICAgIGxldCBuZXh0U2NhbGUgPSA4O1xuICAgIGxldCBkZWx0YVNjYWxlO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgY291bnQ7IGorKykge1xuICAgICAgaWYgKG5leHRTY2FsZSAhPT0gMCkge1xuICAgICAgICBkZWx0YVNjYWxlID0gdGhpcy5yZWFkRUcoKTtcbiAgICAgICAgbmV4dFNjYWxlID0gKGxhc3RTY2FsZSArIGRlbHRhU2NhbGUgKyAyNTYpICUgMjU2O1xuICAgICAgfVxuICAgICAgbGFzdFNjYWxlID0gbmV4dFNjYWxlID09PSAwID8gbGFzdFNjYWxlIDogbmV4dFNjYWxlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkIGEgc2VxdWVuY2UgcGFyYW1ldGVyIHNldCBhbmQgcmV0dXJuIHNvbWUgaW50ZXJlc3RpbmcgdmlkZW9cbiAgICogcHJvcGVydGllcy4gQSBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0IGlzIHRoZSBIMjY0IG1ldGFkYXRhIHRoYXRcbiAgICogZGVzY3JpYmVzIHRoZSBwcm9wZXJ0aWVzIG9mIHVwY29taW5nIHZpZGVvIGZyYW1lcy5cbiAgICogQHJldHVybnMgYW4gb2JqZWN0IHdpdGggY29uZmlndXJhdGlvbiBwYXJzZWQgZnJvbSB0aGVcbiAgICogc2VxdWVuY2UgcGFyYW1ldGVyIHNldCwgaW5jbHVkaW5nIHRoZSBkaW1lbnNpb25zIG9mIHRoZVxuICAgKiBhc3NvY2lhdGVkIHZpZGVvIGZyYW1lcy5cbiAgICovXG4gIHJlYWRTUFMoKSB7XG4gICAgbGV0IGZyYW1lQ3JvcExlZnRPZmZzZXQgPSAwO1xuICAgIGxldCBmcmFtZUNyb3BSaWdodE9mZnNldCA9IDA7XG4gICAgbGV0IGZyYW1lQ3JvcFRvcE9mZnNldCA9IDA7XG4gICAgbGV0IGZyYW1lQ3JvcEJvdHRvbU9mZnNldCA9IDA7XG4gICAgbGV0IG51bVJlZkZyYW1lc0luUGljT3JkZXJDbnRDeWNsZTtcbiAgICBsZXQgc2NhbGluZ0xpc3RDb3VudDtcbiAgICBsZXQgaTtcbiAgICBjb25zdCByZWFkVUJ5dGUgPSB0aGlzLnJlYWRVQnl0ZS5iaW5kKHRoaXMpO1xuICAgIGNvbnN0IHJlYWRCaXRzID0gdGhpcy5yZWFkQml0cy5iaW5kKHRoaXMpO1xuICAgIGNvbnN0IHJlYWRVRUcgPSB0aGlzLnJlYWRVRUcuYmluZCh0aGlzKTtcbiAgICBjb25zdCByZWFkQm9vbGVhbiA9IHRoaXMucmVhZEJvb2xlYW4uYmluZCh0aGlzKTtcbiAgICBjb25zdCBza2lwQml0cyA9IHRoaXMuc2tpcEJpdHMuYmluZCh0aGlzKTtcbiAgICBjb25zdCBza2lwRUcgPSB0aGlzLnNraXBFRy5iaW5kKHRoaXMpO1xuICAgIGNvbnN0IHNraXBVRUcgPSB0aGlzLnNraXBVRUcuYmluZCh0aGlzKTtcbiAgICBjb25zdCBza2lwU2NhbGluZ0xpc3QgPSB0aGlzLnNraXBTY2FsaW5nTGlzdC5iaW5kKHRoaXMpO1xuICAgIHJlYWRVQnl0ZSgpO1xuICAgIGNvbnN0IHByb2ZpbGVJZGMgPSByZWFkVUJ5dGUoKTsgLy8gcHJvZmlsZV9pZGNcbiAgICByZWFkQml0cyg1KTsgLy8gcHJvZmlsZUNvbXBhdCBjb25zdHJhaW50X3NldFswLTRdX2ZsYWcsIHUoNSlcbiAgICBza2lwQml0cygzKTsgLy8gcmVzZXJ2ZWRfemVyb18zYml0cyB1KDMpLFxuICAgIHJlYWRVQnl0ZSgpOyAvLyBsZXZlbF9pZGMgdSg4KVxuICAgIHNraXBVRUcoKTsgLy8gc2VxX3BhcmFtZXRlcl9zZXRfaWRcbiAgICAvLyBzb21lIHByb2ZpbGVzIGhhdmUgbW9yZSBvcHRpb25hbCBkYXRhIHdlIGRvbid0IG5lZWRcbiAgICBpZiAocHJvZmlsZUlkYyA9PT0gMTAwIHx8IHByb2ZpbGVJZGMgPT09IDExMCB8fCBwcm9maWxlSWRjID09PSAxMjIgfHwgcHJvZmlsZUlkYyA9PT0gMjQ0IHx8IHByb2ZpbGVJZGMgPT09IDQ0IHx8IHByb2ZpbGVJZGMgPT09IDgzIHx8IHByb2ZpbGVJZGMgPT09IDg2IHx8IHByb2ZpbGVJZGMgPT09IDExOCB8fCBwcm9maWxlSWRjID09PSAxMjgpIHtcbiAgICAgIGNvbnN0IGNocm9tYUZvcm1hdElkYyA9IHJlYWRVRUcoKTtcbiAgICAgIGlmIChjaHJvbWFGb3JtYXRJZGMgPT09IDMpIHtcbiAgICAgICAgc2tpcEJpdHMoMSk7XG4gICAgICB9IC8vIHNlcGFyYXRlX2NvbG91cl9wbGFuZV9mbGFnXG5cbiAgICAgIHNraXBVRUcoKTsgLy8gYml0X2RlcHRoX2x1bWFfbWludXM4XG4gICAgICBza2lwVUVHKCk7IC8vIGJpdF9kZXB0aF9jaHJvbWFfbWludXM4XG4gICAgICBza2lwQml0cygxKTsgLy8gcXBwcmltZV95X3plcm9fdHJhbnNmb3JtX2J5cGFzc19mbGFnXG4gICAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xuICAgICAgICAvLyBzZXFfc2NhbGluZ19tYXRyaXhfcHJlc2VudF9mbGFnXG4gICAgICAgIHNjYWxpbmdMaXN0Q291bnQgPSBjaHJvbWFGb3JtYXRJZGMgIT09IDMgPyA4IDogMTI7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzY2FsaW5nTGlzdENvdW50OyBpKyspIHtcbiAgICAgICAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xuICAgICAgICAgICAgLy8gc2VxX3NjYWxpbmdfbGlzdF9wcmVzZW50X2ZsYWdbIGkgXVxuICAgICAgICAgICAgaWYgKGkgPCA2KSB7XG4gICAgICAgICAgICAgIHNraXBTY2FsaW5nTGlzdCgxNik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBza2lwU2NhbGluZ0xpc3QoNjQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBza2lwVUVHKCk7IC8vIGxvZzJfbWF4X2ZyYW1lX251bV9taW51czRcbiAgICBjb25zdCBwaWNPcmRlckNudFR5cGUgPSByZWFkVUVHKCk7XG4gICAgaWYgKHBpY09yZGVyQ250VHlwZSA9PT0gMCkge1xuICAgICAgcmVhZFVFRygpOyAvLyBsb2cyX21heF9waWNfb3JkZXJfY250X2xzYl9taW51czRcbiAgICB9IGVsc2UgaWYgKHBpY09yZGVyQ250VHlwZSA9PT0gMSkge1xuICAgICAgc2tpcEJpdHMoMSk7IC8vIGRlbHRhX3BpY19vcmRlcl9hbHdheXNfemVyb19mbGFnXG4gICAgICBza2lwRUcoKTsgLy8gb2Zmc2V0X2Zvcl9ub25fcmVmX3BpY1xuICAgICAgc2tpcEVHKCk7IC8vIG9mZnNldF9mb3JfdG9wX3RvX2JvdHRvbV9maWVsZFxuICAgICAgbnVtUmVmRnJhbWVzSW5QaWNPcmRlckNudEN5Y2xlID0gcmVhZFVFRygpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG51bVJlZkZyYW1lc0luUGljT3JkZXJDbnRDeWNsZTsgaSsrKSB7XG4gICAgICAgIHNraXBFRygpO1xuICAgICAgfSAvLyBvZmZzZXRfZm9yX3JlZl9mcmFtZVsgaSBdXG4gICAgfVxuICAgIHNraXBVRUcoKTsgLy8gbWF4X251bV9yZWZfZnJhbWVzXG4gICAgc2tpcEJpdHMoMSk7IC8vIGdhcHNfaW5fZnJhbWVfbnVtX3ZhbHVlX2FsbG93ZWRfZmxhZ1xuICAgIGNvbnN0IHBpY1dpZHRoSW5NYnNNaW51czEgPSByZWFkVUVHKCk7XG4gICAgY29uc3QgcGljSGVpZ2h0SW5NYXBVbml0c01pbnVzMSA9IHJlYWRVRUcoKTtcbiAgICBjb25zdCBmcmFtZU1ic09ubHlGbGFnID0gcmVhZEJpdHMoMSk7XG4gICAgaWYgKGZyYW1lTWJzT25seUZsYWcgPT09IDApIHtcbiAgICAgIHNraXBCaXRzKDEpO1xuICAgIH0gLy8gbWJfYWRhcHRpdmVfZnJhbWVfZmllbGRfZmxhZ1xuXG4gICAgc2tpcEJpdHMoMSk7IC8vIGRpcmVjdF84eDhfaW5mZXJlbmNlX2ZsYWdcbiAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xuICAgICAgLy8gZnJhbWVfY3JvcHBpbmdfZmxhZ1xuICAgICAgZnJhbWVDcm9wTGVmdE9mZnNldCA9IHJlYWRVRUcoKTtcbiAgICAgIGZyYW1lQ3JvcFJpZ2h0T2Zmc2V0ID0gcmVhZFVFRygpO1xuICAgICAgZnJhbWVDcm9wVG9wT2Zmc2V0ID0gcmVhZFVFRygpO1xuICAgICAgZnJhbWVDcm9wQm90dG9tT2Zmc2V0ID0gcmVhZFVFRygpO1xuICAgIH1cbiAgICBsZXQgcGl4ZWxSYXRpbyA9IFsxLCAxXTtcbiAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xuICAgICAgLy8gdnVpX3BhcmFtZXRlcnNfcHJlc2VudF9mbGFnXG4gICAgICBpZiAocmVhZEJvb2xlYW4oKSkge1xuICAgICAgICAvLyBhc3BlY3RfcmF0aW9faW5mb19wcmVzZW50X2ZsYWdcbiAgICAgICAgY29uc3QgYXNwZWN0UmF0aW9JZGMgPSByZWFkVUJ5dGUoKTtcbiAgICAgICAgc3dpdGNoIChhc3BlY3RSYXRpb0lkYykge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMSwgMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzEyLCAxMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzEwLCAxMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzE2LCAxMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzQwLCAzM107XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzI0LCAxMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzIwLCAxMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzMyLCAxMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzgwLCAzM107XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsxOCwgMTFdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMTUsIDExXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzY0LCAzM107XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsxNjAsIDk5XTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICBwaXhlbFJhdGlvID0gWzQsIDNdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIHBpeGVsUmF0aW8gPSBbMywgMl07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgcGl4ZWxSYXRpbyA9IFsyLCAxXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjU1OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBwaXhlbFJhdGlvID0gW3JlYWRVQnl0ZSgpIDw8IDggfCByZWFkVUJ5dGUoKSwgcmVhZFVCeXRlKCkgPDwgOCB8IHJlYWRVQnl0ZSgpXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBNYXRoLmNlaWwoKHBpY1dpZHRoSW5NYnNNaW51czEgKyAxKSAqIDE2IC0gZnJhbWVDcm9wTGVmdE9mZnNldCAqIDIgLSBmcmFtZUNyb3BSaWdodE9mZnNldCAqIDIpLFxuICAgICAgaGVpZ2h0OiAoMiAtIGZyYW1lTWJzT25seUZsYWcpICogKHBpY0hlaWdodEluTWFwVW5pdHNNaW51czEgKyAxKSAqIDE2IC0gKGZyYW1lTWJzT25seUZsYWcgPyAyIDogNCkgKiAoZnJhbWVDcm9wVG9wT2Zmc2V0ICsgZnJhbWVDcm9wQm90dG9tT2Zmc2V0KSxcbiAgICAgIHBpeGVsUmF0aW86IHBpeGVsUmF0aW9cbiAgICB9O1xuICB9XG4gIHJlYWRTbGljZVR5cGUoKSB7XG4gICAgLy8gc2tpcCBOQUx1IHR5cGVcbiAgICB0aGlzLnJlYWRVQnl0ZSgpO1xuICAgIC8vIGRpc2NhcmQgZmlyc3RfbWJfaW5fc2xpY2VcbiAgICB0aGlzLnJlYWRVRUcoKTtcbiAgICAvLyByZXR1cm4gc2xpY2VfdHlwZVxuICAgIHJldHVybiB0aGlzLnJlYWRVRUcoKTtcbiAgfVxufVxuXG5jbGFzcyBBdmNWaWRlb1BhcnNlciBleHRlbmRzIEJhc2VWaWRlb1BhcnNlciB7XG4gIHBhcnNlQVZDUEVTKHRyYWNrLCB0ZXh0VHJhY2ssIHBlcywgbGFzdCwgZHVyYXRpb24pIHtcbiAgICBjb25zdCB1bml0cyA9IHRoaXMucGFyc2VBVkNOQUx1KHRyYWNrLCBwZXMuZGF0YSk7XG4gICAgbGV0IFZpZGVvU2FtcGxlID0gdGhpcy5WaWRlb1NhbXBsZTtcbiAgICBsZXQgcHVzaDtcbiAgICBsZXQgc3BzZm91bmQgPSBmYWxzZTtcbiAgICAvLyBmcmVlIHBlcy5kYXRhIHRvIHNhdmUgdXAgc29tZSBtZW1vcnlcbiAgICBwZXMuZGF0YSA9IG51bGw7XG5cbiAgICAvLyBpZiBuZXcgTkFMIHVuaXRzIGZvdW5kIGFuZCBsYXN0IHNhbXBsZSBzdGlsbCB0aGVyZSwgbGV0J3MgcHVzaCAuLi5cbiAgICAvLyB0aGlzIGhlbHBzIHBhcnNpbmcgc3RyZWFtcyB3aXRoIG1pc3NpbmcgQVVEIChvbmx5IGRvIHRoaXMgaWYgQVVEIG5ldmVyIGZvdW5kKVxuICAgIGlmIChWaWRlb1NhbXBsZSAmJiB1bml0cy5sZW5ndGggJiYgIXRyYWNrLmF1ZEZvdW5kKSB7XG4gICAgICB0aGlzLnB1c2hBY2Nlc3NVbml0KFZpZGVvU2FtcGxlLCB0cmFjayk7XG4gICAgICBWaWRlb1NhbXBsZSA9IHRoaXMuVmlkZW9TYW1wbGUgPSB0aGlzLmNyZWF0ZVZpZGVvU2FtcGxlKGZhbHNlLCBwZXMucHRzLCBwZXMuZHRzLCAnJyk7XG4gICAgfVxuICAgIHVuaXRzLmZvckVhY2godW5pdCA9PiB7XG4gICAgICB2YXIgX1ZpZGVvU2FtcGxlMjtcbiAgICAgIHN3aXRjaCAodW5pdC50eXBlKSB7XG4gICAgICAgIC8vIE5EUlxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAge1xuICAgICAgICAgICAgbGV0IGlza2V5ID0gZmFsc2U7XG4gICAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB1bml0LmRhdGE7XG4gICAgICAgICAgICAvLyBvbmx5IGNoZWNrIHNsaWNlIHR5cGUgdG8gZGV0ZWN0IEtGIGluIGNhc2UgU1BTIGZvdW5kIGluIHNhbWUgcGFja2V0IChhbnkga2V5ZnJhbWUgaXMgcHJlY2VkZWQgYnkgU1BTIC4uLilcbiAgICAgICAgICAgIGlmIChzcHNmb3VuZCAmJiBkYXRhLmxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgICAgLy8gcmV0cmlldmUgc2xpY2UgdHlwZSBieSBwYXJzaW5nIGJlZ2lubmluZyBvZiBOQUwgdW5pdCAoZm9sbG93IEgyNjQgc3BlYywgc2xpY2VfaGVhZGVyIGRlZmluaXRpb24pIHRvIGRldGVjdCBrZXlmcmFtZSBlbWJlZGRlZCBpbiBORFJcbiAgICAgICAgICAgICAgY29uc3Qgc2xpY2VUeXBlID0gbmV3IEV4cEdvbG9tYihkYXRhKS5yZWFkU2xpY2VUeXBlKCk7XG4gICAgICAgICAgICAgIC8vIDIgOiBJIHNsaWNlLCA0IDogU0kgc2xpY2UsIDcgOiBJIHNsaWNlLCA5OiBTSSBzbGljZVxuICAgICAgICAgICAgICAvLyBTSSBzbGljZSA6IEEgc2xpY2UgdGhhdCBpcyBjb2RlZCB1c2luZyBpbnRyYSBwcmVkaWN0aW9uIG9ubHkgYW5kIHVzaW5nIHF1YW50aXNhdGlvbiBvZiB0aGUgcHJlZGljdGlvbiBzYW1wbGVzLlxuICAgICAgICAgICAgICAvLyBBbiBTSSBzbGljZSBjYW4gYmUgY29kZWQgc3VjaCB0aGF0IGl0cyBkZWNvZGVkIHNhbXBsZXMgY2FuIGJlIGNvbnN0cnVjdGVkIGlkZW50aWNhbGx5IHRvIGFuIFNQIHNsaWNlLlxuICAgICAgICAgICAgICAvLyBJIHNsaWNlOiBBIHNsaWNlIHRoYXQgaXMgbm90IGFuIFNJIHNsaWNlIHRoYXQgaXMgZGVjb2RlZCB1c2luZyBpbnRyYSBwcmVkaWN0aW9uIG9ubHkuXG4gICAgICAgICAgICAgIC8vIGlmIChzbGljZVR5cGUgPT09IDIgfHwgc2xpY2VUeXBlID09PSA3KSB7XG4gICAgICAgICAgICAgIGlmIChzbGljZVR5cGUgPT09IDIgfHwgc2xpY2VUeXBlID09PSA0IHx8IHNsaWNlVHlwZSA9PT0gNyB8fCBzbGljZVR5cGUgPT09IDkpIHtcbiAgICAgICAgICAgICAgICBpc2tleSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc2tleSkge1xuICAgICAgICAgICAgICB2YXIgX1ZpZGVvU2FtcGxlO1xuICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIG5vbi1rZXlmcmFtZSBkYXRhIGFscmVhZHksIHRoYXQgY2Fubm90IGJlbG9uZyB0byB0aGUgc2FtZSBmcmFtZSBhcyBhIGtleWZyYW1lLCBzbyBmb3JjZSBhIHB1c2hcbiAgICAgICAgICAgICAgaWYgKChfVmlkZW9TYW1wbGUgPSBWaWRlb1NhbXBsZSkgIT0gbnVsbCAmJiBfVmlkZW9TYW1wbGUuZnJhbWUgJiYgIVZpZGVvU2FtcGxlLmtleSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHVzaEFjY2Vzc1VuaXQoVmlkZW9TYW1wbGUsIHRyYWNrKTtcbiAgICAgICAgICAgICAgICBWaWRlb1NhbXBsZSA9IHRoaXMuVmlkZW9TYW1wbGUgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIVZpZGVvU2FtcGxlKSB7XG4gICAgICAgICAgICAgIFZpZGVvU2FtcGxlID0gdGhpcy5WaWRlb1NhbXBsZSA9IHRoaXMuY3JlYXRlVmlkZW9TYW1wbGUodHJ1ZSwgcGVzLnB0cywgcGVzLmR0cywgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgVmlkZW9TYW1wbGUuZnJhbWUgPSB0cnVlO1xuICAgICAgICAgICAgVmlkZW9TYW1wbGUua2V5ID0gaXNrZXk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIElEUlxuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHB1c2ggPSB0cnVlO1xuICAgICAgICAgIC8vIGhhbmRsZSBQRVMgbm90IHN0YXJ0aW5nIHdpdGggQVVEXG4gICAgICAgICAgLy8gaWYgd2UgaGF2ZSBmcmFtZSBkYXRhIGFscmVhZHksIHRoYXQgY2Fubm90IGJlbG9uZyB0byB0aGUgc2FtZSBmcmFtZSwgc28gZm9yY2UgYSBwdXNoXG4gICAgICAgICAgaWYgKChfVmlkZW9TYW1wbGUyID0gVmlkZW9TYW1wbGUpICE9IG51bGwgJiYgX1ZpZGVvU2FtcGxlMi5mcmFtZSAmJiAhVmlkZW9TYW1wbGUua2V5KSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hBY2Nlc3NVbml0KFZpZGVvU2FtcGxlLCB0cmFjayk7XG4gICAgICAgICAgICBWaWRlb1NhbXBsZSA9IHRoaXMuVmlkZW9TYW1wbGUgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIVZpZGVvU2FtcGxlKSB7XG4gICAgICAgICAgICBWaWRlb1NhbXBsZSA9IHRoaXMuVmlkZW9TYW1wbGUgPSB0aGlzLmNyZWF0ZVZpZGVvU2FtcGxlKHRydWUsIHBlcy5wdHMsIHBlcy5kdHMsICcnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgVmlkZW9TYW1wbGUua2V5ID0gdHJ1ZTtcbiAgICAgICAgICBWaWRlb1NhbXBsZS5mcmFtZSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFNFSVxuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgICBwYXJzZVNFSU1lc3NhZ2VGcm9tTkFMdSh1bml0LmRhdGEsIDEsIHBlcy5wdHMsIHRleHRUcmFjay5zYW1wbGVzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gU1BTXG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF90cmFjayRwaXhlbFJhdGlvLCBfdHJhY2skcGl4ZWxSYXRpbzI7XG4gICAgICAgICAgICBwdXNoID0gdHJ1ZTtcbiAgICAgICAgICAgIHNwc2ZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IHNwcyA9IHVuaXQuZGF0YTtcbiAgICAgICAgICAgIGNvbnN0IGV4cEdvbG9tYkRlY29kZXIgPSBuZXcgRXhwR29sb21iKHNwcyk7XG4gICAgICAgICAgICBjb25zdCBjb25maWcgPSBleHBHb2xvbWJEZWNvZGVyLnJlYWRTUFMoKTtcbiAgICAgICAgICAgIGlmICghdHJhY2suc3BzIHx8IHRyYWNrLndpZHRoICE9PSBjb25maWcud2lkdGggfHwgdHJhY2suaGVpZ2h0ICE9PSBjb25maWcuaGVpZ2h0IHx8ICgoX3RyYWNrJHBpeGVsUmF0aW8gPSB0cmFjay5waXhlbFJhdGlvKSA9PSBudWxsID8gdm9pZCAwIDogX3RyYWNrJHBpeGVsUmF0aW9bMF0pICE9PSBjb25maWcucGl4ZWxSYXRpb1swXSB8fCAoKF90cmFjayRwaXhlbFJhdGlvMiA9IHRyYWNrLnBpeGVsUmF0aW8pID09IG51bGwgPyB2b2lkIDAgOiBfdHJhY2skcGl4ZWxSYXRpbzJbMV0pICE9PSBjb25maWcucGl4ZWxSYXRpb1sxXSkge1xuICAgICAgICAgICAgICB0cmFjay53aWR0aCA9IGNvbmZpZy53aWR0aDtcbiAgICAgICAgICAgICAgdHJhY2suaGVpZ2h0ID0gY29uZmlnLmhlaWdodDtcbiAgICAgICAgICAgICAgdHJhY2sucGl4ZWxSYXRpbyA9IGNvbmZpZy5waXhlbFJhdGlvO1xuICAgICAgICAgICAgICB0cmFjay5zcHMgPSBbc3BzXTtcbiAgICAgICAgICAgICAgdHJhY2suZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgICAgICAgICAgY29uc3QgY29kZWNhcnJheSA9IHNwcy5zdWJhcnJheSgxLCA0KTtcbiAgICAgICAgICAgICAgbGV0IGNvZGVjc3RyaW5nID0gJ2F2YzEuJztcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgaCA9IGNvZGVjYXJyYXlbaV0udG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgICAgIGlmIChoLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICAgIGggPSAnMCcgKyBoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb2RlY3N0cmluZyArPSBoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRyYWNrLmNvZGVjID0gY29kZWNzdHJpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIC8vIFBQU1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgdHJhY2sucHBzID0gW3VuaXQuZGF0YV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIEFVRFxuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgdHJhY2suYXVkRm91bmQgPSB0cnVlO1xuICAgICAgICAgIGlmIChWaWRlb1NhbXBsZSkge1xuICAgICAgICAgICAgdGhpcy5wdXNoQWNjZXNzVW5pdChWaWRlb1NhbXBsZSwgdHJhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgICBWaWRlb1NhbXBsZSA9IHRoaXMuVmlkZW9TYW1wbGUgPSB0aGlzLmNyZWF0ZVZpZGVvU2FtcGxlKGZhbHNlLCBwZXMucHRzLCBwZXMuZHRzLCAnJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIEZpbGxlciBEYXRhXG4gICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgcHVzaCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHVzaCA9IGZhbHNlO1xuICAgICAgICAgIGlmIChWaWRlb1NhbXBsZSkge1xuICAgICAgICAgICAgVmlkZW9TYW1wbGUuZGVidWcgKz0gJ3Vua25vd24gTkFMICcgKyB1bml0LnR5cGUgKyAnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKFZpZGVvU2FtcGxlICYmIHB1c2gpIHtcbiAgICAgICAgY29uc3QgdW5pdHMgPSBWaWRlb1NhbXBsZS51bml0cztcbiAgICAgICAgdW5pdHMucHVzaCh1bml0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBpZiBsYXN0IFBFUyBwYWNrZXQsIHB1c2ggc2FtcGxlc1xuICAgIGlmIChsYXN0ICYmIFZpZGVvU2FtcGxlKSB7XG4gICAgICB0aGlzLnB1c2hBY2Nlc3NVbml0KFZpZGVvU2FtcGxlLCB0cmFjayk7XG4gICAgICB0aGlzLlZpZGVvU2FtcGxlID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgcGFyc2VBVkNOQUx1KHRyYWNrLCBhcnJheSkge1xuICAgIGNvbnN0IGxlbiA9IGFycmF5LmJ5dGVMZW5ndGg7XG4gICAgbGV0IHN0YXRlID0gdHJhY2submFsdVN0YXRlIHx8IDA7XG4gICAgY29uc3QgbGFzdFN0YXRlID0gc3RhdGU7XG4gICAgY29uc3QgdW5pdHMgPSBbXTtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IHZhbHVlO1xuICAgIGxldCBvdmVyZmxvdztcbiAgICBsZXQgdW5pdFR5cGU7XG4gICAgbGV0IGxhc3RVbml0U3RhcnQgPSAtMTtcbiAgICBsZXQgbGFzdFVuaXRUeXBlID0gMDtcbiAgICAvLyBsb2dnZXIubG9nKCdQRVM6JyArIEhleC5oZXhEdW1wKGFycmF5KSk7XG5cbiAgICBpZiAoc3RhdGUgPT09IC0xKSB7XG4gICAgICAvLyBzcGVjaWFsIHVzZSBjYXNlIHdoZXJlIHdlIGZvdW5kIDMgb3IgNC1ieXRlIHN0YXJ0IGNvZGVzIGV4YWN0bHkgYXQgdGhlIGVuZCBvZiBwcmV2aW91cyBQRVMgcGFja2V0XG4gICAgICBsYXN0VW5pdFN0YXJ0ID0gMDtcbiAgICAgIC8vIE5BTHUgdHlwZSBpcyB2YWx1ZSByZWFkIGZyb20gb2Zmc2V0IDBcbiAgICAgIGxhc3RVbml0VHlwZSA9IGFycmF5WzBdICYgMHgxZjtcbiAgICAgIHN0YXRlID0gMDtcbiAgICAgIGkgPSAxO1xuICAgIH1cbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgdmFsdWUgPSBhcnJheVtpKytdO1xuICAgICAgLy8gb3B0aW1pemF0aW9uLiBzdGF0ZSAwIGFuZCAxIGFyZSB0aGUgcHJlZG9taW5hbnQgY2FzZS4gbGV0J3MgaGFuZGxlIHRoZW0gb3V0c2lkZSBvZiB0aGUgc3dpdGNoL2Nhc2VcbiAgICAgIGlmICghc3RhdGUpIHtcbiAgICAgICAgc3RhdGUgPSB2YWx1ZSA/IDAgOiAxO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZSA9PT0gMSkge1xuICAgICAgICBzdGF0ZSA9IHZhbHVlID8gMCA6IDI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gaGVyZSB3ZSBoYXZlIHN0YXRlIGVpdGhlciBlcXVhbCB0byAyIG9yIDNcbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgc3RhdGUgPSAzO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gMSkge1xuICAgICAgICBvdmVyZmxvdyA9IGkgLSBzdGF0ZSAtIDE7XG4gICAgICAgIGlmIChsYXN0VW5pdFN0YXJ0ID49IDApIHtcbiAgICAgICAgICBjb25zdCB1bml0ID0ge1xuICAgICAgICAgICAgZGF0YTogYXJyYXkuc3ViYXJyYXkobGFzdFVuaXRTdGFydCwgb3ZlcmZsb3cpLFxuICAgICAgICAgICAgdHlwZTogbGFzdFVuaXRUeXBlXG4gICAgICAgICAgfTtcbiAgICAgICAgICAvLyBsb2dnZXIubG9nKCdwdXNoaW5nIE5BTFUsIHR5cGUvc2l6ZTonICsgdW5pdC50eXBlICsgJy8nICsgdW5pdC5kYXRhLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgIHVuaXRzLnB1c2godW5pdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbGFzdFVuaXRTdGFydCBpcyB1bmRlZmluZWQgPT4gdGhpcyBpcyB0aGUgZmlyc3Qgc3RhcnQgY29kZSBmb3VuZCBpbiB0aGlzIFBFUyBwYWNrZXRcbiAgICAgICAgICAvLyBmaXJzdCBjaGVjayBpZiBzdGFydCBjb2RlIGRlbGltaXRlciBpcyBvdmVybGFwcGluZyBiZXR3ZWVuIDIgUEVTIHBhY2tldHMsXG4gICAgICAgICAgLy8gaWUgaXQgc3RhcnRlZCBpbiBsYXN0IHBhY2tldCAobGFzdFN0YXRlIG5vdCB6ZXJvKVxuICAgICAgICAgIC8vIGFuZCBlbmRlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoaXMgUEVTIHBhY2tldCAoaSA8PSA0IC0gbGFzdFN0YXRlKVxuICAgICAgICAgIGNvbnN0IGxhc3RVbml0ID0gdGhpcy5nZXRMYXN0TmFsVW5pdCh0cmFjay5zYW1wbGVzKTtcbiAgICAgICAgICBpZiAobGFzdFVuaXQpIHtcbiAgICAgICAgICAgIGlmIChsYXN0U3RhdGUgJiYgaSA8PSA0IC0gbGFzdFN0YXRlKSB7XG4gICAgICAgICAgICAgIC8vIHN0YXJ0IGRlbGltaXRlciBvdmVybGFwcGluZyBiZXR3ZWVuIFBFUyBwYWNrZXRzXG4gICAgICAgICAgICAgIC8vIHN0cmlwIHN0YXJ0IGRlbGltaXRlciBieXRlcyBmcm9tIHRoZSBlbmQgb2YgbGFzdCBOQUwgdW5pdFxuICAgICAgICAgICAgICAvLyBjaGVjayBpZiBsYXN0VW5pdCBoYWQgYSBzdGF0ZSBkaWZmZXJlbnQgZnJvbSB6ZXJvXG4gICAgICAgICAgICAgIGlmIChsYXN0VW5pdC5zdGF0ZSkge1xuICAgICAgICAgICAgICAgIC8vIHN0cmlwIGxhc3QgYnl0ZXNcbiAgICAgICAgICAgICAgICBsYXN0VW5pdC5kYXRhID0gbGFzdFVuaXQuZGF0YS5zdWJhcnJheSgwLCBsYXN0VW5pdC5kYXRhLmJ5dGVMZW5ndGggLSBsYXN0U3RhdGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBOQUwgdW5pdHMgYXJlIG5vdCBzdGFydGluZyByaWdodCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBQRVMgcGFja2V0LCBwdXNoIHByZWNlZGluZyBkYXRhIGludG8gcHJldmlvdXMgTkFMIHVuaXQuXG5cbiAgICAgICAgICAgIGlmIChvdmVyZmxvdyA+IDApIHtcbiAgICAgICAgICAgICAgLy8gbG9nZ2VyLmxvZygnZmlyc3QgTkFMVSBmb3VuZCB3aXRoIG92ZXJmbG93OicgKyBvdmVyZmxvdyk7XG4gICAgICAgICAgICAgIGxhc3RVbml0LmRhdGEgPSBhcHBlbmRVaW50OEFycmF5KGxhc3RVbml0LmRhdGEsIGFycmF5LnN1YmFycmF5KDAsIG92ZXJmbG93KSk7XG4gICAgICAgICAgICAgIGxhc3RVbml0LnN0YXRlID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgaWYgd2UgY2FuIHJlYWQgdW5pdCB0eXBlXG4gICAgICAgIGlmIChpIDwgbGVuKSB7XG4gICAgICAgICAgdW5pdFR5cGUgPSBhcnJheVtpXSAmIDB4MWY7XG4gICAgICAgICAgLy8gbG9nZ2VyLmxvZygnZmluZCBOQUxVIEAgb2Zmc2V0OicgKyBpICsgJyx0eXBlOicgKyB1bml0VHlwZSk7XG4gICAgICAgICAgbGFzdFVuaXRTdGFydCA9IGk7XG4gICAgICAgICAgbGFzdFVuaXRUeXBlID0gdW5pdFR5cGU7XG4gICAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG5vdCBlbm91Z2ggYnl0ZSB0byByZWFkIHVuaXQgdHlwZS4gbGV0J3MgcmVhZCBpdCBvbiBuZXh0IFBFUyBwYXJzaW5nXG4gICAgICAgICAgc3RhdGUgPSAtMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobGFzdFVuaXRTdGFydCA+PSAwICYmIHN0YXRlID49IDApIHtcbiAgICAgIGNvbnN0IHVuaXQgPSB7XG4gICAgICAgIGRhdGE6IGFycmF5LnN1YmFycmF5KGxhc3RVbml0U3RhcnQsIGxlbiksXG4gICAgICAgIHR5cGU6IGxhc3RVbml0VHlwZSxcbiAgICAgICAgc3RhdGU6IHN0YXRlXG4gICAgICB9O1xuICAgICAgdW5pdHMucHVzaCh1bml0KTtcbiAgICAgIC8vIGxvZ2dlci5sb2coJ3B1c2hpbmcgTkFMVSwgdHlwZS9zaXplL3N0YXRlOicgKyB1bml0LnR5cGUgKyAnLycgKyB1bml0LmRhdGEuYnl0ZUxlbmd0aCArICcvJyArIHN0YXRlKTtcbiAgICB9XG4gICAgLy8gbm8gTkFMdSBmb3VuZFxuICAgIGlmICh1bml0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIGFwcGVuZCBwZXMuZGF0YSB0byBwcmV2aW91cyBOQUwgdW5pdFxuICAgICAgY29uc3QgbGFzdFVuaXQgPSB0aGlzLmdldExhc3ROYWxVbml0KHRyYWNrLnNhbXBsZXMpO1xuICAgICAgaWYgKGxhc3RVbml0KSB7XG4gICAgICAgIGxhc3RVbml0LmRhdGEgPSBhcHBlbmRVaW50OEFycmF5KGxhc3RVbml0LmRhdGEsIGFycmF5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJhY2submFsdVN0YXRlID0gc3RhdGU7XG4gICAgcmV0dXJuIHVuaXRzO1xuICB9XG59XG5cbi8qKlxuICogU0FNUExFLUFFUyBkZWNyeXB0ZXJcbiAqL1xuXG5jbGFzcyBTYW1wbGVBZXNEZWNyeXB0ZXIge1xuICBjb25zdHJ1Y3RvcihvYnNlcnZlciwgY29uZmlnLCBrZXlEYXRhKSB7XG4gICAgdGhpcy5rZXlEYXRhID0gdm9pZCAwO1xuICAgIHRoaXMuZGVjcnlwdGVyID0gdm9pZCAwO1xuICAgIHRoaXMua2V5RGF0YSA9IGtleURhdGE7XG4gICAgdGhpcy5kZWNyeXB0ZXIgPSBuZXcgRGVjcnlwdGVyKGNvbmZpZywge1xuICAgICAgcmVtb3ZlUEtDUzdQYWRkaW5nOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIGRlY3J5cHRCdWZmZXIoZW5jcnlwdGVkRGF0YSkge1xuICAgIHJldHVybiB0aGlzLmRlY3J5cHRlci5kZWNyeXB0KGVuY3J5cHRlZERhdGEsIHRoaXMua2V5RGF0YS5rZXkuYnVmZmVyLCB0aGlzLmtleURhdGEuaXYuYnVmZmVyKTtcbiAgfVxuXG4gIC8vIEFBQyAtIGVuY3J5cHQgYWxsIGZ1bGwgMTYgYnl0ZXMgYmxvY2tzIHN0YXJ0aW5nIGZyb20gb2Zmc2V0IDE2XG4gIGRlY3J5cHRBYWNTYW1wbGUoc2FtcGxlcywgc2FtcGxlSW5kZXgsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgY3VyVW5pdCA9IHNhbXBsZXNbc2FtcGxlSW5kZXhdLnVuaXQ7XG4gICAgaWYgKGN1clVuaXQubGVuZ3RoIDw9IDE2KSB7XG4gICAgICAvLyBObyBlbmNyeXB0ZWQgcG9ydGlvbiBpbiB0aGlzIHNhbXBsZSAoZmlyc3QgMTYgYnl0ZXMgaXMgbm90XG4gICAgICAvLyBlbmNyeXB0ZWQsIHNlZSBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vbGlicmFyeS9hcmNoaXZlL2RvY3VtZW50YXRpb24vQXVkaW9WaWRlby9Db25jZXB0dWFsL0hMU19TYW1wbGVfRW5jcnlwdGlvbi9FbmNyeXB0aW9uL0VuY3J5cHRpb24uaHRtbCksXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGVuY3J5cHRlZERhdGEgPSBjdXJVbml0LnN1YmFycmF5KDE2LCBjdXJVbml0Lmxlbmd0aCAtIGN1clVuaXQubGVuZ3RoICUgMTYpO1xuICAgIGNvbnN0IGVuY3J5cHRlZEJ1ZmZlciA9IGVuY3J5cHRlZERhdGEuYnVmZmVyLnNsaWNlKGVuY3J5cHRlZERhdGEuYnl0ZU9mZnNldCwgZW5jcnlwdGVkRGF0YS5ieXRlT2Zmc2V0ICsgZW5jcnlwdGVkRGF0YS5sZW5ndGgpO1xuICAgIHRoaXMuZGVjcnlwdEJ1ZmZlcihlbmNyeXB0ZWRCdWZmZXIpLnRoZW4oZGVjcnlwdGVkQnVmZmVyID0+IHtcbiAgICAgIGNvbnN0IGRlY3J5cHRlZERhdGEgPSBuZXcgVWludDhBcnJheShkZWNyeXB0ZWRCdWZmZXIpO1xuICAgICAgY3VyVW5pdC5zZXQoZGVjcnlwdGVkRGF0YSwgMTYpO1xuICAgICAgaWYgKCF0aGlzLmRlY3J5cHRlci5pc1N5bmMoKSkge1xuICAgICAgICB0aGlzLmRlY3J5cHRBYWNTYW1wbGVzKHNhbXBsZXMsIHNhbXBsZUluZGV4ICsgMSwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGRlY3J5cHRBYWNTYW1wbGVzKHNhbXBsZXMsIHNhbXBsZUluZGV4LCBjYWxsYmFjaykge1xuICAgIGZvciAoOzsgc2FtcGxlSW5kZXgrKykge1xuICAgICAgaWYgKHNhbXBsZUluZGV4ID49IHNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChzYW1wbGVzW3NhbXBsZUluZGV4XS51bml0Lmxlbmd0aCA8IDMyKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5kZWNyeXB0QWFjU2FtcGxlKHNhbXBsZXMsIHNhbXBsZUluZGV4LCBjYWxsYmFjayk7XG4gICAgICBpZiAoIXRoaXMuZGVjcnlwdGVyLmlzU3luYygpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBBVkMgLSBlbmNyeXB0IG9uZSAxNiBieXRlcyBibG9jayBvdXQgb2YgdGVuLCBzdGFydGluZyBmcm9tIG9mZnNldCAzMlxuICBnZXRBdmNFbmNyeXB0ZWREYXRhKGRlY29kZWREYXRhKSB7XG4gICAgY29uc3QgZW5jcnlwdGVkRGF0YUxlbiA9IE1hdGguZmxvb3IoKGRlY29kZWREYXRhLmxlbmd0aCAtIDQ4KSAvIDE2MCkgKiAxNiArIDE2O1xuICAgIGNvbnN0IGVuY3J5cHRlZERhdGEgPSBuZXcgSW50OEFycmF5KGVuY3J5cHRlZERhdGFMZW4pO1xuICAgIGxldCBvdXRwdXRQb3MgPSAwO1xuICAgIGZvciAobGV0IGlucHV0UG9zID0gMzI7IGlucHV0UG9zIDwgZGVjb2RlZERhdGEubGVuZ3RoIC0gMTY7IGlucHV0UG9zICs9IDE2MCwgb3V0cHV0UG9zICs9IDE2KSB7XG4gICAgICBlbmNyeXB0ZWREYXRhLnNldChkZWNvZGVkRGF0YS5zdWJhcnJheShpbnB1dFBvcywgaW5wdXRQb3MgKyAxNiksIG91dHB1dFBvcyk7XG4gICAgfVxuICAgIHJldHVybiBlbmNyeXB0ZWREYXRhO1xuICB9XG4gIGdldEF2Y0RlY3J5cHRlZFVuaXQoZGVjb2RlZERhdGEsIGRlY3J5cHRlZERhdGEpIHtcbiAgICBjb25zdCB1aW50OERlY3J5cHRlZERhdGEgPSBuZXcgVWludDhBcnJheShkZWNyeXB0ZWREYXRhKTtcbiAgICBsZXQgaW5wdXRQb3MgPSAwO1xuICAgIGZvciAobGV0IG91dHB1dFBvcyA9IDMyOyBvdXRwdXRQb3MgPCBkZWNvZGVkRGF0YS5sZW5ndGggLSAxNjsgb3V0cHV0UG9zICs9IDE2MCwgaW5wdXRQb3MgKz0gMTYpIHtcbiAgICAgIGRlY29kZWREYXRhLnNldCh1aW50OERlY3J5cHRlZERhdGEuc3ViYXJyYXkoaW5wdXRQb3MsIGlucHV0UG9zICsgMTYpLCBvdXRwdXRQb3MpO1xuICAgIH1cbiAgICByZXR1cm4gZGVjb2RlZERhdGE7XG4gIH1cbiAgZGVjcnlwdEF2Y1NhbXBsZShzYW1wbGVzLCBzYW1wbGVJbmRleCwgdW5pdEluZGV4LCBjYWxsYmFjaywgY3VyVW5pdCkge1xuICAgIGNvbnN0IGRlY29kZWREYXRhID0gZGlzY2FyZEVQQihjdXJVbml0LmRhdGEpO1xuICAgIGNvbnN0IGVuY3J5cHRlZERhdGEgPSB0aGlzLmdldEF2Y0VuY3J5cHRlZERhdGEoZGVjb2RlZERhdGEpO1xuICAgIHRoaXMuZGVjcnlwdEJ1ZmZlcihlbmNyeXB0ZWREYXRhLmJ1ZmZlcikudGhlbihkZWNyeXB0ZWRCdWZmZXIgPT4ge1xuICAgICAgY3VyVW5pdC5kYXRhID0gdGhpcy5nZXRBdmNEZWNyeXB0ZWRVbml0KGRlY29kZWREYXRhLCBkZWNyeXB0ZWRCdWZmZXIpO1xuICAgICAgaWYgKCF0aGlzLmRlY3J5cHRlci5pc1N5bmMoKSkge1xuICAgICAgICB0aGlzLmRlY3J5cHRBdmNTYW1wbGVzKHNhbXBsZXMsIHNhbXBsZUluZGV4LCB1bml0SW5kZXggKyAxLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZGVjcnlwdEF2Y1NhbXBsZXMoc2FtcGxlcywgc2FtcGxlSW5kZXgsIHVuaXRJbmRleCwgY2FsbGJhY2spIHtcbiAgICBpZiAoc2FtcGxlcyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGRlY3J5cHQgc2FtcGxlcyBvZiB0eXBlIFVpbnQ4QXJyYXknKTtcbiAgICB9XG4gICAgZm9yICg7OyBzYW1wbGVJbmRleCsrLCB1bml0SW5kZXggPSAwKSB7XG4gICAgICBpZiAoc2FtcGxlSW5kZXggPj0gc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgY3VyVW5pdHMgPSBzYW1wbGVzW3NhbXBsZUluZGV4XS51bml0cztcbiAgICAgIGZvciAoOzsgdW5pdEluZGV4KyspIHtcbiAgICAgICAgaWYgKHVuaXRJbmRleCA+PSBjdXJVbml0cy5sZW5ndGgpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJVbml0ID0gY3VyVW5pdHNbdW5pdEluZGV4XTtcbiAgICAgICAgaWYgKGN1clVuaXQuZGF0YS5sZW5ndGggPD0gNDggfHwgY3VyVW5pdC50eXBlICE9PSAxICYmIGN1clVuaXQudHlwZSAhPT0gNSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVjcnlwdEF2Y1NhbXBsZShzYW1wbGVzLCBzYW1wbGVJbmRleCwgdW5pdEluZGV4LCBjYWxsYmFjaywgY3VyVW5pdCk7XG4gICAgICAgIGlmICghdGhpcy5kZWNyeXB0ZXIuaXNTeW5jKCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuY29uc3QgUEFDS0VUX0xFTkdUSCA9IDE4ODtcbmNsYXNzIFRTRGVtdXhlciB7XG4gIGNvbnN0cnVjdG9yKG9ic2VydmVyLCBjb25maWcsIHR5cGVTdXBwb3J0ZWQpIHtcbiAgICB0aGlzLm9ic2VydmVyID0gdm9pZCAwO1xuICAgIHRoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgIHRoaXMudHlwZVN1cHBvcnRlZCA9IHZvaWQgMDtcbiAgICB0aGlzLnNhbXBsZUFlcyA9IG51bGw7XG4gICAgdGhpcy5wbXRQYXJzZWQgPSBmYWxzZTtcbiAgICB0aGlzLmF1ZGlvQ29kZWMgPSB2b2lkIDA7XG4gICAgdGhpcy52aWRlb0NvZGVjID0gdm9pZCAwO1xuICAgIHRoaXMuX2R1cmF0aW9uID0gMDtcbiAgICB0aGlzLl9wbXRJZCA9IC0xO1xuICAgIHRoaXMuX3ZpZGVvVHJhY2sgPSB2b2lkIDA7XG4gICAgdGhpcy5fYXVkaW9UcmFjayA9IHZvaWQgMDtcbiAgICB0aGlzLl9pZDNUcmFjayA9IHZvaWQgMDtcbiAgICB0aGlzLl90eHRUcmFjayA9IHZvaWQgMDtcbiAgICB0aGlzLmFhY092ZXJGbG93ID0gbnVsbDtcbiAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgIHRoaXMudmlkZW9QYXJzZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5vYnNlcnZlciA9IG9ic2VydmVyO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMudHlwZVN1cHBvcnRlZCA9IHR5cGVTdXBwb3J0ZWQ7XG4gICAgdGhpcy52aWRlb1BhcnNlciA9IG5ldyBBdmNWaWRlb1BhcnNlcigpO1xuICB9XG4gIHN0YXRpYyBwcm9iZShkYXRhKSB7XG4gICAgY29uc3Qgc3luY09mZnNldCA9IFRTRGVtdXhlci5zeW5jT2Zmc2V0KGRhdGEpO1xuICAgIGlmIChzeW5jT2Zmc2V0ID4gMCkge1xuICAgICAgbG9nZ2VyLndhcm4oYE1QRUcyLVRTIGRldGVjdGVkIGJ1dCBmaXJzdCBzeW5jIHdvcmQgZm91bmQgQCBvZmZzZXQgJHtzeW5jT2Zmc2V0fWApO1xuICAgIH1cbiAgICByZXR1cm4gc3luY09mZnNldCAhPT0gLTE7XG4gIH1cbiAgc3RhdGljIHN5bmNPZmZzZXQoZGF0YSkge1xuICAgIGNvbnN0IGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgIGxldCBzY2Fud2luZG93ID0gTWF0aC5taW4oUEFDS0VUX0xFTkdUSCAqIDUsIGxlbmd0aCAtIFBBQ0tFVF9MRU5HVEgpICsgMTtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzY2Fud2luZG93KSB7XG4gICAgICAvLyBhIFRTIGluaXQgc2VnbWVudCBzaG91bGQgY29udGFpbiBhdCBsZWFzdCAyIFRTIHBhY2tldHM6IFBBVCBhbmQgUE1ULCBlYWNoIHN0YXJ0aW5nIHdpdGggMHg0N1xuICAgICAgbGV0IGZvdW5kUGF0ID0gZmFsc2U7XG4gICAgICBsZXQgcGFja2V0U3RhcnQgPSAtMTtcbiAgICAgIGxldCB0c1BhY2tldHMgPSAwO1xuICAgICAgZm9yIChsZXQgaiA9IGk7IGogPCBsZW5ndGg7IGogKz0gUEFDS0VUX0xFTkdUSCkge1xuICAgICAgICBpZiAoZGF0YVtqXSA9PT0gMHg0NyAmJiAobGVuZ3RoIC0gaiA9PT0gUEFDS0VUX0xFTkdUSCB8fCBkYXRhW2ogKyBQQUNLRVRfTEVOR1RIXSA9PT0gMHg0NykpIHtcbiAgICAgICAgICB0c1BhY2tldHMrKztcbiAgICAgICAgICBpZiAocGFja2V0U3RhcnQgPT09IC0xKSB7XG4gICAgICAgICAgICBwYWNrZXRTdGFydCA9IGo7XG4gICAgICAgICAgICAvLyBGaXJzdCBzeW5jIHdvcmQgZm91bmQgYXQgb2Zmc2V0LCBpbmNyZWFzZSBzY2FuIGxlbmd0aCAoIzUyNTEpXG4gICAgICAgICAgICBpZiAocGFja2V0U3RhcnQgIT09IDApIHtcbiAgICAgICAgICAgICAgc2NhbndpbmRvdyA9IE1hdGgubWluKHBhY2tldFN0YXJ0ICsgUEFDS0VUX0xFTkdUSCAqIDk5LCBkYXRhLmxlbmd0aCAtIFBBQ0tFVF9MRU5HVEgpICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFmb3VuZFBhdCkge1xuICAgICAgICAgICAgZm91bmRQYXQgPSBwYXJzZVBJRChkYXRhLCBqKSA9PT0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gU3luYyB3b3JkIGZvdW5kIGF0IDAgd2l0aCAzIHBhY2tldHMsIG9yIGZvdW5kIGF0IG9mZnNldCBsZWFzdCAyIHBhY2tldHMgdXAgdG8gc2NhbndpbmRvdyAoIzU1MDEpXG4gICAgICAgICAgaWYgKGZvdW5kUGF0ICYmIHRzUGFja2V0cyA+IDEgJiYgKHBhY2tldFN0YXJ0ID09PSAwICYmIHRzUGFja2V0cyA+IDIgfHwgaiArIFBBQ0tFVF9MRU5HVEggPiBzY2Fud2luZG93KSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhY2tldFN0YXJ0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0c1BhY2tldHMpIHtcbiAgICAgICAgICAvLyBFeGl0IGlmIHN5bmMgd29yZCBmb3VuZCwgYnV0IGRvZXMgbm90IGNvbnRhaW4gY29udGlndW91cyBwYWNrZXRzXG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgdHJhY2sgbW9kZWwgaW50ZXJuYWwgdG8gZGVtdXhlciB1c2VkIHRvIGRyaXZlIHJlbXV4aW5nIGlucHV0XG4gICAqL1xuICBzdGF0aWMgY3JlYXRlVHJhY2sodHlwZSwgZHVyYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29udGFpbmVyOiB0eXBlID09PSAndmlkZW8nIHx8IHR5cGUgPT09ICdhdWRpbycgPyAndmlkZW8vbXAydCcgOiB1bmRlZmluZWQsXG4gICAgICB0eXBlLFxuICAgICAgaWQ6IFJlbXV4ZXJUcmFja0lkQ29uZmlnW3R5cGVdLFxuICAgICAgcGlkOiAtMSxcbiAgICAgIGlucHV0VGltZVNjYWxlOiA5MDAwMCxcbiAgICAgIHNlcXVlbmNlTnVtYmVyOiAwLFxuICAgICAgc2FtcGxlczogW10sXG4gICAgICBkcm9wcGVkOiAwLFxuICAgICAgZHVyYXRpb246IHR5cGUgPT09ICdhdWRpbycgPyBkdXJhdGlvbiA6IHVuZGVmaW5lZFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgYSBuZXcgaW5pdCBzZWdtZW50IG9uIHRoZSBkZW11eGVyL3JlbXV4ZXIgaW50ZXJmYWNlLiBOZWVkZWQgZm9yIGRpc2NvbnRpbnVpdGllcy90cmFjay1zd2l0Y2hlcyAob3IgYXQgc3RyZWFtIHN0YXJ0KVxuICAgKiBSZXNldHMgYWxsIGludGVybmFsIHRyYWNrIGluc3RhbmNlcyBvZiB0aGUgZGVtdXhlci5cbiAgICovXG4gIHJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRyYWNrRHVyYXRpb24pIHtcbiAgICB0aGlzLnBtdFBhcnNlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3BtdElkID0gLTE7XG4gICAgdGhpcy5fdmlkZW9UcmFjayA9IFRTRGVtdXhlci5jcmVhdGVUcmFjaygndmlkZW8nKTtcbiAgICB0aGlzLl9hdWRpb1RyYWNrID0gVFNEZW11eGVyLmNyZWF0ZVRyYWNrKCdhdWRpbycsIHRyYWNrRHVyYXRpb24pO1xuICAgIHRoaXMuX2lkM1RyYWNrID0gVFNEZW11eGVyLmNyZWF0ZVRyYWNrKCdpZDMnKTtcbiAgICB0aGlzLl90eHRUcmFjayA9IFRTRGVtdXhlci5jcmVhdGVUcmFjaygndGV4dCcpO1xuICAgIHRoaXMuX2F1ZGlvVHJhY2suc2VnbWVudENvZGVjID0gJ2FhYyc7XG5cbiAgICAvLyBmbHVzaCBhbnkgcGFydGlhbCBjb250ZW50XG4gICAgdGhpcy5hYWNPdmVyRmxvdyA9IG51bGw7XG4gICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcbiAgICB0aGlzLmF1ZGlvQ29kZWMgPSBhdWRpb0NvZGVjO1xuICAgIHRoaXMudmlkZW9Db2RlYyA9IHZpZGVvQ29kZWM7XG4gICAgdGhpcy5fZHVyYXRpb24gPSB0cmFja0R1cmF0aW9uO1xuICB9XG4gIHJlc2V0VGltZVN0YW1wKCkge31cbiAgcmVzZXRDb250aWd1aXR5KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIF9hdWRpb1RyYWNrLFxuICAgICAgX3ZpZGVvVHJhY2ssXG4gICAgICBfaWQzVHJhY2tcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoX2F1ZGlvVHJhY2spIHtcbiAgICAgIF9hdWRpb1RyYWNrLnBlc0RhdGEgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoX3ZpZGVvVHJhY2spIHtcbiAgICAgIF92aWRlb1RyYWNrLnBlc0RhdGEgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoX2lkM1RyYWNrKSB7XG4gICAgICBfaWQzVHJhY2sucGVzRGF0YSA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuYWFjT3ZlckZsb3cgPSBudWxsO1xuICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG4gIH1cbiAgZGVtdXgoZGF0YSwgdGltZU9mZnNldCwgaXNTYW1wbGVBZXMgPSBmYWxzZSwgZmx1c2ggPSBmYWxzZSkge1xuICAgIGlmICghaXNTYW1wbGVBZXMpIHtcbiAgICAgIHRoaXMuc2FtcGxlQWVzID0gbnVsbDtcbiAgICB9XG4gICAgbGV0IHBlcztcbiAgICBjb25zdCB2aWRlb1RyYWNrID0gdGhpcy5fdmlkZW9UcmFjaztcbiAgICBjb25zdCBhdWRpb1RyYWNrID0gdGhpcy5fYXVkaW9UcmFjaztcbiAgICBjb25zdCBpZDNUcmFjayA9IHRoaXMuX2lkM1RyYWNrO1xuICAgIGNvbnN0IHRleHRUcmFjayA9IHRoaXMuX3R4dFRyYWNrO1xuICAgIGxldCB2aWRlb1BpZCA9IHZpZGVvVHJhY2sucGlkO1xuICAgIGxldCB2aWRlb0RhdGEgPSB2aWRlb1RyYWNrLnBlc0RhdGE7XG4gICAgbGV0IGF1ZGlvUGlkID0gYXVkaW9UcmFjay5waWQ7XG4gICAgbGV0IGlkM1BpZCA9IGlkM1RyYWNrLnBpZDtcbiAgICBsZXQgYXVkaW9EYXRhID0gYXVkaW9UcmFjay5wZXNEYXRhO1xuICAgIGxldCBpZDNEYXRhID0gaWQzVHJhY2sucGVzRGF0YTtcbiAgICBsZXQgdW5rbm93blBJRCA9IG51bGw7XG4gICAgbGV0IHBtdFBhcnNlZCA9IHRoaXMucG10UGFyc2VkO1xuICAgIGxldCBwbXRJZCA9IHRoaXMuX3BtdElkO1xuICAgIGxldCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICBpZiAodGhpcy5yZW1haW5kZXJEYXRhKSB7XG4gICAgICBkYXRhID0gYXBwZW5kVWludDhBcnJheSh0aGlzLnJlbWFpbmRlckRhdGEsIGRhdGEpO1xuICAgICAgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgIH1cbiAgICBpZiAobGVuIDwgUEFDS0VUX0xFTkdUSCAmJiAhZmx1c2gpIHtcbiAgICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IGRhdGE7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdWRpb1RyYWNrLFxuICAgICAgICB2aWRlb1RyYWNrLFxuICAgICAgICBpZDNUcmFjayxcbiAgICAgICAgdGV4dFRyYWNrXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBzeW5jT2Zmc2V0ID0gTWF0aC5tYXgoMCwgVFNEZW11eGVyLnN5bmNPZmZzZXQoZGF0YSkpO1xuICAgIGxlbiAtPSAobGVuIC0gc3luY09mZnNldCkgJSBQQUNLRVRfTEVOR1RIO1xuICAgIGlmIChsZW4gPCBkYXRhLmJ5dGVMZW5ndGggJiYgIWZsdXNoKSB7XG4gICAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlciwgbGVuLCBkYXRhLmJ1ZmZlci5ieXRlTGVuZ3RoIC0gbGVuKTtcbiAgICB9XG5cbiAgICAvLyBsb29wIHRocm91Z2ggVFMgcGFja2V0c1xuICAgIGxldCB0c1BhY2tldEVycm9ycyA9IDA7XG4gICAgZm9yIChsZXQgc3RhcnQgPSBzeW5jT2Zmc2V0OyBzdGFydCA8IGxlbjsgc3RhcnQgKz0gUEFDS0VUX0xFTkdUSCkge1xuICAgICAgaWYgKGRhdGFbc3RhcnRdID09PSAweDQ3KSB7XG4gICAgICAgIGNvbnN0IHN0dCA9ICEhKGRhdGFbc3RhcnQgKyAxXSAmIDB4NDApO1xuICAgICAgICBjb25zdCBwaWQgPSBwYXJzZVBJRChkYXRhLCBzdGFydCk7XG4gICAgICAgIGNvbnN0IGF0ZiA9IChkYXRhW3N0YXJ0ICsgM10gJiAweDMwKSA+PiA0O1xuXG4gICAgICAgIC8vIGlmIGFuIGFkYXB0aW9uIGZpZWxkIGlzIHByZXNlbnQsIGl0cyBsZW5ndGggaXMgc3BlY2lmaWVkIGJ5IHRoZSBmaWZ0aCBieXRlIG9mIHRoZSBUUyBwYWNrZXQgaGVhZGVyLlxuICAgICAgICBsZXQgb2Zmc2V0O1xuICAgICAgICBpZiAoYXRmID4gMSkge1xuICAgICAgICAgIG9mZnNldCA9IHN0YXJ0ICsgNSArIGRhdGFbc3RhcnQgKyA0XTtcbiAgICAgICAgICAvLyBjb250aW51ZSBpZiB0aGVyZSBpcyBvbmx5IGFkYXB0YXRpb24gZmllbGRcbiAgICAgICAgICBpZiAob2Zmc2V0ID09PSBzdGFydCArIFBBQ0tFVF9MRU5HVEgpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmZzZXQgPSBzdGFydCArIDQ7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChwaWQpIHtcbiAgICAgICAgICBjYXNlIHZpZGVvUGlkOlxuICAgICAgICAgICAgaWYgKHN0dCkge1xuICAgICAgICAgICAgICBpZiAodmlkZW9EYXRhICYmIChwZXMgPSBwYXJzZVBFUyh2aWRlb0RhdGEpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudmlkZW9QYXJzZXIucGFyc2VBVkNQRVModmlkZW9UcmFjaywgdGV4dFRyYWNrLCBwZXMsIGZhbHNlLCB0aGlzLl9kdXJhdGlvbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmlkZW9EYXRhID0ge1xuICAgICAgICAgICAgICAgIGRhdGE6IFtdLFxuICAgICAgICAgICAgICAgIHNpemU6IDBcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2aWRlb0RhdGEpIHtcbiAgICAgICAgICAgICAgdmlkZW9EYXRhLmRhdGEucHVzaChkYXRhLnN1YmFycmF5KG9mZnNldCwgc3RhcnQgKyBQQUNLRVRfTEVOR1RIKSk7XG4gICAgICAgICAgICAgIHZpZGVvRGF0YS5zaXplICs9IHN0YXJ0ICsgUEFDS0VUX0xFTkdUSCAtIG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgYXVkaW9QaWQ6XG4gICAgICAgICAgICBpZiAoc3R0KSB7XG4gICAgICAgICAgICAgIGlmIChhdWRpb0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKGF1ZGlvRGF0YSkpKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChhdWRpb1RyYWNrLnNlZ21lbnRDb2RlYykge1xuICAgICAgICAgICAgICAgICAgY2FzZSAnYWFjJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZUFBQ1BFUyhhdWRpb1RyYWNrLCBwZXMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ21wMyc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VNUEVHUEVTKGF1ZGlvVHJhY2ssIHBlcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSAnYWMzJzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VBQzNQRVMoYXVkaW9UcmFjaywgcGVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXVkaW9EYXRhID0ge1xuICAgICAgICAgICAgICAgIGRhdGE6IFtdLFxuICAgICAgICAgICAgICAgIHNpemU6IDBcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhdWRpb0RhdGEpIHtcbiAgICAgICAgICAgICAgYXVkaW9EYXRhLmRhdGEucHVzaChkYXRhLnN1YmFycmF5KG9mZnNldCwgc3RhcnQgKyBQQUNLRVRfTEVOR1RIKSk7XG4gICAgICAgICAgICAgIGF1ZGlvRGF0YS5zaXplICs9IHN0YXJ0ICsgUEFDS0VUX0xFTkdUSCAtIG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaWQzUGlkOlxuICAgICAgICAgICAgaWYgKHN0dCkge1xuICAgICAgICAgICAgICBpZiAoaWQzRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoaWQzRGF0YSkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZUlEM1BFUyhpZDNUcmFjaywgcGVzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZDNEYXRhID0ge1xuICAgICAgICAgICAgICAgIGRhdGE6IFtdLFxuICAgICAgICAgICAgICAgIHNpemU6IDBcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpZDNEYXRhKSB7XG4gICAgICAgICAgICAgIGlkM0RhdGEuZGF0YS5wdXNoKGRhdGEuc3ViYXJyYXkob2Zmc2V0LCBzdGFydCArIFBBQ0tFVF9MRU5HVEgpKTtcbiAgICAgICAgICAgICAgaWQzRGF0YS5zaXplICs9IHN0YXJ0ICsgUEFDS0VUX0xFTkdUSCAtIG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmIChzdHQpIHtcbiAgICAgICAgICAgICAgb2Zmc2V0ICs9IGRhdGFbb2Zmc2V0XSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwbXRJZCA9IHRoaXMuX3BtdElkID0gcGFyc2VQQVQoZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ1BNVCBQSUQ6JyAgKyB0aGlzLl9wbXRJZCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIHBtdElkOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZiAoc3R0KSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGRhdGFbb2Zmc2V0XSArIDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgcGFyc2VkUElEcyA9IHBhcnNlUE1UKGRhdGEsIG9mZnNldCwgdGhpcy50eXBlU3VwcG9ydGVkLCBpc1NhbXBsZUFlcyk7XG5cbiAgICAgICAgICAgICAgLy8gb25seSB1cGRhdGUgdHJhY2sgaWQgaWYgdHJhY2sgUElEIGZvdW5kIHdoaWxlIHBhcnNpbmcgUE1UXG4gICAgICAgICAgICAgIC8vIHRoaXMgaXMgdG8gYXZvaWQgcmVzZXR0aW5nIHRoZSBQSUQgdG8gLTEgaW4gY2FzZVxuICAgICAgICAgICAgICAvLyB0cmFjayBQSUQgdHJhbnNpZW50bHkgZGlzYXBwZWFycyBmcm9tIHRoZSBzdHJlYW1cbiAgICAgICAgICAgICAgLy8gdGhpcyBjb3VsZCBoYXBwZW4gaW4gY2FzZSBvZiB0cmFuc2llbnQgbWlzc2luZyBhdWRpbyBzYW1wbGVzIGZvciBleGFtcGxlXG4gICAgICAgICAgICAgIC8vIE5PVEUgdGhpcyBpcyBvbmx5IHRoZSBQSUQgb2YgdGhlIHRyYWNrIGFzIGZvdW5kIGluIFRTLFxuICAgICAgICAgICAgICAvLyBidXQgd2UgYXJlIG5vdCB1c2luZyB0aGlzIGZvciBNUDQgdHJhY2sgSURzLlxuICAgICAgICAgICAgICB2aWRlb1BpZCA9IHBhcnNlZFBJRHMudmlkZW9QaWQ7XG4gICAgICAgICAgICAgIGlmICh2aWRlb1BpZCA+IDApIHtcbiAgICAgICAgICAgICAgICB2aWRlb1RyYWNrLnBpZCA9IHZpZGVvUGlkO1xuICAgICAgICAgICAgICAgIHZpZGVvVHJhY2suc2VnbWVudENvZGVjID0gcGFyc2VkUElEcy5zZWdtZW50VmlkZW9Db2RlYztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhdWRpb1BpZCA9IHBhcnNlZFBJRHMuYXVkaW9QaWQ7XG4gICAgICAgICAgICAgIGlmIChhdWRpb1BpZCA+IDApIHtcbiAgICAgICAgICAgICAgICBhdWRpb1RyYWNrLnBpZCA9IGF1ZGlvUGlkO1xuICAgICAgICAgICAgICAgIGF1ZGlvVHJhY2suc2VnbWVudENvZGVjID0gcGFyc2VkUElEcy5zZWdtZW50QXVkaW9Db2RlYztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZDNQaWQgPSBwYXJzZWRQSURzLmlkM1BpZDtcbiAgICAgICAgICAgICAgaWYgKGlkM1BpZCA+IDApIHtcbiAgICAgICAgICAgICAgICBpZDNUcmFjay5waWQgPSBpZDNQaWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHVua25vd25QSUQgIT09IG51bGwgJiYgIXBtdFBhcnNlZCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKGBNUEVHLVRTIFBNVCBmb3VuZCBhdCAke3N0YXJ0fSBhZnRlciB1bmtub3duIFBJRCAnJHt1bmtub3duUElEfScuIEJhY2t0cmFja2luZyB0byBzeW5jIGJ5dGUgQCR7c3luY09mZnNldH0gdG8gcGFyc2UgYWxsIFRTIHBhY2tldHMuYCk7XG4gICAgICAgICAgICAgICAgdW5rbm93blBJRCA9IG51bGw7XG4gICAgICAgICAgICAgICAgLy8gd2Ugc2V0IGl0IHRvIC0xODgsIHRoZSArPSAxODggaW4gdGhlIGZvciBsb29wIHdpbGwgcmVzZXQgc3RhcnQgdG8gMFxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gc3luY09mZnNldCAtIDE4ODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwbXRQYXJzZWQgPSB0aGlzLnBtdFBhcnNlZCA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgMHgxMTpcbiAgICAgICAgICBjYXNlIDB4MWZmZjpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB1bmtub3duUElEID0gcGlkO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRzUGFja2V0RXJyb3JzKys7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0c1BhY2tldEVycm9ycyA+IDApIHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBGb3VuZCAke3RzUGFja2V0RXJyb3JzfSBUUyBwYWNrZXQvcyB0aGF0IGRvIG5vdCBzdGFydCB3aXRoIDB4NDdgKTtcbiAgICAgIHRoaXMub2JzZXJ2ZXIuZW1pdChFdmVudHMuRVJST1IsIEV2ZW50cy5FUlJPUiwge1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLFxuICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgIGVycm9yLFxuICAgICAgICByZWFzb246IGVycm9yLm1lc3NhZ2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICB2aWRlb1RyYWNrLnBlc0RhdGEgPSB2aWRlb0RhdGE7XG4gICAgYXVkaW9UcmFjay5wZXNEYXRhID0gYXVkaW9EYXRhO1xuICAgIGlkM1RyYWNrLnBlc0RhdGEgPSBpZDNEYXRhO1xuICAgIGNvbnN0IGRlbXV4UmVzdWx0ID0ge1xuICAgICAgYXVkaW9UcmFjayxcbiAgICAgIHZpZGVvVHJhY2ssXG4gICAgICBpZDNUcmFjayxcbiAgICAgIHRleHRUcmFja1xuICAgIH07XG4gICAgaWYgKGZsdXNoKSB7XG4gICAgICB0aGlzLmV4dHJhY3RSZW1haW5pbmdTYW1wbGVzKGRlbXV4UmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlbXV4UmVzdWx0O1xuICB9XG4gIGZsdXNoKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlbWFpbmRlckRhdGFcbiAgICB9ID0gdGhpcztcbiAgICB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICAgIGxldCByZXN1bHQ7XG4gICAgaWYgKHJlbWFpbmRlckRhdGEpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMuZGVtdXgocmVtYWluZGVyRGF0YSwgLTEsIGZhbHNlLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICB2aWRlb1RyYWNrOiB0aGlzLl92aWRlb1RyYWNrLFxuICAgICAgICBhdWRpb1RyYWNrOiB0aGlzLl9hdWRpb1RyYWNrLFxuICAgICAgICBpZDNUcmFjazogdGhpcy5faWQzVHJhY2ssXG4gICAgICAgIHRleHRUcmFjazogdGhpcy5fdHh0VHJhY2tcbiAgICAgIH07XG4gICAgfVxuICAgIHRoaXMuZXh0cmFjdFJlbWFpbmluZ1NhbXBsZXMocmVzdWx0KTtcbiAgICBpZiAodGhpcy5zYW1wbGVBZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlY3J5cHQocmVzdWx0LCB0aGlzLnNhbXBsZUFlcyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZXh0cmFjdFJlbWFpbmluZ1NhbXBsZXMoZGVtdXhSZXN1bHQpIHtcbiAgICBjb25zdCB7XG4gICAgICBhdWRpb1RyYWNrLFxuICAgICAgdmlkZW9UcmFjayxcbiAgICAgIGlkM1RyYWNrLFxuICAgICAgdGV4dFRyYWNrXG4gICAgfSA9IGRlbXV4UmVzdWx0O1xuICAgIGNvbnN0IHZpZGVvRGF0YSA9IHZpZGVvVHJhY2sucGVzRGF0YTtcbiAgICBjb25zdCBhdWRpb0RhdGEgPSBhdWRpb1RyYWNrLnBlc0RhdGE7XG4gICAgY29uc3QgaWQzRGF0YSA9IGlkM1RyYWNrLnBlc0RhdGE7XG4gICAgLy8gdHJ5IHRvIHBhcnNlIGxhc3QgUEVTIHBhY2tldHNcbiAgICBsZXQgcGVzO1xuICAgIGlmICh2aWRlb0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKHZpZGVvRGF0YSkpKSB7XG4gICAgICB0aGlzLnZpZGVvUGFyc2VyLnBhcnNlQVZDUEVTKHZpZGVvVHJhY2ssIHRleHRUcmFjaywgcGVzLCB0cnVlLCB0aGlzLl9kdXJhdGlvbik7XG4gICAgICB2aWRlb1RyYWNrLnBlc0RhdGEgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlaXRoZXIgYXZjRGF0YSBudWxsIG9yIFBFUyB0cnVuY2F0ZWQsIGtlZXAgaXQgZm9yIG5leHQgZnJhZyBwYXJzaW5nXG4gICAgICB2aWRlb1RyYWNrLnBlc0RhdGEgPSB2aWRlb0RhdGE7XG4gICAgfVxuICAgIGlmIChhdWRpb0RhdGEgJiYgKHBlcyA9IHBhcnNlUEVTKGF1ZGlvRGF0YSkpKSB7XG4gICAgICBzd2l0Y2ggKGF1ZGlvVHJhY2suc2VnbWVudENvZGVjKSB7XG4gICAgICAgIGNhc2UgJ2FhYyc6XG4gICAgICAgICAgdGhpcy5wYXJzZUFBQ1BFUyhhdWRpb1RyYWNrLCBwZXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtcDMnOlxuICAgICAgICAgIHRoaXMucGFyc2VNUEVHUEVTKGF1ZGlvVHJhY2ssIHBlcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2FjMyc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5wYXJzZUFDM1BFUyhhdWRpb1RyYWNrLCBwZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGF1ZGlvVHJhY2sucGVzRGF0YSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChhdWRpb0RhdGEgIT0gbnVsbCAmJiBhdWRpb0RhdGEuc2l6ZSkge1xuICAgICAgICBsb2dnZXIubG9nKCdsYXN0IEFBQyBQRVMgcGFja2V0IHRydW5jYXRlZCxtaWdodCBvdmVybGFwIGJldHdlZW4gZnJhZ21lbnRzJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGVpdGhlciBhdWRpb0RhdGEgbnVsbCBvciBQRVMgdHJ1bmNhdGVkLCBrZWVwIGl0IGZvciBuZXh0IGZyYWcgcGFyc2luZ1xuICAgICAgYXVkaW9UcmFjay5wZXNEYXRhID0gYXVkaW9EYXRhO1xuICAgIH1cbiAgICBpZiAoaWQzRGF0YSAmJiAocGVzID0gcGFyc2VQRVMoaWQzRGF0YSkpKSB7XG4gICAgICB0aGlzLnBhcnNlSUQzUEVTKGlkM1RyYWNrLCBwZXMpO1xuICAgICAgaWQzVHJhY2sucGVzRGF0YSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVpdGhlciBpZDNEYXRhIG51bGwgb3IgUEVTIHRydW5jYXRlZCwga2VlcCBpdCBmb3IgbmV4dCBmcmFnIHBhcnNpbmdcbiAgICAgIGlkM1RyYWNrLnBlc0RhdGEgPSBpZDNEYXRhO1xuICAgIH1cbiAgfVxuICBkZW11eFNhbXBsZUFlcyhkYXRhLCBrZXlEYXRhLCB0aW1lT2Zmc2V0KSB7XG4gICAgY29uc3QgZGVtdXhSZXN1bHQgPSB0aGlzLmRlbXV4KGRhdGEsIHRpbWVPZmZzZXQsIHRydWUsICF0aGlzLmNvbmZpZy5wcm9ncmVzc2l2ZSk7XG4gICAgY29uc3Qgc2FtcGxlQWVzID0gdGhpcy5zYW1wbGVBZXMgPSBuZXcgU2FtcGxlQWVzRGVjcnlwdGVyKHRoaXMub2JzZXJ2ZXIsIHRoaXMuY29uZmlnLCBrZXlEYXRhKTtcbiAgICByZXR1cm4gdGhpcy5kZWNyeXB0KGRlbXV4UmVzdWx0LCBzYW1wbGVBZXMpO1xuICB9XG4gIGRlY3J5cHQoZGVtdXhSZXN1bHQsIHNhbXBsZUFlcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYXVkaW9UcmFjayxcbiAgICAgICAgdmlkZW9UcmFja1xuICAgICAgfSA9IGRlbXV4UmVzdWx0O1xuICAgICAgaWYgKGF1ZGlvVHJhY2suc2FtcGxlcyAmJiBhdWRpb1RyYWNrLnNlZ21lbnRDb2RlYyA9PT0gJ2FhYycpIHtcbiAgICAgICAgc2FtcGxlQWVzLmRlY3J5cHRBYWNTYW1wbGVzKGF1ZGlvVHJhY2suc2FtcGxlcywgMCwgKCkgPT4ge1xuICAgICAgICAgIGlmICh2aWRlb1RyYWNrLnNhbXBsZXMpIHtcbiAgICAgICAgICAgIHNhbXBsZUFlcy5kZWNyeXB0QXZjU2FtcGxlcyh2aWRlb1RyYWNrLnNhbXBsZXMsIDAsIDAsICgpID0+IHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShkZW11eFJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZShkZW11eFJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAodmlkZW9UcmFjay5zYW1wbGVzKSB7XG4gICAgICAgIHNhbXBsZUFlcy5kZWNyeXB0QXZjU2FtcGxlcyh2aWRlb1RyYWNrLnNhbXBsZXMsIDAsIDAsICgpID0+IHtcbiAgICAgICAgICByZXNvbHZlKGRlbXV4UmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9kdXJhdGlvbiA9IDA7XG4gIH1cbiAgcGFyc2VBQUNQRVModHJhY2ssIHBlcykge1xuICAgIGxldCBzdGFydE9mZnNldCA9IDA7XG4gICAgY29uc3QgYWFjT3ZlckZsb3cgPSB0aGlzLmFhY092ZXJGbG93O1xuICAgIGxldCBkYXRhID0gcGVzLmRhdGE7XG4gICAgaWYgKGFhY092ZXJGbG93KSB7XG4gICAgICB0aGlzLmFhY092ZXJGbG93ID0gbnVsbDtcbiAgICAgIGNvbnN0IGZyYW1lTWlzc2luZ0J5dGVzID0gYWFjT3ZlckZsb3cubWlzc2luZztcbiAgICAgIGNvbnN0IHNhbXBsZUxlbmd0aCA9IGFhY092ZXJGbG93LnNhbXBsZS51bml0LmJ5dGVMZW5ndGg7XG4gICAgICAvLyBsb2dnZXIubG9nKGBBQUM6IGFwcGVuZCBvdmVyZmxvd2luZyAke3NhbXBsZUxlbmd0aH0gYnl0ZXMgdG8gYmVnaW5uaW5nIG9mIG5ldyBQRVNgKTtcbiAgICAgIGlmIChmcmFtZU1pc3NpbmdCeXRlcyA9PT0gLTEpIHtcbiAgICAgICAgZGF0YSA9IGFwcGVuZFVpbnQ4QXJyYXkoYWFjT3ZlckZsb3cuc2FtcGxlLnVuaXQsIGRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZnJhbWVPdmVyZmxvd0J5dGVzID0gc2FtcGxlTGVuZ3RoIC0gZnJhbWVNaXNzaW5nQnl0ZXM7XG4gICAgICAgIGFhY092ZXJGbG93LnNhbXBsZS51bml0LnNldChkYXRhLnN1YmFycmF5KDAsIGZyYW1lTWlzc2luZ0J5dGVzKSwgZnJhbWVPdmVyZmxvd0J5dGVzKTtcbiAgICAgICAgdHJhY2suc2FtcGxlcy5wdXNoKGFhY092ZXJGbG93LnNhbXBsZSk7XG4gICAgICAgIHN0YXJ0T2Zmc2V0ID0gYWFjT3ZlckZsb3cubWlzc2luZztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gbG9vayBmb3IgQURUUyBoZWFkZXIgKDB4RkZGeClcbiAgICBsZXQgb2Zmc2V0O1xuICAgIGxldCBsZW47XG4gICAgZm9yIChvZmZzZXQgPSBzdGFydE9mZnNldCwgbGVuID0gZGF0YS5sZW5ndGg7IG9mZnNldCA8IGxlbiAtIDE7IG9mZnNldCsrKSB7XG4gICAgICBpZiAoaXNIZWFkZXIkMShkYXRhLCBvZmZzZXQpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBpZiBBRFRTIGhlYWRlciBkb2VzIG5vdCBzdGFydCBzdHJhaWdodCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIFBFUyBwYXlsb2FkLCByYWlzZSBhbiBlcnJvclxuICAgIGlmIChvZmZzZXQgIT09IHN0YXJ0T2Zmc2V0KSB7XG4gICAgICBsZXQgcmVhc29uO1xuICAgICAgY29uc3QgcmVjb3ZlcmFibGUgPSBvZmZzZXQgPCBsZW4gLSAxO1xuICAgICAgaWYgKHJlY292ZXJhYmxlKSB7XG4gICAgICAgIHJlYXNvbiA9IGBBQUMgUEVTIGRpZCBub3Qgc3RhcnQgd2l0aCBBRFRTIGhlYWRlcixvZmZzZXQ6JHtvZmZzZXR9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlYXNvbiA9ICdObyBBRFRTIGhlYWRlciBmb3VuZCBpbiBBQUMgUEVTJztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKHJlYXNvbik7XG4gICAgICBsb2dnZXIud2FybihgcGFyc2luZyBlcnJvcjogJHtyZWFzb259YCk7XG4gICAgICB0aGlzLm9ic2VydmVyLmVtaXQoRXZlbnRzLkVSUk9SLCBFdmVudHMuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUixcbiAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICBsZXZlbFJldHJ5OiByZWNvdmVyYWJsZSxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIHJlYXNvblxuICAgICAgfSk7XG4gICAgICBpZiAoIXJlY292ZXJhYmxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaW5pdFRyYWNrQ29uZmlnKHRyYWNrLCB0aGlzLm9ic2VydmVyLCBkYXRhLCBvZmZzZXQsIHRoaXMuYXVkaW9Db2RlYyk7XG4gICAgbGV0IHB0cztcbiAgICBpZiAocGVzLnB0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwdHMgPSBwZXMucHRzO1xuICAgIH0gZWxzZSBpZiAoYWFjT3ZlckZsb3cpIHtcbiAgICAgIC8vIGlmIGxhc3QgQUFDIGZyYW1lIGlzIG92ZXJmbG93aW5nLCB3ZSBzaG91bGQgZW5zdXJlIHRpbWVzdGFtcHMgYXJlIGNvbnRpZ3VvdXM6XG4gICAgICAvLyBmaXJzdCBzYW1wbGUgUFRTIHNob3VsZCBiZSBlcXVhbCB0byBsYXN0IHNhbXBsZSBQVFMgKyBmcmFtZUR1cmF0aW9uXG4gICAgICBjb25zdCBmcmFtZUR1cmF0aW9uID0gZ2V0RnJhbWVEdXJhdGlvbih0cmFjay5zYW1wbGVyYXRlKTtcbiAgICAgIHB0cyA9IGFhY092ZXJGbG93LnNhbXBsZS5wdHMgKyBmcmFtZUR1cmF0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIud2FybignW3RzZGVtdXhlcl06IEFBQyBQRVMgdW5rbm93biBQVFMnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBzY2FuIGZvciBhYWMgc2FtcGxlc1xuICAgIGxldCBmcmFtZUluZGV4ID0gMDtcbiAgICBsZXQgZnJhbWU7XG4gICAgd2hpbGUgKG9mZnNldCA8IGxlbikge1xuICAgICAgZnJhbWUgPSBhcHBlbmRGcmFtZSQyKHRyYWNrLCBkYXRhLCBvZmZzZXQsIHB0cywgZnJhbWVJbmRleCk7XG4gICAgICBvZmZzZXQgKz0gZnJhbWUubGVuZ3RoO1xuICAgICAgaWYgKCFmcmFtZS5taXNzaW5nKSB7XG4gICAgICAgIGZyYW1lSW5kZXgrKztcbiAgICAgICAgZm9yICg7IG9mZnNldCA8IGxlbiAtIDE7IG9mZnNldCsrKSB7XG4gICAgICAgICAgaWYgKGlzSGVhZGVyJDEoZGF0YSwgb2Zmc2V0KSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFhY092ZXJGbG93ID0gZnJhbWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwYXJzZU1QRUdQRVModHJhY2ssIHBlcykge1xuICAgIGNvbnN0IGRhdGEgPSBwZXMuZGF0YTtcbiAgICBjb25zdCBsZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICBsZXQgZnJhbWVJbmRleCA9IDA7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgY29uc3QgcHRzID0gcGVzLnB0cztcbiAgICBpZiAocHRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGxvZ2dlci53YXJuKCdbdHNkZW11eGVyXTogTVBFRyBQRVMgdW5rbm93biBQVFMnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd2hpbGUgKG9mZnNldCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGlzSGVhZGVyKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgY29uc3QgZnJhbWUgPSBhcHBlbmRGcmFtZSQxKHRyYWNrLCBkYXRhLCBvZmZzZXQsIHB0cywgZnJhbWVJbmRleCk7XG4gICAgICAgIGlmIChmcmFtZSkge1xuICAgICAgICAgIG9mZnNldCArPSBmcmFtZS5sZW5ndGg7XG4gICAgICAgICAgZnJhbWVJbmRleCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ1VuYWJsZSB0byBwYXJzZSBNcGVnIGF1ZGlvIGZyYW1lJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vdGhpbmcgZm91bmQsIGtlZXAgbG9va2luZ1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcGFyc2VBQzNQRVModHJhY2ssIHBlcykge1xuICAgIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBwZXMuZGF0YTtcbiAgICAgIGNvbnN0IHB0cyA9IHBlcy5wdHM7XG4gICAgICBpZiAocHRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oJ1t0c2RlbXV4ZXJdOiBBQzMgUEVTIHVua25vd24gUFRTJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgbGV0IGZyYW1lSW5kZXggPSAwO1xuICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICBsZXQgcGFyc2VkO1xuICAgICAgd2hpbGUgKG9mZnNldCA8IGxlbmd0aCAmJiAocGFyc2VkID0gYXBwZW5kRnJhbWUodHJhY2ssIGRhdGEsIG9mZnNldCwgcHRzLCBmcmFtZUluZGV4KyspKSA+IDApIHtcbiAgICAgICAgb2Zmc2V0ICs9IHBhcnNlZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcGFyc2VJRDNQRVMoaWQzVHJhY2ssIHBlcykge1xuICAgIGlmIChwZXMucHRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGxvZ2dlci53YXJuKCdbdHNkZW11eGVyXTogSUQzIFBFUyB1bmtub3duIFBUUycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpZDNTYW1wbGUgPSBfZXh0ZW5kcyh7fSwgcGVzLCB7XG4gICAgICB0eXBlOiB0aGlzLl92aWRlb1RyYWNrID8gTWV0YWRhdGFTY2hlbWEuZW1zZyA6IE1ldGFkYXRhU2NoZW1hLmF1ZGlvSWQzLFxuICAgICAgZHVyYXRpb246IE51bWJlci5QT1NJVElWRV9JTkZJTklUWVxuICAgIH0pO1xuICAgIGlkM1RyYWNrLnNhbXBsZXMucHVzaChpZDNTYW1wbGUpO1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZVBJRChkYXRhLCBvZmZzZXQpIHtcbiAgLy8gcGlkIGlzIGEgMTMtYml0IGZpZWxkIHN0YXJ0aW5nIGF0IHRoZSBsYXN0IGJpdCBvZiBUU1sxXVxuICByZXR1cm4gKChkYXRhW29mZnNldCArIDFdICYgMHgxZikgPDwgOCkgKyBkYXRhW29mZnNldCArIDJdO1xufVxuZnVuY3Rpb24gcGFyc2VQQVQoZGF0YSwgb2Zmc2V0KSB7XG4gIC8vIHNraXAgdGhlIFBTSSBoZWFkZXIgYW5kIHBhcnNlIHRoZSBmaXJzdCBQTVQgZW50cnlcbiAgcmV0dXJuIChkYXRhW29mZnNldCArIDEwXSAmIDB4MWYpIDw8IDggfCBkYXRhW29mZnNldCArIDExXTtcbn1cbmZ1bmN0aW9uIHBhcnNlUE1UKGRhdGEsIG9mZnNldCwgdHlwZVN1cHBvcnRlZCwgaXNTYW1wbGVBZXMpIHtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIGF1ZGlvUGlkOiAtMSxcbiAgICB2aWRlb1BpZDogLTEsXG4gICAgaWQzUGlkOiAtMSxcbiAgICBzZWdtZW50VmlkZW9Db2RlYzogJ2F2YycsXG4gICAgc2VnbWVudEF1ZGlvQ29kZWM6ICdhYWMnXG4gIH07XG4gIGNvbnN0IHNlY3Rpb25MZW5ndGggPSAoZGF0YVtvZmZzZXQgKyAxXSAmIDB4MGYpIDw8IDggfCBkYXRhW29mZnNldCArIDJdO1xuICBjb25zdCB0YWJsZUVuZCA9IG9mZnNldCArIDMgKyBzZWN0aW9uTGVuZ3RoIC0gNDtcbiAgLy8gdG8gZGV0ZXJtaW5lIHdoZXJlIHRoZSB0YWJsZSBpcywgd2UgaGF2ZSB0byBmaWd1cmUgb3V0IGhvd1xuICAvLyBsb25nIHRoZSBwcm9ncmFtIGluZm8gZGVzY3JpcHRvcnMgYXJlXG4gIGNvbnN0IHByb2dyYW1JbmZvTGVuZ3RoID0gKGRhdGFbb2Zmc2V0ICsgMTBdICYgMHgwZikgPDwgOCB8IGRhdGFbb2Zmc2V0ICsgMTFdO1xuICAvLyBhZHZhbmNlIHRoZSBvZmZzZXQgdG8gdGhlIGZpcnN0IGVudHJ5IGluIHRoZSBtYXBwaW5nIHRhYmxlXG4gIG9mZnNldCArPSAxMiArIHByb2dyYW1JbmZvTGVuZ3RoO1xuICB3aGlsZSAob2Zmc2V0IDwgdGFibGVFbmQpIHtcbiAgICBjb25zdCBwaWQgPSBwYXJzZVBJRChkYXRhLCBvZmZzZXQpO1xuICAgIGNvbnN0IGVzSW5mb0xlbmd0aCA9IChkYXRhW29mZnNldCArIDNdICYgMHgwZikgPDwgOCB8IGRhdGFbb2Zmc2V0ICsgNF07XG4gICAgc3dpdGNoIChkYXRhW29mZnNldF0pIHtcbiAgICAgIGNhc2UgMHhjZjpcbiAgICAgICAgLy8gU0FNUExFLUFFUyBBQUNcbiAgICAgICAgaWYgKCFpc1NhbXBsZUFlcykge1xuICAgICAgICAgIGxvZ0VuY3J5cHRlZFNhbXBsZXNGb3VuZEluVW5lbmNyeXB0ZWRTdHJlYW0oJ0FEVFMgQUFDJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgMHgwZjpcbiAgICAgICAgLy8gSVNPL0lFQyAxMzgxOC03IEFEVFMgQUFDIChNUEVHLTIgbG93ZXIgYml0LXJhdGUgYXVkaW8pXG4gICAgICAgIC8vIGxvZ2dlci5sb2coJ0FBQyBQSUQ6JyAgKyBwaWQpO1xuICAgICAgICBpZiAocmVzdWx0LmF1ZGlvUGlkID09PSAtMSkge1xuICAgICAgICAgIHJlc3VsdC5hdWRpb1BpZCA9IHBpZDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgLy8gUGFja2V0aXplZCBtZXRhZGF0YSAoSUQzKVxuICAgICAgY2FzZSAweDE1OlxuICAgICAgICAvLyBsb2dnZXIubG9nKCdJRDMgUElEOicgICsgcGlkKTtcbiAgICAgICAgaWYgKHJlc3VsdC5pZDNQaWQgPT09IC0xKSB7XG4gICAgICAgICAgcmVzdWx0LmlkM1BpZCA9IHBpZDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMHhkYjpcbiAgICAgICAgLy8gU0FNUExFLUFFUyBBVkNcbiAgICAgICAgaWYgKCFpc1NhbXBsZUFlcykge1xuICAgICAgICAgIGxvZ0VuY3J5cHRlZFNhbXBsZXNGb3VuZEluVW5lbmNyeXB0ZWRTdHJlYW0oJ0guMjY0Jyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgMHgxYjpcbiAgICAgICAgLy8gSVRVLVQgUmVjLiBILjI2NCBhbmQgSVNPL0lFQyAxNDQ5Ni0xMCAobG93ZXIgYml0LXJhdGUgdmlkZW8pXG4gICAgICAgIC8vIGxvZ2dlci5sb2coJ0FWQyBQSUQ6JyAgKyBwaWQpO1xuICAgICAgICBpZiAocmVzdWx0LnZpZGVvUGlkID09PSAtMSkge1xuICAgICAgICAgIHJlc3VsdC52aWRlb1BpZCA9IHBpZDtcbiAgICAgICAgICByZXN1bHQuc2VnbWVudFZpZGVvQ29kZWMgPSAnYXZjJztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgLy8gSVNPL0lFQyAxMTE3Mi0zIChNUEVHLTEgYXVkaW8pXG4gICAgICAvLyBvciBJU08vSUVDIDEzODE4LTMgKE1QRUctMiBoYWx2ZWQgc2FtcGxlIHJhdGUgYXVkaW8pXG4gICAgICBjYXNlIDB4MDM6XG4gICAgICBjYXNlIDB4MDQ6XG4gICAgICAgIC8vIGxvZ2dlci5sb2coJ01QRUcgUElEOicgICsgcGlkKTtcbiAgICAgICAgaWYgKCF0eXBlU3VwcG9ydGVkLm1wZWcgJiYgIXR5cGVTdXBwb3J0ZWQubXAzKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZygnTVBFRyBhdWRpbyBmb3VuZCwgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQuYXVkaW9QaWQgPT09IC0xKSB7XG4gICAgICAgICAgcmVzdWx0LmF1ZGlvUGlkID0gcGlkO1xuICAgICAgICAgIHJlc3VsdC5zZWdtZW50QXVkaW9Db2RlYyA9ICdtcDMnO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAweGMxOlxuICAgICAgICAvLyBTQU1QTEUtQUVTIEFDM1xuICAgICAgICBpZiAoIWlzU2FtcGxlQWVzKSB7XG4gICAgICAgICAgbG9nRW5jcnlwdGVkU2FtcGxlc0ZvdW5kSW5VbmVuY3J5cHRlZFN0cmVhbSgnQUMtMycpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIDB4ODE6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoIXR5cGVTdXBwb3J0ZWQuYWMzKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKCdBQy0zIGF1ZGlvIGZvdW5kLCBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LmF1ZGlvUGlkID09PSAtMSkge1xuICAgICAgICAgICAgcmVzdWx0LmF1ZGlvUGlkID0gcGlkO1xuICAgICAgICAgICAgcmVzdWx0LnNlZ21lbnRBdWRpb0NvZGVjID0gJ2FjMyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAweDA2OlxuICAgICAgICAvLyBzdHJlYW1fdHlwZSA2IGNhbiBtZWFuIGEgbG90IG9mIGRpZmZlcmVudCB0aGluZ3MgaW4gY2FzZSBvZiBEVkIuXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gbG9vayBhdCB0aGUgZGVzY3JpcHRvcnMuIFJpZ2h0IG5vdywgd2UncmUgb25seSBpbnRlcmVzdGVkXG4gICAgICAgIC8vIGluIEFDLTMgYXVkaW8sIHNvIHdlIGRvIHRoZSBkZXNjcmlwdG9yIHBhcnNpbmcgb25seSB3aGVuIHdlIGRvbid0IGhhdmVcbiAgICAgICAgLy8gYW4gYXVkaW8gUElEIHlldC5cbiAgICAgICAgaWYgKHJlc3VsdC5hdWRpb1BpZCA9PT0gLTEgJiYgZXNJbmZvTGVuZ3RoID4gMCkge1xuICAgICAgICAgIGxldCBwYXJzZVBvcyA9IG9mZnNldCArIDU7XG4gICAgICAgICAgbGV0IHJlbWFpbmluZyA9IGVzSW5mb0xlbmd0aDtcbiAgICAgICAgICB3aGlsZSAocmVtYWluaW5nID4gMikge1xuICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRvcklkID0gZGF0YVtwYXJzZVBvc107XG4gICAgICAgICAgICBzd2l0Y2ggKGRlc2NyaXB0b3JJZCkge1xuICAgICAgICAgICAgICBjYXNlIDB4NmE6XG4gICAgICAgICAgICAgICAgLy8gRFZCIERlc2NyaXB0b3IgZm9yIEFDLTNcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZVN1cHBvcnRlZC5hYzMgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZygnQUMtMyBhdWRpbyBmb3VuZCwgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXIgZm9yIG5vdycpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmF1ZGlvUGlkID0gcGlkO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2VnbWVudEF1ZGlvQ29kZWMgPSAnYWMzJztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkZXNjcmlwdG9yTGVuID0gZGF0YVtwYXJzZVBvcyArIDFdICsgMjtcbiAgICAgICAgICAgIHBhcnNlUG9zICs9IGRlc2NyaXB0b3JMZW47XG4gICAgICAgICAgICByZW1haW5pbmcgLT0gZGVzY3JpcHRvckxlbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDB4YzI6IC8vIFNBTVBMRS1BRVMgRUMzXG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIDB4ODc6XG4gICAgICAgIGxvZ2dlci53YXJuKCdVbnN1cHBvcnRlZCBFQy0zIGluIE0yVFMgZm91bmQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDB4MjQ6XG4gICAgICAgIGxvZ2dlci53YXJuKCdVbnN1cHBvcnRlZCBIRVZDIGluIE0yVFMgZm91bmQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIG1vdmUgdG8gdGhlIG5leHQgdGFibGUgZW50cnlcbiAgICAvLyBza2lwIHBhc3QgdGhlIGVsZW1lbnRhcnkgc3RyZWFtIGRlc2NyaXB0b3JzLCBpZiBwcmVzZW50XG4gICAgb2Zmc2V0ICs9IGVzSW5mb0xlbmd0aCArIDU7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGxvZ0VuY3J5cHRlZFNhbXBsZXNGb3VuZEluVW5lbmNyeXB0ZWRTdHJlYW0odHlwZSkge1xuICBsb2dnZXIubG9nKGAke3R5cGV9IHdpdGggQUVTLTEyOC1DQkMgZW5jcnlwdGlvbiBmb3VuZCBpbiB1bmVuY3J5cHRlZCBzdHJlYW1gKTtcbn1cbmZ1bmN0aW9uIHBhcnNlUEVTKHN0cmVhbSkge1xuICBsZXQgaSA9IDA7XG4gIGxldCBmcmFnO1xuICBsZXQgcGVzTGVuO1xuICBsZXQgcGVzSGRyTGVuO1xuICBsZXQgcGVzUHRzO1xuICBsZXQgcGVzRHRzO1xuICBjb25zdCBkYXRhID0gc3RyZWFtLmRhdGE7XG4gIC8vIHNhZmV0eSBjaGVja1xuICBpZiAoIXN0cmVhbSB8fCBzdHJlYW0uc2l6ZSA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gd2UgbWlnaHQgbmVlZCB1cCB0byAxOSBieXRlcyB0byByZWFkIFBFUyBoZWFkZXJcbiAgLy8gaWYgZmlyc3QgY2h1bmsgb2YgZGF0YSBpcyBsZXNzIHRoYW4gMTkgYnl0ZXMsIGxldCdzIG1lcmdlIGl0IHdpdGggZm9sbG93aW5nIG9uZXMgdW50aWwgd2UgZ2V0IDE5IGJ5dGVzXG4gIC8vIHVzdWFsbHkgb25seSBvbmUgbWVyZ2UgaXMgbmVlZGVkIChhbmQgdGhpcyBpcyByYXJlIC4uLilcbiAgd2hpbGUgKGRhdGFbMF0ubGVuZ3RoIDwgMTkgJiYgZGF0YS5sZW5ndGggPiAxKSB7XG4gICAgZGF0YVswXSA9IGFwcGVuZFVpbnQ4QXJyYXkoZGF0YVswXSwgZGF0YVsxXSk7XG4gICAgZGF0YS5zcGxpY2UoMSwgMSk7XG4gIH1cbiAgLy8gcmV0cmlldmUgUFRTL0RUUyBmcm9tIGZpcnN0IGZyYWdtZW50XG4gIGZyYWcgPSBkYXRhWzBdO1xuICBjb25zdCBwZXNQcmVmaXggPSAoZnJhZ1swXSA8PCAxNikgKyAoZnJhZ1sxXSA8PCA4KSArIGZyYWdbMl07XG4gIGlmIChwZXNQcmVmaXggPT09IDEpIHtcbiAgICBwZXNMZW4gPSAoZnJhZ1s0XSA8PCA4KSArIGZyYWdbNV07XG4gICAgLy8gaWYgUEVTIHBhcnNlZCBsZW5ndGggaXMgbm90IHplcm8gYW5kIGdyZWF0ZXIgdGhhbiB0b3RhbCByZWNlaXZlZCBsZW5ndGgsIHN0b3AgcGFyc2luZy4gUEVTIG1pZ2h0IGJlIHRydW5jYXRlZFxuICAgIC8vIG1pbnVzIDYgOiBQRVMgaGVhZGVyIHNpemVcbiAgICBpZiAocGVzTGVuICYmIHBlc0xlbiA+IHN0cmVhbS5zaXplIC0gNikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHBlc0ZsYWdzID0gZnJhZ1s3XTtcbiAgICBpZiAocGVzRmxhZ3MgJiAweGMwKSB7XG4gICAgICAvKiBQRVMgaGVhZGVyIGRlc2NyaWJlZCBoZXJlIDogaHR0cDovL2R2ZC5zb3VyY2Vmb3JnZS5uZXQvZHZkaW5mby9wZXMtaGRyLmh0bWxcbiAgICAgICAgICBhcyBQVFMgLyBEVFMgaXMgMzMgYml0IHdlIGNhbm5vdCB1c2UgYml0d2lzZSBvcGVyYXRvciBpbiBKUyxcbiAgICAgICAgICBhcyBCaXR3aXNlIG9wZXJhdG9ycyB0cmVhdCB0aGVpciBvcGVyYW5kcyBhcyBhIHNlcXVlbmNlIG9mIDMyIGJpdHMgKi9cbiAgICAgIHBlc1B0cyA9IChmcmFnWzldICYgMHgwZSkgKiA1MzY4NzA5MTIgK1xuICAgICAgLy8gMSA8PCAyOVxuICAgICAgKGZyYWdbMTBdICYgMHhmZikgKiA0MTk0MzA0ICtcbiAgICAgIC8vIDEgPDwgMjJcbiAgICAgIChmcmFnWzExXSAmIDB4ZmUpICogMTYzODQgK1xuICAgICAgLy8gMSA8PCAxNFxuICAgICAgKGZyYWdbMTJdICYgMHhmZikgKiAxMjggK1xuICAgICAgLy8gMSA8PCA3XG4gICAgICAoZnJhZ1sxM10gJiAweGZlKSAvIDI7XG4gICAgICBpZiAocGVzRmxhZ3MgJiAweDQwKSB7XG4gICAgICAgIHBlc0R0cyA9IChmcmFnWzE0XSAmIDB4MGUpICogNTM2ODcwOTEyICtcbiAgICAgICAgLy8gMSA8PCAyOVxuICAgICAgICAoZnJhZ1sxNV0gJiAweGZmKSAqIDQxOTQzMDQgK1xuICAgICAgICAvLyAxIDw8IDIyXG4gICAgICAgIChmcmFnWzE2XSAmIDB4ZmUpICogMTYzODQgK1xuICAgICAgICAvLyAxIDw8IDE0XG4gICAgICAgIChmcmFnWzE3XSAmIDB4ZmYpICogMTI4ICtcbiAgICAgICAgLy8gMSA8PCA3XG4gICAgICAgIChmcmFnWzE4XSAmIDB4ZmUpIC8gMjtcbiAgICAgICAgaWYgKHBlc1B0cyAtIHBlc0R0cyA+IDYwICogOTAwMDApIHtcbiAgICAgICAgICBsb2dnZXIud2FybihgJHtNYXRoLnJvdW5kKChwZXNQdHMgLSBwZXNEdHMpIC8gOTAwMDApfXMgZGVsdGEgYmV0d2VlbiBQVFMgYW5kIERUUywgYWxpZ24gdGhlbWApO1xuICAgICAgICAgIHBlc1B0cyA9IHBlc0R0cztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVzRHRzID0gcGVzUHRzO1xuICAgICAgfVxuICAgIH1cbiAgICBwZXNIZHJMZW4gPSBmcmFnWzhdO1xuICAgIC8vIDkgYnl0ZXMgOiA2IGJ5dGVzIGZvciBQRVMgaGVhZGVyICsgMyBieXRlcyBmb3IgUEVTIGV4dGVuc2lvblxuICAgIGxldCBwYXlsb2FkU3RhcnRPZmZzZXQgPSBwZXNIZHJMZW4gKyA5O1xuICAgIGlmIChzdHJlYW0uc2l6ZSA8PSBwYXlsb2FkU3RhcnRPZmZzZXQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzdHJlYW0uc2l6ZSAtPSBwYXlsb2FkU3RhcnRPZmZzZXQ7XG4gICAgLy8gcmVhc3NlbWJsZSBQRVMgcGFja2V0XG4gICAgY29uc3QgcGVzRGF0YSA9IG5ldyBVaW50OEFycmF5KHN0cmVhbS5zaXplKTtcbiAgICBmb3IgKGxldCBqID0gMCwgZGF0YUxlbiA9IGRhdGEubGVuZ3RoOyBqIDwgZGF0YUxlbjsgaisrKSB7XG4gICAgICBmcmFnID0gZGF0YVtqXTtcbiAgICAgIGxldCBsZW4gPSBmcmFnLmJ5dGVMZW5ndGg7XG4gICAgICBpZiAocGF5bG9hZFN0YXJ0T2Zmc2V0KSB7XG4gICAgICAgIGlmIChwYXlsb2FkU3RhcnRPZmZzZXQgPiBsZW4pIHtcbiAgICAgICAgICAvLyB0cmltIGZ1bGwgZnJhZyBpZiBQRVMgaGVhZGVyIGJpZ2dlciB0aGFuIGZyYWdcbiAgICAgICAgICBwYXlsb2FkU3RhcnRPZmZzZXQgLT0gbGVuO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHRyaW0gcGFydGlhbCBmcmFnIGlmIFBFUyBoZWFkZXIgc21hbGxlciB0aGFuIGZyYWdcbiAgICAgICAgICBmcmFnID0gZnJhZy5zdWJhcnJheShwYXlsb2FkU3RhcnRPZmZzZXQpO1xuICAgICAgICAgIGxlbiAtPSBwYXlsb2FkU3RhcnRPZmZzZXQ7XG4gICAgICAgICAgcGF5bG9hZFN0YXJ0T2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGVzRGF0YS5zZXQoZnJhZywgaSk7XG4gICAgICBpICs9IGxlbjtcbiAgICB9XG4gICAgaWYgKHBlc0xlbikge1xuICAgICAgLy8gcGF5bG9hZCBzaXplIDogcmVtb3ZlIFBFUyBoZWFkZXIgKyBQRVMgZXh0ZW5zaW9uXG4gICAgICBwZXNMZW4gLT0gcGVzSGRyTGVuICsgMztcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IHBlc0RhdGEsXG4gICAgICBwdHM6IHBlc1B0cyxcbiAgICAgIGR0czogcGVzRHRzLFxuICAgICAgbGVuOiBwZXNMZW5cbiAgICB9O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIE1QMyBkZW11eGVyXG4gKi9cbmNsYXNzIE1QM0RlbXV4ZXIgZXh0ZW5kcyBCYXNlQXVkaW9EZW11eGVyIHtcbiAgcmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudCwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdHJhY2tEdXJhdGlvbikge1xuICAgIHN1cGVyLnJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnQsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRyYWNrRHVyYXRpb24pO1xuICAgIHRoaXMuX2F1ZGlvVHJhY2sgPSB7XG4gICAgICBjb250YWluZXI6ICdhdWRpby9tcGVnJyxcbiAgICAgIHR5cGU6ICdhdWRpbycsXG4gICAgICBpZDogMixcbiAgICAgIHBpZDogLTEsXG4gICAgICBzZXF1ZW5jZU51bWJlcjogMCxcbiAgICAgIHNlZ21lbnRDb2RlYzogJ21wMycsXG4gICAgICBzYW1wbGVzOiBbXSxcbiAgICAgIG1hbmlmZXN0Q29kZWM6IGF1ZGlvQ29kZWMsXG4gICAgICBkdXJhdGlvbjogdHJhY2tEdXJhdGlvbixcbiAgICAgIGlucHV0VGltZVNjYWxlOiA5MDAwMCxcbiAgICAgIGRyb3BwZWQ6IDBcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBwcm9iZShkYXRhKSB7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgaWYgZGF0YSBjb250YWlucyBJRDMgdGltZXN0YW1wIGFuZCBNUEVHIHN5bmMgd29yZFxuICAgIC8vIExvb2sgZm9yIE1QRUcgaGVhZGVyIHwgMTExMSAxMTExIHwgMTExWCBYWVpYIHwgd2hlcmUgWCBjYW4gYmUgZWl0aGVyIDAgb3IgMSBhbmQgWSBvciBaIHNob3VsZCBiZSAxXG4gICAgLy8gTGF5ZXIgYml0cyAocG9zaXRpb24gMTQgYW5kIDE1KSBpbiBoZWFkZXIgc2hvdWxkIGJlIGFsd2F5cyBkaWZmZXJlbnQgZnJvbSAwIChMYXllciBJIG9yIExheWVyIElJIG9yIExheWVyIElJSSlcbiAgICAvLyBNb3JlIGluZm8gaHR0cDovL3d3dy5tcDMtdGVjaC5vcmcvcHJvZ3JhbW1lci9mcmFtZV9oZWFkZXIuaHRtbFxuICAgIGNvbnN0IGlkM0RhdGEgPSBnZXRJRDNEYXRhKGRhdGEsIDApO1xuICAgIGxldCBvZmZzZXQgPSAoaWQzRGF0YSA9PSBudWxsID8gdm9pZCAwIDogaWQzRGF0YS5sZW5ndGgpIHx8IDA7XG5cbiAgICAvLyBDaGVjayBmb3IgYWMtM3xlYy0zIHN5bmMgYnl0ZXMgYW5kIHJldHVybiBmYWxzZSBpZiBwcmVzZW50XG4gICAgaWYgKGlkM0RhdGEgJiYgZGF0YVtvZmZzZXRdID09PSAweDBiICYmIGRhdGFbb2Zmc2V0ICsgMV0gPT09IDB4NzcgJiYgZ2V0VGltZVN0YW1wKGlkM0RhdGEpICE9PSB1bmRlZmluZWQgJiZcbiAgICAvLyBjaGVjayB0aGUgYnNpZCB0byBjb25maXJtIGFjLTMgb3IgZWMtMyAobm90IG1wMylcbiAgICBnZXRBdWRpb0JTSUQoZGF0YSwgb2Zmc2V0KSA8PSAxNikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBsZW5ndGggPSBkYXRhLmxlbmd0aDsgb2Zmc2V0IDwgbGVuZ3RoOyBvZmZzZXQrKykge1xuICAgICAgaWYgKHByb2JlKGRhdGEsIG9mZnNldCkpIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnTVBFRyBBdWRpbyBzeW5jIHdvcmQgZm91bmQgIScpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNhblBhcnNlKGRhdGEsIG9mZnNldCkge1xuICAgIHJldHVybiBjYW5QYXJzZShkYXRhLCBvZmZzZXQpO1xuICB9XG4gIGFwcGVuZEZyYW1lKHRyYWNrLCBkYXRhLCBvZmZzZXQpIHtcbiAgICBpZiAodGhpcy5iYXNlUFRTID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBhcHBlbmRGcmFtZSQxKHRyYWNrLCBkYXRhLCBvZmZzZXQsIHRoaXMuYmFzZVBUUywgdGhpcy5mcmFtZUluZGV4KTtcbiAgfVxufVxuXG4vKipcbiAqICBBQUMgaGVscGVyXG4gKi9cblxuY2xhc3MgQUFDIHtcbiAgc3RhdGljIGdldFNpbGVudEZyYW1lKGNvZGVjLCBjaGFubmVsQ291bnQpIHtcbiAgICBzd2l0Y2ggKGNvZGVjKSB7XG4gICAgICBjYXNlICdtcDRhLjQwLjInOlxuICAgICAgICBpZiAoY2hhbm5lbENvdW50ID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIzLCAweDgwXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSAyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDIxLCAweDAwLCAweDQ5LCAweDkwLCAweDAyLCAweDE5LCAweDAwLCAweDIzLCAweDgwXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSAzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDhlXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSA0KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDgwLCAweDJjLCAweDgwLCAweDA4LCAweDAyLCAweDM4XSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSA1KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDgyLCAweDMwLCAweDA0LCAweDk5LCAweDAwLCAweDIxLCAweDkwLCAweDAyLCAweDM4XSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSA2KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweGM4LCAweDAwLCAweDgwLCAweDIwLCAweDg0LCAweDAxLCAweDI2LCAweDQwLCAweDA4LCAweDY0LCAweDAwLCAweDgyLCAweDMwLCAweDA0LCAweDk5LCAweDAwLCAweDIxLCAweDkwLCAweDAyLCAweDAwLCAweGIyLCAweDAwLCAweDIwLCAweDA4LCAweGUwXSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBoYW5kbGUgSEUtQUFDIGJlbG93IChtcDRhLjQwLjUgLyBtcDRhLjQwLjI5KVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGNoYW5uZWxDb3VudCA9PT0gMSkge1xuICAgICAgICAgIC8vIGZmbXBlZyAteSAtZiBsYXZmaSAtaSBcImFldmFsc3JjPTA6ZD0wLjA1XCIgLWM6YSBsaWJmZGtfYWFjIC1wcm9maWxlOmEgYWFjX2hlIC1iOmEgNGsgb3V0cHV0LmFhYyAmJiBoZXhkdW1wIC12IC1lICcxNi8xIFwiMHgleCxcIiBcIlxcblwiJyAtdiBvdXRwdXQuYWFjXG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDEsIDB4NDAsIDB4MjIsIDB4ODAsIDB4YTMsIDB4NGUsIDB4ZTYsIDB4ODAsIDB4YmEsIDB4OCwgMHgwLCAweDAsIDB4MCwgMHgxYywgMHg2LCAweGYxLCAweGMxLCAweGEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWEsIDB4NWVdKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFubmVsQ291bnQgPT09IDIpIHtcbiAgICAgICAgICAvLyBmZm1wZWcgLXkgLWYgbGF2ZmkgLWkgXCJhZXZhbHNyYz0wfDA6ZD0wLjA1XCIgLWM6YSBsaWJmZGtfYWFjIC1wcm9maWxlOmEgYWFjX2hlX3YyIC1iOmEgNGsgb3V0cHV0LmFhYyAmJiBoZXhkdW1wIC12IC1lICcxNi8xIFwiMHgleCxcIiBcIlxcblwiJyAtdiBvdXRwdXQuYWFjXG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDEsIDB4NDAsIDB4MjIsIDB4ODAsIDB4YTMsIDB4NWUsIDB4ZTYsIDB4ODAsIDB4YmEsIDB4OCwgMHgwLCAweDAsIDB4MCwgMHgwLCAweDk1LCAweDAsIDB4NiwgMHhmMSwgMHhhMSwgMHhhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVlXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbENvdW50ID09PSAzKSB7XG4gICAgICAgICAgLy8gZmZtcGVnIC15IC1mIGxhdmZpIC1pIFwiYWV2YWxzcmM9MHwwfDA6ZD0wLjA1XCIgLWM6YSBsaWJmZGtfYWFjIC1wcm9maWxlOmEgYWFjX2hlX3YyIC1iOmEgNGsgb3V0cHV0LmFhYyAmJiBoZXhkdW1wIC12IC1lICcxNi8xIFwiMHgleCxcIiBcIlxcblwiJyAtdiBvdXRwdXQuYWFjXG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDEsIDB4NDAsIDB4MjIsIDB4ODAsIDB4YTMsIDB4NWUsIDB4ZTYsIDB4ODAsIDB4YmEsIDB4OCwgMHgwLCAweDAsIDB4MCwgMHgwLCAweDk1LCAweDAsIDB4NiwgMHhmMSwgMHhhMSwgMHhhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVhLCAweDVlXSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBNUDQgQm94XG4gKi9cblxuY29uc3QgVUlOVDMyX01BWCA9IE1hdGgucG93KDIsIDMyKSAtIDE7XG5jbGFzcyBNUDQge1xuICBzdGF0aWMgaW5pdCgpIHtcbiAgICBNUDQudHlwZXMgPSB7XG4gICAgICBhdmMxOiBbXSxcbiAgICAgIC8vIGNvZGluZ25hbWVcbiAgICAgIGF2Y0M6IFtdLFxuICAgICAgYnRydDogW10sXG4gICAgICBkaW5mOiBbXSxcbiAgICAgIGRyZWY6IFtdLFxuICAgICAgZXNkczogW10sXG4gICAgICBmdHlwOiBbXSxcbiAgICAgIGhkbHI6IFtdLFxuICAgICAgbWRhdDogW10sXG4gICAgICBtZGhkOiBbXSxcbiAgICAgIG1kaWE6IFtdLFxuICAgICAgbWZoZDogW10sXG4gICAgICBtaW5mOiBbXSxcbiAgICAgIG1vb2Y6IFtdLFxuICAgICAgbW9vdjogW10sXG4gICAgICBtcDRhOiBbXSxcbiAgICAgICcubXAzJzogW10sXG4gICAgICBkYWMzOiBbXSxcbiAgICAgICdhYy0zJzogW10sXG4gICAgICBtdmV4OiBbXSxcbiAgICAgIG12aGQ6IFtdLFxuICAgICAgcGFzcDogW10sXG4gICAgICBzZHRwOiBbXSxcbiAgICAgIHN0Ymw6IFtdLFxuICAgICAgc3RjbzogW10sXG4gICAgICBzdHNjOiBbXSxcbiAgICAgIHN0c2Q6IFtdLFxuICAgICAgc3RzejogW10sXG4gICAgICBzdHRzOiBbXSxcbiAgICAgIHRmZHQ6IFtdLFxuICAgICAgdGZoZDogW10sXG4gICAgICB0cmFmOiBbXSxcbiAgICAgIHRyYWs6IFtdLFxuICAgICAgdHJ1bjogW10sXG4gICAgICB0cmV4OiBbXSxcbiAgICAgIHRraGQ6IFtdLFxuICAgICAgdm1oZDogW10sXG4gICAgICBzbWhkOiBbXVxuICAgIH07XG4gICAgbGV0IGk7XG4gICAgZm9yIChpIGluIE1QNC50eXBlcykge1xuICAgICAgaWYgKE1QNC50eXBlcy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICBNUDQudHlwZXNbaV0gPSBbaS5jaGFyQ29kZUF0KDApLCBpLmNoYXJDb2RlQXQoMSksIGkuY2hhckNvZGVBdCgyKSwgaS5jaGFyQ29kZUF0KDMpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdmlkZW9IZGxyID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsXG4gICAgLy8gdmVyc2lvbiAwXG4gICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcHJlX2RlZmluZWRcbiAgICAweDc2LCAweDY5LCAweDY0LCAweDY1LFxuICAgIC8vIGhhbmRsZXJfdHlwZTogJ3ZpZGUnXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHg1NiwgMHg2OSwgMHg2NCwgMHg2NSwgMHg2ZiwgMHg0OCwgMHg2MSwgMHg2ZSwgMHg2NCwgMHg2YywgMHg2NSwgMHg3MiwgMHgwMCAvLyBuYW1lOiAnVmlkZW9IYW5kbGVyJ1xuICAgIF0pO1xuICAgIGNvbnN0IGF1ZGlvSGRsciA9IG5ldyBVaW50OEFycmF5KFsweDAwLFxuICAgIC8vIHZlcnNpb24gMFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gZmxhZ3NcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHByZV9kZWZpbmVkXG4gICAgMHg3MywgMHg2ZiwgMHg3NSwgMHg2ZSxcbiAgICAvLyBoYW5kbGVyX3R5cGU6ICdzb3VuJ1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyByZXNlcnZlZFxuICAgIDB4NTMsIDB4NmYsIDB4NzUsIDB4NmUsIDB4NjQsIDB4NDgsIDB4NjEsIDB4NmUsIDB4NjQsIDB4NmMsIDB4NjUsIDB4NzIsIDB4MDAgLy8gbmFtZTogJ1NvdW5kSGFuZGxlcidcbiAgICBdKTtcbiAgICBNUDQuSERMUl9UWVBFUyA9IHtcbiAgICAgIHZpZGVvOiB2aWRlb0hkbHIsXG4gICAgICBhdWRpbzogYXVkaW9IZGxyXG4gICAgfTtcbiAgICBjb25zdCBkcmVmID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsXG4gICAgLy8gdmVyc2lvbiAwXG4gICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsXG4gICAgLy8gZW50cnlfY291bnRcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDBjLFxuICAgIC8vIGVudHJ5X3NpemVcbiAgICAweDc1LCAweDcyLCAweDZjLCAweDIwLFxuICAgIC8vICd1cmwnIHR5cGVcbiAgICAweDAwLFxuICAgIC8vIHZlcnNpb24gMFxuICAgIDB4MDAsIDB4MDAsIDB4MDEgLy8gZW50cnlfZmxhZ3NcbiAgICBdKTtcbiAgICBjb25zdCBzdGNvID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsXG4gICAgLy8gdmVyc2lvblxuICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gZmxhZ3NcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwIC8vIGVudHJ5X2NvdW50XG4gICAgXSk7XG4gICAgTVA0LlNUVFMgPSBNUDQuU1RTQyA9IE1QNC5TVENPID0gc3RjbztcbiAgICBNUDQuU1RTWiA9IG5ldyBVaW50OEFycmF5KFsweDAwLFxuICAgIC8vIHZlcnNpb25cbiAgICAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIGZsYWdzXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBzYW1wbGVfc2l6ZVxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAgLy8gc2FtcGxlX2NvdW50XG4gICAgXSk7XG4gICAgTVA0LlZNSEQgPSBuZXcgVWludDhBcnJheShbMHgwMCxcbiAgICAvLyB2ZXJzaW9uXG4gICAgMHgwMCwgMHgwMCwgMHgwMSxcbiAgICAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsXG4gICAgLy8gZ3JhcGhpY3Ntb2RlXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCAvLyBvcGNvbG9yXG4gICAgXSk7XG4gICAgTVA0LlNNSEQgPSBuZXcgVWludDhBcnJheShbMHgwMCxcbiAgICAvLyB2ZXJzaW9uXG4gICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsXG4gICAgLy8gYmFsYW5jZVxuICAgIDB4MDAsIDB4MDAgLy8gcmVzZXJ2ZWRcbiAgICBdKTtcbiAgICBNUDQuU1RTRCA9IG5ldyBVaW50OEFycmF5KFsweDAwLFxuICAgIC8vIHZlcnNpb24gMFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gZmxhZ3NcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAxXSk7IC8vIGVudHJ5X2NvdW50XG5cbiAgICBjb25zdCBtYWpvckJyYW5kID0gbmV3IFVpbnQ4QXJyYXkoWzEwNSwgMTE1LCAxMTEsIDEwOV0pOyAvLyBpc29tXG4gICAgY29uc3QgYXZjMUJyYW5kID0gbmV3IFVpbnQ4QXJyYXkoWzk3LCAxMTgsIDk5LCA0OV0pOyAvLyBhdmMxXG4gICAgY29uc3QgbWlub3JWZXJzaW9uID0gbmV3IFVpbnQ4QXJyYXkoWzAsIDAsIDAsIDFdKTtcbiAgICBNUDQuRlRZUCA9IE1QNC5ib3goTVA0LnR5cGVzLmZ0eXAsIG1ham9yQnJhbmQsIG1pbm9yVmVyc2lvbiwgbWFqb3JCcmFuZCwgYXZjMUJyYW5kKTtcbiAgICBNUDQuRElORiA9IE1QNC5ib3goTVA0LnR5cGVzLmRpbmYsIE1QNC5ib3goTVA0LnR5cGVzLmRyZWYsIGRyZWYpKTtcbiAgfVxuICBzdGF0aWMgYm94KHR5cGUsIC4uLnBheWxvYWQpIHtcbiAgICBsZXQgc2l6ZSA9IDg7XG4gICAgbGV0IGkgPSBwYXlsb2FkLmxlbmd0aDtcbiAgICBjb25zdCBsZW4gPSBpO1xuICAgIC8vIGNhbGN1bGF0ZSB0aGUgdG90YWwgc2l6ZSB3ZSBuZWVkIHRvIGFsbG9jYXRlXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgc2l6ZSArPSBwYXlsb2FkW2ldLmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgIHJlc3VsdFswXSA9IHNpemUgPj4gMjQgJiAweGZmO1xuICAgIHJlc3VsdFsxXSA9IHNpemUgPj4gMTYgJiAweGZmO1xuICAgIHJlc3VsdFsyXSA9IHNpemUgPj4gOCAmIDB4ZmY7XG4gICAgcmVzdWx0WzNdID0gc2l6ZSAmIDB4ZmY7XG4gICAgcmVzdWx0LnNldCh0eXBlLCA0KTtcbiAgICAvLyBjb3B5IHRoZSBwYXlsb2FkIGludG8gdGhlIHJlc3VsdFxuICAgIGZvciAoaSA9IDAsIHNpemUgPSA4OyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIC8vIGNvcHkgcGF5bG9hZFtpXSBhcnJheSBAIG9mZnNldCBzaXplXG4gICAgICByZXN1bHQuc2V0KHBheWxvYWRbaV0sIHNpemUpO1xuICAgICAgc2l6ZSArPSBwYXlsb2FkW2ldLmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgc3RhdGljIGhkbHIodHlwZSkge1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5oZGxyLCBNUDQuSERMUl9UWVBFU1t0eXBlXSk7XG4gIH1cbiAgc3RhdGljIG1kYXQoZGF0YSkge1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tZGF0LCBkYXRhKTtcbiAgfVxuICBzdGF0aWMgbWRoZCh0aW1lc2NhbGUsIGR1cmF0aW9uKSB7XG4gICAgZHVyYXRpb24gKj0gdGltZXNjYWxlO1xuICAgIGNvbnN0IHVwcGVyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAvIChVSU5UMzJfTUFYICsgMSkpO1xuICAgIGNvbnN0IGxvd2VyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAlIChVSU5UMzJfTUFYICsgMSkpO1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tZGhkLCBuZXcgVWludDhBcnJheShbMHgwMSxcbiAgICAvLyB2ZXJzaW9uIDFcbiAgICAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIGZsYWdzXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMixcbiAgICAvLyBjcmVhdGlvbl90aW1lXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMyxcbiAgICAvLyBtb2RpZmljYXRpb25fdGltZVxuICAgIHRpbWVzY2FsZSA+PiAyNCAmIDB4ZmYsIHRpbWVzY2FsZSA+PiAxNiAmIDB4ZmYsIHRpbWVzY2FsZSA+PiA4ICYgMHhmZiwgdGltZXNjYWxlICYgMHhmZixcbiAgICAvLyB0aW1lc2NhbGVcbiAgICB1cHBlcldvcmREdXJhdGlvbiA+PiAyNCwgdXBwZXJXb3JkRHVyYXRpb24gPj4gMTYgJiAweGZmLCB1cHBlcldvcmREdXJhdGlvbiA+PiA4ICYgMHhmZiwgdXBwZXJXb3JkRHVyYXRpb24gJiAweGZmLCBsb3dlcldvcmREdXJhdGlvbiA+PiAyNCwgbG93ZXJXb3JkRHVyYXRpb24gPj4gMTYgJiAweGZmLCBsb3dlcldvcmREdXJhdGlvbiA+PiA4ICYgMHhmZiwgbG93ZXJXb3JkRHVyYXRpb24gJiAweGZmLCAweDU1LCAweGM0LFxuICAgIC8vICd1bmQnIGxhbmd1YWdlICh1bmRldGVybWluZWQpXG4gICAgMHgwMCwgMHgwMF0pKTtcbiAgfVxuICBzdGF0aWMgbWRpYSh0cmFjaykge1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tZGlhLCBNUDQubWRoZCh0cmFjay50aW1lc2NhbGUsIHRyYWNrLmR1cmF0aW9uKSwgTVA0LmhkbHIodHJhY2sudHlwZSksIE1QNC5taW5mKHRyYWNrKSk7XG4gIH1cbiAgc3RhdGljIG1maGQoc2VxdWVuY2VOdW1iZXIpIHtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWZoZCwgbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gZmxhZ3NcbiAgICBzZXF1ZW5jZU51bWJlciA+PiAyNCwgc2VxdWVuY2VOdW1iZXIgPj4gMTYgJiAweGZmLCBzZXF1ZW5jZU51bWJlciA+PiA4ICYgMHhmZiwgc2VxdWVuY2VOdW1iZXIgJiAweGZmIC8vIHNlcXVlbmNlX251bWJlclxuICAgIF0pKTtcbiAgfVxuICBzdGF0aWMgbWluZih0cmFjaykge1xuICAgIGlmICh0cmFjay50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubWluZiwgTVA0LmJveChNUDQudHlwZXMuc21oZCwgTVA0LlNNSEQpLCBNUDQuRElORiwgTVA0LnN0YmwodHJhY2spKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1pbmYsIE1QNC5ib3goTVA0LnR5cGVzLnZtaGQsIE1QNC5WTUhEKSwgTVA0LkRJTkYsIE1QNC5zdGJsKHRyYWNrKSk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBtb29mKHNuLCBiYXNlTWVkaWFEZWNvZGVUaW1lLCB0cmFjaykge1xuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5tb29mLCBNUDQubWZoZChzbiksIE1QNC50cmFmKHRyYWNrLCBiYXNlTWVkaWFEZWNvZGVUaW1lKSk7XG4gIH1cbiAgc3RhdGljIG1vb3YodHJhY2tzKSB7XG4gICAgbGV0IGkgPSB0cmFja3MubGVuZ3RoO1xuICAgIGNvbnN0IGJveGVzID0gW107XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgYm94ZXNbaV0gPSBNUDQudHJhayh0cmFja3NbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gTVA0LmJveC5hcHBseShudWxsLCBbTVA0LnR5cGVzLm1vb3YsIE1QNC5tdmhkKHRyYWNrc1swXS50aW1lc2NhbGUsIHRyYWNrc1swXS5kdXJhdGlvbildLmNvbmNhdChib3hlcykuY29uY2F0KE1QNC5tdmV4KHRyYWNrcykpKTtcbiAgfVxuICBzdGF0aWMgbXZleCh0cmFja3MpIHtcbiAgICBsZXQgaSA9IHRyYWNrcy5sZW5ndGg7XG4gICAgY29uc3QgYm94ZXMgPSBbXTtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBib3hlc1tpXSA9IE1QNC50cmV4KHRyYWNrc1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBNUDQuYm94LmFwcGx5KG51bGwsIFtNUDQudHlwZXMubXZleCwgLi4uYm94ZXNdKTtcbiAgfVxuICBzdGF0aWMgbXZoZCh0aW1lc2NhbGUsIGR1cmF0aW9uKSB7XG4gICAgZHVyYXRpb24gKj0gdGltZXNjYWxlO1xuICAgIGNvbnN0IHVwcGVyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAvIChVSU5UMzJfTUFYICsgMSkpO1xuICAgIGNvbnN0IGxvd2VyV29yZER1cmF0aW9uID0gTWF0aC5mbG9vcihkdXJhdGlvbiAlIChVSU5UMzJfTUFYICsgMSkpO1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoWzB4MDEsXG4gICAgLy8gdmVyc2lvbiAxXG4gICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDIsXG4gICAgLy8gY3JlYXRpb25fdGltZVxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDMsXG4gICAgLy8gbW9kaWZpY2F0aW9uX3RpbWVcbiAgICB0aW1lc2NhbGUgPj4gMjQgJiAweGZmLCB0aW1lc2NhbGUgPj4gMTYgJiAweGZmLCB0aW1lc2NhbGUgPj4gOCAmIDB4ZmYsIHRpbWVzY2FsZSAmIDB4ZmYsXG4gICAgLy8gdGltZXNjYWxlXG4gICAgdXBwZXJXb3JkRHVyYXRpb24gPj4gMjQsIHVwcGVyV29yZER1cmF0aW9uID4+IDE2ICYgMHhmZiwgdXBwZXJXb3JkRHVyYXRpb24gPj4gOCAmIDB4ZmYsIHVwcGVyV29yZER1cmF0aW9uICYgMHhmZiwgbG93ZXJXb3JkRHVyYXRpb24gPj4gMjQsIGxvd2VyV29yZER1cmF0aW9uID4+IDE2ICYgMHhmZiwgbG93ZXJXb3JkRHVyYXRpb24gPj4gOCAmIDB4ZmYsIGxvd2VyV29yZER1cmF0aW9uICYgMHhmZiwgMHgwMCwgMHgwMSwgMHgwMCwgMHgwMCxcbiAgICAvLyAxLjAgcmF0ZVxuICAgIDB4MDEsIDB4MDAsXG4gICAgLy8gMS4wIHZvbHVtZVxuICAgIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4NDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gdHJhbnNmb3JtYXRpb246IHVuaXR5IG1hdHJpeFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcHJlX2RlZmluZWRcbiAgICAweGZmLCAweGZmLCAweGZmLCAweGZmIC8vIG5leHRfdHJhY2tfSURcbiAgICBdKTtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMubXZoZCwgYnl0ZXMpO1xuICB9XG4gIHN0YXRpYyBzZHRwKHRyYWNrKSB7XG4gICAgY29uc3Qgc2FtcGxlcyA9IHRyYWNrLnNhbXBsZXMgfHwgW107XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheSg0ICsgc2FtcGxlcy5sZW5ndGgpO1xuICAgIGxldCBpO1xuICAgIGxldCBmbGFncztcbiAgICAvLyBsZWF2ZSB0aGUgZnVsbCBib3ggaGVhZGVyICg0IGJ5dGVzKSBhbGwgemVyb1xuICAgIC8vIHdyaXRlIHRoZSBzYW1wbGUgdGFibGVcbiAgICBmb3IgKGkgPSAwOyBpIDwgc2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgZmxhZ3MgPSBzYW1wbGVzW2ldLmZsYWdzO1xuICAgICAgYnl0ZXNbaSArIDRdID0gZmxhZ3MuZGVwZW5kc09uIDw8IDQgfCBmbGFncy5pc0RlcGVuZGVkT24gPDwgMiB8IGZsYWdzLmhhc1JlZHVuZGFuY3k7XG4gICAgfVxuICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zZHRwLCBieXRlcyk7XG4gIH1cbiAgc3RhdGljIHN0YmwodHJhY2spIHtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RibCwgTVA0LnN0c2QodHJhY2spLCBNUDQuYm94KE1QNC50eXBlcy5zdHRzLCBNUDQuU1RUUyksIE1QNC5ib3goTVA0LnR5cGVzLnN0c2MsIE1QNC5TVFNDKSwgTVA0LmJveChNUDQudHlwZXMuc3RzeiwgTVA0LlNUU1opLCBNUDQuYm94KE1QNC50eXBlcy5zdGNvLCBNUDQuU1RDTykpO1xuICB9XG4gIHN0YXRpYyBhdmMxKHRyYWNrKSB7XG4gICAgbGV0IHNwcyA9IFtdO1xuICAgIGxldCBwcHMgPSBbXTtcbiAgICBsZXQgaTtcbiAgICBsZXQgZGF0YTtcbiAgICBsZXQgbGVuO1xuICAgIC8vIGFzc2VtYmxlIHRoZSBTUFNzXG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdHJhY2suc3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkYXRhID0gdHJhY2suc3BzW2ldO1xuICAgICAgbGVuID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgc3BzLnB1c2gobGVuID4+PiA4ICYgMHhmZik7XG4gICAgICBzcHMucHVzaChsZW4gJiAweGZmKTtcblxuICAgICAgLy8gU1BTXG4gICAgICBzcHMgPSBzcHMuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRhdGEpKTtcbiAgICB9XG5cbiAgICAvLyBhc3NlbWJsZSB0aGUgUFBTc1xuICAgIGZvciAoaSA9IDA7IGkgPCB0cmFjay5wcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRhdGEgPSB0cmFjay5wcHNbaV07XG4gICAgICBsZW4gPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICBwcHMucHVzaChsZW4gPj4+IDggJiAweGZmKTtcbiAgICAgIHBwcy5wdXNoKGxlbiAmIDB4ZmYpO1xuICAgICAgcHBzID0gcHBzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGF2Y2MgPSBNUDQuYm94KE1QNC50eXBlcy5hdmNDLCBuZXcgVWludDhBcnJheShbMHgwMSxcbiAgICAvLyB2ZXJzaW9uXG4gICAgc3BzWzNdLFxuICAgIC8vIHByb2ZpbGVcbiAgICBzcHNbNF0sXG4gICAgLy8gcHJvZmlsZSBjb21wYXRcbiAgICBzcHNbNV0sXG4gICAgLy8gbGV2ZWxcbiAgICAweGZjIHwgMyxcbiAgICAvLyBsZW5ndGhTaXplTWludXNPbmUsIGhhcmQtY29kZWQgdG8gNCBieXRlc1xuICAgIDB4ZTAgfCB0cmFjay5zcHMubGVuZ3RoIC8vIDNiaXQgcmVzZXJ2ZWQgKDExMSkgKyBudW1PZlNlcXVlbmNlUGFyYW1ldGVyU2V0c1xuICAgIF0uY29uY2F0KHNwcykuY29uY2F0KFt0cmFjay5wcHMubGVuZ3RoIC8vIG51bU9mUGljdHVyZVBhcmFtZXRlclNldHNcbiAgICBdKS5jb25jYXQocHBzKSkpOyAvLyBcIlBQU1wiXG4gICAgY29uc3Qgd2lkdGggPSB0cmFjay53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSB0cmFjay5oZWlnaHQ7XG4gICAgY29uc3QgaFNwYWNpbmcgPSB0cmFjay5waXhlbFJhdGlvWzBdO1xuICAgIGNvbnN0IHZTcGFjaW5nID0gdHJhY2sucGl4ZWxSYXRpb1sxXTtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuYXZjMSwgbmV3IFVpbnQ4QXJyYXkoWzB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWRcbiAgICAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMSxcbiAgICAvLyBkYXRhX3JlZmVyZW5jZV9pbmRleFxuICAgIDB4MDAsIDB4MDAsXG4gICAgLy8gcHJlX2RlZmluZWRcbiAgICAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBwcmVfZGVmaW5lZFxuICAgIHdpZHRoID4+IDggJiAweGZmLCB3aWR0aCAmIDB4ZmYsXG4gICAgLy8gd2lkdGhcbiAgICBoZWlnaHQgPj4gOCAmIDB4ZmYsIGhlaWdodCAmIDB4ZmYsXG4gICAgLy8gaGVpZ2h0XG4gICAgMHgwMCwgMHg0OCwgMHgwMCwgMHgwMCxcbiAgICAvLyBob3JpenJlc29sdXRpb25cbiAgICAweDAwLCAweDQ4LCAweDAwLCAweDAwLFxuICAgIC8vIHZlcnRyZXNvbHV0aW9uXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDEsXG4gICAgLy8gZnJhbWVfY291bnRcbiAgICAweDEyLCAweDY0LCAweDYxLCAweDY5LCAweDZjLFxuICAgIC8vIGRhaWx5bW90aW9uL2hscy5qc1xuICAgIDB4NzksIDB4NmQsIDB4NmYsIDB4NzQsIDB4NjksIDB4NmYsIDB4NmUsIDB4MmYsIDB4NjgsIDB4NmMsIDB4NzMsIDB4MmUsIDB4NmEsIDB4NzMsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gY29tcHJlc3Nvcm5hbWVcbiAgICAweDAwLCAweDE4LFxuICAgIC8vIGRlcHRoID0gMjRcbiAgICAweDExLCAweDExXSksXG4gICAgLy8gcHJlX2RlZmluZWQgPSAtMVxuICAgIGF2Y2MsIE1QNC5ib3goTVA0LnR5cGVzLmJ0cnQsIG5ldyBVaW50OEFycmF5KFsweDAwLCAweDFjLCAweDljLCAweDgwLFxuICAgIC8vIGJ1ZmZlclNpemVEQlxuICAgIDB4MDAsIDB4MmQsIDB4YzYsIDB4YzAsXG4gICAgLy8gbWF4Qml0cmF0ZVxuICAgIDB4MDAsIDB4MmQsIDB4YzYsIDB4YzBdKSksXG4gICAgLy8gYXZnQml0cmF0ZVxuICAgIE1QNC5ib3goTVA0LnR5cGVzLnBhc3AsIG5ldyBVaW50OEFycmF5KFtoU3BhY2luZyA+PiAyNCxcbiAgICAvLyBoU3BhY2luZ1xuICAgIGhTcGFjaW5nID4+IDE2ICYgMHhmZiwgaFNwYWNpbmcgPj4gOCAmIDB4ZmYsIGhTcGFjaW5nICYgMHhmZiwgdlNwYWNpbmcgPj4gMjQsXG4gICAgLy8gdlNwYWNpbmdcbiAgICB2U3BhY2luZyA+PiAxNiAmIDB4ZmYsIHZTcGFjaW5nID4+IDggJiAweGZmLCB2U3BhY2luZyAmIDB4ZmZdKSkpO1xuICB9XG4gIHN0YXRpYyBlc2RzKHRyYWNrKSB7XG4gICAgY29uc3QgY29uZmlnbGVuID0gdHJhY2suY29uZmlnLmxlbmd0aDtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzB4MDAsXG4gICAgLy8gdmVyc2lvbiAwXG4gICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBmbGFnc1xuXG4gICAgMHgwMyxcbiAgICAvLyBkZXNjcmlwdG9yX3R5cGVcbiAgICAweDE3ICsgY29uZmlnbGVuLFxuICAgIC8vIGxlbmd0aFxuICAgIDB4MDAsIDB4MDEsXG4gICAgLy8gZXNfaWRcbiAgICAweDAwLFxuICAgIC8vIHN0cmVhbV9wcmlvcml0eVxuXG4gICAgMHgwNCxcbiAgICAvLyBkZXNjcmlwdG9yX3R5cGVcbiAgICAweDBmICsgY29uZmlnbGVuLFxuICAgIC8vIGxlbmd0aFxuICAgIDB4NDAsXG4gICAgLy8gY29kZWMgOiBtcGVnNF9hdWRpb1xuICAgIDB4MTUsXG4gICAgLy8gc3RyZWFtX3R5cGVcbiAgICAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIGJ1ZmZlcl9zaXplXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBtYXhCaXRyYXRlXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBhdmdCaXRyYXRlXG5cbiAgICAweDA1IC8vIGRlc2NyaXB0b3JfdHlwZVxuICAgIF0uY29uY2F0KFtjb25maWdsZW5dKS5jb25jYXQodHJhY2suY29uZmlnKS5jb25jYXQoWzB4MDYsIDB4MDEsIDB4MDJdKSk7IC8vIEdBU3BlY2lmaWNDb25maWcpKTsgLy8gbGVuZ3RoICsgYXVkaW8gY29uZmlnIGRlc2NyaXB0b3JcbiAgfVxuICBzdGF0aWMgYXVkaW9TdHNkKHRyYWNrKSB7XG4gICAgY29uc3Qgc2FtcGxlcmF0ZSA9IHRyYWNrLnNhbXBsZXJhdGU7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDEsXG4gICAgLy8gZGF0YV9yZWZlcmVuY2VfaW5kZXhcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgdHJhY2suY2hhbm5lbENvdW50LFxuICAgIC8vIGNoYW5uZWxjb3VudFxuICAgIDB4MDAsIDB4MTAsXG4gICAgLy8gc2FtcGxlU2l6ZToxNmJpdHNcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkMlxuICAgIHNhbXBsZXJhdGUgPj4gOCAmIDB4ZmYsIHNhbXBsZXJhdGUgJiAweGZmLFxuICAgIC8vXG4gICAgMHgwMCwgMHgwMF0pO1xuICB9XG4gIHN0YXRpYyBtcDRhKHRyYWNrKSB7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLm1wNGEsIE1QNC5hdWRpb1N0c2QodHJhY2spLCBNUDQuYm94KE1QNC50eXBlcy5lc2RzLCBNUDQuZXNkcyh0cmFjaykpKTtcbiAgfVxuICBzdGF0aWMgbXAzKHRyYWNrKSB7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzWycubXAzJ10sIE1QNC5hdWRpb1N0c2QodHJhY2spKTtcbiAgfVxuICBzdGF0aWMgYWMzKHRyYWNrKSB7XG4gICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzWydhYy0zJ10sIE1QNC5hdWRpb1N0c2QodHJhY2spLCBNUDQuYm94KE1QNC50eXBlcy5kYWMzLCB0cmFjay5jb25maWcpKTtcbiAgfVxuICBzdGF0aWMgc3RzZCh0cmFjaykge1xuICAgIGlmICh0cmFjay50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICBpZiAodHJhY2suc2VnbWVudENvZGVjID09PSAnbXAzJyAmJiB0cmFjay5jb2RlYyA9PT0gJ21wMycpIHtcbiAgICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnN0c2QsIE1QNC5TVFNELCBNUDQubXAzKHRyYWNrKSk7XG4gICAgICB9XG4gICAgICBpZiAodHJhY2suc2VnbWVudENvZGVjID09PSAnYWMzJykge1xuICAgICAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMuc3RzZCwgTVA0LlNUU0QsIE1QNC5hYzModHJhY2spKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNUDQuYm94KE1QNC50eXBlcy5zdHNkLCBNUDQuU1RTRCwgTVA0Lm1wNGEodHJhY2spKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE1QNC5ib3goTVA0LnR5cGVzLnN0c2QsIE1QNC5TVFNELCBNUDQuYXZjMSh0cmFjaykpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgdGtoZCh0cmFjaykge1xuICAgIGNvbnN0IGlkID0gdHJhY2suaWQ7XG4gICAgY29uc3QgZHVyYXRpb24gPSB0cmFjay5kdXJhdGlvbiAqIHRyYWNrLnRpbWVzY2FsZTtcbiAgICBjb25zdCB3aWR0aCA9IHRyYWNrLndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IHRyYWNrLmhlaWdodDtcbiAgICBjb25zdCB1cHBlcldvcmREdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb24gLyAoVUlOVDMyX01BWCArIDEpKTtcbiAgICBjb25zdCBsb3dlcldvcmREdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb24gJSAoVUlOVDMyX01BWCArIDEpKTtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudGtoZCwgbmV3IFVpbnQ4QXJyYXkoWzB4MDEsXG4gICAgLy8gdmVyc2lvbiAxXG4gICAgMHgwMCwgMHgwMCwgMHgwNyxcbiAgICAvLyBmbGFnc1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDIsXG4gICAgLy8gY3JlYXRpb25fdGltZVxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDMsXG4gICAgLy8gbW9kaWZpY2F0aW9uX3RpbWVcbiAgICBpZCA+PiAyNCAmIDB4ZmYsIGlkID4+IDE2ICYgMHhmZiwgaWQgPj4gOCAmIDB4ZmYsIGlkICYgMHhmZixcbiAgICAvLyB0cmFja19JRFxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gcmVzZXJ2ZWRcbiAgICB1cHBlcldvcmREdXJhdGlvbiA+PiAyNCwgdXBwZXJXb3JkRHVyYXRpb24gPj4gMTYgJiAweGZmLCB1cHBlcldvcmREdXJhdGlvbiA+PiA4ICYgMHhmZiwgdXBwZXJXb3JkRHVyYXRpb24gJiAweGZmLCBsb3dlcldvcmREdXJhdGlvbiA+PiAyNCwgbG93ZXJXb3JkRHVyYXRpb24gPj4gMTYgJiAweGZmLCBsb3dlcldvcmREdXJhdGlvbiA+PiA4ICYgMHhmZiwgbG93ZXJXb3JkRHVyYXRpb24gJiAweGZmLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAgIC8vIHJlc2VydmVkXG4gICAgMHgwMCwgMHgwMCxcbiAgICAvLyBsYXllclxuICAgIDB4MDAsIDB4MDAsXG4gICAgLy8gYWx0ZXJuYXRlX2dyb3VwXG4gICAgMHgwMCwgMHgwMCxcbiAgICAvLyBub24tYXVkaW8gdHJhY2sgdm9sdW1lXG4gICAgMHgwMCwgMHgwMCxcbiAgICAvLyByZXNlcnZlZFxuICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4NDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gdHJhbnNmb3JtYXRpb246IHVuaXR5IG1hdHJpeFxuICAgIHdpZHRoID4+IDggJiAweGZmLCB3aWR0aCAmIDB4ZmYsIDB4MDAsIDB4MDAsXG4gICAgLy8gd2lkdGhcbiAgICBoZWlnaHQgPj4gOCAmIDB4ZmYsIGhlaWdodCAmIDB4ZmYsIDB4MDAsIDB4MDAgLy8gaGVpZ2h0XG4gICAgXSkpO1xuICB9XG4gIHN0YXRpYyB0cmFmKHRyYWNrLCBiYXNlTWVkaWFEZWNvZGVUaW1lKSB7XG4gICAgY29uc3Qgc2FtcGxlRGVwZW5kZW5jeVRhYmxlID0gTVA0LnNkdHAodHJhY2spO1xuICAgIGNvbnN0IGlkID0gdHJhY2suaWQ7XG4gICAgY29uc3QgdXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA9IE1hdGguZmxvb3IoYmFzZU1lZGlhRGVjb2RlVGltZSAvIChVSU5UMzJfTUFYICsgMSkpO1xuICAgIGNvbnN0IGxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPSBNYXRoLmZsb29yKGJhc2VNZWRpYURlY29kZVRpbWUgJSAoVUlOVDMyX01BWCArIDEpKTtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudHJhZiwgTVA0LmJveChNUDQudHlwZXMudGZoZCwgbmV3IFVpbnQ4QXJyYXkoWzB4MDAsXG4gICAgLy8gdmVyc2lvbiAwXG4gICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBmbGFnc1xuICAgIGlkID4+IDI0LCBpZCA+PiAxNiAmIDB4ZmYsIGlkID4+IDggJiAweGZmLCBpZCAmIDB4ZmYgLy8gdHJhY2tfSURcbiAgICBdKSksIE1QNC5ib3goTVA0LnR5cGVzLnRmZHQsIG5ldyBVaW50OEFycmF5KFsweDAxLFxuICAgIC8vIHZlcnNpb24gMVxuICAgIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gZmxhZ3NcbiAgICB1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+IDI0LCB1cHBlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+IDE2ICYgMHhmZiwgdXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSA+PiA4ICYgMHhmZiwgdXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSAmIDB4ZmYsIGxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4gMjQsIGxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUgPj4gMTYgJiAweGZmLCBsb3dlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lID4+IDggJiAweGZmLCBsb3dlcldvcmRCYXNlTWVkaWFEZWNvZGVUaW1lICYgMHhmZl0pKSwgTVA0LnRydW4odHJhY2ssIHNhbXBsZURlcGVuZGVuY3lUYWJsZS5sZW5ndGggKyAxNiArXG4gICAgLy8gdGZoZFxuICAgIDIwICtcbiAgICAvLyB0ZmR0XG4gICAgOCArXG4gICAgLy8gdHJhZiBoZWFkZXJcbiAgICAxNiArXG4gICAgLy8gbWZoZFxuICAgIDggK1xuICAgIC8vIG1vb2YgaGVhZGVyXG4gICAgOCksXG4gICAgLy8gbWRhdCBoZWFkZXJcbiAgICBzYW1wbGVEZXBlbmRlbmN5VGFibGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhY2sgYm94LlxuICAgKiBAcGFyYW0gdHJhY2sgYSB0cmFjayBkZWZpbml0aW9uXG4gICAqL1xuICBzdGF0aWMgdHJhayh0cmFjaykge1xuICAgIHRyYWNrLmR1cmF0aW9uID0gdHJhY2suZHVyYXRpb24gfHwgMHhmZmZmZmZmZjtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudHJhaywgTVA0LnRraGQodHJhY2spLCBNUDQubWRpYSh0cmFjaykpO1xuICB9XG4gIHN0YXRpYyB0cmV4KHRyYWNrKSB7XG4gICAgY29uc3QgaWQgPSB0cmFjay5pZDtcbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudHJleCwgbmV3IFVpbnQ4QXJyYXkoWzB4MDAsXG4gICAgLy8gdmVyc2lvbiAwXG4gICAgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBmbGFnc1xuICAgIGlkID4+IDI0LCBpZCA+PiAxNiAmIDB4ZmYsIGlkID4+IDggJiAweGZmLCBpZCAmIDB4ZmYsXG4gICAgLy8gdHJhY2tfSURcbiAgICAweDAwLCAweDAwLCAweDAwLCAweDAxLFxuICAgIC8vIGRlZmF1bHRfc2FtcGxlX2Rlc2NyaXB0aW9uX2luZGV4XG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgICAvLyBkZWZhdWx0X3NhbXBsZV9kdXJhdGlvblxuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gICAgLy8gZGVmYXVsdF9zYW1wbGVfc2l6ZVxuICAgIDB4MDAsIDB4MDEsIDB4MDAsIDB4MDEgLy8gZGVmYXVsdF9zYW1wbGVfZmxhZ3NcbiAgICBdKSk7XG4gIH1cbiAgc3RhdGljIHRydW4odHJhY2ssIG9mZnNldCkge1xuICAgIGNvbnN0IHNhbXBsZXMgPSB0cmFjay5zYW1wbGVzIHx8IFtdO1xuICAgIGNvbnN0IGxlbiA9IHNhbXBsZXMubGVuZ3RoO1xuICAgIGNvbnN0IGFycmF5bGVuID0gMTIgKyAxNiAqIGxlbjtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5bGVuKTtcbiAgICBsZXQgaTtcbiAgICBsZXQgc2FtcGxlO1xuICAgIGxldCBkdXJhdGlvbjtcbiAgICBsZXQgc2l6ZTtcbiAgICBsZXQgZmxhZ3M7XG4gICAgbGV0IGN0cztcbiAgICBvZmZzZXQgKz0gOCArIGFycmF5bGVuO1xuICAgIGFycmF5LnNldChbdHJhY2sudHlwZSA9PT0gJ3ZpZGVvJyA/IDB4MDEgOiAweDAwLFxuICAgIC8vIHZlcnNpb24gMSBmb3IgdmlkZW8gd2l0aCBzaWduZWQtaW50IHNhbXBsZV9jb21wb3NpdGlvbl90aW1lX29mZnNldFxuICAgIDB4MDAsIDB4MGYsIDB4MDEsXG4gICAgLy8gZmxhZ3NcbiAgICBsZW4gPj4+IDI0ICYgMHhmZiwgbGVuID4+PiAxNiAmIDB4ZmYsIGxlbiA+Pj4gOCAmIDB4ZmYsIGxlbiAmIDB4ZmYsXG4gICAgLy8gc2FtcGxlX2NvdW50XG4gICAgb2Zmc2V0ID4+PiAyNCAmIDB4ZmYsIG9mZnNldCA+Pj4gMTYgJiAweGZmLCBvZmZzZXQgPj4+IDggJiAweGZmLCBvZmZzZXQgJiAweGZmIC8vIGRhdGFfb2Zmc2V0XG4gICAgXSwgMCk7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBzYW1wbGUgPSBzYW1wbGVzW2ldO1xuICAgICAgZHVyYXRpb24gPSBzYW1wbGUuZHVyYXRpb247XG4gICAgICBzaXplID0gc2FtcGxlLnNpemU7XG4gICAgICBmbGFncyA9IHNhbXBsZS5mbGFncztcbiAgICAgIGN0cyA9IHNhbXBsZS5jdHM7XG4gICAgICBhcnJheS5zZXQoW2R1cmF0aW9uID4+PiAyNCAmIDB4ZmYsIGR1cmF0aW9uID4+PiAxNiAmIDB4ZmYsIGR1cmF0aW9uID4+PiA4ICYgMHhmZiwgZHVyYXRpb24gJiAweGZmLFxuICAgICAgLy8gc2FtcGxlX2R1cmF0aW9uXG4gICAgICBzaXplID4+PiAyNCAmIDB4ZmYsIHNpemUgPj4+IDE2ICYgMHhmZiwgc2l6ZSA+Pj4gOCAmIDB4ZmYsIHNpemUgJiAweGZmLFxuICAgICAgLy8gc2FtcGxlX3NpemVcbiAgICAgIGZsYWdzLmlzTGVhZGluZyA8PCAyIHwgZmxhZ3MuZGVwZW5kc09uLCBmbGFncy5pc0RlcGVuZGVkT24gPDwgNiB8IGZsYWdzLmhhc1JlZHVuZGFuY3kgPDwgNCB8IGZsYWdzLnBhZGRpbmdWYWx1ZSA8PCAxIHwgZmxhZ3MuaXNOb25TeW5jLCBmbGFncy5kZWdyYWRQcmlvICYgMHhmMCA8PCA4LCBmbGFncy5kZWdyYWRQcmlvICYgMHgwZixcbiAgICAgIC8vIHNhbXBsZV9mbGFnc1xuICAgICAgY3RzID4+PiAyNCAmIDB4ZmYsIGN0cyA+Pj4gMTYgJiAweGZmLCBjdHMgPj4+IDggJiAweGZmLCBjdHMgJiAweGZmIC8vIHNhbXBsZV9jb21wb3NpdGlvbl90aW1lX29mZnNldFxuICAgICAgXSwgMTIgKyAxNiAqIGkpO1xuICAgIH1cbiAgICByZXR1cm4gTVA0LmJveChNUDQudHlwZXMudHJ1biwgYXJyYXkpO1xuICB9XG4gIHN0YXRpYyBpbml0U2VnbWVudCh0cmFja3MpIHtcbiAgICBpZiAoIU1QNC50eXBlcykge1xuICAgICAgTVA0LmluaXQoKTtcbiAgICB9XG4gICAgY29uc3QgbW92aWUgPSBNUDQubW9vdih0cmFja3MpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGFwcGVuZFVpbnQ4QXJyYXkoTVA0LkZUWVAsIG1vdmllKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5NUDQudHlwZXMgPSB2b2lkIDA7XG5NUDQuSERMUl9UWVBFUyA9IHZvaWQgMDtcbk1QNC5TVFRTID0gdm9pZCAwO1xuTVA0LlNUU0MgPSB2b2lkIDA7XG5NUDQuU1RDTyA9IHZvaWQgMDtcbk1QNC5TVFNaID0gdm9pZCAwO1xuTVA0LlZNSEQgPSB2b2lkIDA7XG5NUDQuU01IRCA9IHZvaWQgMDtcbk1QNC5TVFNEID0gdm9pZCAwO1xuTVA0LkZUWVAgPSB2b2lkIDA7XG5NUDQuRElORiA9IHZvaWQgMDtcblxuY29uc3QgTVBFR19UU19DTE9DS19GUkVRX0haID0gOTAwMDA7XG5mdW5jdGlvbiB0b1RpbWVzY2FsZUZyb21CYXNlKGJhc2VUaW1lLCBkZXN0U2NhbGUsIHNyY0Jhc2UgPSAxLCByb3VuZCA9IGZhbHNlKSB7XG4gIGNvbnN0IHJlc3VsdCA9IGJhc2VUaW1lICogZGVzdFNjYWxlICogc3JjQmFzZTsgLy8gZXF1aXZhbGVudCB0byBgKHZhbHVlICogc2NhbGUpIC8gKDEgLyBiYXNlKWBcbiAgcmV0dXJuIHJvdW5kID8gTWF0aC5yb3VuZChyZXN1bHQpIDogcmVzdWx0O1xufVxuZnVuY3Rpb24gdG9UaW1lc2NhbGVGcm9tU2NhbGUoYmFzZVRpbWUsIGRlc3RTY2FsZSwgc3JjU2NhbGUgPSAxLCByb3VuZCA9IGZhbHNlKSB7XG4gIHJldHVybiB0b1RpbWVzY2FsZUZyb21CYXNlKGJhc2VUaW1lLCBkZXN0U2NhbGUsIDEgLyBzcmNTY2FsZSwgcm91bmQpO1xufVxuZnVuY3Rpb24gdG9Nc0Zyb21NcGVnVHNDbG9jayhiYXNlVGltZSwgcm91bmQgPSBmYWxzZSkge1xuICByZXR1cm4gdG9UaW1lc2NhbGVGcm9tQmFzZShiYXNlVGltZSwgMTAwMCwgMSAvIE1QRUdfVFNfQ0xPQ0tfRlJFUV9IWiwgcm91bmQpO1xufVxuZnVuY3Rpb24gdG9NcGVnVHNDbG9ja0Zyb21UaW1lc2NhbGUoYmFzZVRpbWUsIHNyY1NjYWxlID0gMSkge1xuICByZXR1cm4gdG9UaW1lc2NhbGVGcm9tQmFzZShiYXNlVGltZSwgTVBFR19UU19DTE9DS19GUkVRX0haLCAxIC8gc3JjU2NhbGUpO1xufVxuXG5jb25zdCBNQVhfU0lMRU5UX0ZSQU1FX0RVUkFUSU9OID0gMTAgKiAxMDAwOyAvLyAxMCBzZWNvbmRzXG5jb25zdCBBQUNfU0FNUExFU19QRVJfRlJBTUUgPSAxMDI0O1xuY29uc3QgTVBFR19BVURJT19TQU1QTEVfUEVSX0ZSQU1FID0gMTE1MjtcbmNvbnN0IEFDM19TQU1QTEVTX1BFUl9GUkFNRSA9IDE1MzY7XG5sZXQgY2hyb21lVmVyc2lvbiA9IG51bGw7XG5sZXQgc2FmYXJpV2Via2l0VmVyc2lvbiA9IG51bGw7XG5jbGFzcyBNUDRSZW11eGVyIHtcbiAgY29uc3RydWN0b3Iob2JzZXJ2ZXIsIGNvbmZpZywgdHlwZVN1cHBvcnRlZCwgdmVuZG9yID0gJycpIHtcbiAgICB0aGlzLm9ic2VydmVyID0gdm9pZCAwO1xuICAgIHRoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgIHRoaXMudHlwZVN1cHBvcnRlZCA9IHZvaWQgMDtcbiAgICB0aGlzLklTR2VuZXJhdGVkID0gZmFsc2U7XG4gICAgdGhpcy5faW5pdFBUUyA9IG51bGw7XG4gICAgdGhpcy5faW5pdERUUyA9IG51bGw7XG4gICAgdGhpcy5uZXh0QXZjRHRzID0gbnVsbDtcbiAgICB0aGlzLm5leHRBdWRpb1B0cyA9IG51bGw7XG4gICAgdGhpcy52aWRlb1NhbXBsZUR1cmF0aW9uID0gbnVsbDtcbiAgICB0aGlzLmlzQXVkaW9Db250aWd1b3VzID0gZmFsc2U7XG4gICAgdGhpcy5pc1ZpZGVvQ29udGlndW91cyA9IGZhbHNlO1xuICAgIHRoaXMudmlkZW9UcmFja0NvbmZpZyA9IHZvaWQgMDtcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy50eXBlU3VwcG9ydGVkID0gdHlwZVN1cHBvcnRlZDtcbiAgICB0aGlzLklTR2VuZXJhdGVkID0gZmFsc2U7XG4gICAgaWYgKGNocm9tZVZlcnNpb24gPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQgfHwgJyc7XG4gICAgICBjb25zdCByZXN1bHQgPSB1c2VyQWdlbnQubWF0Y2goL0Nocm9tZVxcLyhcXGQrKS9pKTtcbiAgICAgIGNocm9tZVZlcnNpb24gPSByZXN1bHQgPyBwYXJzZUludChyZXN1bHRbMV0pIDogMDtcbiAgICB9XG4gICAgaWYgKHNhZmFyaVdlYmtpdFZlcnNpb24gPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1NhZmFyaVxcLyhcXGQrKS9pKTtcbiAgICAgIHNhZmFyaVdlYmtpdFZlcnNpb24gPSByZXN1bHQgPyBwYXJzZUludChyZXN1bHRbMV0pIDogMDtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5jb25maWcgPSB0aGlzLnZpZGVvVHJhY2tDb25maWcgPSB0aGlzLl9pbml0UFRTID0gdGhpcy5faW5pdERUUyA9IG51bGw7XG4gIH1cbiAgcmVzZXRUaW1lU3RhbXAoZGVmYXVsdFRpbWVTdGFtcCkge1xuICAgIGxvZ2dlci5sb2coJ1ttcDQtcmVtdXhlcl06IGluaXRQVFMgJiBpbml0RFRTIHJlc2V0Jyk7XG4gICAgdGhpcy5faW5pdFBUUyA9IHRoaXMuX2luaXREVFMgPSBkZWZhdWx0VGltZVN0YW1wO1xuICB9XG4gIHJlc2V0TmV4dFRpbWVzdGFtcCgpIHtcbiAgICBsb2dnZXIubG9nKCdbbXA0LXJlbXV4ZXJdOiByZXNldCBuZXh0IHRpbWVzdGFtcCcpO1xuICAgIHRoaXMuaXNWaWRlb0NvbnRpZ3VvdXMgPSBmYWxzZTtcbiAgICB0aGlzLmlzQXVkaW9Db250aWd1b3VzID0gZmFsc2U7XG4gIH1cbiAgcmVzZXRJbml0U2VnbWVudCgpIHtcbiAgICBsb2dnZXIubG9nKCdbbXA0LXJlbXV4ZXJdOiBJU0dlbmVyYXRlZCBmbGFnIHJlc2V0Jyk7XG4gICAgdGhpcy5JU0dlbmVyYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMudmlkZW9UcmFja0NvbmZpZyA9IHVuZGVmaW5lZDtcbiAgfVxuICBnZXRWaWRlb1N0YXJ0UHRzKHZpZGVvU2FtcGxlcykge1xuICAgIGxldCByb2xsb3ZlckRldGVjdGVkID0gZmFsc2U7XG4gICAgY29uc3Qgc3RhcnRQVFMgPSB2aWRlb1NhbXBsZXMucmVkdWNlKChtaW5QVFMsIHNhbXBsZSkgPT4ge1xuICAgICAgY29uc3QgZGVsdGEgPSBzYW1wbGUucHRzIC0gbWluUFRTO1xuICAgICAgaWYgKGRlbHRhIDwgLTQyOTQ5NjcyOTYpIHtcbiAgICAgICAgLy8gMl4zMiwgc2VlIFBUU05vcm1hbGl6ZSBmb3IgcmVhc29uaW5nLCBidXQgd2UncmUgaGl0dGluZyBhIHJvbGxvdmVyIGhlcmUsIGFuZCB3ZSBkb24ndCB3YW50IHRoYXQgdG8gaW1wYWN0IHRoZSB0aW1lT2Zmc2V0IGNhbGN1bGF0aW9uXG4gICAgICAgIHJvbGxvdmVyRGV0ZWN0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplUHRzKG1pblBUUywgc2FtcGxlLnB0cyk7XG4gICAgICB9IGVsc2UgaWYgKGRlbHRhID4gMCkge1xuICAgICAgICByZXR1cm4gbWluUFRTO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNhbXBsZS5wdHM7XG4gICAgICB9XG4gICAgfSwgdmlkZW9TYW1wbGVzWzBdLnB0cyk7XG4gICAgaWYgKHJvbGxvdmVyRGV0ZWN0ZWQpIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZygnUFRTIHJvbGxvdmVyIGRldGVjdGVkJyk7XG4gICAgfVxuICAgIHJldHVybiBzdGFydFBUUztcbiAgfVxuICByZW11eChhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCBpZDNUcmFjaywgdGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGZsdXNoLCBwbGF5bGlzdFR5cGUpIHtcbiAgICBsZXQgdmlkZW87XG4gICAgbGV0IGF1ZGlvO1xuICAgIGxldCBpbml0U2VnbWVudDtcbiAgICBsZXQgdGV4dDtcbiAgICBsZXQgaWQzO1xuICAgIGxldCBpbmRlcGVuZGVudDtcbiAgICBsZXQgYXVkaW9UaW1lT2Zmc2V0ID0gdGltZU9mZnNldDtcbiAgICBsZXQgdmlkZW9UaW1lT2Zmc2V0ID0gdGltZU9mZnNldDtcblxuICAgIC8vIElmIHdlJ3JlIHJlbXV4aW5nIGF1ZGlvIGFuZCB2aWRlbyBwcm9ncmVzc2l2ZWx5LCB3YWl0IHVudGlsIHdlJ3ZlIHJlY2VpdmVkIGVub3VnaCBzYW1wbGVzIGZvciBlYWNoIHRyYWNrIGJlZm9yZSBwcm9jZWVkaW5nLlxuICAgIC8vIFRoaXMgaXMgZG9uZSB0byBzeW5jaHJvbml6ZSB0aGUgYXVkaW8gYW5kIHZpZGVvIHN0cmVhbXMuIFdlIGtub3cgaWYgdGhlIGN1cnJlbnQgc2VnbWVudCB3aWxsIGhhdmUgc2FtcGxlcyBpZiB0aGUgXCJwaWRcIlxuICAgIC8vIHBhcmFtZXRlciBpcyBncmVhdGVyIHRoYW4gLTEuIFRoZSBwaWQgaXMgc2V0IHdoZW4gdGhlIFBNVCBpcyBwYXJzZWQsIHdoaWNoIGNvbnRhaW5zIHRoZSB0cmFja3MgbGlzdC5cbiAgICAvLyBIb3dldmVyLCBpZiB0aGUgaW5pdFNlZ21lbnQgaGFzIGFscmVhZHkgYmVlbiBnZW5lcmF0ZWQsIG9yIHdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCBvZiBhIHNlZ21lbnQgKGZsdXNoKSxcbiAgICAvLyB0aGVuIHdlIGNhbiByZW11eCBvbmUgdHJhY2sgd2l0aG91dCB3YWl0aW5nIGZvciB0aGUgb3RoZXIuXG4gICAgY29uc3QgaGFzQXVkaW8gPSBhdWRpb1RyYWNrLnBpZCA+IC0xO1xuICAgIGNvbnN0IGhhc1ZpZGVvID0gdmlkZW9UcmFjay5waWQgPiAtMTtcbiAgICBjb25zdCBsZW5ndGggPSB2aWRlb1RyYWNrLnNhbXBsZXMubGVuZ3RoO1xuICAgIGNvbnN0IGVub3VnaEF1ZGlvU2FtcGxlcyA9IGF1ZGlvVHJhY2suc2FtcGxlcy5sZW5ndGggPiAwO1xuICAgIGNvbnN0IGVub3VnaFZpZGVvU2FtcGxlcyA9IGZsdXNoICYmIGxlbmd0aCA+IDAgfHwgbGVuZ3RoID4gMTtcbiAgICBjb25zdCBjYW5SZW11eEF2YyA9ICghaGFzQXVkaW8gfHwgZW5vdWdoQXVkaW9TYW1wbGVzKSAmJiAoIWhhc1ZpZGVvIHx8IGVub3VnaFZpZGVvU2FtcGxlcykgfHwgdGhpcy5JU0dlbmVyYXRlZCB8fCBmbHVzaDtcbiAgICBpZiAoY2FuUmVtdXhBdmMpIHtcbiAgICAgIGlmICh0aGlzLklTR2VuZXJhdGVkKSB7XG4gICAgICAgIHZhciBfdmlkZW9UcmFjayRwaXhlbFJhdGksIF9jb25maWckcGl4ZWxSYXRpbywgX3ZpZGVvVHJhY2skcGl4ZWxSYXRpMiwgX2NvbmZpZyRwaXhlbFJhdGlvMjtcbiAgICAgICAgY29uc3QgY29uZmlnID0gdGhpcy52aWRlb1RyYWNrQ29uZmlnO1xuICAgICAgICBpZiAoY29uZmlnICYmICh2aWRlb1RyYWNrLndpZHRoICE9PSBjb25maWcud2lkdGggfHwgdmlkZW9UcmFjay5oZWlnaHQgIT09IGNvbmZpZy5oZWlnaHQgfHwgKChfdmlkZW9UcmFjayRwaXhlbFJhdGkgPSB2aWRlb1RyYWNrLnBpeGVsUmF0aW8pID09IG51bGwgPyB2b2lkIDAgOiBfdmlkZW9UcmFjayRwaXhlbFJhdGlbMF0pICE9PSAoKF9jb25maWckcGl4ZWxSYXRpbyA9IGNvbmZpZy5waXhlbFJhdGlvKSA9PSBudWxsID8gdm9pZCAwIDogX2NvbmZpZyRwaXhlbFJhdGlvWzBdKSB8fCAoKF92aWRlb1RyYWNrJHBpeGVsUmF0aTIgPSB2aWRlb1RyYWNrLnBpeGVsUmF0aW8pID09IG51bGwgPyB2b2lkIDAgOiBfdmlkZW9UcmFjayRwaXhlbFJhdGkyWzFdKSAhPT0gKChfY29uZmlnJHBpeGVsUmF0aW8yID0gY29uZmlnLnBpeGVsUmF0aW8pID09IG51bGwgPyB2b2lkIDAgOiBfY29uZmlnJHBpeGVsUmF0aW8yWzFdKSkpIHtcbiAgICAgICAgICB0aGlzLnJlc2V0SW5pdFNlZ21lbnQoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5pdFNlZ21lbnQgPSB0aGlzLmdlbmVyYXRlSVMoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzVmlkZW9Db250aWd1b3VzID0gdGhpcy5pc1ZpZGVvQ29udGlndW91cztcbiAgICAgIGxldCBmaXJzdEtleUZyYW1lSW5kZXggPSAtMTtcbiAgICAgIGxldCBmaXJzdEtleUZyYW1lUFRTO1xuICAgICAgaWYgKGVub3VnaFZpZGVvU2FtcGxlcykge1xuICAgICAgICBmaXJzdEtleUZyYW1lSW5kZXggPSBmaW5kS2V5ZnJhbWVJbmRleCh2aWRlb1RyYWNrLnNhbXBsZXMpO1xuICAgICAgICBpZiAoIWlzVmlkZW9Db250aWd1b3VzICYmIHRoaXMuY29uZmlnLmZvcmNlS2V5RnJhbWVPbkRpc2NvbnRpbnVpdHkpIHtcbiAgICAgICAgICBpbmRlcGVuZGVudCA9IHRydWU7XG4gICAgICAgICAgaWYgKGZpcnN0S2V5RnJhbWVJbmRleCA+IDApIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGBbbXA0LXJlbXV4ZXJdOiBEcm9wcGVkICR7Zmlyc3RLZXlGcmFtZUluZGV4fSBvdXQgb2YgJHtsZW5ndGh9IHZpZGVvIHNhbXBsZXMgZHVlIHRvIGEgbWlzc2luZyBrZXlmcmFtZWApO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRQVFMgPSB0aGlzLmdldFZpZGVvU3RhcnRQdHModmlkZW9UcmFjay5zYW1wbGVzKTtcbiAgICAgICAgICAgIHZpZGVvVHJhY2suc2FtcGxlcyA9IHZpZGVvVHJhY2suc2FtcGxlcy5zbGljZShmaXJzdEtleUZyYW1lSW5kZXgpO1xuICAgICAgICAgICAgdmlkZW9UcmFjay5kcm9wcGVkICs9IGZpcnN0S2V5RnJhbWVJbmRleDtcbiAgICAgICAgICAgIHZpZGVvVGltZU9mZnNldCArPSAodmlkZW9UcmFjay5zYW1wbGVzWzBdLnB0cyAtIHN0YXJ0UFRTKSAvIHZpZGVvVHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gICAgICAgICAgICBmaXJzdEtleUZyYW1lUFRTID0gdmlkZW9UaW1lT2Zmc2V0O1xuICAgICAgICAgIH0gZWxzZSBpZiAoZmlyc3RLZXlGcmFtZUluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oYFttcDQtcmVtdXhlcl06IE5vIGtleWZyYW1lIGZvdW5kIG91dCBvZiAke2xlbmd0aH0gdmlkZW8gc2FtcGxlc2ApO1xuICAgICAgICAgICAgaW5kZXBlbmRlbnQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLklTR2VuZXJhdGVkKSB7XG4gICAgICAgIGlmIChlbm91Z2hBdWRpb1NhbXBsZXMgJiYgZW5vdWdoVmlkZW9TYW1wbGVzKSB7XG4gICAgICAgICAgLy8gdGltZU9mZnNldCBpcyBleHBlY3RlZCB0byBiZSB0aGUgb2Zmc2V0IG9mIHRoZSBmaXJzdCB0aW1lc3RhbXAgb2YgdGhpcyBmcmFnbWVudCAoZmlyc3QgRFRTKVxuICAgICAgICAgIC8vIGlmIGZpcnN0IGF1ZGlvIERUUyBpcyBub3QgYWxpZ25lZCB3aXRoIGZpcnN0IHZpZGVvIERUUyB0aGVuIHdlIG5lZWQgdG8gdGFrZSB0aGF0IGludG8gYWNjb3VudFxuICAgICAgICAgIC8vIHdoZW4gcHJvdmlkaW5nIHRpbWVPZmZzZXQgdG8gcmVtdXhBdWRpbyAvIHJlbXV4VmlkZW8uIGlmIHdlIGRvbid0IGRvIHRoYXQsIHRoZXJlIG1pZ2h0IGJlIGEgcGVybWFuZW50IC8gc21hbGxcbiAgICAgICAgICAvLyBkcmlmdCBiZXR3ZWVuIGF1ZGlvIGFuZCB2aWRlbyBzdHJlYW1zXG4gICAgICAgICAgY29uc3Qgc3RhcnRQVFMgPSB0aGlzLmdldFZpZGVvU3RhcnRQdHModmlkZW9UcmFjay5zYW1wbGVzKTtcbiAgICAgICAgICBjb25zdCB0c0RlbHRhID0gbm9ybWFsaXplUHRzKGF1ZGlvVHJhY2suc2FtcGxlc1swXS5wdHMsIHN0YXJ0UFRTKSAtIHN0YXJ0UFRTO1xuICAgICAgICAgIGNvbnN0IGF1ZGlvdmlkZW9UaW1lc3RhbXBEZWx0YSA9IHRzRGVsdGEgLyB2aWRlb1RyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgICAgICAgIGF1ZGlvVGltZU9mZnNldCArPSBNYXRoLm1heCgwLCBhdWRpb3ZpZGVvVGltZXN0YW1wRGVsdGEpO1xuICAgICAgICAgIHZpZGVvVGltZU9mZnNldCArPSBNYXRoLm1heCgwLCAtYXVkaW92aWRlb1RpbWVzdGFtcERlbHRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFB1cnBvc2VmdWxseSByZW11eGluZyBhdWRpbyBiZWZvcmUgdmlkZW8sIHNvIHRoYXQgcmVtdXhWaWRlbyBjYW4gdXNlIG5leHRBdWRpb1B0cywgd2hpY2ggaXMgY2FsY3VsYXRlZCBpbiByZW11eEF1ZGlvLlxuICAgICAgICBpZiAoZW5vdWdoQXVkaW9TYW1wbGVzKSB7XG4gICAgICAgICAgLy8gaWYgaW5pdFNlZ21lbnQgd2FzIGdlbmVyYXRlZCB3aXRob3V0IGF1ZGlvIHNhbXBsZXMsIHJlZ2VuZXJhdGUgaXQgYWdhaW5cbiAgICAgICAgICBpZiAoIWF1ZGlvVHJhY2suc2FtcGxlcmF0ZSkge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ1ttcDQtcmVtdXhlcl06IHJlZ2VuZXJhdGUgSW5pdFNlZ21lbnQgYXMgYXVkaW8gZGV0ZWN0ZWQnKTtcbiAgICAgICAgICAgIGluaXRTZWdtZW50ID0gdGhpcy5nZW5lcmF0ZUlTKGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF1ZGlvID0gdGhpcy5yZW11eEF1ZGlvKGF1ZGlvVHJhY2ssIGF1ZGlvVGltZU9mZnNldCwgdGhpcy5pc0F1ZGlvQ29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0LCBoYXNWaWRlbyB8fCBlbm91Z2hWaWRlb1NhbXBsZXMgfHwgcGxheWxpc3RUeXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5BVURJTyA/IHZpZGVvVGltZU9mZnNldCA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgaWYgKGVub3VnaFZpZGVvU2FtcGxlcykge1xuICAgICAgICAgICAgY29uc3QgYXVkaW9UcmFja0xlbmd0aCA9IGF1ZGlvID8gYXVkaW8uZW5kUFRTIC0gYXVkaW8uc3RhcnRQVFMgOiAwO1xuICAgICAgICAgICAgLy8gaWYgaW5pdFNlZ21lbnQgd2FzIGdlbmVyYXRlZCB3aXRob3V0IHZpZGVvIHNhbXBsZXMsIHJlZ2VuZXJhdGUgaXQgYWdhaW5cbiAgICAgICAgICAgIGlmICghdmlkZW9UcmFjay5pbnB1dFRpbWVTY2FsZSkge1xuICAgICAgICAgICAgICBsb2dnZXIud2FybignW21wNC1yZW11eGVyXTogcmVnZW5lcmF0ZSBJbml0U2VnbWVudCBhcyB2aWRlbyBkZXRlY3RlZCcpO1xuICAgICAgICAgICAgICBpbml0U2VnbWVudCA9IHRoaXMuZ2VuZXJhdGVJUyhhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCB0aW1lT2Zmc2V0LCBhY2N1cmF0ZVRpbWVPZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmlkZW8gPSB0aGlzLnJlbXV4VmlkZW8odmlkZW9UcmFjaywgdmlkZW9UaW1lT2Zmc2V0LCBpc1ZpZGVvQ29udGlndW91cywgYXVkaW9UcmFja0xlbmd0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGVub3VnaFZpZGVvU2FtcGxlcykge1xuICAgICAgICAgIHZpZGVvID0gdGhpcy5yZW11eFZpZGVvKHZpZGVvVHJhY2ssIHZpZGVvVGltZU9mZnNldCwgaXNWaWRlb0NvbnRpZ3VvdXMsIDApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2aWRlbykge1xuICAgICAgICAgIHZpZGVvLmZpcnN0S2V5RnJhbWUgPSBmaXJzdEtleUZyYW1lSW5kZXg7XG4gICAgICAgICAgdmlkZW8uaW5kZXBlbmRlbnQgPSBmaXJzdEtleUZyYW1lSW5kZXggIT09IC0xO1xuICAgICAgICAgIHZpZGVvLmZpcnN0S2V5RnJhbWVQVFMgPSBmaXJzdEtleUZyYW1lUFRTO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWxsb3cgSUQzIGFuZCB0ZXh0IHRvIHJlbXV4LCBldmVuIGlmIG1vcmUgYXVkaW8vdmlkZW8gc2FtcGxlcyBhcmUgcmVxdWlyZWRcbiAgICBpZiAodGhpcy5JU0dlbmVyYXRlZCAmJiB0aGlzLl9pbml0UFRTICYmIHRoaXMuX2luaXREVFMpIHtcbiAgICAgIGlmIChpZDNUcmFjay5zYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICBpZDMgPSBmbHVzaFRleHRUcmFja01ldGFkYXRhQ3VlU2FtcGxlcyhpZDNUcmFjaywgdGltZU9mZnNldCwgdGhpcy5faW5pdFBUUywgdGhpcy5faW5pdERUUyk7XG4gICAgICB9XG4gICAgICBpZiAodGV4dFRyYWNrLnNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgIHRleHQgPSBmbHVzaFRleHRUcmFja1VzZXJkYXRhQ3VlU2FtcGxlcyh0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIHRoaXMuX2luaXRQVFMpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgYXVkaW8sXG4gICAgICB2aWRlbyxcbiAgICAgIGluaXRTZWdtZW50LFxuICAgICAgaW5kZXBlbmRlbnQsXG4gICAgICB0ZXh0LFxuICAgICAgaWQzXG4gICAgfTtcbiAgfVxuICBnZW5lcmF0ZUlTKGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCkge1xuICAgIGNvbnN0IGF1ZGlvU2FtcGxlcyA9IGF1ZGlvVHJhY2suc2FtcGxlcztcbiAgICBjb25zdCB2aWRlb1NhbXBsZXMgPSB2aWRlb1RyYWNrLnNhbXBsZXM7XG4gICAgY29uc3QgdHlwZVN1cHBvcnRlZCA9IHRoaXMudHlwZVN1cHBvcnRlZDtcbiAgICBjb25zdCB0cmFja3MgPSB7fTtcbiAgICBjb25zdCBfaW5pdFBUUyA9IHRoaXMuX2luaXRQVFM7XG4gICAgbGV0IGNvbXB1dGVQVFNEVFMgPSAhX2luaXRQVFMgfHwgYWNjdXJhdGVUaW1lT2Zmc2V0O1xuICAgIGxldCBjb250YWluZXIgPSAnYXVkaW8vbXA0JztcbiAgICBsZXQgaW5pdFBUUztcbiAgICBsZXQgaW5pdERUUztcbiAgICBsZXQgdGltZXNjYWxlO1xuICAgIGlmIChjb21wdXRlUFRTRFRTKSB7XG4gICAgICBpbml0UFRTID0gaW5pdERUUyA9IEluZmluaXR5O1xuICAgIH1cbiAgICBpZiAoYXVkaW9UcmFjay5jb25maWcgJiYgYXVkaW9TYW1wbGVzLmxlbmd0aCkge1xuICAgICAgLy8gbGV0J3MgdXNlIGF1ZGlvIHNhbXBsaW5nIHJhdGUgYXMgTVA0IHRpbWUgc2NhbGUuXG4gICAgICAvLyByYXRpb25hbGUgaXMgdGhhdCB0aGVyZSBpcyBhIGludGVnZXIgbmIgb2YgYXVkaW8gZnJhbWVzIHBlciBhdWRpbyBzYW1wbGUgKDEwMjQgZm9yIEFBQylcbiAgICAgIC8vIHVzaW5nIGF1ZGlvIHNhbXBsaW5nIHJhdGUgaGVyZSBoZWxwcyBoYXZpbmcgYW4gaW50ZWdlciBNUDQgZnJhbWUgZHVyYXRpb25cbiAgICAgIC8vIHRoaXMgYXZvaWRzIHBvdGVudGlhbCByb3VuZGluZyBpc3N1ZSBhbmQgQVYgc3luYyBpc3N1ZVxuICAgICAgYXVkaW9UcmFjay50aW1lc2NhbGUgPSBhdWRpb1RyYWNrLnNhbXBsZXJhdGU7XG4gICAgICBzd2l0Y2ggKGF1ZGlvVHJhY2suc2VnbWVudENvZGVjKSB7XG4gICAgICAgIGNhc2UgJ21wMyc6XG4gICAgICAgICAgaWYgKHR5cGVTdXBwb3J0ZWQubXBlZykge1xuICAgICAgICAgICAgLy8gQ2hyb21lIGFuZCBTYWZhcmlcbiAgICAgICAgICAgIGNvbnRhaW5lciA9ICdhdWRpby9tcGVnJztcbiAgICAgICAgICAgIGF1ZGlvVHJhY2suY29kZWMgPSAnJztcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVTdXBwb3J0ZWQubXAzKSB7XG4gICAgICAgICAgICAvLyBGaXJlZm94XG4gICAgICAgICAgICBhdWRpb1RyYWNrLmNvZGVjID0gJ21wMyc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdhYzMnOlxuICAgICAgICAgIGF1ZGlvVHJhY2suY29kZWMgPSAnYWMtMyc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB0cmFja3MuYXVkaW8gPSB7XG4gICAgICAgIGlkOiAnYXVkaW8nLFxuICAgICAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAgICAgY29kZWM6IGF1ZGlvVHJhY2suY29kZWMsXG4gICAgICAgIGluaXRTZWdtZW50OiBhdWRpb1RyYWNrLnNlZ21lbnRDb2RlYyA9PT0gJ21wMycgJiYgdHlwZVN1cHBvcnRlZC5tcGVnID8gbmV3IFVpbnQ4QXJyYXkoMCkgOiBNUDQuaW5pdFNlZ21lbnQoW2F1ZGlvVHJhY2tdKSxcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICBjaGFubmVsQ291bnQ6IGF1ZGlvVHJhY2suY2hhbm5lbENvdW50XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAoY29tcHV0ZVBUU0RUUykge1xuICAgICAgICB0aW1lc2NhbGUgPSBhdWRpb1RyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgICAgICBpZiAoIV9pbml0UFRTIHx8IHRpbWVzY2FsZSAhPT0gX2luaXRQVFMudGltZXNjYWxlKSB7XG4gICAgICAgICAgLy8gcmVtZW1iZXIgZmlyc3QgUFRTIG9mIHRoaXMgZGVtdXhpbmcgY29udGV4dC4gZm9yIGF1ZGlvLCBQVFMgPSBEVFNcbiAgICAgICAgICBpbml0UFRTID0gaW5pdERUUyA9IGF1ZGlvU2FtcGxlc1swXS5wdHMgLSBNYXRoLnJvdW5kKHRpbWVzY2FsZSAqIHRpbWVPZmZzZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbXB1dGVQVFNEVFMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodmlkZW9UcmFjay5zcHMgJiYgdmlkZW9UcmFjay5wcHMgJiYgdmlkZW9TYW1wbGVzLmxlbmd0aCkge1xuICAgICAgLy8gbGV0J3MgdXNlIGlucHV0IHRpbWUgc2NhbGUgYXMgTVA0IHZpZGVvIHRpbWVzY2FsZVxuICAgICAgLy8gd2UgdXNlIGlucHV0IHRpbWUgc2NhbGUgc3RyYWlnaHQgYXdheSB0byBhdm9pZCByb3VuZGluZyBpc3N1ZXMgb24gZnJhbWUgZHVyYXRpb24gLyBjdHMgY29tcHV0YXRpb25cbiAgICAgIHZpZGVvVHJhY2sudGltZXNjYWxlID0gdmlkZW9UcmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICAgIHRyYWNrcy52aWRlbyA9IHtcbiAgICAgICAgaWQ6ICdtYWluJyxcbiAgICAgICAgY29udGFpbmVyOiAndmlkZW8vbXA0JyxcbiAgICAgICAgY29kZWM6IHZpZGVvVHJhY2suY29kZWMsXG4gICAgICAgIGluaXRTZWdtZW50OiBNUDQuaW5pdFNlZ21lbnQoW3ZpZGVvVHJhY2tdKSxcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICB3aWR0aDogdmlkZW9UcmFjay53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHZpZGVvVHJhY2suaGVpZ2h0XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAoY29tcHV0ZVBUU0RUUykge1xuICAgICAgICB0aW1lc2NhbGUgPSB2aWRlb1RyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgICAgICBpZiAoIV9pbml0UFRTIHx8IHRpbWVzY2FsZSAhPT0gX2luaXRQVFMudGltZXNjYWxlKSB7XG4gICAgICAgICAgY29uc3Qgc3RhcnRQVFMgPSB0aGlzLmdldFZpZGVvU3RhcnRQdHModmlkZW9TYW1wbGVzKTtcbiAgICAgICAgICBjb25zdCBzdGFydE9mZnNldCA9IE1hdGgucm91bmQodGltZXNjYWxlICogdGltZU9mZnNldCk7XG4gICAgICAgICAgaW5pdERUUyA9IE1hdGgubWluKGluaXREVFMsIG5vcm1hbGl6ZVB0cyh2aWRlb1NhbXBsZXNbMF0uZHRzLCBzdGFydFBUUykgLSBzdGFydE9mZnNldCk7XG4gICAgICAgICAgaW5pdFBUUyA9IE1hdGgubWluKGluaXRQVFMsIHN0YXJ0UFRTIC0gc3RhcnRPZmZzZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbXB1dGVQVFNEVFMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy52aWRlb1RyYWNrQ29uZmlnID0ge1xuICAgICAgICB3aWR0aDogdmlkZW9UcmFjay53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiB2aWRlb1RyYWNrLmhlaWdodCxcbiAgICAgICAgcGl4ZWxSYXRpbzogdmlkZW9UcmFjay5waXhlbFJhdGlvXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmtleXModHJhY2tzKS5sZW5ndGgpIHtcbiAgICAgIHRoaXMuSVNHZW5lcmF0ZWQgPSB0cnVlO1xuICAgICAgaWYgKGNvbXB1dGVQVFNEVFMpIHtcbiAgICAgICAgdGhpcy5faW5pdFBUUyA9IHtcbiAgICAgICAgICBiYXNlVGltZTogaW5pdFBUUyxcbiAgICAgICAgICB0aW1lc2NhbGU6IHRpbWVzY2FsZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9pbml0RFRTID0ge1xuICAgICAgICAgIGJhc2VUaW1lOiBpbml0RFRTLFxuICAgICAgICAgIHRpbWVzY2FsZTogdGltZXNjYWxlXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbml0UFRTID0gdGltZXNjYWxlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHJhY2tzLFxuICAgICAgICBpbml0UFRTLFxuICAgICAgICB0aW1lc2NhbGVcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHJlbXV4VmlkZW8odHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIGF1ZGlvVHJhY2tMZW5ndGgpIHtcbiAgICBjb25zdCB0aW1lU2NhbGUgPSB0cmFjay5pbnB1dFRpbWVTY2FsZTtcbiAgICBjb25zdCBpbnB1dFNhbXBsZXMgPSB0cmFjay5zYW1wbGVzO1xuICAgIGNvbnN0IG91dHB1dFNhbXBsZXMgPSBbXTtcbiAgICBjb25zdCBuYlNhbXBsZXMgPSBpbnB1dFNhbXBsZXMubGVuZ3RoO1xuICAgIGNvbnN0IGluaXRQVFMgPSB0aGlzLl9pbml0UFRTO1xuICAgIGxldCBuZXh0QXZjRHRzID0gdGhpcy5uZXh0QXZjRHRzO1xuICAgIGxldCBvZmZzZXQgPSA4O1xuICAgIGxldCBtcDRTYW1wbGVEdXJhdGlvbiA9IHRoaXMudmlkZW9TYW1wbGVEdXJhdGlvbjtcbiAgICBsZXQgZmlyc3REVFM7XG4gICAgbGV0IGxhc3REVFM7XG4gICAgbGV0IG1pblBUUyA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBsZXQgbWF4UFRTID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgIGxldCBzb3J0U2FtcGxlcyA9IGZhbHNlO1xuXG4gICAgLy8gaWYgcGFyc2VkIGZyYWdtZW50IGlzIGNvbnRpZ3VvdXMgd2l0aCBsYXN0IG9uZSwgbGV0J3MgdXNlIGxhc3QgRFRTIHZhbHVlIGFzIHJlZmVyZW5jZVxuICAgIGlmICghY29udGlndW91cyB8fCBuZXh0QXZjRHRzID09PSBudWxsKSB7XG4gICAgICBjb25zdCBwdHMgPSB0aW1lT2Zmc2V0ICogdGltZVNjYWxlO1xuICAgICAgY29uc3QgY3RzID0gaW5wdXRTYW1wbGVzWzBdLnB0cyAtIG5vcm1hbGl6ZVB0cyhpbnB1dFNhbXBsZXNbMF0uZHRzLCBpbnB1dFNhbXBsZXNbMF0ucHRzKTtcbiAgICAgIGlmIChjaHJvbWVWZXJzaW9uICYmIG5leHRBdmNEdHMgIT09IG51bGwgJiYgTWF0aC5hYnMocHRzIC0gY3RzIC0gbmV4dEF2Y0R0cykgPCAxNTAwMCkge1xuICAgICAgICAvLyB0cmVhdCBhcyBjb250aWdvdXMgdG8gYWRqdXN0IHNhbXBsZXMgdGhhdCB3b3VsZCBvdGhlcndpc2UgcHJvZHVjZSB2aWRlbyBidWZmZXIgZ2FwcyBpbiBDaHJvbWVcbiAgICAgICAgY29udGlndW91cyA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiBub3QgY29udGlndW91cywgbGV0J3MgdXNlIHRhcmdldCB0aW1lT2Zmc2V0XG4gICAgICAgIG5leHRBdmNEdHMgPSBwdHMgLSBjdHM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUFRTIGlzIGNvZGVkIG9uIDMzYml0cywgYW5kIGNhbiBsb29wIGZyb20gLTJeMzIgdG8gMl4zMlxuICAgIC8vIFBUU05vcm1hbGl6ZSB3aWxsIG1ha2UgUFRTL0RUUyB2YWx1ZSBtb25vdG9uaWMsIHdlIHVzZSBsYXN0IGtub3duIERUUyB2YWx1ZSBhcyByZWZlcmVuY2UgdmFsdWVcbiAgICBjb25zdCBpbml0VGltZSA9IGluaXRQVFMuYmFzZVRpbWUgKiB0aW1lU2NhbGUgLyBpbml0UFRTLnRpbWVzY2FsZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5iU2FtcGxlczsgaSsrKSB7XG4gICAgICBjb25zdCBzYW1wbGUgPSBpbnB1dFNhbXBsZXNbaV07XG4gICAgICBzYW1wbGUucHRzID0gbm9ybWFsaXplUHRzKHNhbXBsZS5wdHMgLSBpbml0VGltZSwgbmV4dEF2Y0R0cyk7XG4gICAgICBzYW1wbGUuZHRzID0gbm9ybWFsaXplUHRzKHNhbXBsZS5kdHMgLSBpbml0VGltZSwgbmV4dEF2Y0R0cyk7XG4gICAgICBpZiAoc2FtcGxlLmR0cyA8IGlucHV0U2FtcGxlc1tpID4gMCA/IGkgLSAxIDogaV0uZHRzKSB7XG4gICAgICAgIHNvcnRTYW1wbGVzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzb3J0IHZpZGVvIHNhbXBsZXMgYnkgRFRTIHRoZW4gUFRTIHRoZW4gZGVtdXggaWQgb3JkZXJcbiAgICBpZiAoc29ydFNhbXBsZXMpIHtcbiAgICAgIGlucHV0U2FtcGxlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIGNvbnN0IGRlbHRhZHRzID0gYS5kdHMgLSBiLmR0cztcbiAgICAgICAgY29uc3QgZGVsdGFwdHMgPSBhLnB0cyAtIGIucHRzO1xuICAgICAgICByZXR1cm4gZGVsdGFkdHMgfHwgZGVsdGFwdHM7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBHZXQgZmlyc3QvbGFzdCBEVFNcbiAgICBmaXJzdERUUyA9IGlucHV0U2FtcGxlc1swXS5kdHM7XG4gICAgbGFzdERUUyA9IGlucHV0U2FtcGxlc1tpbnB1dFNhbXBsZXMubGVuZ3RoIC0gMV0uZHRzO1xuXG4gICAgLy8gU2FtcGxlIGR1cmF0aW9uIChhcyBleHBlY3RlZCBieSB0cnVuIE1QNCBib3hlcyksIHNob3VsZCBiZSB0aGUgZGVsdGEgYmV0d2VlbiBzYW1wbGUgRFRTXG4gICAgLy8gc2V0IHRoaXMgY29uc3RhbnQgZHVyYXRpb24gYXMgYmVpbmcgdGhlIGF2ZyBkZWx0YSBiZXR3ZWVuIGNvbnNlY3V0aXZlIERUUy5cbiAgICBjb25zdCBpbnB1dER1cmF0aW9uID0gbGFzdERUUyAtIGZpcnN0RFRTO1xuICAgIGNvbnN0IGF2ZXJhZ2VTYW1wbGVEdXJhdGlvbiA9IGlucHV0RHVyYXRpb24gPyBNYXRoLnJvdW5kKGlucHV0RHVyYXRpb24gLyAobmJTYW1wbGVzIC0gMSkpIDogbXA0U2FtcGxlRHVyYXRpb24gfHwgdHJhY2suaW5wdXRUaW1lU2NhbGUgLyAzMDtcblxuICAgIC8vIGlmIGZyYWdtZW50IGFyZSBjb250aWd1b3VzLCBkZXRlY3QgaG9sZS9vdmVybGFwcGluZyBiZXR3ZWVuIGZyYWdtZW50c1xuICAgIGlmIChjb250aWd1b3VzKSB7XG4gICAgICAvLyBjaGVjayB0aW1lc3RhbXAgY29udGludWl0eSBhY3Jvc3MgY29uc2VjdXRpdmUgZnJhZ21lbnRzICh0aGlzIGlzIHRvIHJlbW92ZSBpbnRlci1mcmFnbWVudCBnYXAvaG9sZSlcbiAgICAgIGNvbnN0IGRlbHRhID0gZmlyc3REVFMgLSBuZXh0QXZjRHRzO1xuICAgICAgY29uc3QgZm91bmRIb2xlID0gZGVsdGEgPiBhdmVyYWdlU2FtcGxlRHVyYXRpb247XG4gICAgICBjb25zdCBmb3VuZE92ZXJsYXAgPSBkZWx0YSA8IC0xO1xuICAgICAgaWYgKGZvdW5kSG9sZSB8fCBmb3VuZE92ZXJsYXApIHtcbiAgICAgICAgaWYgKGZvdW5kSG9sZSkge1xuICAgICAgICAgIGxvZ2dlci53YXJuKGBBVkM6ICR7dG9Nc0Zyb21NcGVnVHNDbG9jayhkZWx0YSwgdHJ1ZSl9IG1zICgke2RlbHRhfWR0cykgaG9sZSBiZXR3ZWVuIGZyYWdtZW50cyBkZXRlY3RlZCBhdCAke3RpbWVPZmZzZXQudG9GaXhlZCgzKX1gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2dnZXIud2FybihgQVZDOiAke3RvTXNGcm9tTXBlZ1RzQ2xvY2soLWRlbHRhLCB0cnVlKX0gbXMgKCR7ZGVsdGF9ZHRzKSBvdmVybGFwcGluZyBiZXR3ZWVuIGZyYWdtZW50cyBkZXRlY3RlZCBhdCAke3RpbWVPZmZzZXQudG9GaXhlZCgzKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZvdW5kT3ZlcmxhcCB8fCBuZXh0QXZjRHRzID49IGlucHV0U2FtcGxlc1swXS5wdHMgfHwgY2hyb21lVmVyc2lvbikge1xuICAgICAgICAgIGZpcnN0RFRTID0gbmV4dEF2Y0R0cztcbiAgICAgICAgICBjb25zdCBmaXJzdFBUUyA9IGlucHV0U2FtcGxlc1swXS5wdHMgLSBkZWx0YTtcbiAgICAgICAgICBpZiAoZm91bmRIb2xlKSB7XG4gICAgICAgICAgICBpbnB1dFNhbXBsZXNbMF0uZHRzID0gZmlyc3REVFM7XG4gICAgICAgICAgICBpbnB1dFNhbXBsZXNbMF0ucHRzID0gZmlyc3RQVFM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRTYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmIChpbnB1dFNhbXBsZXNbaV0uZHRzID4gZmlyc3RQVFMpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpbnB1dFNhbXBsZXNbaV0uZHRzIC09IGRlbHRhO1xuICAgICAgICAgICAgICBpbnB1dFNhbXBsZXNbaV0ucHRzIC09IGRlbHRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBsb2dnZXIubG9nKGBWaWRlbzogSW5pdGlhbCBQVFMvRFRTIGFkanVzdGVkOiAke3RvTXNGcm9tTXBlZ1RzQ2xvY2soZmlyc3RQVFMsIHRydWUpfS8ke3RvTXNGcm9tTXBlZ1RzQ2xvY2soZmlyc3REVFMsIHRydWUpfSwgZGVsdGE6ICR7dG9Nc0Zyb21NcGVnVHNDbG9jayhkZWx0YSwgdHJ1ZSl9IG1zYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZmlyc3REVFMgPSBNYXRoLm1heCgwLCBmaXJzdERUUyk7XG4gICAgbGV0IG5iTmFsdSA9IDA7XG4gICAgbGV0IG5hbHVMZW4gPSAwO1xuICAgIGxldCBkdHNTdGVwID0gZmlyc3REVFM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYlNhbXBsZXM7IGkrKykge1xuICAgICAgLy8gY29tcHV0ZSB0b3RhbC9hdmMgc2FtcGxlIGxlbmd0aCBhbmQgbmIgb2YgTkFMIHVuaXRzXG4gICAgICBjb25zdCBzYW1wbGUgPSBpbnB1dFNhbXBsZXNbaV07XG4gICAgICBjb25zdCB1bml0cyA9IHNhbXBsZS51bml0cztcbiAgICAgIGNvbnN0IG5iVW5pdHMgPSB1bml0cy5sZW5ndGg7XG4gICAgICBsZXQgc2FtcGxlTGVuID0gMDtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbmJVbml0czsgaisrKSB7XG4gICAgICAgIHNhbXBsZUxlbiArPSB1bml0c1tqXS5kYXRhLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIG5hbHVMZW4gKz0gc2FtcGxlTGVuO1xuICAgICAgbmJOYWx1ICs9IG5iVW5pdHM7XG4gICAgICBzYW1wbGUubGVuZ3RoID0gc2FtcGxlTGVuO1xuXG4gICAgICAvLyBlbnN1cmUgc2FtcGxlIG1vbm90b25pYyBEVFNcbiAgICAgIGlmIChzYW1wbGUuZHRzIDwgZHRzU3RlcCkge1xuICAgICAgICBzYW1wbGUuZHRzID0gZHRzU3RlcDtcbiAgICAgICAgZHRzU3RlcCArPSBhdmVyYWdlU2FtcGxlRHVyYXRpb24gLyA0IHwgMCB8fCAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZHRzU3RlcCA9IHNhbXBsZS5kdHM7XG4gICAgICB9XG4gICAgICBtaW5QVFMgPSBNYXRoLm1pbihzYW1wbGUucHRzLCBtaW5QVFMpO1xuICAgICAgbWF4UFRTID0gTWF0aC5tYXgoc2FtcGxlLnB0cywgbWF4UFRTKTtcbiAgICB9XG4gICAgbGFzdERUUyA9IGlucHV0U2FtcGxlc1tuYlNhbXBsZXMgLSAxXS5kdHM7XG5cbiAgICAvKiBjb25jYXRlbmF0ZSB0aGUgdmlkZW8gZGF0YSBhbmQgY29uc3RydWN0IHRoZSBtZGF0IGluIHBsYWNlXG4gICAgICAobmVlZCA4IG1vcmUgYnl0ZXMgdG8gZmlsbCBsZW5ndGggYW5kIG1wZGF0IHR5cGUpICovXG4gICAgY29uc3QgbWRhdFNpemUgPSBuYWx1TGVuICsgNCAqIG5iTmFsdSArIDg7XG4gICAgbGV0IG1kYXQ7XG4gICAgdHJ5IHtcbiAgICAgIG1kYXQgPSBuZXcgVWludDhBcnJheShtZGF0U2l6ZSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLm9ic2VydmVyLmVtaXQoRXZlbnRzLkVSUk9SLCBFdmVudHMuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NVVhfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5SRU1VWF9BTExPQ19FUlJPUixcbiAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyLFxuICAgICAgICBieXRlczogbWRhdFNpemUsXG4gICAgICAgIHJlYXNvbjogYGZhaWwgYWxsb2NhdGluZyB2aWRlbyBtZGF0ICR7bWRhdFNpemV9YFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcobWRhdC5idWZmZXIpO1xuICAgIHZpZXcuc2V0VWludDMyKDAsIG1kYXRTaXplKTtcbiAgICBtZGF0LnNldChNUDQudHlwZXMubWRhdCwgNCk7XG4gICAgbGV0IHN0cmV0Y2hlZExhc3RGcmFtZSA9IGZhbHNlO1xuICAgIGxldCBtaW5EdHNEZWx0YSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBsZXQgbWluUHRzRGVsdGEgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgbGV0IG1heER0c0RlbHRhID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgIGxldCBtYXhQdHNEZWx0YSA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5iU2FtcGxlczsgaSsrKSB7XG4gICAgICBjb25zdCBWaWRlb1NhbXBsZSA9IGlucHV0U2FtcGxlc1tpXTtcbiAgICAgIGNvbnN0IFZpZGVvU2FtcGxlVW5pdHMgPSBWaWRlb1NhbXBsZS51bml0cztcbiAgICAgIGxldCBtcDRTYW1wbGVMZW5ndGggPSAwO1xuICAgICAgLy8gY29udmVydCBOQUxVIGJpdHN0cmVhbSB0byBNUDQgZm9ybWF0IChwcmVwZW5kIE5BTFUgd2l0aCBzaXplIGZpZWxkKVxuICAgICAgZm9yIChsZXQgaiA9IDAsIG5iVW5pdHMgPSBWaWRlb1NhbXBsZVVuaXRzLmxlbmd0aDsgaiA8IG5iVW5pdHM7IGorKykge1xuICAgICAgICBjb25zdCB1bml0ID0gVmlkZW9TYW1wbGVVbml0c1tqXTtcbiAgICAgICAgY29uc3QgdW5pdERhdGEgPSB1bml0LmRhdGE7XG4gICAgICAgIGNvbnN0IHVuaXREYXRhTGVuID0gdW5pdC5kYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCwgdW5pdERhdGFMZW4pO1xuICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgbWRhdC5zZXQodW5pdERhdGEsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSB1bml0RGF0YUxlbjtcbiAgICAgICAgbXA0U2FtcGxlTGVuZ3RoICs9IDQgKyB1bml0RGF0YUxlbjtcbiAgICAgIH1cblxuICAgICAgLy8gZXhwZWN0ZWQgc2FtcGxlIGR1cmF0aW9uIGlzIHRoZSBEZWNvZGluZyBUaW1lc3RhbXAgZGlmZiBvZiBjb25zZWN1dGl2ZSBzYW1wbGVzXG4gICAgICBsZXQgcHRzRGVsdGE7XG4gICAgICBpZiAoaSA8IG5iU2FtcGxlcyAtIDEpIHtcbiAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBpbnB1dFNhbXBsZXNbaSArIDFdLmR0cyAtIFZpZGVvU2FtcGxlLmR0cztcbiAgICAgICAgcHRzRGVsdGEgPSBpbnB1dFNhbXBsZXNbaSArIDFdLnB0cyAtIFZpZGVvU2FtcGxlLnB0cztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgICAgICBjb25zdCBsYXN0RnJhbWVEdXJhdGlvbiA9IGkgPiAwID8gVmlkZW9TYW1wbGUuZHRzIC0gaW5wdXRTYW1wbGVzW2kgLSAxXS5kdHMgOiBhdmVyYWdlU2FtcGxlRHVyYXRpb247XG4gICAgICAgIHB0c0RlbHRhID0gaSA+IDAgPyBWaWRlb1NhbXBsZS5wdHMgLSBpbnB1dFNhbXBsZXNbaSAtIDFdLnB0cyA6IGF2ZXJhZ2VTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgaWYgKGNvbmZpZy5zdHJldGNoU2hvcnRWaWRlb1RyYWNrICYmIHRoaXMubmV4dEF1ZGlvUHRzICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gSW4gc29tZSBjYXNlcywgYSBzZWdtZW50J3MgYXVkaW8gdHJhY2sgZHVyYXRpb24gbWF5IGV4Y2VlZCB0aGUgdmlkZW8gdHJhY2sgZHVyYXRpb24uXG4gICAgICAgICAgLy8gU2luY2Ugd2UndmUgYWxyZWFkeSByZW11eGVkIGF1ZGlvLCBhbmQgd2Uga25vdyBob3cgbG9uZyB0aGUgYXVkaW8gdHJhY2sgaXMsIHdlIGxvb2sgdG9cbiAgICAgICAgICAvLyBzZWUgaWYgdGhlIGRlbHRhIHRvIHRoZSBuZXh0IHNlZ21lbnQgaXMgbG9uZ2VyIHRoYW4gbWF4QnVmZmVySG9sZS5cbiAgICAgICAgICAvLyBJZiBzbywgcGxheWJhY2sgd291bGQgcG90ZW50aWFsbHkgZ2V0IHN0dWNrLCBzbyB3ZSBhcnRpZmljaWFsbHkgaW5mbGF0ZVxuICAgICAgICAgIC8vIHRoZSBkdXJhdGlvbiBvZiB0aGUgbGFzdCBmcmFtZSB0byBtaW5pbWl6ZSBhbnkgcG90ZW50aWFsIGdhcCBiZXR3ZWVuIHNlZ21lbnRzLlxuICAgICAgICAgIGNvbnN0IGdhcFRvbGVyYW5jZSA9IE1hdGguZmxvb3IoY29uZmlnLm1heEJ1ZmZlckhvbGUgKiB0aW1lU2NhbGUpO1xuICAgICAgICAgIGNvbnN0IGRlbHRhVG9GcmFtZUVuZCA9IChhdWRpb1RyYWNrTGVuZ3RoID8gbWluUFRTICsgYXVkaW9UcmFja0xlbmd0aCAqIHRpbWVTY2FsZSA6IHRoaXMubmV4dEF1ZGlvUHRzKSAtIFZpZGVvU2FtcGxlLnB0cztcbiAgICAgICAgICBpZiAoZGVsdGFUb0ZyYW1lRW5kID4gZ2FwVG9sZXJhbmNlKSB7XG4gICAgICAgICAgICAvLyBXZSBzdWJ0cmFjdCBsYXN0RnJhbWVEdXJhdGlvbiBmcm9tIGRlbHRhVG9GcmFtZUVuZCB0byB0cnkgdG8gcHJldmVudCBhbnkgdmlkZW9cbiAgICAgICAgICAgIC8vIGZyYW1lIG92ZXJsYXAuIG1heEJ1ZmZlckhvbGUgc2hvdWxkIGJlID4+IGxhc3RGcmFtZUR1cmF0aW9uIGFueXdheS5cbiAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gZGVsdGFUb0ZyYW1lRW5kIC0gbGFzdEZyYW1lRHVyYXRpb247XG4gICAgICAgICAgICBpZiAobXA0U2FtcGxlRHVyYXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgIG1wNFNhbXBsZUR1cmF0aW9uID0gbGFzdEZyYW1lRHVyYXRpb247XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHJldGNoZWRMYXN0RnJhbWUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLmxvZyhgW21wNC1yZW11eGVyXTogSXQgaXMgYXBwcm94aW1hdGVseSAke2RlbHRhVG9GcmFtZUVuZCAvIDkwfSBtcyB0byB0aGUgbmV4dCBzZWdtZW50OyB1c2luZyBkdXJhdGlvbiAke21wNFNhbXBsZUR1cmF0aW9uIC8gOTB9IG1zIGZvciB0aGUgbGFzdCB2aWRlbyBmcmFtZS5gKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBsYXN0RnJhbWVEdXJhdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbXA0U2FtcGxlRHVyYXRpb24gPSBsYXN0RnJhbWVEdXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgY29tcG9zaXRpb25UaW1lT2Zmc2V0ID0gTWF0aC5yb3VuZChWaWRlb1NhbXBsZS5wdHMgLSBWaWRlb1NhbXBsZS5kdHMpO1xuICAgICAgbWluRHRzRGVsdGEgPSBNYXRoLm1pbihtaW5EdHNEZWx0YSwgbXA0U2FtcGxlRHVyYXRpb24pO1xuICAgICAgbWF4RHRzRGVsdGEgPSBNYXRoLm1heChtYXhEdHNEZWx0YSwgbXA0U2FtcGxlRHVyYXRpb24pO1xuICAgICAgbWluUHRzRGVsdGEgPSBNYXRoLm1pbihtaW5QdHNEZWx0YSwgcHRzRGVsdGEpO1xuICAgICAgbWF4UHRzRGVsdGEgPSBNYXRoLm1heChtYXhQdHNEZWx0YSwgcHRzRGVsdGEpO1xuICAgICAgb3V0cHV0U2FtcGxlcy5wdXNoKG5ldyBNcDRTYW1wbGUoVmlkZW9TYW1wbGUua2V5LCBtcDRTYW1wbGVEdXJhdGlvbiwgbXA0U2FtcGxlTGVuZ3RoLCBjb21wb3NpdGlvblRpbWVPZmZzZXQpKTtcbiAgICB9XG4gICAgaWYgKG91dHB1dFNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICBpZiAoY2hyb21lVmVyc2lvbikge1xuICAgICAgICBpZiAoY2hyb21lVmVyc2lvbiA8IDcwKSB7XG4gICAgICAgICAgLy8gQ2hyb21lIHdvcmthcm91bmQsIG1hcmsgZmlyc3Qgc2FtcGxlIGFzIGJlaW5nIGEgUmFuZG9tIEFjY2VzcyBQb2ludCAoa2V5ZnJhbWUpIHRvIGF2b2lkIHNvdXJjZWJ1ZmZlciBhcHBlbmQgaXNzdWVcbiAgICAgICAgICAvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjI5NDEyXG4gICAgICAgICAgY29uc3QgZmxhZ3MgPSBvdXRwdXRTYW1wbGVzWzBdLmZsYWdzO1xuICAgICAgICAgIGZsYWdzLmRlcGVuZHNPbiA9IDI7XG4gICAgICAgICAgZmxhZ3MuaXNOb25TeW5jID0gMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzYWZhcmlXZWJraXRWZXJzaW9uKSB7XG4gICAgICAgIC8vIEZpeCBmb3IgXCJDTk4gc3BlY2lhbCByZXBvcnQsIHdpdGggQ0NcIiBpbiB0ZXN0LXN0cmVhbXMgKFNhZmFyaSBicm93c2VyIG9ubHkpXG4gICAgICAgIC8vIElnbm9yZSBEVFMgd2hlbiBmcmFtZSBkdXJhdGlvbnMgYXJlIGlycmVndWxhci4gU2FmYXJpIE1TRSBkb2VzIG5vdCBoYW5kbGUgdGhpcyBsZWFkaW5nIHRvIGdhcHMuXG4gICAgICAgIGlmIChtYXhQdHNEZWx0YSAtIG1pblB0c0RlbHRhIDwgbWF4RHRzRGVsdGEgLSBtaW5EdHNEZWx0YSAmJiBhdmVyYWdlU2FtcGxlRHVyYXRpb24gLyBtYXhEdHNEZWx0YSA8IDAuMDI1ICYmIG91dHB1dFNhbXBsZXNbMF0uY3RzID09PSAwKSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oJ0ZvdW5kIGlycmVndWxhciBnYXBzIGluIHNhbXBsZSBkdXJhdGlvbi4gVXNpbmcgUFRTIGluc3RlYWQgb2YgRFRTIHRvIGRldGVybWluZSBNUDQgc2FtcGxlIGR1cmF0aW9uLicpO1xuICAgICAgICAgIGxldCBkdHMgPSBmaXJzdERUUztcbiAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gb3V0cHV0U2FtcGxlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbmV4dER0cyA9IGR0cyArIG91dHB1dFNhbXBsZXNbaV0uZHVyYXRpb247XG4gICAgICAgICAgICBjb25zdCBwdHMgPSBkdHMgKyBvdXRwdXRTYW1wbGVzW2ldLmN0cztcbiAgICAgICAgICAgIGlmIChpIDwgbGVuIC0gMSkge1xuICAgICAgICAgICAgICBjb25zdCBuZXh0UHRzID0gbmV4dER0cyArIG91dHB1dFNhbXBsZXNbaSArIDFdLmN0cztcbiAgICAgICAgICAgICAgb3V0cHV0U2FtcGxlc1tpXS5kdXJhdGlvbiA9IG5leHRQdHMgLSBwdHM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvdXRwdXRTYW1wbGVzW2ldLmR1cmF0aW9uID0gaSA/IG91dHB1dFNhbXBsZXNbaSAtIDFdLmR1cmF0aW9uIDogYXZlcmFnZVNhbXBsZUR1cmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0cHV0U2FtcGxlc1tpXS5jdHMgPSAwO1xuICAgICAgICAgICAgZHRzID0gbmV4dER0cztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gbmV4dCBBVkMgc2FtcGxlIERUUyBzaG91bGQgYmUgZXF1YWwgdG8gbGFzdCBzYW1wbGUgRFRTICsgbGFzdCBzYW1wbGUgZHVyYXRpb24gKGluIFBFUyB0aW1lc2NhbGUpXG4gICAgbXA0U2FtcGxlRHVyYXRpb24gPSBzdHJldGNoZWRMYXN0RnJhbWUgfHwgIW1wNFNhbXBsZUR1cmF0aW9uID8gYXZlcmFnZVNhbXBsZUR1cmF0aW9uIDogbXA0U2FtcGxlRHVyYXRpb247XG4gICAgdGhpcy5uZXh0QXZjRHRzID0gbmV4dEF2Y0R0cyA9IGxhc3REVFMgKyBtcDRTYW1wbGVEdXJhdGlvbjtcbiAgICB0aGlzLnZpZGVvU2FtcGxlRHVyYXRpb24gPSBtcDRTYW1wbGVEdXJhdGlvbjtcbiAgICB0aGlzLmlzVmlkZW9Db250aWd1b3VzID0gdHJ1ZTtcbiAgICBjb25zdCBtb29mID0gTVA0Lm1vb2YodHJhY2suc2VxdWVuY2VOdW1iZXIrKywgZmlyc3REVFMsIF9leHRlbmRzKHt9LCB0cmFjaywge1xuICAgICAgc2FtcGxlczogb3V0cHV0U2FtcGxlc1xuICAgIH0pKTtcbiAgICBjb25zdCB0eXBlID0gJ3ZpZGVvJztcbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgZGF0YTE6IG1vb2YsXG4gICAgICBkYXRhMjogbWRhdCxcbiAgICAgIHN0YXJ0UFRTOiBtaW5QVFMgLyB0aW1lU2NhbGUsXG4gICAgICBlbmRQVFM6IChtYXhQVFMgKyBtcDRTYW1wbGVEdXJhdGlvbikgLyB0aW1lU2NhbGUsXG4gICAgICBzdGFydERUUzogZmlyc3REVFMgLyB0aW1lU2NhbGUsXG4gICAgICBlbmREVFM6IG5leHRBdmNEdHMgLyB0aW1lU2NhbGUsXG4gICAgICB0eXBlLFxuICAgICAgaGFzQXVkaW86IGZhbHNlLFxuICAgICAgaGFzVmlkZW86IHRydWUsXG4gICAgICBuYjogb3V0cHV0U2FtcGxlcy5sZW5ndGgsXG4gICAgICBkcm9wcGVkOiB0cmFjay5kcm9wcGVkXG4gICAgfTtcbiAgICB0cmFjay5zYW1wbGVzID0gW107XG4gICAgdHJhY2suZHJvcHBlZCA9IDA7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgZ2V0U2FtcGxlc1BlckZyYW1lKHRyYWNrKSB7XG4gICAgc3dpdGNoICh0cmFjay5zZWdtZW50Q29kZWMpIHtcbiAgICAgIGNhc2UgJ21wMyc6XG4gICAgICAgIHJldHVybiBNUEVHX0FVRElPX1NBTVBMRV9QRVJfRlJBTUU7XG4gICAgICBjYXNlICdhYzMnOlxuICAgICAgICByZXR1cm4gQUMzX1NBTVBMRVNfUEVSX0ZSQU1FO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIEFBQ19TQU1QTEVTX1BFUl9GUkFNRTtcbiAgICB9XG4gIH1cbiAgcmVtdXhBdWRpbyh0cmFjaywgdGltZU9mZnNldCwgY29udGlndW91cywgYWNjdXJhdGVUaW1lT2Zmc2V0LCB2aWRlb1RpbWVPZmZzZXQpIHtcbiAgICBjb25zdCBpbnB1dFRpbWVTY2FsZSA9IHRyYWNrLmlucHV0VGltZVNjYWxlO1xuICAgIGNvbnN0IG1wNHRpbWVTY2FsZSA9IHRyYWNrLnNhbXBsZXJhdGUgPyB0cmFjay5zYW1wbGVyYXRlIDogaW5wdXRUaW1lU2NhbGU7XG4gICAgY29uc3Qgc2NhbGVGYWN0b3IgPSBpbnB1dFRpbWVTY2FsZSAvIG1wNHRpbWVTY2FsZTtcbiAgICBjb25zdCBtcDRTYW1wbGVEdXJhdGlvbiA9IHRoaXMuZ2V0U2FtcGxlc1BlckZyYW1lKHRyYWNrKTtcbiAgICBjb25zdCBpbnB1dFNhbXBsZUR1cmF0aW9uID0gbXA0U2FtcGxlRHVyYXRpb24gKiBzY2FsZUZhY3RvcjtcbiAgICBjb25zdCBpbml0UFRTID0gdGhpcy5faW5pdFBUUztcbiAgICBjb25zdCByYXdNUEVHID0gdHJhY2suc2VnbWVudENvZGVjID09PSAnbXAzJyAmJiB0aGlzLnR5cGVTdXBwb3J0ZWQubXBlZztcbiAgICBjb25zdCBvdXRwdXRTYW1wbGVzID0gW107XG4gICAgY29uc3QgYWxpZ25lZFdpdGhWaWRlbyA9IHZpZGVvVGltZU9mZnNldCAhPT0gdW5kZWZpbmVkO1xuICAgIGxldCBpbnB1dFNhbXBsZXMgPSB0cmFjay5zYW1wbGVzO1xuICAgIGxldCBvZmZzZXQgPSByYXdNUEVHID8gMCA6IDg7XG4gICAgbGV0IG5leHRBdWRpb1B0cyA9IHRoaXMubmV4dEF1ZGlvUHRzIHx8IC0xO1xuXG4gICAgLy8gd2luZG93LmF1ZGlvU2FtcGxlcyA/IHdpbmRvdy5hdWRpb1NhbXBsZXMucHVzaChpbnB1dFNhbXBsZXMubWFwKHMgPT4gcy5wdHMpKSA6ICh3aW5kb3cuYXVkaW9TYW1wbGVzID0gW2lucHV0U2FtcGxlcy5tYXAocyA9PiBzLnB0cyldKTtcblxuICAgIC8vIGZvciBhdWRpbyBzYW1wbGVzLCBhbHNvIGNvbnNpZGVyIGNvbnNlY3V0aXZlIGZyYWdtZW50cyBhcyBiZWluZyBjb250aWd1b3VzIChldmVuIGlmIGEgbGV2ZWwgc3dpdGNoIG9jY3VycyksXG4gICAgLy8gZm9yIHNha2Ugb2YgY2xhcml0eTpcbiAgICAvLyBjb25zZWN1dGl2ZSBmcmFnbWVudHMgYXJlIGZyYWdzIHdpdGhcbiAgICAvLyAgLSBsZXNzIHRoYW4gMTAwbXMgZ2FwcyBiZXR3ZWVuIG5ldyB0aW1lIG9mZnNldCAoaWYgYWNjdXJhdGUpIGFuZCBuZXh0IGV4cGVjdGVkIFBUUyBPUlxuICAgIC8vICAtIGxlc3MgdGhhbiAyMCBhdWRpbyBmcmFtZXMgZGlzdGFuY2VcbiAgICAvLyBjb250aWd1b3VzIGZyYWdtZW50cyBhcmUgY29uc2VjdXRpdmUgZnJhZ21lbnRzIGZyb20gc2FtZSBxdWFsaXR5IGxldmVsIChzYW1lIGxldmVsLCBuZXcgU04gPSBvbGQgU04gKyAxKVxuICAgIC8vIHRoaXMgaGVscHMgZW5zdXJpbmcgYXVkaW8gY29udGludWl0eVxuICAgIC8vIGFuZCB0aGlzIGFsc28gYXZvaWRzIGF1ZGlvIGdsaXRjaGVzL2N1dCB3aGVuIHN3aXRjaGluZyBxdWFsaXR5LCBvciByZXBvcnRpbmcgd3JvbmcgZHVyYXRpb24gb24gZmlyc3QgYXVkaW8gZnJhbWVcbiAgICBjb25zdCB0aW1lT2Zmc2V0TXBlZ1RTID0gdGltZU9mZnNldCAqIGlucHV0VGltZVNjYWxlO1xuICAgIGNvbnN0IGluaXRUaW1lID0gaW5pdFBUUy5iYXNlVGltZSAqIGlucHV0VGltZVNjYWxlIC8gaW5pdFBUUy50aW1lc2NhbGU7XG4gICAgdGhpcy5pc0F1ZGlvQ29udGlndW91cyA9IGNvbnRpZ3VvdXMgPSBjb250aWd1b3VzIHx8IGlucHV0U2FtcGxlcy5sZW5ndGggJiYgbmV4dEF1ZGlvUHRzID4gMCAmJiAoYWNjdXJhdGVUaW1lT2Zmc2V0ICYmIE1hdGguYWJzKHRpbWVPZmZzZXRNcGVnVFMgLSBuZXh0QXVkaW9QdHMpIDwgOTAwMCB8fCBNYXRoLmFicyhub3JtYWxpemVQdHMoaW5wdXRTYW1wbGVzWzBdLnB0cyAtIGluaXRUaW1lLCB0aW1lT2Zmc2V0TXBlZ1RTKSAtIG5leHRBdWRpb1B0cykgPCAyMCAqIGlucHV0U2FtcGxlRHVyYXRpb24pO1xuXG4gICAgLy8gY29tcHV0ZSBub3JtYWxpemVkIFBUU1xuICAgIGlucHV0U2FtcGxlcy5mb3JFYWNoKGZ1bmN0aW9uIChzYW1wbGUpIHtcbiAgICAgIHNhbXBsZS5wdHMgPSBub3JtYWxpemVQdHMoc2FtcGxlLnB0cyAtIGluaXRUaW1lLCB0aW1lT2Zmc2V0TXBlZ1RTKTtcbiAgICB9KTtcbiAgICBpZiAoIWNvbnRpZ3VvdXMgfHwgbmV4dEF1ZGlvUHRzIDwgMCkge1xuICAgICAgLy8gZmlsdGVyIG91dCBzYW1wbGUgd2l0aCBuZWdhdGl2ZSBQVFMgdGhhdCBhcmUgbm90IHBsYXlhYmxlIGFueXdheVxuICAgICAgLy8gaWYgd2UgZG9uJ3QgcmVtb3ZlIHRoZXNlIG5lZ2F0aXZlIHNhbXBsZXMsIHRoZXkgd2lsbCBzaGlmdCBhbGwgYXVkaW8gc2FtcGxlcyBmb3J3YXJkLlxuICAgICAgLy8gbGVhZGluZyB0byBhdWRpbyBvdmVybGFwIGJldHdlZW4gY3VycmVudCAvIG5leHQgZnJhZ21lbnRcbiAgICAgIGlucHV0U2FtcGxlcyA9IGlucHV0U2FtcGxlcy5maWx0ZXIoc2FtcGxlID0+IHNhbXBsZS5wdHMgPj0gMCk7XG5cbiAgICAgIC8vIGluIGNhc2UgYWxsIHNhbXBsZXMgaGF2ZSBuZWdhdGl2ZSBQVFMsIGFuZCBoYXZlIGJlZW4gZmlsdGVyZWQgb3V0LCByZXR1cm4gbm93XG4gICAgICBpZiAoIWlucHV0U2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHZpZGVvVGltZU9mZnNldCA9PT0gMCkge1xuICAgICAgICAvLyBTZXQgdGhlIHN0YXJ0IHRvIDAgdG8gbWF0Y2ggdmlkZW8gc28gdGhhdCBzdGFydCBnYXBzIGxhcmdlciB0aGFuIGlucHV0U2FtcGxlRHVyYXRpb24gYXJlIGZpbGxlZCB3aXRoIHNpbGVuY2VcbiAgICAgICAgbmV4dEF1ZGlvUHRzID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoYWNjdXJhdGVUaW1lT2Zmc2V0ICYmICFhbGlnbmVkV2l0aFZpZGVvKSB7XG4gICAgICAgIC8vIFdoZW4gbm90IHNlZWtpbmcsIG5vdCBsaXZlLCBhbmQgTGV2ZWxEZXRhaWxzLlBUU0tub3duLCB1c2UgZnJhZ21lbnQgc3RhcnQgYXMgcHJlZGljdGVkIG5leHQgYXVkaW8gUFRTXG4gICAgICAgIG5leHRBdWRpb1B0cyA9IE1hdGgubWF4KDAsIHRpbWVPZmZzZXRNcGVnVFMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgZnJhZ3MgYXJlIG5vdCBjb250aWd1b3VzIGFuZCBpZiB3ZSBjYW50IHRydXN0IHRpbWUgb2Zmc2V0LCBsZXQncyB1c2UgZmlyc3Qgc2FtcGxlIFBUUyBhcyBuZXh0IGF1ZGlvIFBUU1xuICAgICAgICBuZXh0QXVkaW9QdHMgPSBpbnB1dFNhbXBsZXNbMF0ucHRzO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBhdWRpbyB0cmFjayBpcyBtaXNzaW5nIHNhbXBsZXMsIHRoZSBmcmFtZXMgc2VlbSB0byBnZXQgXCJsZWZ0LXNoaWZ0ZWRcIiB3aXRoaW4gdGhlXG4gICAgLy8gcmVzdWx0aW5nIG1wNCBzZWdtZW50LCBjYXVzaW5nIHN5bmMgaXNzdWVzIGFuZCBsZWF2aW5nIGdhcHMgYXQgdGhlIGVuZCBvZiB0aGUgYXVkaW8gc2VnbWVudC5cbiAgICAvLyBJbiBhbiBlZmZvcnQgdG8gcHJldmVudCB0aGlzIGZyb20gaGFwcGVuaW5nLCB3ZSBpbmplY3QgZnJhbWVzIGhlcmUgd2hlcmUgdGhlcmUgYXJlIGdhcHMuXG4gICAgLy8gV2hlbiBwb3NzaWJsZSwgd2UgaW5qZWN0IGEgc2lsZW50IGZyYW1lOyB3aGVuIHRoYXQncyBub3QgcG9zc2libGUsIHdlIGR1cGxpY2F0ZSB0aGUgbGFzdFxuICAgIC8vIGZyYW1lLlxuXG4gICAgaWYgKHRyYWNrLnNlZ21lbnRDb2RlYyA9PT0gJ2FhYycpIHtcbiAgICAgIGNvbnN0IG1heEF1ZGlvRnJhbWVzRHJpZnQgPSB0aGlzLmNvbmZpZy5tYXhBdWRpb0ZyYW1lc0RyaWZ0O1xuICAgICAgZm9yIChsZXQgaSA9IDAsIG5leHRQdHMgPSBuZXh0QXVkaW9QdHM7IGkgPCBpbnB1dFNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gRmlyc3QsIGxldCdzIHNlZSBob3cgZmFyIG9mZiB0aGlzIGZyYW1lIGlzIGZyb20gd2hlcmUgd2UgZXhwZWN0IGl0IHRvIGJlXG4gICAgICAgIGNvbnN0IHNhbXBsZSA9IGlucHV0U2FtcGxlc1tpXTtcbiAgICAgICAgY29uc3QgcHRzID0gc2FtcGxlLnB0cztcbiAgICAgICAgY29uc3QgZGVsdGEgPSBwdHMgLSBuZXh0UHRzO1xuICAgICAgICBjb25zdCBkdXJhdGlvbiA9IE1hdGguYWJzKDEwMDAgKiBkZWx0YSAvIGlucHV0VGltZVNjYWxlKTtcblxuICAgICAgICAvLyBXaGVuIHJlbXV4aW5nIHdpdGggdmlkZW8sIGlmIHdlJ3JlIG92ZXJsYXBwaW5nIGJ5IG1vcmUgdGhhbiBhIGR1cmF0aW9uLCBkcm9wIHRoaXMgc2FtcGxlIHRvIHN0YXkgaW4gc3luY1xuICAgICAgICBpZiAoZGVsdGEgPD0gLW1heEF1ZGlvRnJhbWVzRHJpZnQgKiBpbnB1dFNhbXBsZUR1cmF0aW9uICYmIGFsaWduZWRXaXRoVmlkZW8pIHtcbiAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oYEF1ZGlvIGZyYW1lIEAgJHsocHRzIC8gaW5wdXRUaW1lU2NhbGUpLnRvRml4ZWQoMyl9cyBvdmVybGFwcyBuZXh0QXVkaW9QdHMgYnkgJHtNYXRoLnJvdW5kKDEwMDAgKiBkZWx0YSAvIGlucHV0VGltZVNjYWxlKX0gbXMuYCk7XG4gICAgICAgICAgICB0aGlzLm5leHRBdWRpb1B0cyA9IG5leHRBdWRpb1B0cyA9IG5leHRQdHMgPSBwdHM7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgYnJhY2Utc3R5bGVcblxuICAgICAgICAvLyBJbnNlcnQgbWlzc2luZyBmcmFtZXMgaWY6XG4gICAgICAgIC8vIDE6IFdlJ3JlIG1vcmUgdGhhbiBtYXhBdWRpb0ZyYW1lc0RyaWZ0IGZyYW1lIGF3YXlcbiAgICAgICAgLy8gMjogTm90IG1vcmUgdGhhbiBNQVhfU0lMRU5UX0ZSQU1FX0RVUkFUSU9OIGF3YXlcbiAgICAgICAgLy8gMzogY3VycmVudFRpbWUgKGFrYSBuZXh0UHRzTm9ybSkgaXMgbm90IDBcbiAgICAgICAgLy8gNDogcmVtdXhpbmcgd2l0aCB2aWRlbyAodmlkZW9UaW1lT2Zmc2V0ICE9PSB1bmRlZmluZWQpXG4gICAgICAgIGVsc2UgaWYgKGRlbHRhID49IG1heEF1ZGlvRnJhbWVzRHJpZnQgKiBpbnB1dFNhbXBsZUR1cmF0aW9uICYmIGR1cmF0aW9uIDwgTUFYX1NJTEVOVF9GUkFNRV9EVVJBVElPTiAmJiBhbGlnbmVkV2l0aFZpZGVvKSB7XG4gICAgICAgICAgbGV0IG1pc3NpbmcgPSBNYXRoLnJvdW5kKGRlbHRhIC8gaW5wdXRTYW1wbGVEdXJhdGlvbik7XG4gICAgICAgICAgLy8gQWRqdXN0IG5leHRQdHMgc28gdGhhdCBzaWxlbnQgc2FtcGxlcyBhcmUgYWxpZ25lZCB3aXRoIG1lZGlhIHB0cy4gVGhpcyB3aWxsIHByZXZlbnQgbWVkaWEgc2FtcGxlcyBmcm9tXG4gICAgICAgICAgLy8gbGF0ZXIgYmVpbmcgc2hpZnRlZCBpZiBuZXh0UHRzIGlzIGJhc2VkIG9uIHRpbWVPZmZzZXQgYW5kIGRlbHRhIGlzIG5vdCBhIG11bHRpcGxlIG9mIGlucHV0U2FtcGxlRHVyYXRpb24uXG4gICAgICAgICAgbmV4dFB0cyA9IHB0cyAtIG1pc3NpbmcgKiBpbnB1dFNhbXBsZUR1cmF0aW9uO1xuICAgICAgICAgIGlmIChuZXh0UHRzIDwgMCkge1xuICAgICAgICAgICAgbWlzc2luZy0tO1xuICAgICAgICAgICAgbmV4dFB0cyArPSBpbnB1dFNhbXBsZUR1cmF0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0QXVkaW9QdHMgPSBuZXh0QXVkaW9QdHMgPSBuZXh0UHRzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsb2dnZXIud2FybihgW21wNC1yZW11eGVyXTogSW5qZWN0aW5nICR7bWlzc2luZ30gYXVkaW8gZnJhbWUgQCAkeyhuZXh0UHRzIC8gaW5wdXRUaW1lU2NhbGUpLnRvRml4ZWQoMyl9cyBkdWUgdG8gJHtNYXRoLnJvdW5kKDEwMDAgKiBkZWx0YSAvIGlucHV0VGltZVNjYWxlKX0gbXMgZ2FwLmApO1xuICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbWlzc2luZzsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdTdGFtcCA9IE1hdGgubWF4KG5leHRQdHMsIDApO1xuICAgICAgICAgICAgbGV0IGZpbGxGcmFtZSA9IEFBQy5nZXRTaWxlbnRGcmFtZSh0cmFjay5tYW5pZmVzdENvZGVjIHx8IHRyYWNrLmNvZGVjLCB0cmFjay5jaGFubmVsQ291bnQpO1xuICAgICAgICAgICAgaWYgKCFmaWxsRnJhbWUpIHtcbiAgICAgICAgICAgICAgbG9nZ2VyLmxvZygnW21wNC1yZW11eGVyXTogVW5hYmxlIHRvIGdldCBzaWxlbnQgZnJhbWUgZm9yIGdpdmVuIGF1ZGlvIGNvZGVjOyBkdXBsaWNhdGluZyBsYXN0IGZyYW1lIGluc3RlYWQuJyk7XG4gICAgICAgICAgICAgIGZpbGxGcmFtZSA9IHNhbXBsZS51bml0LnN1YmFycmF5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnB1dFNhbXBsZXMuc3BsaWNlKGksIDAsIHtcbiAgICAgICAgICAgICAgdW5pdDogZmlsbEZyYW1lLFxuICAgICAgICAgICAgICBwdHM6IG5ld1N0YW1wXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG5leHRQdHMgKz0gaW5wdXRTYW1wbGVEdXJhdGlvbjtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2FtcGxlLnB0cyA9IG5leHRQdHM7XG4gICAgICAgIG5leHRQdHMgKz0gaW5wdXRTYW1wbGVEdXJhdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGZpcnN0UFRTID0gbnVsbDtcbiAgICBsZXQgbGFzdFBUUyA9IG51bGw7XG4gICAgbGV0IG1kYXQ7XG4gICAgbGV0IG1kYXRTaXplID0gMDtcbiAgICBsZXQgc2FtcGxlTGVuZ3RoID0gaW5wdXRTYW1wbGVzLmxlbmd0aDtcbiAgICB3aGlsZSAoc2FtcGxlTGVuZ3RoLS0pIHtcbiAgICAgIG1kYXRTaXplICs9IGlucHV0U2FtcGxlc1tzYW1wbGVMZW5ndGhdLnVuaXQuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgZm9yIChsZXQgaiA9IDAsIF9uYlNhbXBsZXMgPSBpbnB1dFNhbXBsZXMubGVuZ3RoOyBqIDwgX25iU2FtcGxlczsgaisrKSB7XG4gICAgICBjb25zdCBhdWRpb1NhbXBsZSA9IGlucHV0U2FtcGxlc1tqXTtcbiAgICAgIGNvbnN0IHVuaXQgPSBhdWRpb1NhbXBsZS51bml0O1xuICAgICAgbGV0IHB0cyA9IGF1ZGlvU2FtcGxlLnB0cztcbiAgICAgIGlmIChsYXN0UFRTICE9PSBudWxsKSB7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgbW9yZSB0aGFuIG9uZSBzYW1wbGUsIHNldCB0aGUgZHVyYXRpb24gb2YgdGhlIHNhbXBsZSB0byB0aGUgXCJyZWFsXCIgZHVyYXRpb247IHRoZSBQVFMgZGlmZiB3aXRoXG4gICAgICAgIC8vIHRoZSBwcmV2aW91cyBzYW1wbGVcbiAgICAgICAgY29uc3QgcHJldlNhbXBsZSA9IG91dHB1dFNhbXBsZXNbaiAtIDFdO1xuICAgICAgICBwcmV2U2FtcGxlLmR1cmF0aW9uID0gTWF0aC5yb3VuZCgocHRzIC0gbGFzdFBUUykgLyBzY2FsZUZhY3Rvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY29udGlndW91cyAmJiB0cmFjay5zZWdtZW50Q29kZWMgPT09ICdhYWMnKSB7XG4gICAgICAgICAgLy8gc2V0IFBUUy9EVFMgdG8gZXhwZWN0ZWQgUFRTL0RUU1xuICAgICAgICAgIHB0cyA9IG5leHRBdWRpb1B0cztcbiAgICAgICAgfVxuICAgICAgICAvLyByZW1lbWJlciBmaXJzdCBQVFMgb2Ygb3VyIGF1ZGlvU2FtcGxlc1xuICAgICAgICBmaXJzdFBUUyA9IHB0cztcbiAgICAgICAgaWYgKG1kYXRTaXplID4gMCkge1xuICAgICAgICAgIC8qIGNvbmNhdGVuYXRlIHRoZSBhdWRpbyBkYXRhIGFuZCBjb25zdHJ1Y3QgdGhlIG1kYXQgaW4gcGxhY2VcbiAgICAgICAgICAgIChuZWVkIDggbW9yZSBieXRlcyB0byBmaWxsIGxlbmd0aCBhbmQgbWRhdCB0eXBlKSAqL1xuICAgICAgICAgIG1kYXRTaXplICs9IG9mZnNldDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbWRhdCA9IG5ldyBVaW50OEFycmF5KG1kYXRTaXplKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIuZW1pdChFdmVudHMuRVJST1IsIEV2ZW50cy5FUlJPUiwge1xuICAgICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1VWF9FUlJPUixcbiAgICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLlJFTVVYX0FMTE9DX0VSUk9SLFxuICAgICAgICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgICAgICAgIGVycm9yOiBlcnIsXG4gICAgICAgICAgICAgIGJ5dGVzOiBtZGF0U2l6ZSxcbiAgICAgICAgICAgICAgcmVhc29uOiBgZmFpbCBhbGxvY2F0aW5nIGF1ZGlvIG1kYXQgJHttZGF0U2l6ZX1gXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFyYXdNUEVHKSB7XG4gICAgICAgICAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KG1kYXQuYnVmZmVyKTtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDMyKDAsIG1kYXRTaXplKTtcbiAgICAgICAgICAgIG1kYXQuc2V0KE1QNC50eXBlcy5tZGF0LCA0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbm8gYXVkaW8gc2FtcGxlc1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbWRhdC5zZXQodW5pdCwgb2Zmc2V0KTtcbiAgICAgIGNvbnN0IHVuaXRMZW4gPSB1bml0LmJ5dGVMZW5ndGg7XG4gICAgICBvZmZzZXQgKz0gdW5pdExlbjtcbiAgICAgIC8vIERlZmF1bHQgdGhlIHNhbXBsZSdzIGR1cmF0aW9uIHRvIHRoZSBjb21wdXRlZCBtcDRTYW1wbGVEdXJhdGlvbiwgd2hpY2ggd2lsbCBlaXRoZXIgYmUgMTAyNCBmb3IgQUFDIG9yIDExNTIgZm9yIE1QRUdcbiAgICAgIC8vIEluIHRoZSBjYXNlIHRoYXQgd2UgaGF2ZSAxIHNhbXBsZSwgdGhpcyB3aWxsIGJlIHRoZSBkdXJhdGlvbi4gSWYgd2UgaGF2ZSBtb3JlIHRoYW4gb25lIHNhbXBsZSwgdGhlIGR1cmF0aW9uXG4gICAgICAvLyBiZWNvbWVzIHRoZSBQVFMgZGlmZiB3aXRoIHRoZSBwcmV2aW91cyBzYW1wbGVcbiAgICAgIG91dHB1dFNhbXBsZXMucHVzaChuZXcgTXA0U2FtcGxlKHRydWUsIG1wNFNhbXBsZUR1cmF0aW9uLCB1bml0TGVuLCAwKSk7XG4gICAgICBsYXN0UFRTID0gcHRzO1xuICAgIH1cblxuICAgIC8vIFdlIGNvdWxkIGVuZCB1cCB3aXRoIG5vIGF1ZGlvIHNhbXBsZXMgaWYgYWxsIGlucHV0IHNhbXBsZXMgd2VyZSBvdmVybGFwcGluZyB3aXRoIHRoZSBwcmV2aW91c2x5IHJlbXV4ZWQgb25lc1xuICAgIGNvbnN0IG5iU2FtcGxlcyA9IG91dHB1dFNhbXBsZXMubGVuZ3RoO1xuICAgIGlmICghbmJTYW1wbGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVGhlIG5leHQgYXVkaW8gc2FtcGxlIFBUUyBzaG91bGQgYmUgZXF1YWwgdG8gbGFzdCBzYW1wbGUgUFRTICsgZHVyYXRpb25cbiAgICBjb25zdCBsYXN0U2FtcGxlID0gb3V0cHV0U2FtcGxlc1tvdXRwdXRTYW1wbGVzLmxlbmd0aCAtIDFdO1xuICAgIHRoaXMubmV4dEF1ZGlvUHRzID0gbmV4dEF1ZGlvUHRzID0gbGFzdFBUUyArIHNjYWxlRmFjdG9yICogbGFzdFNhbXBsZS5kdXJhdGlvbjtcblxuICAgIC8vIFNldCB0aGUgdHJhY2sgc2FtcGxlcyBmcm9tIGlucHV0U2FtcGxlcyB0byBvdXRwdXRTYW1wbGVzIGJlZm9yZSByZW11eGluZ1xuICAgIGNvbnN0IG1vb2YgPSByYXdNUEVHID8gbmV3IFVpbnQ4QXJyYXkoMCkgOiBNUDQubW9vZih0cmFjay5zZXF1ZW5jZU51bWJlcisrLCBmaXJzdFBUUyAvIHNjYWxlRmFjdG9yLCBfZXh0ZW5kcyh7fSwgdHJhY2ssIHtcbiAgICAgIHNhbXBsZXM6IG91dHB1dFNhbXBsZXNcbiAgICB9KSk7XG5cbiAgICAvLyBDbGVhciB0aGUgdHJhY2sgc2FtcGxlcy4gVGhpcyBhbHNvIGNsZWFycyB0aGUgc2FtcGxlcyBhcnJheSBpbiB0aGUgZGVtdXhlciwgc2luY2UgdGhlIHJlZmVyZW5jZSBpcyBzaGFyZWRcbiAgICB0cmFjay5zYW1wbGVzID0gW107XG4gICAgY29uc3Qgc3RhcnQgPSBmaXJzdFBUUyAvIGlucHV0VGltZVNjYWxlO1xuICAgIGNvbnN0IGVuZCA9IG5leHRBdWRpb1B0cyAvIGlucHV0VGltZVNjYWxlO1xuICAgIGNvbnN0IHR5cGUgPSAnYXVkaW8nO1xuICAgIGNvbnN0IGF1ZGlvRGF0YSA9IHtcbiAgICAgIGRhdGExOiBtb29mLFxuICAgICAgZGF0YTI6IG1kYXQsXG4gICAgICBzdGFydFBUUzogc3RhcnQsXG4gICAgICBlbmRQVFM6IGVuZCxcbiAgICAgIHN0YXJ0RFRTOiBzdGFydCxcbiAgICAgIGVuZERUUzogZW5kLFxuICAgICAgdHlwZSxcbiAgICAgIGhhc0F1ZGlvOiB0cnVlLFxuICAgICAgaGFzVmlkZW86IGZhbHNlLFxuICAgICAgbmI6IG5iU2FtcGxlc1xuICAgIH07XG4gICAgdGhpcy5pc0F1ZGlvQ29udGlndW91cyA9IHRydWU7XG4gICAgcmV0dXJuIGF1ZGlvRGF0YTtcbiAgfVxuICByZW11eEVtcHR5QXVkaW8odHJhY2ssIHRpbWVPZmZzZXQsIGNvbnRpZ3VvdXMsIHZpZGVvRGF0YSkge1xuICAgIGNvbnN0IGlucHV0VGltZVNjYWxlID0gdHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gICAgY29uc3QgbXA0dGltZVNjYWxlID0gdHJhY2suc2FtcGxlcmF0ZSA/IHRyYWNrLnNhbXBsZXJhdGUgOiBpbnB1dFRpbWVTY2FsZTtcbiAgICBjb25zdCBzY2FsZUZhY3RvciA9IGlucHV0VGltZVNjYWxlIC8gbXA0dGltZVNjYWxlO1xuICAgIGNvbnN0IG5leHRBdWRpb1B0cyA9IHRoaXMubmV4dEF1ZGlvUHRzO1xuICAgIC8vIHN5bmMgd2l0aCB2aWRlbydzIHRpbWVzdGFtcFxuICAgIGNvbnN0IGluaXREVFMgPSB0aGlzLl9pbml0RFRTO1xuICAgIGNvbnN0IGluaXQ5MGtIeiA9IGluaXREVFMuYmFzZVRpbWUgKiA5MDAwMCAvIGluaXREVFMudGltZXNjYWxlO1xuICAgIGNvbnN0IHN0YXJ0RFRTID0gKG5leHRBdWRpb1B0cyAhPT0gbnVsbCA/IG5leHRBdWRpb1B0cyA6IHZpZGVvRGF0YS5zdGFydERUUyAqIGlucHV0VGltZVNjYWxlKSArIGluaXQ5MGtIejtcbiAgICBjb25zdCBlbmREVFMgPSB2aWRlb0RhdGEuZW5kRFRTICogaW5wdXRUaW1lU2NhbGUgKyBpbml0OTBrSHo7XG4gICAgLy8gb25lIHNhbXBsZSdzIGR1cmF0aW9uIHZhbHVlXG4gICAgY29uc3QgZnJhbWVEdXJhdGlvbiA9IHNjYWxlRmFjdG9yICogQUFDX1NBTVBMRVNfUEVSX0ZSQU1FO1xuICAgIC8vIHNhbXBsZXMgY291bnQgb2YgdGhpcyBzZWdtZW50J3MgZHVyYXRpb25cbiAgICBjb25zdCBuYlNhbXBsZXMgPSBNYXRoLmNlaWwoKGVuZERUUyAtIHN0YXJ0RFRTKSAvIGZyYW1lRHVyYXRpb24pO1xuICAgIC8vIHNpbGVudCBmcmFtZVxuICAgIGNvbnN0IHNpbGVudEZyYW1lID0gQUFDLmdldFNpbGVudEZyYW1lKHRyYWNrLm1hbmlmZXN0Q29kZWMgfHwgdHJhY2suY29kZWMsIHRyYWNrLmNoYW5uZWxDb3VudCk7XG4gICAgbG9nZ2VyLndhcm4oJ1ttcDQtcmVtdXhlcl06IHJlbXV4IGVtcHR5IEF1ZGlvJyk7XG4gICAgLy8gQ2FuJ3QgcmVtdXggaWYgd2UgY2FuJ3QgZ2VuZXJhdGUgYSBzaWxlbnQgZnJhbWUuLi5cbiAgICBpZiAoIXNpbGVudEZyYW1lKSB7XG4gICAgICBsb2dnZXIudHJhY2UoJ1ttcDQtcmVtdXhlcl06IFVuYWJsZSB0byByZW11eEVtcHR5QXVkaW8gc2luY2Ugd2Ugd2VyZSB1bmFibGUgdG8gZ2V0IGEgc2lsZW50IGZyYW1lIGZvciBnaXZlbiBhdWRpbyBjb2RlYycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzYW1wbGVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYlNhbXBsZXM7IGkrKykge1xuICAgICAgY29uc3Qgc3RhbXAgPSBzdGFydERUUyArIGkgKiBmcmFtZUR1cmF0aW9uO1xuICAgICAgc2FtcGxlcy5wdXNoKHtcbiAgICAgICAgdW5pdDogc2lsZW50RnJhbWUsXG4gICAgICAgIHB0czogc3RhbXAsXG4gICAgICAgIGR0czogc3RhbXBcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0cmFjay5zYW1wbGVzID0gc2FtcGxlcztcbiAgICByZXR1cm4gdGhpcy5yZW11eEF1ZGlvKHRyYWNrLCB0aW1lT2Zmc2V0LCBjb250aWd1b3VzLCBmYWxzZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVB0cyh2YWx1ZSwgcmVmZXJlbmNlKSB7XG4gIGxldCBvZmZzZXQ7XG4gIGlmIChyZWZlcmVuY2UgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHJlZmVyZW5jZSA8IHZhbHVlKSB7XG4gICAgLy8gLSAyXjMzXG4gICAgb2Zmc2V0ID0gLTg1ODk5MzQ1OTI7XG4gIH0gZWxzZSB7XG4gICAgLy8gKyAyXjMzXG4gICAgb2Zmc2V0ID0gODU4OTkzNDU5MjtcbiAgfVxuICAvKiBQVFMgaXMgMzNiaXQgKGZyb20gMCB0byAyXjMzIC0xKVxuICAgIGlmIGRpZmYgYmV0d2VlbiB2YWx1ZSBhbmQgcmVmZXJlbmNlIGlzIGJpZ2dlciB0aGFuIGhhbGYgb2YgdGhlIGFtcGxpdHVkZSAoMl4zMikgdGhlbiBpdCBtZWFucyB0aGF0XG4gICAgUFRTIGxvb3Bpbmcgb2NjdXJlZC4gZmlsbCB0aGUgZ2FwICovXG4gIHdoaWxlIChNYXRoLmFicyh2YWx1ZSAtIHJlZmVyZW5jZSkgPiA0Mjk0OTY3Mjk2KSB7XG4gICAgdmFsdWUgKz0gb2Zmc2V0O1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGZpbmRLZXlmcmFtZUluZGV4KHNhbXBsZXMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHNhbXBsZXNbaV0ua2V5KSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gZmx1c2hUZXh0VHJhY2tNZXRhZGF0YUN1ZVNhbXBsZXModHJhY2ssIHRpbWVPZmZzZXQsIGluaXRQVFMsIGluaXREVFMpIHtcbiAgY29uc3QgbGVuZ3RoID0gdHJhY2suc2FtcGxlcy5sZW5ndGg7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGlucHV0VGltZVNjYWxlID0gdHJhY2suaW5wdXRUaW1lU2NhbGU7XG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCBzYW1wbGUgPSB0cmFjay5zYW1wbGVzW2luZGV4XTtcbiAgICAvLyBzZXR0aW5nIGlkMyBwdHMsIGR0cyB0byByZWxhdGl2ZSB0aW1lXG4gICAgLy8gdXNpbmcgdGhpcy5faW5pdFBUUyBhbmQgdGhpcy5faW5pdERUUyB0byBjYWxjdWxhdGUgcmVsYXRpdmUgdGltZVxuICAgIHNhbXBsZS5wdHMgPSBub3JtYWxpemVQdHMoc2FtcGxlLnB0cyAtIGluaXRQVFMuYmFzZVRpbWUgKiBpbnB1dFRpbWVTY2FsZSAvIGluaXRQVFMudGltZXNjYWxlLCB0aW1lT2Zmc2V0ICogaW5wdXRUaW1lU2NhbGUpIC8gaW5wdXRUaW1lU2NhbGU7XG4gICAgc2FtcGxlLmR0cyA9IG5vcm1hbGl6ZVB0cyhzYW1wbGUuZHRzIC0gaW5pdERUUy5iYXNlVGltZSAqIGlucHV0VGltZVNjYWxlIC8gaW5pdERUUy50aW1lc2NhbGUsIHRpbWVPZmZzZXQgKiBpbnB1dFRpbWVTY2FsZSkgLyBpbnB1dFRpbWVTY2FsZTtcbiAgfVxuICBjb25zdCBzYW1wbGVzID0gdHJhY2suc2FtcGxlcztcbiAgdHJhY2suc2FtcGxlcyA9IFtdO1xuICByZXR1cm4ge1xuICAgIHNhbXBsZXNcbiAgfTtcbn1cbmZ1bmN0aW9uIGZsdXNoVGV4dFRyYWNrVXNlcmRhdGFDdWVTYW1wbGVzKHRyYWNrLCB0aW1lT2Zmc2V0LCBpbml0UFRTKSB7XG4gIGNvbnN0IGxlbmd0aCA9IHRyYWNrLnNhbXBsZXMubGVuZ3RoO1xuICBpZiAoIWxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBpbnB1dFRpbWVTY2FsZSA9IHRyYWNrLmlucHV0VGltZVNjYWxlO1xuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgY29uc3Qgc2FtcGxlID0gdHJhY2suc2FtcGxlc1tpbmRleF07XG4gICAgLy8gc2V0dGluZyB0ZXh0IHB0cywgZHRzIHRvIHJlbGF0aXZlIHRpbWVcbiAgICAvLyB1c2luZyB0aGlzLl9pbml0UFRTIGFuZCB0aGlzLl9pbml0RFRTIHRvIGNhbGN1bGF0ZSByZWxhdGl2ZSB0aW1lXG4gICAgc2FtcGxlLnB0cyA9IG5vcm1hbGl6ZVB0cyhzYW1wbGUucHRzIC0gaW5pdFBUUy5iYXNlVGltZSAqIGlucHV0VGltZVNjYWxlIC8gaW5pdFBUUy50aW1lc2NhbGUsIHRpbWVPZmZzZXQgKiBpbnB1dFRpbWVTY2FsZSkgLyBpbnB1dFRpbWVTY2FsZTtcbiAgfVxuICB0cmFjay5zYW1wbGVzLnNvcnQoKGEsIGIpID0+IGEucHRzIC0gYi5wdHMpO1xuICBjb25zdCBzYW1wbGVzID0gdHJhY2suc2FtcGxlcztcbiAgdHJhY2suc2FtcGxlcyA9IFtdO1xuICByZXR1cm4ge1xuICAgIHNhbXBsZXNcbiAgfTtcbn1cbmNsYXNzIE1wNFNhbXBsZSB7XG4gIGNvbnN0cnVjdG9yKGlzS2V5ZnJhbWUsIGR1cmF0aW9uLCBzaXplLCBjdHMpIHtcbiAgICB0aGlzLnNpemUgPSB2b2lkIDA7XG4gICAgdGhpcy5kdXJhdGlvbiA9IHZvaWQgMDtcbiAgICB0aGlzLmN0cyA9IHZvaWQgMDtcbiAgICB0aGlzLmZsYWdzID0gdm9pZCAwO1xuICAgIHRoaXMuZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgIHRoaXMuY3RzID0gY3RzO1xuICAgIHRoaXMuZmxhZ3MgPSB7XG4gICAgICBpc0xlYWRpbmc6IDAsXG4gICAgICBpc0RlcGVuZGVkT246IDAsXG4gICAgICBoYXNSZWR1bmRhbmN5OiAwLFxuICAgICAgZGVncmFkUHJpbzogMCxcbiAgICAgIGRlcGVuZHNPbjogaXNLZXlmcmFtZSA/IDIgOiAxLFxuICAgICAgaXNOb25TeW5jOiBpc0tleWZyYW1lID8gMCA6IDFcbiAgICB9O1xuICB9XG59XG5cbmNsYXNzIFBhc3NUaHJvdWdoUmVtdXhlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZW1pdEluaXRTZWdtZW50ID0gZmFsc2U7XG4gICAgdGhpcy5hdWRpb0NvZGVjID0gdm9pZCAwO1xuICAgIHRoaXMudmlkZW9Db2RlYyA9IHZvaWQgMDtcbiAgICB0aGlzLmluaXREYXRhID0gdm9pZCAwO1xuICAgIHRoaXMuaW5pdFBUUyA9IG51bGw7XG4gICAgdGhpcy5pbml0VHJhY2tzID0gdm9pZCAwO1xuICAgIHRoaXMubGFzdEVuZFRpbWUgPSBudWxsO1xuICB9XG4gIGRlc3Ryb3koKSB7fVxuICByZXNldFRpbWVTdGFtcChkZWZhdWx0SW5pdFBUUykge1xuICAgIHRoaXMuaW5pdFBUUyA9IGRlZmF1bHRJbml0UFRTO1xuICAgIHRoaXMubGFzdEVuZFRpbWUgPSBudWxsO1xuICB9XG4gIHJlc2V0TmV4dFRpbWVzdGFtcCgpIHtcbiAgICB0aGlzLmxhc3RFbmRUaW1lID0gbnVsbDtcbiAgfVxuICByZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50LCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBkZWNyeXB0ZGF0YSkge1xuICAgIHRoaXMuYXVkaW9Db2RlYyA9IGF1ZGlvQ29kZWM7XG4gICAgdGhpcy52aWRlb0NvZGVjID0gdmlkZW9Db2RlYztcbiAgICB0aGlzLmdlbmVyYXRlSW5pdFNlZ21lbnQocGF0Y2hFbmN5cHRpb25EYXRhKGluaXRTZWdtZW50LCBkZWNyeXB0ZGF0YSkpO1xuICAgIHRoaXMuZW1pdEluaXRTZWdtZW50ID0gdHJ1ZTtcbiAgfVxuICBnZW5lcmF0ZUluaXRTZWdtZW50KGluaXRTZWdtZW50KSB7XG4gICAgbGV0IHtcbiAgICAgIGF1ZGlvQ29kZWMsXG4gICAgICB2aWRlb0NvZGVjXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCEoaW5pdFNlZ21lbnQgIT0gbnVsbCAmJiBpbml0U2VnbWVudC5ieXRlTGVuZ3RoKSkge1xuICAgICAgdGhpcy5pbml0VHJhY2tzID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5pbml0RGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW5pdERhdGEgPSB0aGlzLmluaXREYXRhID0gcGFyc2VJbml0U2VnbWVudChpbml0U2VnbWVudCk7XG5cbiAgICAvLyBHZXQgY29kZWMgZnJvbSBpbml0U2VnbWVudCBvciBmYWxsYmFjayB0byBkZWZhdWx0XG4gICAgaWYgKGluaXREYXRhLmF1ZGlvKSB7XG4gICAgICBhdWRpb0NvZGVjID0gZ2V0UGFyc2VkVHJhY2tDb2RlYyhpbml0RGF0YS5hdWRpbywgRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPKTtcbiAgICB9XG4gICAgaWYgKGluaXREYXRhLnZpZGVvKSB7XG4gICAgICB2aWRlb0NvZGVjID0gZ2V0UGFyc2VkVHJhY2tDb2RlYyhpbml0RGF0YS52aWRlbywgRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPKTtcbiAgICB9XG4gICAgY29uc3QgdHJhY2tzID0ge307XG4gICAgaWYgKGluaXREYXRhLmF1ZGlvICYmIGluaXREYXRhLnZpZGVvKSB7XG4gICAgICB0cmFja3MuYXVkaW92aWRlbyA9IHtcbiAgICAgICAgY29udGFpbmVyOiAndmlkZW8vbXA0JyxcbiAgICAgICAgY29kZWM6IGF1ZGlvQ29kZWMgKyAnLCcgKyB2aWRlb0NvZGVjLFxuICAgICAgICBpbml0U2VnbWVudCxcbiAgICAgICAgaWQ6ICdtYWluJ1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGluaXREYXRhLmF1ZGlvKSB7XG4gICAgICB0cmFja3MuYXVkaW8gPSB7XG4gICAgICAgIGNvbnRhaW5lcjogJ2F1ZGlvL21wNCcsXG4gICAgICAgIGNvZGVjOiBhdWRpb0NvZGVjLFxuICAgICAgICBpbml0U2VnbWVudCxcbiAgICAgICAgaWQ6ICdhdWRpbydcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChpbml0RGF0YS52aWRlbykge1xuICAgICAgdHJhY2tzLnZpZGVvID0ge1xuICAgICAgICBjb250YWluZXI6ICd2aWRlby9tcDQnLFxuICAgICAgICBjb2RlYzogdmlkZW9Db2RlYyxcbiAgICAgICAgaW5pdFNlZ21lbnQsXG4gICAgICAgIGlkOiAnbWFpbidcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlci53YXJuKCdbcGFzc3Rocm91Z2gtcmVtdXhlci50c106IGluaXRTZWdtZW50IGRvZXMgbm90IGNvbnRhaW4gbW9vdiBvciB0cmFrIGJveGVzLicpO1xuICAgIH1cbiAgICB0aGlzLmluaXRUcmFja3MgPSB0cmFja3M7XG4gIH1cbiAgcmVtdXgoYXVkaW9UcmFjaywgdmlkZW9UcmFjaywgaWQzVHJhY2ssIHRleHRUcmFjaywgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XG4gICAgdmFyIF9pbml0RGF0YSwgX2luaXREYXRhMjtcbiAgICBsZXQge1xuICAgICAgaW5pdFBUUyxcbiAgICAgIGxhc3RFbmRUaW1lXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgYXVkaW86IHVuZGVmaW5lZCxcbiAgICAgIHZpZGVvOiB1bmRlZmluZWQsXG4gICAgICB0ZXh0OiB0ZXh0VHJhY2ssXG4gICAgICBpZDM6IGlkM1RyYWNrLFxuICAgICAgaW5pdFNlZ21lbnQ6IHVuZGVmaW5lZFxuICAgIH07XG5cbiAgICAvLyBJZiB3ZSBoYXZlbid0IHlldCBzZXQgYSBsYXN0RW5kRFRTLCBvciBpdCB3YXMgcmVzZXQsIHNldCBpdCB0byB0aGUgcHJvdmlkZWQgdGltZU9mZnNldC4gV2Ugd2FudCB0byB1c2UgdGhlXG4gICAgLy8gbGFzdEVuZERUUyBvdmVyIHRpbWVPZmZzZXQgd2hlbmV2ZXIgcG9zc2libGU7IGR1cmluZyBwcm9ncmVzc2l2ZSBwbGF5YmFjaywgdGhlIG1lZGlhIHNvdXJjZSB3aWxsIG5vdCB1cGRhdGVcbiAgICAvLyB0aGUgbWVkaWEgZHVyYXRpb24gKHdoaWNoIGlzIHdoYXQgdGltZU9mZnNldCBpcyBwcm92aWRlZCBhcykgYmVmb3JlIHdlIG5lZWQgdG8gcHJvY2VzcyB0aGUgbmV4dCBjaHVuay5cbiAgICBpZiAoIWlzRmluaXRlTnVtYmVyKGxhc3RFbmRUaW1lKSkge1xuICAgICAgbGFzdEVuZFRpbWUgPSB0aGlzLmxhc3RFbmRUaW1lID0gdGltZU9mZnNldCB8fCAwO1xuICAgIH1cblxuICAgIC8vIFRoZSBiaW5hcnkgc2VnbWVudCBkYXRhIGlzIGFkZGVkIHRvIHRoZSB2aWRlb1RyYWNrIGluIHRoZSBtcDRkZW11eGVyLiBXZSBkb24ndCBjaGVjayB0byBzZWUgaWYgdGhlIGRhdGEgaXMgb25seVxuICAgIC8vIGF1ZGlvIG9yIHZpZGVvIChvciBib3RoKTsgYWRkaW5nIGl0IHRvIHZpZGVvIHdhcyBhbiBhcmJpdHJhcnkgY2hvaWNlLlxuICAgIGNvbnN0IGRhdGEgPSB2aWRlb1RyYWNrLnNhbXBsZXM7XG4gICAgaWYgKCEoZGF0YSAhPSBudWxsICYmIGRhdGEubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY29uc3QgaW5pdFNlZ21lbnQgPSB7XG4gICAgICBpbml0UFRTOiB1bmRlZmluZWQsXG4gICAgICB0aW1lc2NhbGU6IDFcbiAgICB9O1xuICAgIGxldCBpbml0RGF0YSA9IHRoaXMuaW5pdERhdGE7XG4gICAgaWYgKCEoKF9pbml0RGF0YSA9IGluaXREYXRhKSAhPSBudWxsICYmIF9pbml0RGF0YS5sZW5ndGgpKSB7XG4gICAgICB0aGlzLmdlbmVyYXRlSW5pdFNlZ21lbnQoZGF0YSk7XG4gICAgICBpbml0RGF0YSA9IHRoaXMuaW5pdERhdGE7XG4gICAgfVxuICAgIGlmICghKChfaW5pdERhdGEyID0gaW5pdERhdGEpICE9IG51bGwgJiYgX2luaXREYXRhMi5sZW5ndGgpKSB7XG4gICAgICAvLyBXZSBjYW4ndCByZW11eCBpZiB0aGUgaW5pdFNlZ21lbnQgY291bGQgbm90IGJlIGdlbmVyYXRlZFxuICAgICAgbG9nZ2VyLndhcm4oJ1twYXNzdGhyb3VnaC1yZW11eGVyLnRzXTogRmFpbGVkIHRvIGdlbmVyYXRlIGluaXRTZWdtZW50LicpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHRoaXMuZW1pdEluaXRTZWdtZW50KSB7XG4gICAgICBpbml0U2VnbWVudC50cmFja3MgPSB0aGlzLmluaXRUcmFja3M7XG4gICAgICB0aGlzLmVtaXRJbml0U2VnbWVudCA9IGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBkdXJhdGlvbiA9IGdldER1cmF0aW9uKGRhdGEsIGluaXREYXRhKTtcbiAgICBjb25zdCBzdGFydERUUyA9IGdldFN0YXJ0RFRTKGluaXREYXRhLCBkYXRhKTtcbiAgICBjb25zdCBkZWNvZGVUaW1lID0gc3RhcnREVFMgPT09IG51bGwgPyB0aW1lT2Zmc2V0IDogc3RhcnREVFM7XG4gICAgaWYgKGlzSW52YWxpZEluaXRQdHMoaW5pdFBUUywgZGVjb2RlVGltZSwgdGltZU9mZnNldCwgZHVyYXRpb24pIHx8IGluaXRTZWdtZW50LnRpbWVzY2FsZSAhPT0gaW5pdFBUUy50aW1lc2NhbGUgJiYgYWNjdXJhdGVUaW1lT2Zmc2V0KSB7XG4gICAgICBpbml0U2VnbWVudC5pbml0UFRTID0gZGVjb2RlVGltZSAtIHRpbWVPZmZzZXQ7XG4gICAgICBpZiAoaW5pdFBUUyAmJiBpbml0UFRTLnRpbWVzY2FsZSA9PT0gMSkge1xuICAgICAgICBsb2dnZXIud2FybihgQWRqdXN0aW5nIGluaXRQVFMgYnkgJHtpbml0U2VnbWVudC5pbml0UFRTIC0gaW5pdFBUUy5iYXNlVGltZX1gKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5pdFBUUyA9IGluaXRQVFMgPSB7XG4gICAgICAgIGJhc2VUaW1lOiBpbml0U2VnbWVudC5pbml0UFRTLFxuICAgICAgICB0aW1lc2NhbGU6IDFcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0VGltZSA9IGF1ZGlvVHJhY2sgPyBkZWNvZGVUaW1lIC0gaW5pdFBUUy5iYXNlVGltZSAvIGluaXRQVFMudGltZXNjYWxlIDogbGFzdEVuZFRpbWU7XG4gICAgY29uc3QgZW5kVGltZSA9IHN0YXJ0VGltZSArIGR1cmF0aW9uO1xuICAgIG9mZnNldFN0YXJ0RFRTKGluaXREYXRhLCBkYXRhLCBpbml0UFRTLmJhc2VUaW1lIC8gaW5pdFBUUy50aW1lc2NhbGUpO1xuICAgIGlmIChkdXJhdGlvbiA+IDApIHtcbiAgICAgIHRoaXMubGFzdEVuZFRpbWUgPSBlbmRUaW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dnZXIud2FybignRHVyYXRpb24gcGFyc2VkIGZyb20gbXA0IHNob3VsZCBiZSBncmVhdGVyIHRoYW4gemVybycpO1xuICAgICAgdGhpcy5yZXNldE5leHRUaW1lc3RhbXAoKTtcbiAgICB9XG4gICAgY29uc3QgaGFzQXVkaW8gPSAhIWluaXREYXRhLmF1ZGlvO1xuICAgIGNvbnN0IGhhc1ZpZGVvID0gISFpbml0RGF0YS52aWRlbztcbiAgICBsZXQgdHlwZSA9ICcnO1xuICAgIGlmIChoYXNBdWRpbykge1xuICAgICAgdHlwZSArPSAnYXVkaW8nO1xuICAgIH1cbiAgICBpZiAoaGFzVmlkZW8pIHtcbiAgICAgIHR5cGUgKz0gJ3ZpZGVvJztcbiAgICB9XG4gICAgY29uc3QgdHJhY2sgPSB7XG4gICAgICBkYXRhMTogZGF0YSxcbiAgICAgIHN0YXJ0UFRTOiBzdGFydFRpbWUsXG4gICAgICBzdGFydERUUzogc3RhcnRUaW1lLFxuICAgICAgZW5kUFRTOiBlbmRUaW1lLFxuICAgICAgZW5kRFRTOiBlbmRUaW1lLFxuICAgICAgdHlwZSxcbiAgICAgIGhhc0F1ZGlvLFxuICAgICAgaGFzVmlkZW8sXG4gICAgICBuYjogMSxcbiAgICAgIGRyb3BwZWQ6IDBcbiAgICB9O1xuICAgIHJlc3VsdC5hdWRpbyA9IHRyYWNrLnR5cGUgPT09ICdhdWRpbycgPyB0cmFjayA6IHVuZGVmaW5lZDtcbiAgICByZXN1bHQudmlkZW8gPSB0cmFjay50eXBlICE9PSAnYXVkaW8nID8gdHJhY2sgOiB1bmRlZmluZWQ7XG4gICAgcmVzdWx0LmluaXRTZWdtZW50ID0gaW5pdFNlZ21lbnQ7XG4gICAgcmVzdWx0LmlkMyA9IGZsdXNoVGV4dFRyYWNrTWV0YWRhdGFDdWVTYW1wbGVzKGlkM1RyYWNrLCB0aW1lT2Zmc2V0LCBpbml0UFRTLCBpbml0UFRTKTtcbiAgICBpZiAodGV4dFRyYWNrLnNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICByZXN1bHQudGV4dCA9IGZsdXNoVGV4dFRyYWNrVXNlcmRhdGFDdWVTYW1wbGVzKHRleHRUcmFjaywgdGltZU9mZnNldCwgaW5pdFBUUyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzSW52YWxpZEluaXRQdHMoaW5pdFBUUywgc3RhcnREVFMsIHRpbWVPZmZzZXQsIGR1cmF0aW9uKSB7XG4gIGlmIChpbml0UFRTID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8gSW5pdFBUUyBpcyBpbnZhbGlkIHdoZW4gZGlzdGFuY2UgZnJvbSBwcm9ncmFtIHdvdWxkIGJlIG1vcmUgdGhhbiBzZWdtZW50IGR1cmF0aW9uIG9yIGEgbWluaW11bSBvZiBvbmUgc2Vjb25kXG4gIGNvbnN0IG1pbkR1cmF0aW9uID0gTWF0aC5tYXgoZHVyYXRpb24sIDEpO1xuICBjb25zdCBzdGFydFRpbWUgPSBzdGFydERUUyAtIGluaXRQVFMuYmFzZVRpbWUgLyBpbml0UFRTLnRpbWVzY2FsZTtcbiAgcmV0dXJuIE1hdGguYWJzKHN0YXJ0VGltZSAtIHRpbWVPZmZzZXQpID4gbWluRHVyYXRpb247XG59XG5mdW5jdGlvbiBnZXRQYXJzZWRUcmFja0NvZGVjKHRyYWNrLCB0eXBlKSB7XG4gIGNvbnN0IHBhcnNlZENvZGVjID0gdHJhY2sgPT0gbnVsbCA/IHZvaWQgMCA6IHRyYWNrLmNvZGVjO1xuICBpZiAocGFyc2VkQ29kZWMgJiYgcGFyc2VkQ29kZWMubGVuZ3RoID4gNCkge1xuICAgIHJldHVybiBwYXJzZWRDb2RlYztcbiAgfVxuICBpZiAodHlwZSA9PT0gRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPKSB7XG4gICAgaWYgKHBhcnNlZENvZGVjID09PSAnZWMtMycgfHwgcGFyc2VkQ29kZWMgPT09ICdhYy0zJyB8fCBwYXJzZWRDb2RlYyA9PT0gJ2FsYWMnKSB7XG4gICAgICByZXR1cm4gcGFyc2VkQ29kZWM7XG4gICAgfVxuICAgIGlmIChwYXJzZWRDb2RlYyA9PT0gJ2ZMYUMnIHx8IHBhcnNlZENvZGVjID09PSAnT3B1cycpIHtcbiAgICAgIC8vIE9wdGluZyBub3QgdG8gZ2V0IGBwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2VgIGZyb20gcGxheWVyIGNvbmZpZyBmb3IgaXNTdXBwb3J0ZWQoKSBjaGVjayBmb3Igc2ltcGxpY2l0eVxuICAgICAgY29uc3QgcHJlZmVyTWFuYWdlZE1lZGlhU291cmNlID0gZmFsc2U7XG4gICAgICByZXR1cm4gZ2V0Q29kZWNDb21wYXRpYmxlTmFtZShwYXJzZWRDb2RlYywgcHJlZmVyTWFuYWdlZE1lZGlhU291cmNlKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gJ21wNGEuNDAuNSc7XG4gICAgbG9nZ2VyLmluZm8oYFBhcnNlZCBhdWRpbyBjb2RlYyBcIiR7cGFyc2VkQ29kZWN9XCIgb3IgYXVkaW8gb2JqZWN0IHR5cGUgbm90IGhhbmRsZWQuIFVzaW5nIFwiJHtyZXN1bHR9XCJgKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8vIFByb3ZpZGUgZGVmYXVsdHMgYmFzZWQgb24gY29kZWMgdHlwZVxuICAvLyBUaGlzIGFsbG93cyBmb3Igc29tZSBwbGF5YmFjayBvZiBzb21lIGZtcDQgcGxheWxpc3RzIHdpdGhvdXQgQ09ERUNTIGRlZmluZWQgaW4gbWFuaWZlc3RcbiAgbG9nZ2VyLndhcm4oYFVuaGFuZGxlZCB2aWRlbyBjb2RlYyBcIiR7cGFyc2VkQ29kZWN9XCJgKTtcbiAgaWYgKHBhcnNlZENvZGVjID09PSAnaHZjMScgfHwgcGFyc2VkQ29kZWMgPT09ICdoZXYxJykge1xuICAgIHJldHVybiAnaHZjMS4xLjYuTDEyMC45MCc7XG4gIH1cbiAgaWYgKHBhcnNlZENvZGVjID09PSAnYXYwMScpIHtcbiAgICByZXR1cm4gJ2F2MDEuMC4wNE0uMDgnO1xuICB9XG4gIHJldHVybiAnYXZjMS40MmUwMWUnO1xufVxuXG5sZXQgbm93O1xuLy8gcGVyZm9ybWFuY2Uubm93KCkgbm90IGF2YWlsYWJsZSBvbiBXZWJXb3JrZXIsIGF0IGxlYXN0IG9uIFNhZmFyaSBEZXNrdG9wXG50cnkge1xuICBub3cgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdy5iaW5kKHNlbGYucGVyZm9ybWFuY2UpO1xufSBjYXRjaCAoZXJyKSB7XG4gIGxvZ2dlci5kZWJ1ZygnVW5hYmxlIHRvIHVzZSBQZXJmb3JtYW5jZSBBUEkgb24gdGhpcyBlbnZpcm9ubWVudCcpO1xuICBub3cgPSBvcHRpb25hbFNlbGYgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbmFsU2VsZi5EYXRlLm5vdztcbn1cbmNvbnN0IG11eENvbmZpZyA9IFt7XG4gIGRlbXV4OiBNUDREZW11eGVyLFxuICByZW11eDogUGFzc1Rocm91Z2hSZW11eGVyXG59LCB7XG4gIGRlbXV4OiBUU0RlbXV4ZXIsXG4gIHJlbXV4OiBNUDRSZW11eGVyXG59LCB7XG4gIGRlbXV4OiBBQUNEZW11eGVyLFxuICByZW11eDogTVA0UmVtdXhlclxufSwge1xuICBkZW11eDogTVAzRGVtdXhlcixcbiAgcmVtdXg6IE1QNFJlbXV4ZXJcbn1dO1xue1xuICBtdXhDb25maWcuc3BsaWNlKDIsIDAsIHtcbiAgICBkZW11eDogQUMzRGVtdXhlcixcbiAgICByZW11eDogTVA0UmVtdXhlclxuICB9KTtcbn1cbmNsYXNzIFRyYW5zbXV4ZXIge1xuICBjb25zdHJ1Y3RvcihvYnNlcnZlciwgdHlwZVN1cHBvcnRlZCwgY29uZmlnLCB2ZW5kb3IsIGlkKSB7XG4gICAgdGhpcy5hc3luYyA9IGZhbHNlO1xuICAgIHRoaXMub2JzZXJ2ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy50eXBlU3VwcG9ydGVkID0gdm9pZCAwO1xuICAgIHRoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgIHRoaXMudmVuZG9yID0gdm9pZCAwO1xuICAgIHRoaXMuaWQgPSB2b2lkIDA7XG4gICAgdGhpcy5kZW11eGVyID0gdm9pZCAwO1xuICAgIHRoaXMucmVtdXhlciA9IHZvaWQgMDtcbiAgICB0aGlzLmRlY3J5cHRlciA9IHZvaWQgMDtcbiAgICB0aGlzLnByb2JlID0gdm9pZCAwO1xuICAgIHRoaXMuZGVjcnlwdGlvblByb21pc2UgPSBudWxsO1xuICAgIHRoaXMudHJhbnNtdXhDb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy5jdXJyZW50VHJhbnNtdXhTdGF0ZSA9IHZvaWQgMDtcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgdGhpcy50eXBlU3VwcG9ydGVkID0gdHlwZVN1cHBvcnRlZDtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLnZlbmRvciA9IHZlbmRvcjtcbiAgICB0aGlzLmlkID0gaWQ7XG4gIH1cbiAgY29uZmlndXJlKHRyYW5zbXV4Q29uZmlnKSB7XG4gICAgdGhpcy50cmFuc211eENvbmZpZyA9IHRyYW5zbXV4Q29uZmlnO1xuICAgIGlmICh0aGlzLmRlY3J5cHRlcikge1xuICAgICAgdGhpcy5kZWNyeXB0ZXIucmVzZXQoKTtcbiAgICB9XG4gIH1cbiAgcHVzaChkYXRhLCBkZWNyeXB0ZGF0YSwgY2h1bmtNZXRhLCBzdGF0ZSkge1xuICAgIGNvbnN0IHN0YXRzID0gY2h1bmtNZXRhLnRyYW5zbXV4aW5nO1xuICAgIHN0YXRzLmV4ZWN1dGVTdGFydCA9IG5vdygpO1xuICAgIGxldCB1aW50RGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICAgIGNvbnN0IHtcbiAgICAgIGN1cnJlbnRUcmFuc211eFN0YXRlLFxuICAgICAgdHJhbnNtdXhDb25maWdcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoc3RhdGUpIHtcbiAgICAgIHRoaXMuY3VycmVudFRyYW5zbXV4U3RhdGUgPSBzdGF0ZTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY29udGlndW91cyxcbiAgICAgIGRpc2NvbnRpbnVpdHksXG4gICAgICB0cmFja1N3aXRjaCxcbiAgICAgIGFjY3VyYXRlVGltZU9mZnNldCxcbiAgICAgIHRpbWVPZmZzZXQsXG4gICAgICBpbml0U2VnbWVudENoYW5nZVxuICAgIH0gPSBzdGF0ZSB8fCBjdXJyZW50VHJhbnNtdXhTdGF0ZTtcbiAgICBjb25zdCB7XG4gICAgICBhdWRpb0NvZGVjLFxuICAgICAgdmlkZW9Db2RlYyxcbiAgICAgIGRlZmF1bHRJbml0UHRzLFxuICAgICAgZHVyYXRpb24sXG4gICAgICBpbml0U2VnbWVudERhdGFcbiAgICB9ID0gdHJhbnNtdXhDb25maWc7XG4gICAgY29uc3Qga2V5RGF0YSA9IGdldEVuY3J5cHRpb25UeXBlKHVpbnREYXRhLCBkZWNyeXB0ZGF0YSk7XG4gICAgaWYgKGtleURhdGEgJiYga2V5RGF0YS5tZXRob2QgPT09ICdBRVMtMTI4Jykge1xuICAgICAgY29uc3QgZGVjcnlwdGVyID0gdGhpcy5nZXREZWNyeXB0ZXIoKTtcbiAgICAgIC8vIFNvZnR3YXJlIGRlY3J5cHRpb24gaXMgc3luY2hyb25vdXM7IHdlYkNyeXB0byBpcyBub3RcbiAgICAgIGlmIChkZWNyeXB0ZXIuaXNTeW5jKCkpIHtcbiAgICAgICAgLy8gU29mdHdhcmUgZGVjcnlwdGlvbiBpcyBwcm9ncmVzc2l2ZS4gUHJvZ3Jlc3NpdmUgZGVjcnlwdGlvbiBtYXkgbm90IHJldHVybiBhIHJlc3VsdCBvbiBlYWNoIGNhbGwuIEFueSBjYWNoZWRcbiAgICAgICAgLy8gZGF0YSBpcyBoYW5kbGVkIGluIHRoZSBmbHVzaCgpIGNhbGxcbiAgICAgICAgbGV0IGRlY3J5cHRlZERhdGEgPSBkZWNyeXB0ZXIuc29mdHdhcmVEZWNyeXB0KHVpbnREYXRhLCBrZXlEYXRhLmtleS5idWZmZXIsIGtleURhdGEuaXYuYnVmZmVyKTtcbiAgICAgICAgLy8gRm9yIExvdy1MYXRlbmN5IEhMUyBQYXJ0cywgZGVjcnlwdCBpbiBwbGFjZSwgc2luY2UgcGFydCBwYXJzaW5nIGlzIGV4cGVjdGVkIG9uIHB1c2ggcHJvZ3Jlc3NcbiAgICAgICAgY29uc3QgbG9hZGluZ1BhcnRzID0gY2h1bmtNZXRhLnBhcnQgPiAtMTtcbiAgICAgICAgaWYgKGxvYWRpbmdQYXJ0cykge1xuICAgICAgICAgIGRlY3J5cHRlZERhdGEgPSBkZWNyeXB0ZXIuZmx1c2goKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlY3J5cHRlZERhdGEpIHtcbiAgICAgICAgICBzdGF0cy5leGVjdXRlRW5kID0gbm93KCk7XG4gICAgICAgICAgcmV0dXJuIGVtcHR5UmVzdWx0KGNodW5rTWV0YSk7XG4gICAgICAgIH1cbiAgICAgICAgdWludERhdGEgPSBuZXcgVWludDhBcnJheShkZWNyeXB0ZWREYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVjcnlwdGlvblByb21pc2UgPSBkZWNyeXB0ZXIud2ViQ3J5cHRvRGVjcnlwdCh1aW50RGF0YSwga2V5RGF0YS5rZXkuYnVmZmVyLCBrZXlEYXRhLml2LmJ1ZmZlcikudGhlbihkZWNyeXB0ZWREYXRhID0+IHtcbiAgICAgICAgICAvLyBDYWxsaW5nIHB1c2ggaGVyZSBpcyBpbXBvcnRhbnQ7IGlmIGZsdXNoKCkgaXMgY2FsbGVkIHdoaWxlIHRoaXMgaXMgc3RpbGwgcmVzb2x2aW5nLCB0aGlzIGVuc3VyZXMgdGhhdFxuICAgICAgICAgIC8vIHRoZSBkZWNyeXB0ZWQgZGF0YSBoYXMgYmVlbiB0cmFuc211eGVkXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5wdXNoKGRlY3J5cHRlZERhdGEsIG51bGwsIGNodW5rTWV0YSk7XG4gICAgICAgICAgdGhpcy5kZWNyeXB0aW9uUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmRlY3J5cHRpb25Qcm9taXNlO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXNldE11eGVycyA9IHRoaXMubmVlZHNQcm9iaW5nKGRpc2NvbnRpbnVpdHksIHRyYWNrU3dpdGNoKTtcbiAgICBpZiAocmVzZXRNdXhlcnMpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jb25maWd1cmVUcmFuc211eGVyKHVpbnREYXRhKTtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBsb2dnZXIud2FybihgW3RyYW5zbXV4ZXJdICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgdGhpcy5vYnNlcnZlci5lbWl0KEV2ZW50cy5FUlJPUiwgRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19QQVJTSU5HX0VSUk9SLFxuICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgICByZWFzb246IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgfSk7XG4gICAgICAgIHN0YXRzLmV4ZWN1dGVFbmQgPSBub3coKTtcbiAgICAgICAgcmV0dXJuIGVtcHR5UmVzdWx0KGNodW5rTWV0YSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkaXNjb250aW51aXR5IHx8IHRyYWNrU3dpdGNoIHx8IGluaXRTZWdtZW50Q2hhbmdlIHx8IHJlc2V0TXV4ZXJzKSB7XG4gICAgICB0aGlzLnJlc2V0SW5pdFNlZ21lbnQoaW5pdFNlZ21lbnREYXRhLCBhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBkdXJhdGlvbiwgZGVjcnlwdGRhdGEpO1xuICAgIH1cbiAgICBpZiAoZGlzY29udGludWl0eSB8fCBpbml0U2VnbWVudENoYW5nZSB8fCByZXNldE11eGVycykge1xuICAgICAgdGhpcy5yZXNldEluaXRpYWxUaW1lc3RhbXAoZGVmYXVsdEluaXRQdHMpO1xuICAgIH1cbiAgICBpZiAoIWNvbnRpZ3VvdXMpIHtcbiAgICAgIHRoaXMucmVzZXRDb250aWd1aXR5KCk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMudHJhbnNtdXgodWludERhdGEsIGtleURhdGEsIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCwgY2h1bmtNZXRhKTtcbiAgICBjb25zdCBjdXJyZW50U3RhdGUgPSB0aGlzLmN1cnJlbnRUcmFuc211eFN0YXRlO1xuICAgIGN1cnJlbnRTdGF0ZS5jb250aWd1b3VzID0gdHJ1ZTtcbiAgICBjdXJyZW50U3RhdGUuZGlzY29udGludWl0eSA9IGZhbHNlO1xuICAgIGN1cnJlbnRTdGF0ZS50cmFja1N3aXRjaCA9IGZhbHNlO1xuICAgIHN0YXRzLmV4ZWN1dGVFbmQgPSBub3coKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gRHVlIHRvIGRhdGEgY2FjaGluZywgZmx1c2ggY2FsbHMgY2FuIHByb2R1Y2UgbW9yZSB0aGFuIG9uZSBUcmFuc211eGVyUmVzdWx0IChoZW5jZSB0aGUgQXJyYXkgdHlwZSlcbiAgZmx1c2goY2h1bmtNZXRhKSB7XG4gICAgY29uc3Qgc3RhdHMgPSBjaHVua01ldGEudHJhbnNtdXhpbmc7XG4gICAgc3RhdHMuZXhlY3V0ZVN0YXJ0ID0gbm93KCk7XG4gICAgY29uc3Qge1xuICAgICAgZGVjcnlwdGVyLFxuICAgICAgY3VycmVudFRyYW5zbXV4U3RhdGUsXG4gICAgICBkZWNyeXB0aW9uUHJvbWlzZVxuICAgIH0gPSB0aGlzO1xuICAgIGlmIChkZWNyeXB0aW9uUHJvbWlzZSkge1xuICAgICAgLy8gVXBvbiByZXNvbHV0aW9uLCB0aGUgZGVjcnlwdGlvbiBwcm9taXNlIGNhbGxzIHB1c2goKSBhbmQgcmV0dXJucyBpdHMgVHJhbnNtdXhlclJlc3VsdCB1cCB0aGUgc3RhY2suIFRoZXJlZm9yZVxuICAgICAgLy8gb25seSBmbHVzaGluZyBpcyByZXF1aXJlZCBmb3IgYXN5bmMgZGVjcnlwdGlvblxuICAgICAgcmV0dXJuIGRlY3J5cHRpb25Qcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5mbHVzaChjaHVua01ldGEpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHRyYW5zbXV4UmVzdWx0cyA9IFtdO1xuICAgIGNvbnN0IHtcbiAgICAgIHRpbWVPZmZzZXRcbiAgICB9ID0gY3VycmVudFRyYW5zbXV4U3RhdGU7XG4gICAgaWYgKGRlY3J5cHRlcikge1xuICAgICAgLy8gVGhlIGRlY3J5cHRlciBtYXkgaGF2ZSBkYXRhIGNhY2hlZCwgd2hpY2ggbmVlZHMgdG8gYmUgZGVtdXhlZC4gSW4gdGhpcyBjYXNlIHdlJ2xsIGhhdmUgdHdvIFRyYW5zbXV4UmVzdWx0c1xuICAgICAgLy8gVGhpcyBoYXBwZW5zIGluIHRoZSBjYXNlIHRoYXQgd2UgcmVjZWl2ZSBvbmx5IDEgcHVzaCBjYWxsIGZvciBhIHNlZ21lbnQgKGVpdGhlciBmb3Igbm9uLXByb2dyZXNzaXZlIGRvd25sb2FkcyxcbiAgICAgIC8vIG9yIGZvciBwcm9ncmVzc2l2ZSBkb3dubG9hZHMgd2l0aCBzbWFsbCBzZWdtZW50cylcbiAgICAgIGNvbnN0IGRlY3J5cHRlZERhdGEgPSBkZWNyeXB0ZXIuZmx1c2goKTtcbiAgICAgIGlmIChkZWNyeXB0ZWREYXRhKSB7XG4gICAgICAgIC8vIFB1c2ggYWx3YXlzIHJldHVybnMgYSBUcmFuc211eGVyUmVzdWx0IGlmIGRlY3J5cHRkYXRhIGlzIG51bGxcbiAgICAgICAgdHJhbnNtdXhSZXN1bHRzLnB1c2godGhpcy5wdXNoKGRlY3J5cHRlZERhdGEsIG51bGwsIGNodW5rTWV0YSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBkZW11eGVyLFxuICAgICAgcmVtdXhlclxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghZGVtdXhlciB8fCAhcmVtdXhlcikge1xuICAgICAgLy8gSWYgcHJvYmluZyBmYWlsZWQsIHRoZW4gSGxzLmpzIGhhcyBiZWVuIGdpdmVuIGNvbnRlbnQgaXRzIG5vdCBhYmxlIHRvIGhhbmRsZVxuICAgICAgc3RhdHMuZXhlY3V0ZUVuZCA9IG5vdygpO1xuICAgICAgcmV0dXJuIFtlbXB0eVJlc3VsdChjaHVua01ldGEpXTtcbiAgICB9XG4gICAgY29uc3QgZGVtdXhSZXN1bHRPclByb21pc2UgPSBkZW11eGVyLmZsdXNoKHRpbWVPZmZzZXQpO1xuICAgIGlmIChpc1Byb21pc2UoZGVtdXhSZXN1bHRPclByb21pc2UpKSB7XG4gICAgICAvLyBEZWNyeXB0IGZpbmFsIFNBTVBMRS1BRVMgc2FtcGxlc1xuICAgICAgcmV0dXJuIGRlbXV4UmVzdWx0T3JQcm9taXNlLnRoZW4oZGVtdXhSZXN1bHQgPT4ge1xuICAgICAgICB0aGlzLmZsdXNoUmVtdXgodHJhbnNtdXhSZXN1bHRzLCBkZW11eFJlc3VsdCwgY2h1bmtNZXRhKTtcbiAgICAgICAgcmV0dXJuIHRyYW5zbXV4UmVzdWx0cztcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLmZsdXNoUmVtdXgodHJhbnNtdXhSZXN1bHRzLCBkZW11eFJlc3VsdE9yUHJvbWlzZSwgY2h1bmtNZXRhKTtcbiAgICByZXR1cm4gdHJhbnNtdXhSZXN1bHRzO1xuICB9XG4gIGZsdXNoUmVtdXgodHJhbnNtdXhSZXN1bHRzLCBkZW11eFJlc3VsdCwgY2h1bmtNZXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgYXVkaW9UcmFjayxcbiAgICAgIHZpZGVvVHJhY2ssXG4gICAgICBpZDNUcmFjayxcbiAgICAgIHRleHRUcmFja1xuICAgIH0gPSBkZW11eFJlc3VsdDtcbiAgICBjb25zdCB7XG4gICAgICBhY2N1cmF0ZVRpbWVPZmZzZXQsXG4gICAgICB0aW1lT2Zmc2V0XG4gICAgfSA9IHRoaXMuY3VycmVudFRyYW5zbXV4U3RhdGU7XG4gICAgbG9nZ2VyLmxvZyhgW3RyYW5zbXV4ZXIudHNdOiBGbHVzaGVkIGZyYWdtZW50ICR7Y2h1bmtNZXRhLnNufSR7Y2h1bmtNZXRhLnBhcnQgPiAtMSA/ICcgcDogJyArIGNodW5rTWV0YS5wYXJ0IDogJyd9IG9mIGxldmVsICR7Y2h1bmtNZXRhLmxldmVsfWApO1xuICAgIGNvbnN0IHJlbXV4UmVzdWx0ID0gdGhpcy5yZW11eGVyLnJlbXV4KGF1ZGlvVHJhY2ssIHZpZGVvVHJhY2ssIGlkM1RyYWNrLCB0ZXh0VHJhY2ssIHRpbWVPZmZzZXQsIGFjY3VyYXRlVGltZU9mZnNldCwgdHJ1ZSwgdGhpcy5pZCk7XG4gICAgdHJhbnNtdXhSZXN1bHRzLnB1c2goe1xuICAgICAgcmVtdXhSZXN1bHQsXG4gICAgICBjaHVua01ldGFcbiAgICB9KTtcbiAgICBjaHVua01ldGEudHJhbnNtdXhpbmcuZXhlY3V0ZUVuZCA9IG5vdygpO1xuICB9XG4gIHJlc2V0SW5pdGlhbFRpbWVzdGFtcChkZWZhdWx0SW5pdFB0cykge1xuICAgIGNvbnN0IHtcbiAgICAgIGRlbXV4ZXIsXG4gICAgICByZW11eGVyXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFkZW11eGVyIHx8ICFyZW11eGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRlbXV4ZXIucmVzZXRUaW1lU3RhbXAoZGVmYXVsdEluaXRQdHMpO1xuICAgIHJlbXV4ZXIucmVzZXRUaW1lU3RhbXAoZGVmYXVsdEluaXRQdHMpO1xuICB9XG4gIHJlc2V0Q29udGlndWl0eSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBkZW11eGVyLFxuICAgICAgcmVtdXhlclxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghZGVtdXhlciB8fCAhcmVtdXhlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkZW11eGVyLnJlc2V0Q29udGlndWl0eSgpO1xuICAgIHJlbXV4ZXIucmVzZXROZXh0VGltZXN0YW1wKCk7XG4gIH1cbiAgcmVzZXRJbml0U2VnbWVudChpbml0U2VnbWVudERhdGEsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIHRyYWNrRHVyYXRpb24sIGRlY3J5cHRkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGVtdXhlcixcbiAgICAgIHJlbXV4ZXJcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWRlbXV4ZXIgfHwgIXJlbXV4ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVtdXhlci5yZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50RGF0YSwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgdHJhY2tEdXJhdGlvbik7XG4gICAgcmVtdXhlci5yZXNldEluaXRTZWdtZW50KGluaXRTZWdtZW50RGF0YSwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgZGVjcnlwdGRhdGEpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuZGVtdXhlcikge1xuICAgICAgdGhpcy5kZW11eGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuZGVtdXhlciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKHRoaXMucmVtdXhlcikge1xuICAgICAgdGhpcy5yZW11eGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMucmVtdXhlciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbiAgdHJhbnNtdXgoZGF0YSwga2V5RGF0YSwgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBjaHVua01ldGEpIHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmIChrZXlEYXRhICYmIGtleURhdGEubWV0aG9kID09PSAnU0FNUExFLUFFUycpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMudHJhbnNtdXhTYW1wbGVBZXMoZGF0YSwga2V5RGF0YSwgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBjaHVua01ldGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSB0aGlzLnRyYW5zbXV4VW5lbmNyeXB0ZWQoZGF0YSwgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBjaHVua01ldGEpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHRyYW5zbXV4VW5lbmNyeXB0ZWQoZGF0YSwgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBjaHVua01ldGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBhdWRpb1RyYWNrLFxuICAgICAgdmlkZW9UcmFjayxcbiAgICAgIGlkM1RyYWNrLFxuICAgICAgdGV4dFRyYWNrXG4gICAgfSA9IHRoaXMuZGVtdXhlci5kZW11eChkYXRhLCB0aW1lT2Zmc2V0LCBmYWxzZSwgIXRoaXMuY29uZmlnLnByb2dyZXNzaXZlKTtcbiAgICBjb25zdCByZW11eFJlc3VsdCA9IHRoaXMucmVtdXhlci5yZW11eChhdWRpb1RyYWNrLCB2aWRlb1RyYWNrLCBpZDNUcmFjaywgdGV4dFRyYWNrLCB0aW1lT2Zmc2V0LCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGZhbHNlLCB0aGlzLmlkKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVtdXhSZXN1bHQsXG4gICAgICBjaHVua01ldGFcbiAgICB9O1xuICB9XG4gIHRyYW5zbXV4U2FtcGxlQWVzKGRhdGEsIGRlY3J5cHREYXRhLCB0aW1lT2Zmc2V0LCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGNodW5rTWV0YSkge1xuICAgIHJldHVybiB0aGlzLmRlbXV4ZXIuZGVtdXhTYW1wbGVBZXMoZGF0YSwgZGVjcnlwdERhdGEsIHRpbWVPZmZzZXQpLnRoZW4oZGVtdXhSZXN1bHQgPT4ge1xuICAgICAgY29uc3QgcmVtdXhSZXN1bHQgPSB0aGlzLnJlbXV4ZXIucmVtdXgoZGVtdXhSZXN1bHQuYXVkaW9UcmFjaywgZGVtdXhSZXN1bHQudmlkZW9UcmFjaywgZGVtdXhSZXN1bHQuaWQzVHJhY2ssIGRlbXV4UmVzdWx0LnRleHRUcmFjaywgdGltZU9mZnNldCwgYWNjdXJhdGVUaW1lT2Zmc2V0LCBmYWxzZSwgdGhpcy5pZCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW11eFJlc3VsdCxcbiAgICAgICAgY2h1bmtNZXRhXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIGNvbmZpZ3VyZVRyYW5zbXV4ZXIoZGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbmZpZyxcbiAgICAgIG9ic2VydmVyLFxuICAgICAgdHlwZVN1cHBvcnRlZCxcbiAgICAgIHZlbmRvclxuICAgIH0gPSB0aGlzO1xuICAgIC8vIHByb2JlIGZvciBjb250ZW50IHR5cGVcbiAgICBsZXQgbXV4O1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBtdXhDb25maWcubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBfbXV4Q29uZmlnJGkkZGVtdXg7XG4gICAgICBpZiAoKF9tdXhDb25maWckaSRkZW11eCA9IG11eENvbmZpZ1tpXS5kZW11eCkgIT0gbnVsbCAmJiBfbXV4Q29uZmlnJGkkZGVtdXgucHJvYmUoZGF0YSkpIHtcbiAgICAgICAgbXV4ID0gbXV4Q29uZmlnW2ldO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFtdXgpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmaW5kIGRlbXV4ZXIgYnkgcHJvYmluZyBmcmFnbWVudCBkYXRhJyk7XG4gICAgfVxuICAgIC8vIHNvIGxldCdzIGNoZWNrIHRoYXQgY3VycmVudCByZW11eGVyIGFuZCBkZW11eGVyIGFyZSBzdGlsbCB2YWxpZFxuICAgIGNvbnN0IGRlbXV4ZXIgPSB0aGlzLmRlbXV4ZXI7XG4gICAgY29uc3QgcmVtdXhlciA9IHRoaXMucmVtdXhlcjtcbiAgICBjb25zdCBSZW11eGVyID0gbXV4LnJlbXV4O1xuICAgIGNvbnN0IERlbXV4ZXIgPSBtdXguZGVtdXg7XG4gICAgaWYgKCFyZW11eGVyIHx8ICEocmVtdXhlciBpbnN0YW5jZW9mIFJlbXV4ZXIpKSB7XG4gICAgICB0aGlzLnJlbXV4ZXIgPSBuZXcgUmVtdXhlcihvYnNlcnZlciwgY29uZmlnLCB0eXBlU3VwcG9ydGVkLCB2ZW5kb3IpO1xuICAgIH1cbiAgICBpZiAoIWRlbXV4ZXIgfHwgIShkZW11eGVyIGluc3RhbmNlb2YgRGVtdXhlcikpIHtcbiAgICAgIHRoaXMuZGVtdXhlciA9IG5ldyBEZW11eGVyKG9ic2VydmVyLCBjb25maWcsIHR5cGVTdXBwb3J0ZWQpO1xuICAgICAgdGhpcy5wcm9iZSA9IERlbXV4ZXIucHJvYmU7XG4gICAgfVxuICB9XG4gIG5lZWRzUHJvYmluZyhkaXNjb250aW51aXR5LCB0cmFja1N3aXRjaCkge1xuICAgIC8vIGluIGNhc2Ugb2YgY29udGludWl0eSBjaGFuZ2UsIG9yIHRyYWNrIHN3aXRjaFxuICAgIC8vIHdlIG1pZ2h0IHN3aXRjaCBmcm9tIGNvbnRlbnQgdHlwZSAoQUFDIGNvbnRhaW5lciB0byBUUyBjb250YWluZXIsIG9yIFRTIHRvIGZtcDQgZm9yIGV4YW1wbGUpXG4gICAgcmV0dXJuICF0aGlzLmRlbXV4ZXIgfHwgIXRoaXMucmVtdXhlciB8fCBkaXNjb250aW51aXR5IHx8IHRyYWNrU3dpdGNoO1xuICB9XG4gIGdldERlY3J5cHRlcigpIHtcbiAgICBsZXQgZGVjcnlwdGVyID0gdGhpcy5kZWNyeXB0ZXI7XG4gICAgaWYgKCFkZWNyeXB0ZXIpIHtcbiAgICAgIGRlY3J5cHRlciA9IHRoaXMuZGVjcnlwdGVyID0gbmV3IERlY3J5cHRlcih0aGlzLmNvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiBkZWNyeXB0ZXI7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEVuY3J5cHRpb25UeXBlKGRhdGEsIGRlY3J5cHREYXRhKSB7XG4gIGxldCBlbmNyeXB0aW9uVHlwZSA9IG51bGw7XG4gIGlmIChkYXRhLmJ5dGVMZW5ndGggPiAwICYmIChkZWNyeXB0RGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGVjcnlwdERhdGEua2V5KSAhPSBudWxsICYmIGRlY3J5cHREYXRhLml2ICE9PSBudWxsICYmIGRlY3J5cHREYXRhLm1ldGhvZCAhPSBudWxsKSB7XG4gICAgZW5jcnlwdGlvblR5cGUgPSBkZWNyeXB0RGF0YTtcbiAgfVxuICByZXR1cm4gZW5jcnlwdGlvblR5cGU7XG59XG5jb25zdCBlbXB0eVJlc3VsdCA9IGNodW5rTWV0YSA9PiAoe1xuICByZW11eFJlc3VsdDoge30sXG4gIGNodW5rTWV0YVxufSk7XG5mdW5jdGlvbiBpc1Byb21pc2UocCkge1xuICByZXR1cm4gJ3RoZW4nIGluIHAgJiYgcC50aGVuIGluc3RhbmNlb2YgRnVuY3Rpb247XG59XG5jbGFzcyBUcmFuc211eENvbmZpZyB7XG4gIGNvbnN0cnVjdG9yKGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGluaXRTZWdtZW50RGF0YSwgZHVyYXRpb24sIGRlZmF1bHRJbml0UHRzKSB7XG4gICAgdGhpcy5hdWRpb0NvZGVjID0gdm9pZCAwO1xuICAgIHRoaXMudmlkZW9Db2RlYyA9IHZvaWQgMDtcbiAgICB0aGlzLmluaXRTZWdtZW50RGF0YSA9IHZvaWQgMDtcbiAgICB0aGlzLmR1cmF0aW9uID0gdm9pZCAwO1xuICAgIHRoaXMuZGVmYXVsdEluaXRQdHMgPSB2b2lkIDA7XG4gICAgdGhpcy5hdWRpb0NvZGVjID0gYXVkaW9Db2RlYztcbiAgICB0aGlzLnZpZGVvQ29kZWMgPSB2aWRlb0NvZGVjO1xuICAgIHRoaXMuaW5pdFNlZ21lbnREYXRhID0gaW5pdFNlZ21lbnREYXRhO1xuICAgIHRoaXMuZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICB0aGlzLmRlZmF1bHRJbml0UHRzID0gZGVmYXVsdEluaXRQdHMgfHwgbnVsbDtcbiAgfVxufVxuY2xhc3MgVHJhbnNtdXhTdGF0ZSB7XG4gIGNvbnN0cnVjdG9yKGRpc2NvbnRpbnVpdHksIGNvbnRpZ3VvdXMsIGFjY3VyYXRlVGltZU9mZnNldCwgdHJhY2tTd2l0Y2gsIHRpbWVPZmZzZXQsIGluaXRTZWdtZW50Q2hhbmdlKSB7XG4gICAgdGhpcy5kaXNjb250aW51aXR5ID0gdm9pZCAwO1xuICAgIHRoaXMuY29udGlndW91cyA9IHZvaWQgMDtcbiAgICB0aGlzLmFjY3VyYXRlVGltZU9mZnNldCA9IHZvaWQgMDtcbiAgICB0aGlzLnRyYWNrU3dpdGNoID0gdm9pZCAwO1xuICAgIHRoaXMudGltZU9mZnNldCA9IHZvaWQgMDtcbiAgICB0aGlzLmluaXRTZWdtZW50Q2hhbmdlID0gdm9pZCAwO1xuICAgIHRoaXMuZGlzY29udGludWl0eSA9IGRpc2NvbnRpbnVpdHk7XG4gICAgdGhpcy5jb250aWd1b3VzID0gY29udGlndW91cztcbiAgICB0aGlzLmFjY3VyYXRlVGltZU9mZnNldCA9IGFjY3VyYXRlVGltZU9mZnNldDtcbiAgICB0aGlzLnRyYWNrU3dpdGNoID0gdHJhY2tTd2l0Y2g7XG4gICAgdGhpcy50aW1lT2Zmc2V0ID0gdGltZU9mZnNldDtcbiAgICB0aGlzLmluaXRTZWdtZW50Q2hhbmdlID0gaW5pdFNlZ21lbnRDaGFuZ2U7XG4gIH1cbn1cblxudmFyIGV2ZW50ZW1pdHRlcjMgPSB7ZXhwb3J0czoge319O1xuXG4oZnVuY3Rpb24gKG1vZHVsZSkge1xuXG5cdHZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG5cdCAgLCBwcmVmaXggPSAnfic7XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdG9yIHRvIGNyZWF0ZSBhIHN0b3JhZ2UgZm9yIG91ciBgRUVgIG9iamVjdHMuXG5cdCAqIEFuIGBFdmVudHNgIGluc3RhbmNlIGlzIGEgcGxhaW4gb2JqZWN0IHdob3NlIHByb3BlcnRpZXMgYXJlIGV2ZW50IG5hbWVzLlxuXHQgKlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIEV2ZW50cygpIHt9XG5cblx0Ly9cblx0Ly8gV2UgdHJ5IHRvIG5vdCBpbmhlcml0IGZyb20gYE9iamVjdC5wcm90b3R5cGVgLiBJbiBzb21lIGVuZ2luZXMgY3JlYXRpbmcgYW5cblx0Ly8gaW5zdGFuY2UgaW4gdGhpcyB3YXkgaXMgZmFzdGVyIHRoYW4gY2FsbGluZyBgT2JqZWN0LmNyZWF0ZShudWxsKWAgZGlyZWN0bHkuXG5cdC8vIElmIGBPYmplY3QuY3JlYXRlKG51bGwpYCBpcyBub3Qgc3VwcG9ydGVkIHdlIHByZWZpeCB0aGUgZXZlbnQgbmFtZXMgd2l0aCBhXG5cdC8vIGNoYXJhY3RlciB0byBtYWtlIHN1cmUgdGhhdCB0aGUgYnVpbHQtaW4gb2JqZWN0IHByb3BlcnRpZXMgYXJlIG5vdFxuXHQvLyBvdmVycmlkZGVuIG9yIHVzZWQgYXMgYW4gYXR0YWNrIHZlY3Rvci5cblx0Ly9cblx0aWYgKE9iamVjdC5jcmVhdGUpIHtcblx0ICBFdmVudHMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuXHQgIC8vXG5cdCAgLy8gVGhpcyBoYWNrIGlzIG5lZWRlZCBiZWNhdXNlIHRoZSBgX19wcm90b19fYCBwcm9wZXJ0eSBpcyBzdGlsbCBpbmhlcml0ZWQgaW5cblx0ICAvLyBzb21lIG9sZCBicm93c2VycyBsaWtlIEFuZHJvaWQgNCwgaVBob25lIDUuMSwgT3BlcmEgMTEgYW5kIFNhZmFyaSA1LlxuXHQgIC8vXG5cdCAgaWYgKCFuZXcgRXZlbnRzKCkuX19wcm90b19fKSBwcmVmaXggPSBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXByZXNlbnRhdGlvbiBvZiBhIHNpbmdsZSBldmVudCBsaXN0ZW5lci5cblx0ICpcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuXHQgKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtvbmNlPWZhbHNlXSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIEVFKGZuLCBjb250ZXh0LCBvbmNlKSB7XG5cdCAgdGhpcy5mbiA9IGZuO1xuXHQgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG5cdCAgdGhpcy5vbmNlID0gb25jZSB8fCBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG5cdCAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuXHQgKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWRkTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG5cdCAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGxpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXHQgIH1cblxuXHQgIHZhciBsaXN0ZW5lciA9IG5ldyBFRShmbiwgY29udGV4dCB8fCBlbWl0dGVyLCBvbmNlKVxuXHQgICAgLCBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG5cdCAgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XSkgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBsaXN0ZW5lciwgZW1pdHRlci5fZXZlbnRzQ291bnQrKztcblx0ICBlbHNlIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0uZm4pIGVtaXR0ZXIuX2V2ZW50c1tldnRdLnB1c2gobGlzdGVuZXIpO1xuXHQgIGVsc2UgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBbZW1pdHRlci5fZXZlbnRzW2V2dF0sIGxpc3RlbmVyXTtcblxuXHQgIHJldHVybiBlbWl0dGVyO1xuXHR9XG5cblx0LyoqXG5cdCAqIENsZWFyIGV2ZW50IGJ5IG5hbWUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG5cdCAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldnQgVGhlIEV2ZW50IG5hbWUuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBjbGVhckV2ZW50KGVtaXR0ZXIsIGV2dCkge1xuXHQgIGlmICgtLWVtaXR0ZXIuX2V2ZW50c0NvdW50ID09PSAwKSBlbWl0dGVyLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG5cdCAgZWxzZSBkZWxldGUgZW1pdHRlci5fZXZlbnRzW2V2dF07XG5cdH1cblxuXHQvKipcblx0ICogTWluaW1hbCBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UgdGhhdCBpcyBtb2xkZWQgYWdhaW5zdCB0aGUgTm9kZS5qc1xuXHQgKiBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UuXG5cdCAqXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcHVibGljXG5cdCAqL1xuXHRmdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG5cdCAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuXHQgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm4gYW4gYXJyYXkgbGlzdGluZyB0aGUgZXZlbnRzIGZvciB3aGljaCB0aGUgZW1pdHRlciBoYXMgcmVnaXN0ZXJlZFxuXHQgKiBsaXN0ZW5lcnMuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtBcnJheX1cblx0ICogQHB1YmxpY1xuXHQgKi9cblx0RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcblx0ICB2YXIgbmFtZXMgPSBbXVxuXHQgICAgLCBldmVudHNcblx0ICAgICwgbmFtZTtcblxuXHQgIGlmICh0aGlzLl9ldmVudHNDb3VudCA9PT0gMCkgcmV0dXJuIG5hbWVzO1xuXG5cdCAgZm9yIChuYW1lIGluIChldmVudHMgPSB0aGlzLl9ldmVudHMpKSB7XG5cdCAgICBpZiAoaGFzLmNhbGwoZXZlbnRzLCBuYW1lKSkgbmFtZXMucHVzaChwcmVmaXggPyBuYW1lLnNsaWNlKDEpIDogbmFtZSk7XG5cdCAgfVxuXG5cdCAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0ICAgIHJldHVybiBuYW1lcy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhldmVudHMpKTtcblx0ICB9XG5cblx0ICByZXR1cm4gbmFtZXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgcmVnaXN0ZXJlZCBsaXN0ZW5lcnMuXG5cdCAqIEBwdWJsaWNcblx0ICovXG5cdEV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKGV2ZW50KSB7XG5cdCAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcblx0ICAgICwgaGFuZGxlcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuXHQgIGlmICghaGFuZGxlcnMpIHJldHVybiBbXTtcblx0ICBpZiAoaGFuZGxlcnMuZm4pIHJldHVybiBbaGFuZGxlcnMuZm5dO1xuXG5cdCAgZm9yICh2YXIgaSA9IDAsIGwgPSBoYW5kbGVycy5sZW5ndGgsIGVlID0gbmV3IEFycmF5KGwpOyBpIDwgbDsgaSsrKSB7XG5cdCAgICBlZVtpXSA9IGhhbmRsZXJzW2ldLmZuO1xuXHQgIH1cblxuXHQgIHJldHVybiBlZTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJuIHRoZSBudW1iZXIgb2YgbGlzdGVuZXJzIGxpc3RlbmluZyB0byBhIGdpdmVuIGV2ZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1iZXIgb2YgbGlzdGVuZXJzLlxuXHQgKiBAcHVibGljXG5cdCAqL1xuXHRFdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiBsaXN0ZW5lckNvdW50KGV2ZW50KSB7XG5cdCAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcblx0ICAgICwgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cblx0ICBpZiAoIWxpc3RlbmVycykgcmV0dXJuIDA7XG5cdCAgaWYgKGxpc3RlbmVycy5mbikgcmV0dXJuIDE7XG5cdCAgcmV0dXJuIGxpc3RlbmVycy5sZW5ndGg7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxzIGVhY2ggb2YgdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIGV2ZW50IGhhZCBsaXN0ZW5lcnMsIGVsc2UgYGZhbHNlYC5cblx0ICogQHB1YmxpY1xuXHQgKi9cblx0RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdChldmVudCwgYTEsIGEyLCBhMywgYTQsIGE1KSB7XG5cdCAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cblx0ICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gZmFsc2U7XG5cblx0ICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF1cblx0ICAgICwgbGVuID0gYXJndW1lbnRzLmxlbmd0aFxuXHQgICAgLCBhcmdzXG5cdCAgICAsIGk7XG5cblx0ICBpZiAobGlzdGVuZXJzLmZuKSB7XG5cdCAgICBpZiAobGlzdGVuZXJzLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVycy5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuXHQgICAgc3dpdGNoIChsZW4pIHtcblx0ICAgICAgY2FzZSAxOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQpLCB0cnVlO1xuXHQgICAgICBjYXNlIDI6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEpLCB0cnVlO1xuXHQgICAgICBjYXNlIDM6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyKSwgdHJ1ZTtcblx0ICAgICAgY2FzZSA0OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMpLCB0cnVlO1xuXHQgICAgICBjYXNlIDU6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQpLCB0cnVlO1xuXHQgICAgICBjYXNlIDY6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQsIGE1KSwgdHJ1ZTtcblx0ICAgIH1cblxuXHQgICAgZm9yIChpID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBpIDwgbGVuOyBpKyspIHtcblx0ICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG5cdCAgICB9XG5cblx0ICAgIGxpc3RlbmVycy5mbi5hcHBseShsaXN0ZW5lcnMuY29udGV4dCwgYXJncyk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHZhciBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoXG5cdCAgICAgICwgajtcblxuXHQgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIGlmIChsaXN0ZW5lcnNbaV0ub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzW2ldLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG5cdCAgICAgIHN3aXRjaCAobGVuKSB7XG5cdCAgICAgICAgY2FzZSAxOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCk7IGJyZWFrO1xuXHQgICAgICAgIGNhc2UgMjogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExKTsgYnJlYWs7XG5cdCAgICAgICAgY2FzZSAzOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyKTsgYnJlYWs7XG5cdCAgICAgICAgY2FzZSA0OiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyLCBhMyk7IGJyZWFrO1xuXHQgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICBpZiAoIWFyZ3MpIGZvciAoaiA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaiA8IGxlbjsgaisrKSB7XG5cdCAgICAgICAgICAgIGFyZ3NbaiAtIDFdID0gYXJndW1lbnRzW2pdO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBsaXN0ZW5lcnNbaV0uZm4uYXBwbHkobGlzdGVuZXJzW2ldLmNvbnRleHQsIGFyZ3MpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHRydWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cblx0ICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG5cdCAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cblx0ICogQHB1YmxpY1xuXHQgKi9cblx0RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKGV2ZW50LCBmbiwgY29udGV4dCkge1xuXHQgIHJldHVybiBhZGRMaXN0ZW5lcih0aGlzLCBldmVudCwgZm4sIGNvbnRleHQsIGZhbHNlKTtcblx0fTtcblxuXHQvKipcblx0ICogQWRkIGEgb25lLXRpbWUgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuXHQgKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cblx0ICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuXHQgKiBAcHVibGljXG5cdCAqL1xuXHRFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKGV2ZW50LCBmbiwgY29udGV4dCkge1xuXHQgIHJldHVybiBhZGRMaXN0ZW5lcih0aGlzLCBldmVudCwgZm4sIGNvbnRleHQsIHRydWUpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZW1vdmUgdGhlIGxpc3RlbmVycyBvZiBhIGdpdmVuIGV2ZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIE9ubHkgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdGhhdCBtYXRjaCB0aGlzIGZ1bmN0aW9uLlxuXHQgKiBAcGFyYW0geyp9IGNvbnRleHQgT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IGhhdmUgdGhpcyBjb250ZXh0LlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgT25seSByZW1vdmUgb25lLXRpbWUgbGlzdGVuZXJzLlxuXHQgKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG5cdCAqIEBwdWJsaWNcblx0ICovXG5cdEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcblx0ICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuXHQgIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiB0aGlzO1xuXHQgIGlmICghZm4pIHtcblx0ICAgIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH1cblxuXHQgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuXHQgIGlmIChsaXN0ZW5lcnMuZm4pIHtcblx0ICAgIGlmIChcblx0ICAgICAgbGlzdGVuZXJzLmZuID09PSBmbiAmJlxuXHQgICAgICAoIW9uY2UgfHwgbGlzdGVuZXJzLm9uY2UpICYmXG5cdCAgICAgICghY29udGV4dCB8fCBsaXN0ZW5lcnMuY29udGV4dCA9PT0gY29udGV4dClcblx0ICAgICkge1xuXHQgICAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG5cdCAgICB9XG5cdCAgfSBlbHNlIHtcblx0ICAgIGZvciAodmFyIGkgPSAwLCBldmVudHMgPSBbXSwgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIGlmIChcblx0ICAgICAgICBsaXN0ZW5lcnNbaV0uZm4gIT09IGZuIHx8XG5cdCAgICAgICAgKG9uY2UgJiYgIWxpc3RlbmVyc1tpXS5vbmNlKSB8fFxuXHQgICAgICAgIChjb250ZXh0ICYmIGxpc3RlbmVyc1tpXS5jb250ZXh0ICE9PSBjb250ZXh0KVxuXHQgICAgICApIHtcblx0ICAgICAgICBldmVudHMucHVzaChsaXN0ZW5lcnNbaV0pO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIC8vXG5cdCAgICAvLyBSZXNldCB0aGUgYXJyYXksIG9yIHJlbW92ZSBpdCBjb21wbGV0ZWx5IGlmIHdlIGhhdmUgbm8gbW9yZSBsaXN0ZW5lcnMuXG5cdCAgICAvL1xuXHQgICAgaWYgKGV2ZW50cy5sZW5ndGgpIHRoaXMuX2V2ZW50c1tldnRdID0gZXZlbnRzLmxlbmd0aCA9PT0gMSA/IGV2ZW50c1swXSA6IGV2ZW50cztcblx0ICAgIGVsc2UgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuXHQgIH1cblxuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZW1vdmUgYWxsIGxpc3RlbmVycywgb3IgdGhvc2Ugb2YgdGhlIHNwZWNpZmllZCBldmVudC5cblx0ICpcblx0ICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IFtldmVudF0gVGhlIGV2ZW50IG5hbWUuXG5cdCAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cblx0ICogQHB1YmxpY1xuXHQgKi9cblx0RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcblx0ICB2YXIgZXZ0O1xuXG5cdCAgaWYgKGV2ZW50KSB7XG5cdCAgICBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXHQgICAgaWYgKHRoaXMuX2V2ZW50c1tldnRdKSBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcblx0ICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcblx0ICB9XG5cblx0ICByZXR1cm4gdGhpcztcblx0fTtcblxuXHQvL1xuXHQvLyBBbGlhcyBtZXRob2RzIG5hbWVzIGJlY2F1c2UgcGVvcGxlIHJvbGwgbGlrZSB0aGF0LlxuXHQvL1xuXHRFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5cdEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uO1xuXG5cdC8vXG5cdC8vIEV4cG9zZSB0aGUgcHJlZml4LlxuXHQvL1xuXHRFdmVudEVtaXR0ZXIucHJlZml4ZWQgPSBwcmVmaXg7XG5cblx0Ly9cblx0Ly8gQWxsb3cgYEV2ZW50RW1pdHRlcmAgdG8gYmUgaW1wb3J0ZWQgYXMgbW9kdWxlIG5hbWVzcGFjZS5cblx0Ly9cblx0RXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuXHQvL1xuXHQvLyBFeHBvc2UgdGhlIG1vZHVsZS5cblx0Ly9cblx0e1xuXHQgIG1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXHR9IFxufSAoZXZlbnRlbWl0dGVyMykpO1xuXG52YXIgZXZlbnRlbWl0dGVyM0V4cG9ydHMgPSBldmVudGVtaXR0ZXIzLmV4cG9ydHM7XG52YXIgRXZlbnRFbWl0dGVyID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGV2ZW50ZW1pdHRlcjNFeHBvcnRzKTtcblxuY2xhc3MgVHJhbnNtdXhlckludGVyZmFjZSB7XG4gIGNvbnN0cnVjdG9yKGhscywgaWQsIG9uVHJhbnNtdXhDb21wbGV0ZSwgb25GbHVzaCkge1xuICAgIHRoaXMuZXJyb3IgPSBudWxsO1xuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMuaWQgPSB2b2lkIDA7XG4gICAgdGhpcy5vYnNlcnZlciA9IHZvaWQgMDtcbiAgICB0aGlzLmZyYWcgPSBudWxsO1xuICAgIHRoaXMucGFydCA9IG51bGw7XG4gICAgdGhpcy51c2VXb3JrZXIgPSB2b2lkIDA7XG4gICAgdGhpcy53b3JrZXJDb250ZXh0ID0gbnVsbDtcbiAgICB0aGlzLm9ud21zZyA9IHZvaWQgMDtcbiAgICB0aGlzLnRyYW5zbXV4ZXIgPSBudWxsO1xuICAgIHRoaXMub25UcmFuc211eENvbXBsZXRlID0gdm9pZCAwO1xuICAgIHRoaXMub25GbHVzaCA9IHZvaWQgMDtcbiAgICBjb25zdCBjb25maWcgPSBobHMuY29uZmlnO1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLnVzZVdvcmtlciA9ICEhY29uZmlnLmVuYWJsZVdvcmtlcjtcbiAgICB0aGlzLm9uVHJhbnNtdXhDb21wbGV0ZSA9IG9uVHJhbnNtdXhDb21wbGV0ZTtcbiAgICB0aGlzLm9uRmx1c2ggPSBvbkZsdXNoO1xuICAgIGNvbnN0IGZvcndhcmRNZXNzYWdlID0gKGV2LCBkYXRhKSA9PiB7XG4gICAgICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgICAgIGRhdGEuZnJhZyA9IHRoaXMuZnJhZztcbiAgICAgIGRhdGEuaWQgPSB0aGlzLmlkO1xuICAgICAgaWYgKGV2ID09PSBFdmVudHMuRVJST1IpIHtcbiAgICAgICAgdGhpcy5lcnJvciA9IGRhdGEuZXJyb3I7XG4gICAgICB9XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKGV2LCBkYXRhKTtcbiAgICB9O1xuXG4gICAgLy8gZm9yd2FyZCBldmVudHMgdG8gbWFpbiB0aHJlYWRcbiAgICB0aGlzLm9ic2VydmVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIHRoaXMub2JzZXJ2ZXIub24oRXZlbnRzLkZSQUdfREVDUllQVEVELCBmb3J3YXJkTWVzc2FnZSk7XG4gICAgdGhpcy5vYnNlcnZlci5vbihFdmVudHMuRVJST1IsIGZvcndhcmRNZXNzYWdlKTtcbiAgICBjb25zdCBNZWRpYVNvdXJjZSA9IGdldE1lZGlhU291cmNlKGNvbmZpZy5wcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UpIHx8IHtcbiAgICAgIGlzVHlwZVN1cHBvcnRlZDogKCkgPT4gZmFsc2VcbiAgICB9O1xuICAgIGNvbnN0IG0ydHNUeXBlU3VwcG9ydGVkID0ge1xuICAgICAgbXBlZzogTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKCdhdWRpby9tcGVnJyksXG4gICAgICBtcDM6IE1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCgnYXVkaW8vbXA0OyBjb2RlY3M9XCJtcDNcIicpLFxuICAgICAgYWMzOiBNZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQoJ2F1ZGlvL21wNDsgY29kZWNzPVwiYWMtM1wiJykgXG4gICAgfTtcblxuICAgIC8vIG5hdmlnYXRvci52ZW5kb3IgaXMgbm90IGFsd2F5cyBhdmFpbGFibGUgaW4gV2ViIFdvcmtlclxuICAgIC8vIHJlZmVyIHRvIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Xb3JrZXJHbG9iYWxTY29wZS9uYXZpZ2F0b3JcbiAgICBjb25zdCB2ZW5kb3IgPSBuYXZpZ2F0b3IudmVuZG9yO1xuICAgIGlmICh0aGlzLnVzZVdvcmtlciAmJiB0eXBlb2YgV29ya2VyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc3QgY2FuQ3JlYXRlV29ya2VyID0gY29uZmlnLndvcmtlclBhdGggfHwgaGFzVU1EV29ya2VyKCk7XG4gICAgICBpZiAoY2FuQ3JlYXRlV29ya2VyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKGNvbmZpZy53b3JrZXJQYXRoKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKGBsb2FkaW5nIFdlYiBXb3JrZXIgJHtjb25maWcud29ya2VyUGF0aH0gZm9yIFwiJHtpZH1cImApO1xuICAgICAgICAgICAgdGhpcy53b3JrZXJDb250ZXh0ID0gbG9hZFdvcmtlcihjb25maWcud29ya2VyUGF0aCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coYGluamVjdGluZyBXZWIgV29ya2VyIGZvciBcIiR7aWR9XCJgKTtcbiAgICAgICAgICAgIHRoaXMud29ya2VyQ29udGV4dCA9IGluamVjdFdvcmtlcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLm9ud21zZyA9IGV2ID0+IHRoaXMub25Xb3JrZXJNZXNzYWdlKGV2KTtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICB3b3JrZXJcbiAgICAgICAgICB9ID0gdGhpcy53b3JrZXJDb250ZXh0O1xuICAgICAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5vbndtc2cpO1xuICAgICAgICAgIHdvcmtlci5vbmVycm9yID0gZXZlbnQgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYCR7ZXZlbnQubWVzc2FnZX0gICgke2V2ZW50LmZpbGVuYW1lfToke2V2ZW50LmxpbmVub30pYCk7XG4gICAgICAgICAgICBjb25maWcuZW5hYmxlV29ya2VyID0gZmFsc2U7XG4gICAgICAgICAgICBsb2dnZXIud2FybihgRXJyb3IgaW4gXCIke2lkfVwiIFdlYiBXb3JrZXIsIGZhbGxiYWNrIHRvIGlubGluZWApO1xuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5PVEhFUl9FUlJPUixcbiAgICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLklOVEVSTkFMX0VYQ0VQVElPTixcbiAgICAgICAgICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgICAgICAgICBldmVudDogJ2RlbXV4ZXJXb3JrZXInLFxuICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgY21kOiAnaW5pdCcsXG4gICAgICAgICAgICB0eXBlU3VwcG9ydGVkOiBtMnRzVHlwZVN1cHBvcnRlZCxcbiAgICAgICAgICAgIHZlbmRvcjogdmVuZG9yLFxuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgY29uZmlnOiBKU09OLnN0cmluZ2lmeShjb25maWcpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGxvZ2dlci53YXJuKGBFcnJvciBzZXR0aW5nIHVwIFwiJHtpZH1cIiBXZWIgV29ya2VyLCBmYWxsYmFjayB0byBpbmxpbmVgLCBlcnIpO1xuICAgICAgICAgIHRoaXMucmVzZXRXb3JrZXIoKTtcbiAgICAgICAgICB0aGlzLmVycm9yID0gbnVsbDtcbiAgICAgICAgICB0aGlzLnRyYW5zbXV4ZXIgPSBuZXcgVHJhbnNtdXhlcih0aGlzLm9ic2VydmVyLCBtMnRzVHlwZVN1cHBvcnRlZCwgY29uZmlnLCB2ZW5kb3IsIGlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudHJhbnNtdXhlciA9IG5ldyBUcmFuc211eGVyKHRoaXMub2JzZXJ2ZXIsIG0ydHNUeXBlU3VwcG9ydGVkLCBjb25maWcsIHZlbmRvciwgaWQpO1xuICB9XG4gIHJlc2V0V29ya2VyKCkge1xuICAgIGlmICh0aGlzLndvcmtlckNvbnRleHQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgd29ya2VyLFxuICAgICAgICBvYmplY3RVUkxcbiAgICAgIH0gPSB0aGlzLndvcmtlckNvbnRleHQ7XG4gICAgICBpZiAob2JqZWN0VVJMKSB7XG4gICAgICAgIC8vIHJldm9rZSB0aGUgT2JqZWN0IFVSTCB0aGF0IHdhcyB1c2VkIHRvIGNyZWF0ZSB0cmFuc211eGVyIHdvcmtlciwgc28gYXMgbm90IHRvIGxlYWsgaXRcbiAgICAgICAgc2VsZi5VUkwucmV2b2tlT2JqZWN0VVJMKG9iamVjdFVSTCk7XG4gICAgICB9XG4gICAgICB3b3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMub253bXNnKTtcbiAgICAgIHdvcmtlci5vbmVycm9yID0gbnVsbDtcbiAgICAgIHdvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgIHRoaXMud29ya2VyQ29udGV4dCA9IG51bGw7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMud29ya2VyQ29udGV4dCkge1xuICAgICAgdGhpcy5yZXNldFdvcmtlcigpO1xuICAgICAgdGhpcy5vbndtc2cgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRyYW5zbXV4ZXIgPSB0aGlzLnRyYW5zbXV4ZXI7XG4gICAgICBpZiAodHJhbnNtdXhlcikge1xuICAgICAgICB0cmFuc211eGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy50cmFuc211eGVyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSB0aGlzLm9ic2VydmVyO1xuICAgIGlmIChvYnNlcnZlcikge1xuICAgICAgb2JzZXJ2ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgfVxuICAgIHRoaXMuZnJhZyA9IG51bGw7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMub2JzZXJ2ZXIgPSBudWxsO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmhscyA9IG51bGw7XG4gIH1cbiAgcHVzaChkYXRhLCBpbml0U2VnbWVudERhdGEsIGF1ZGlvQ29kZWMsIHZpZGVvQ29kZWMsIGZyYWcsIHBhcnQsIGR1cmF0aW9uLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGNodW5rTWV0YSwgZGVmYXVsdEluaXRQVFMpIHtcbiAgICB2YXIgX2ZyYWckaW5pdFNlZ21lbnQsIF9sYXN0RnJhZyRpbml0U2VnbWVudDtcbiAgICBjaHVua01ldGEudHJhbnNtdXhpbmcuc3RhcnQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGNvbnN0IHtcbiAgICAgIHRyYW5zbXV4ZXJcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB0aW1lT2Zmc2V0ID0gcGFydCA/IHBhcnQuc3RhcnQgOiBmcmFnLnN0YXJ0O1xuICAgIC8vIFRPRE86IHB1c2ggXCJjbGVhci1sZWFkXCIgZGVjcnlwdCBkYXRhIGZvciB1bmVuY3J5cHRlZCBmcmFnbWVudHMgaW4gc3RyZWFtcyB3aXRoIGVuY3J5cHRlZCBvbmVzXG4gICAgY29uc3QgZGVjcnlwdGRhdGEgPSBmcmFnLmRlY3J5cHRkYXRhO1xuICAgIGNvbnN0IGxhc3RGcmFnID0gdGhpcy5mcmFnO1xuICAgIGNvbnN0IGRpc2NvbnRpbnVpdHkgPSAhKGxhc3RGcmFnICYmIGZyYWcuY2MgPT09IGxhc3RGcmFnLmNjKTtcbiAgICBjb25zdCB0cmFja1N3aXRjaCA9ICEobGFzdEZyYWcgJiYgY2h1bmtNZXRhLmxldmVsID09PSBsYXN0RnJhZy5sZXZlbCk7XG4gICAgY29uc3Qgc25EaWZmID0gbGFzdEZyYWcgPyBjaHVua01ldGEuc24gLSBsYXN0RnJhZy5zbiA6IC0xO1xuICAgIGNvbnN0IHBhcnREaWZmID0gdGhpcy5wYXJ0ID8gY2h1bmtNZXRhLnBhcnQgLSB0aGlzLnBhcnQuaW5kZXggOiAtMTtcbiAgICBjb25zdCBwcm9ncmVzc2l2ZSA9IHNuRGlmZiA9PT0gMCAmJiBjaHVua01ldGEuaWQgPiAxICYmIGNodW5rTWV0YS5pZCA9PT0gKGxhc3RGcmFnID09IG51bGwgPyB2b2lkIDAgOiBsYXN0RnJhZy5zdGF0cy5jaHVua0NvdW50KTtcbiAgICBjb25zdCBjb250aWd1b3VzID0gIXRyYWNrU3dpdGNoICYmIChzbkRpZmYgPT09IDEgfHwgc25EaWZmID09PSAwICYmIChwYXJ0RGlmZiA9PT0gMSB8fCBwcm9ncmVzc2l2ZSAmJiBwYXJ0RGlmZiA8PSAwKSk7XG4gICAgY29uc3Qgbm93ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICBpZiAodHJhY2tTd2l0Y2ggfHwgc25EaWZmIHx8IGZyYWcuc3RhdHMucGFyc2luZy5zdGFydCA9PT0gMCkge1xuICAgICAgZnJhZy5zdGF0cy5wYXJzaW5nLnN0YXJ0ID0gbm93O1xuICAgIH1cbiAgICBpZiAocGFydCAmJiAocGFydERpZmYgfHwgIWNvbnRpZ3VvdXMpKSB7XG4gICAgICBwYXJ0LnN0YXRzLnBhcnNpbmcuc3RhcnQgPSBub3c7XG4gICAgfVxuICAgIGNvbnN0IGluaXRTZWdtZW50Q2hhbmdlID0gIShsYXN0RnJhZyAmJiAoKF9mcmFnJGluaXRTZWdtZW50ID0gZnJhZy5pbml0U2VnbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9mcmFnJGluaXRTZWdtZW50LnVybCkgPT09ICgoX2xhc3RGcmFnJGluaXRTZWdtZW50ID0gbGFzdEZyYWcuaW5pdFNlZ21lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfbGFzdEZyYWckaW5pdFNlZ21lbnQudXJsKSk7XG4gICAgY29uc3Qgc3RhdGUgPSBuZXcgVHJhbnNtdXhTdGF0ZShkaXNjb250aW51aXR5LCBjb250aWd1b3VzLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIHRyYWNrU3dpdGNoLCB0aW1lT2Zmc2V0LCBpbml0U2VnbWVudENoYW5nZSk7XG4gICAgaWYgKCFjb250aWd1b3VzIHx8IGRpc2NvbnRpbnVpdHkgfHwgaW5pdFNlZ21lbnRDaGFuZ2UpIHtcbiAgICAgIGxvZ2dlci5sb2coYFt0cmFuc211eGVyLWludGVyZmFjZSwgJHtmcmFnLnR5cGV9XTogU3RhcnRpbmcgbmV3IHRyYW5zbXV4IHNlc3Npb24gZm9yIHNuOiAke2NodW5rTWV0YS5zbn0gcDogJHtjaHVua01ldGEucGFydH0gbGV2ZWw6ICR7Y2h1bmtNZXRhLmxldmVsfSBpZDogJHtjaHVua01ldGEuaWR9XG4gICAgICAgIGRpc2NvbnRpbnVpdHk6ICR7ZGlzY29udGludWl0eX1cbiAgICAgICAgdHJhY2tTd2l0Y2g6ICR7dHJhY2tTd2l0Y2h9XG4gICAgICAgIGNvbnRpZ3VvdXM6ICR7Y29udGlndW91c31cbiAgICAgICAgYWNjdXJhdGVUaW1lT2Zmc2V0OiAke2FjY3VyYXRlVGltZU9mZnNldH1cbiAgICAgICAgdGltZU9mZnNldDogJHt0aW1lT2Zmc2V0fVxuICAgICAgICBpbml0U2VnbWVudENoYW5nZTogJHtpbml0U2VnbWVudENoYW5nZX1gKTtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IG5ldyBUcmFuc211eENvbmZpZyhhdWRpb0NvZGVjLCB2aWRlb0NvZGVjLCBpbml0U2VnbWVudERhdGEsIGR1cmF0aW9uLCBkZWZhdWx0SW5pdFBUUyk7XG4gICAgICB0aGlzLmNvbmZpZ3VyZVRyYW5zbXV4ZXIoY29uZmlnKTtcbiAgICB9XG4gICAgdGhpcy5mcmFnID0gZnJhZztcbiAgICB0aGlzLnBhcnQgPSBwYXJ0O1xuXG4gICAgLy8gRnJhZ3Mgd2l0aCBzbiBvZiAnaW5pdFNlZ21lbnQnIGFyZSBub3QgdHJhbnNtdXhlZFxuICAgIGlmICh0aGlzLndvcmtlckNvbnRleHQpIHtcbiAgICAgIC8vIHBvc3QgZnJhZ21lbnQgcGF5bG9hZCBhcyB0cmFuc2ZlcmFibGUgb2JqZWN0cyBmb3IgQXJyYXlCdWZmZXIgKG5vIGNvcHkpXG4gICAgICB0aGlzLndvcmtlckNvbnRleHQud29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgY21kOiAnZGVtdXgnLFxuICAgICAgICBkYXRhLFxuICAgICAgICBkZWNyeXB0ZGF0YSxcbiAgICAgICAgY2h1bmtNZXRhLFxuICAgICAgICBzdGF0ZVxuICAgICAgfSwgZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyID8gW2RhdGFdIDogW10pO1xuICAgIH0gZWxzZSBpZiAodHJhbnNtdXhlcikge1xuICAgICAgY29uc3QgdHJhbnNtdXhSZXN1bHQgPSB0cmFuc211eGVyLnB1c2goZGF0YSwgZGVjcnlwdGRhdGEsIGNodW5rTWV0YSwgc3RhdGUpO1xuICAgICAgaWYgKGlzUHJvbWlzZSh0cmFuc211eFJlc3VsdCkpIHtcbiAgICAgICAgdHJhbnNtdXhlci5hc3luYyA9IHRydWU7XG4gICAgICAgIHRyYW5zbXV4UmVzdWx0LnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVUcmFuc211eENvbXBsZXRlKGRhdGEpO1xuICAgICAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgdGhpcy50cmFuc211eGVyRXJyb3IoZXJyb3IsIGNodW5rTWV0YSwgJ3RyYW5zbXV4ZXItaW50ZXJmYWNlIHB1c2ggZXJyb3InKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFuc211eGVyLmFzeW5jID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFuZGxlVHJhbnNtdXhDb21wbGV0ZSh0cmFuc211eFJlc3VsdCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZsdXNoKGNodW5rTWV0YSkge1xuICAgIGNodW5rTWV0YS50cmFuc211eGluZy5zdGFydCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY29uc3Qge1xuICAgICAgdHJhbnNtdXhlclxuICAgIH0gPSB0aGlzO1xuICAgIGlmICh0aGlzLndvcmtlckNvbnRleHQpIHtcbiAgICAgIHRoaXMud29ya2VyQ29udGV4dC53b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBjbWQ6ICdmbHVzaCcsXG4gICAgICAgIGNodW5rTWV0YVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0cmFuc211eGVyKSB7XG4gICAgICBsZXQgdHJhbnNtdXhSZXN1bHQgPSB0cmFuc211eGVyLmZsdXNoKGNodW5rTWV0YSk7XG4gICAgICBjb25zdCBhc3luY0ZsdXNoID0gaXNQcm9taXNlKHRyYW5zbXV4UmVzdWx0KTtcbiAgICAgIGlmIChhc3luY0ZsdXNoIHx8IHRyYW5zbXV4ZXIuYXN5bmMpIHtcbiAgICAgICAgaWYgKCFpc1Byb21pc2UodHJhbnNtdXhSZXN1bHQpKSB7XG4gICAgICAgICAgdHJhbnNtdXhSZXN1bHQgPSBQcm9taXNlLnJlc29sdmUodHJhbnNtdXhSZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zbXV4UmVzdWx0LnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVGbHVzaFJlc3VsdChkYXRhLCBjaHVua01ldGEpO1xuICAgICAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgdGhpcy50cmFuc211eGVyRXJyb3IoZXJyb3IsIGNodW5rTWV0YSwgJ3RyYW5zbXV4ZXItaW50ZXJmYWNlIGZsdXNoIGVycm9yJyk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oYW5kbGVGbHVzaFJlc3VsdCh0cmFuc211eFJlc3VsdCwgY2h1bmtNZXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdHJhbnNtdXhlckVycm9yKGVycm9yLCBjaHVua01ldGEsIHJlYXNvbikge1xuICAgIGlmICghdGhpcy5obHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkZSQUdfUEFSU0lOR19FUlJPUixcbiAgICAgIGNodW5rTWV0YSxcbiAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgIGVycm9yLFxuICAgICAgZXJyOiBlcnJvcixcbiAgICAgIHJlYXNvblxuICAgIH0pO1xuICB9XG4gIGhhbmRsZUZsdXNoUmVzdWx0KHJlc3VsdHMsIGNodW5rTWV0YSkge1xuICAgIHJlc3VsdHMuZm9yRWFjaChyZXN1bHQgPT4ge1xuICAgICAgdGhpcy5oYW5kbGVUcmFuc211eENvbXBsZXRlKHJlc3VsdCk7XG4gICAgfSk7XG4gICAgdGhpcy5vbkZsdXNoKGNodW5rTWV0YSk7XG4gIH1cbiAgb25Xb3JrZXJNZXNzYWdlKGV2KSB7XG4gICAgY29uc3QgZGF0YSA9IGV2LmRhdGE7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgc3dpdGNoIChkYXRhLmV2ZW50KSB7XG4gICAgICBjYXNlICdpbml0JzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfdGhpcyR3b3JrZXJDb250ZXh0O1xuICAgICAgICAgIGNvbnN0IG9iamVjdFVSTCA9IChfdGhpcyR3b3JrZXJDb250ZXh0ID0gdGhpcy53b3JrZXJDb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkd29ya2VyQ29udGV4dC5vYmplY3RVUkw7XG4gICAgICAgICAgaWYgKG9iamVjdFVSTCkge1xuICAgICAgICAgICAgLy8gcmV2b2tlIHRoZSBPYmplY3QgVVJMIHRoYXQgd2FzIHVzZWQgdG8gY3JlYXRlIHRyYW5zbXV4ZXIgd29ya2VyLCBzbyBhcyBub3QgdG8gbGVhayBpdFxuICAgICAgICAgICAgc2VsZi5VUkwucmV2b2tlT2JqZWN0VVJMKG9iamVjdFVSTCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICd0cmFuc211eENvbXBsZXRlJzpcbiAgICAgICAge1xuICAgICAgICAgIHRoaXMuaGFuZGxlVHJhbnNtdXhDb21wbGV0ZShkYXRhLmRhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdmbHVzaCc6XG4gICAgICAgIHtcbiAgICAgICAgICB0aGlzLm9uRmx1c2goZGF0YS5kYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAvLyBwYXNzIGxvZ3MgZnJvbSB0aGUgd29ya2VyIHRocmVhZCB0byB0aGUgbWFpbiBsb2dnZXJcbiAgICAgIGNhc2UgJ3dvcmtlckxvZyc6XG4gICAgICAgIGlmIChsb2dnZXJbZGF0YS5kYXRhLmxvZ1R5cGVdKSB7XG4gICAgICAgICAgbG9nZ2VyW2RhdGEuZGF0YS5sb2dUeXBlXShkYXRhLmRhdGEubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgZGF0YS5kYXRhID0gZGF0YS5kYXRhIHx8IHt9O1xuICAgICAgICAgIGRhdGEuZGF0YS5mcmFnID0gdGhpcy5mcmFnO1xuICAgICAgICAgIGRhdGEuZGF0YS5pZCA9IHRoaXMuaWQ7XG4gICAgICAgICAgaGxzLnRyaWdnZXIoZGF0YS5ldmVudCwgZGF0YS5kYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25maWd1cmVUcmFuc211eGVyKGNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIHRyYW5zbXV4ZXJcbiAgICB9ID0gdGhpcztcbiAgICBpZiAodGhpcy53b3JrZXJDb250ZXh0KSB7XG4gICAgICB0aGlzLndvcmtlckNvbnRleHQud29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgY21kOiAnY29uZmlndXJlJyxcbiAgICAgICAgY29uZmlnXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRyYW5zbXV4ZXIpIHtcbiAgICAgIHRyYW5zbXV4ZXIuY29uZmlndXJlKGNvbmZpZyk7XG4gICAgfVxuICB9XG4gIGhhbmRsZVRyYW5zbXV4Q29tcGxldGUocmVzdWx0KSB7XG4gICAgcmVzdWx0LmNodW5rTWV0YS50cmFuc211eGluZy5lbmQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHRoaXMub25UcmFuc211eENvbXBsZXRlKHJlc3VsdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3VidGl0bGVPcHRpb25zSWRlbnRpY2FsKHRyYWNrTGlzdDEsIHRyYWNrTGlzdDIpIHtcbiAgaWYgKHRyYWNrTGlzdDEubGVuZ3RoICE9PSB0cmFja0xpc3QyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYWNrTGlzdDEubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIW1lZGlhQXR0cmlidXRlc0lkZW50aWNhbCh0cmFja0xpc3QxW2ldLmF0dHJzLCB0cmFja0xpc3QyW2ldLmF0dHJzKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG1lZGlhQXR0cmlidXRlc0lkZW50aWNhbChhdHRyczEsIGF0dHJzMiwgY3VzdG9tQXR0cmlidXRlcykge1xuICAvLyBNZWRpYSBvcHRpb25zIHdpdGggdGhlIHNhbWUgcmVuZGl0aW9uIElEIG11c3QgYmUgYml0IGlkZW50aWNhbFxuICBjb25zdCBzdGFibGVSZW5kaXRpb25JZCA9IGF0dHJzMVsnU1RBQkxFLVJFTkRJVElPTi1JRCddO1xuICBpZiAoc3RhYmxlUmVuZGl0aW9uSWQgJiYgIWN1c3RvbUF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gc3RhYmxlUmVuZGl0aW9uSWQgPT09IGF0dHJzMlsnU1RBQkxFLVJFTkRJVElPTi1JRCddO1xuICB9XG4gIC8vIFdoZW4gcmVuZGl0aW9uIElEIGlzIG5vdCBwcmVzZW50LCBjb21wYXJlIGF0dHJpYnV0ZXNcbiAgcmV0dXJuICEoY3VzdG9tQXR0cmlidXRlcyB8fCBbJ0xBTkdVQUdFJywgJ05BTUUnLCAnQ0hBUkFDVEVSSVNUSUNTJywgJ0FVVE9TRUxFQ1QnLCAnREVGQVVMVCcsICdGT1JDRUQnLCAnQVNTT0MtTEFOR1VBR0UnXSkuc29tZShzdWJ0aXRsZUF0dHJpYnV0ZSA9PiBhdHRyczFbc3VidGl0bGVBdHRyaWJ1dGVdICE9PSBhdHRyczJbc3VidGl0bGVBdHRyaWJ1dGVdKTtcbn1cbmZ1bmN0aW9uIHN1YnRpdGxlVHJhY2tNYXRjaGVzVGV4dFRyYWNrKHN1YnRpdGxlVHJhY2ssIHRleHRUcmFjaykge1xuICByZXR1cm4gdGV4dFRyYWNrLmxhYmVsLnRvTG93ZXJDYXNlKCkgPT09IHN1YnRpdGxlVHJhY2submFtZS50b0xvd2VyQ2FzZSgpICYmICghdGV4dFRyYWNrLmxhbmd1YWdlIHx8IHRleHRUcmFjay5sYW5ndWFnZS50b0xvd2VyQ2FzZSgpID09PSAoc3VidGl0bGVUcmFjay5sYW5nIHx8ICcnKS50b0xvd2VyQ2FzZSgpKTtcbn1cblxuY29uc3QgVElDS19JTlRFUlZBTCQyID0gMTAwOyAvLyBob3cgb2Z0ZW4gdG8gdGljayBpbiBtc1xuXG5jbGFzcyBBdWRpb1N0cmVhbUNvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlU3RyZWFtQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGhscywgZnJhZ21lbnRUcmFja2VyLCBrZXlMb2FkZXIpIHtcbiAgICBzdXBlcihobHMsIGZyYWdtZW50VHJhY2tlciwga2V5TG9hZGVyLCAnW2F1ZGlvLXN0cmVhbS1jb250cm9sbGVyXScsIFBsYXlsaXN0TGV2ZWxUeXBlLkFVRElPKTtcbiAgICB0aGlzLnZpZGVvQnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLnZpZGVvVHJhY2tDQyA9IC0xO1xuICAgIHRoaXMud2FpdGluZ1ZpZGVvQ0MgPSAtMTtcbiAgICB0aGlzLmJ1ZmZlcmVkVHJhY2sgPSBudWxsO1xuICAgIHRoaXMuc3dpdGNoaW5nVHJhY2sgPSBudWxsO1xuICAgIHRoaXMudHJhY2tJZCA9IC0xO1xuICAgIHRoaXMud2FpdGluZ0RhdGEgPSBudWxsO1xuICAgIHRoaXMubWFpbkRldGFpbHMgPSBudWxsO1xuICAgIHRoaXMuZmx1c2hpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmJ1ZmZlckZsdXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNhY2hlZFRyYWNrTG9hZGVkRGF0YSA9IG51bGw7XG4gICAgdGhpcy5fcmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICBvbkhhbmRsZXJEZXN0cm95aW5nKCkge1xuICAgIHRoaXMuX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICBzdXBlci5vbkhhbmRsZXJEZXN0cm95aW5nKCk7XG4gICAgdGhpcy5tYWluRGV0YWlscyA9IG51bGw7XG4gICAgdGhpcy5idWZmZXJlZFRyYWNrID0gbnVsbDtcbiAgICB0aGlzLnN3aXRjaGluZ1RyYWNrID0gbnVsbDtcbiAgfVxuICBfcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaGxzLm9uKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9MT0FERUQsIHRoaXMub25MZXZlbExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5BVURJT19UUkFDS1NfVVBEQVRFRCwgdGhpcy5vbkF1ZGlvVHJhY2tzVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5BVURJT19UUkFDS19TV0lUQ0hJTkcsIHRoaXMub25BdWRpb1RyYWNrU3dpdGNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkFVRElPX1RSQUNLX0xPQURFRCwgdGhpcy5vbkF1ZGlvVHJhY2tMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfUkVTRVQsIHRoaXMub25CdWZmZXJSZXNldCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfQ1JFQVRFRCwgdGhpcy5vbkJ1ZmZlckNyZWF0ZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0ZMVVNISU5HLCB0aGlzLm9uQnVmZmVyRmx1c2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0ZMVVNIRUQsIHRoaXMub25CdWZmZXJGbHVzaGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLklOSVRfUFRTX0ZPVU5ELCB0aGlzLm9uSW5pdFB0c0ZvdW5kLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkZSQUdfQlVGRkVSRUQsIHRoaXMub25GcmFnQnVmZmVyZWQsIHRoaXMpO1xuICB9XG4gIF91bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX0xPQURFRCwgdGhpcy5vbkxldmVsTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5BVURJT19UUkFDS1NfVVBEQVRFRCwgdGhpcy5vbkF1ZGlvVHJhY2tzVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQVVESU9fVFJBQ0tfU1dJVENISU5HLCB0aGlzLm9uQXVkaW9UcmFja1N3aXRjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQVVESU9fVFJBQ0tfTE9BREVELCB0aGlzLm9uQXVkaW9UcmFja0xvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX1JFU0VULCB0aGlzLm9uQnVmZmVyUmVzZXQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9DUkVBVEVELCB0aGlzLm9uQnVmZmVyQ3JlYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0ZMVVNISU5HLCB0aGlzLm9uQnVmZmVyRmx1c2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9GTFVTSEVELCB0aGlzLm9uQnVmZmVyRmx1c2hlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuSU5JVF9QVFNfRk9VTkQsIHRoaXMub25Jbml0UHRzRm91bmQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkZSQUdfQlVGRkVSRUQsIHRoaXMub25GcmFnQnVmZmVyZWQsIHRoaXMpO1xuICB9XG5cbiAgLy8gSU5JVF9QVFNfRk9VTkQgaXMgdHJpZ2dlcmVkIHdoZW4gdGhlIHZpZGVvIHRyYWNrIHBhcnNlZCBpbiB0aGUgc3RyZWFtLWNvbnRyb2xsZXIgaGFzIGEgbmV3IFBUUyB2YWx1ZVxuICBvbkluaXRQdHNGb3VuZChldmVudCwge1xuICAgIGZyYWcsXG4gICAgaWQsXG4gICAgaW5pdFBUUyxcbiAgICB0aW1lc2NhbGVcbiAgfSkge1xuICAgIC8vIEFsd2F5cyB1cGRhdGUgdGhlIG5ldyBJTklUIFBUU1xuICAgIC8vIENhbiBjaGFuZ2UgZHVlIGxldmVsIHN3aXRjaFxuICAgIGlmIChpZCA9PT0gJ21haW4nKSB7XG4gICAgICBjb25zdCBjYyA9IGZyYWcuY2M7XG4gICAgICB0aGlzLmluaXRQVFNbZnJhZy5jY10gPSB7XG4gICAgICAgIGJhc2VUaW1lOiBpbml0UFRTLFxuICAgICAgICB0aW1lc2NhbGVcbiAgICAgIH07XG4gICAgICB0aGlzLmxvZyhgSW5pdFBUUyBmb3IgY2M6ICR7Y2N9IGZvdW5kIGZyb20gbWFpbjogJHtpbml0UFRTfWApO1xuICAgICAgdGhpcy52aWRlb1RyYWNrQ0MgPSBjYztcbiAgICAgIC8vIElmIHdlIGFyZSB3YWl0aW5nLCB0aWNrIGltbWVkaWF0ZWx5IHRvIHVuYmxvY2sgYXVkaW8gZnJhZ21lbnQgdHJhbnNtdXhpbmdcbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5XQUlUSU5HX0lOSVRfUFRTKSB7XG4gICAgICAgIHRoaXMudGljaygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdGFydExvYWQoc3RhcnRQb3NpdGlvbikge1xuICAgIGlmICghdGhpcy5sZXZlbHMpIHtcbiAgICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHN0YXJ0UG9zaXRpb247XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuU1RPUFBFRDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGFzdEN1cnJlbnRUaW1lID0gdGhpcy5sYXN0Q3VycmVudFRpbWU7XG4gICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgIHRoaXMuc2V0SW50ZXJ2YWwoVElDS19JTlRFUlZBTCQyKTtcbiAgICBpZiAobGFzdEN1cnJlbnRUaW1lID4gMCAmJiBzdGFydFBvc2l0aW9uID09PSAtMSkge1xuICAgICAgdGhpcy5sb2coYE92ZXJyaWRlIHN0YXJ0UG9zaXRpb24gd2l0aCBsYXN0Q3VycmVudFRpbWUgQCR7bGFzdEN1cnJlbnRUaW1lLnRvRml4ZWQoMyl9YCk7XG4gICAgICBzdGFydFBvc2l0aW9uID0gbGFzdEN1cnJlbnRUaW1lO1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9hZGVkbWV0YWRhdGEgPSBmYWxzZTtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5XQUlUSU5HX1RSQUNLO1xuICAgIH1cbiAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IHN0YXJ0UG9zaXRpb247XG4gICAgdGhpcy50aWNrKCk7XG4gIH1cbiAgZG9UaWNrKCkge1xuICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgY2FzZSBTdGF0ZS5JRExFOlxuICAgICAgICB0aGlzLmRvVGlja0lkbGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0YXRlLldBSVRJTkdfVFJBQ0s6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2xldmVscyR0cmFja0lkO1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGxldmVscyxcbiAgICAgICAgICAgIHRyYWNrSWRcbiAgICAgICAgICB9ID0gdGhpcztcbiAgICAgICAgICBjb25zdCBkZXRhaWxzID0gbGV2ZWxzID09IG51bGwgPyB2b2lkIDAgOiAoX2xldmVscyR0cmFja0lkID0gbGV2ZWxzW3RyYWNrSWRdKSA9PSBudWxsID8gdm9pZCAwIDogX2xldmVscyR0cmFja0lkLmRldGFpbHM7XG4gICAgICAgICAgaWYgKGRldGFpbHMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLndhaXRGb3JDZG5UdW5lSW4oZGV0YWlscykpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuV0FJVElOR19JTklUX1BUUztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgU3RhdGUuRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX3RoaXMkbWVkaWE7XG4gICAgICAgICAgY29uc3Qgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgY29uc3QgcmV0cnlEYXRlID0gdGhpcy5yZXRyeURhdGU7XG4gICAgICAgICAgLy8gaWYgY3VycmVudCB0aW1lIGlzIGd0IHRoYW4gcmV0cnlEYXRlLCBvciBpZiBtZWRpYSBzZWVraW5nIGxldCdzIHN3aXRjaCB0byBJRExFIHN0YXRlIHRvIHJldHJ5IGxvYWRpbmdcbiAgICAgICAgICBpZiAoIXJldHJ5RGF0ZSB8fCBub3cgPj0gcmV0cnlEYXRlIHx8IChfdGhpcyRtZWRpYSA9IHRoaXMubWVkaWEpICE9IG51bGwgJiYgX3RoaXMkbWVkaWEuc2Vla2luZykge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBsZXZlbHMsXG4gICAgICAgICAgICAgIHRyYWNrSWRcbiAgICAgICAgICAgIH0gPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5sb2coJ1JldHJ5RGF0ZSByZWFjaGVkLCBzd2l0Y2ggYmFjayB0byBJRExFIHN0YXRlJyk7XG4gICAgICAgICAgICB0aGlzLnJlc2V0U3RhcnRXaGVuTm90TG9hZGVkKChsZXZlbHMgPT0gbnVsbCA/IHZvaWQgMCA6IGxldmVsc1t0cmFja0lkXSkgfHwgbnVsbCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgU3RhdGUuV0FJVElOR19JTklUX1BUUzpcbiAgICAgICAge1xuICAgICAgICAgIC8vIEVuc3VyZSB3ZSBkb24ndCBnZXQgc3R1Y2sgaW4gdGhlIFdBSVRJTkdfSU5JVF9QVFMgc3RhdGUgaWYgdGhlIHdhaXRpbmcgZnJhZyBDQyBkb2Vzbid0IG1hdGNoIGFueSBpbml0UFRTXG4gICAgICAgICAgY29uc3Qgd2FpdGluZ0RhdGEgPSB0aGlzLndhaXRpbmdEYXRhO1xuICAgICAgICAgIGlmICh3YWl0aW5nRGF0YSkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgICBwYXJ0LFxuICAgICAgICAgICAgICBjYWNoZSxcbiAgICAgICAgICAgICAgY29tcGxldGVcbiAgICAgICAgICAgIH0gPSB3YWl0aW5nRGF0YTtcbiAgICAgICAgICAgIGlmICh0aGlzLmluaXRQVFNbZnJhZy5jY10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB0aGlzLndhaXRpbmdEYXRhID0gbnVsbDtcbiAgICAgICAgICAgICAgdGhpcy53YWl0aW5nVmlkZW9DQyA9IC0xO1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRlJBR19MT0FESU5HO1xuICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gY2FjaGUuZmx1c2goKTtcbiAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAgICAgIHBhcnQsXG4gICAgICAgICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgICAgICAgICBuZXR3b3JrRGV0YWlsczogbnVsbFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVGcmFnbWVudExvYWRQcm9ncmVzcyhkYXRhKTtcbiAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgc3VwZXIuX2hhbmRsZUZyYWdtZW50TG9hZENvbXBsZXRlKGRhdGEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudmlkZW9UcmFja0NDICE9PSB0aGlzLndhaXRpbmdWaWRlb0NDKSB7XG4gICAgICAgICAgICAgIC8vIERyb3Agd2FpdGluZyBmcmFnbWVudCBpZiB2aWRlb1RyYWNrQ0MgaGFzIGNoYW5nZWQgc2luY2Ugd2FpdGluZ0ZyYWdtZW50IHdhcyBzZXQgYW5kIGluaXRQVFMgd2FzIG5vdCBmb3VuZFxuICAgICAgICAgICAgICB0aGlzLmxvZyhgV2FpdGluZyBmcmFnbWVudCBjYyAoJHtmcmFnLmNjfSkgY2FuY2VsbGVkIGJlY2F1c2UgdmlkZW8gaXMgYXQgY2MgJHt0aGlzLnZpZGVvVHJhY2tDQ31gKTtcbiAgICAgICAgICAgICAgdGhpcy5jbGVhcldhaXRpbmdGcmFnbWVudCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gRHJvcCB3YWl0aW5nIGZyYWdtZW50IGlmIGFuIGVhcmxpZXIgZnJhZ21lbnQgaXMgbmVlZGVkXG4gICAgICAgICAgICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0TG9hZFBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyh0aGlzLm1lZGlhQnVmZmVyLCBwb3MsIHRoaXMuY29uZmlnLm1heEJ1ZmZlckhvbGUpO1xuICAgICAgICAgICAgICBjb25zdCB3YWl0aW5nRnJhZ21lbnRBdFBvc2l0aW9uID0gZnJhZ21lbnRXaXRoaW5Ub2xlcmFuY2VUZXN0KGJ1ZmZlckluZm8uZW5kLCB0aGlzLmNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlLCBmcmFnKTtcbiAgICAgICAgICAgICAgaWYgKHdhaXRpbmdGcmFnbWVudEF0UG9zaXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2coYFdhaXRpbmcgZnJhZ21lbnQgY2MgKCR7ZnJhZy5jY30pIEAgJHtmcmFnLnN0YXJ0fSBjYW5jZWxsZWQgYmVjYXVzZSBhbm90aGVyIGZyYWdtZW50IGF0ICR7YnVmZmVySW5mby5lbmR9IGlzIG5lZWRlZGApO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJXYWl0aW5nRnJhZ21lbnQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5vblRpY2tFbmQoKTtcbiAgfVxuICBjbGVhcldhaXRpbmdGcmFnbWVudCgpIHtcbiAgICBjb25zdCB3YWl0aW5nRGF0YSA9IHRoaXMud2FpdGluZ0RhdGE7XG4gICAgaWYgKHdhaXRpbmdEYXRhKSB7XG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudCh3YWl0aW5nRGF0YS5mcmFnKTtcbiAgICAgIHRoaXMud2FpdGluZ0RhdGEgPSBudWxsO1xuICAgICAgdGhpcy53YWl0aW5nVmlkZW9DQyA9IC0xO1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgfVxuICB9XG4gIHJlc2V0TG9hZGluZ1N0YXRlKCkge1xuICAgIHRoaXMuY2xlYXJXYWl0aW5nRnJhZ21lbnQoKTtcbiAgICBzdXBlci5yZXNldExvYWRpbmdTdGF0ZSgpO1xuICB9XG4gIG9uVGlja0VuZCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBtZWRpYVxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghKG1lZGlhICE9IG51bGwgJiYgbWVkaWEucmVhZHlTdGF0ZSkpIHtcbiAgICAgIC8vIEV4aXQgZWFybHkgaWYgd2UgZG9uJ3QgaGF2ZSBtZWRpYSBvciBpZiB0aGUgbWVkaWEgaGFzbid0IGJ1ZmZlcmVkIGFueXRoaW5nIHlldCAocmVhZHlTdGF0ZSAwKVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxhc3RDdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICB9XG4gIGRvVGlja0lkbGUoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzLFxuICAgICAgbGV2ZWxzLFxuICAgICAgbWVkaWEsXG4gICAgICB0cmFja0lkXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgY29uZmlnID0gaGxzLmNvbmZpZztcblxuICAgIC8vIDEuIGlmIHZpZGVvIG5vdCBhdHRhY2hlZCBBTkRcbiAgICAvLyAgICBzdGFydCBmcmFnbWVudCBhbHJlYWR5IHJlcXVlc3RlZCBPUiBzdGFydCBmcmFnIHByZWZldGNoIG5vdCBlbmFibGVkXG4gICAgLy8gMi4gaWYgdHJhY2tzIG9yIHRyYWNrIG5vdCBsb2FkZWQgYW5kIHNlbGVjdGVkXG4gICAgLy8gdGhlbiBleGl0IGxvb3BcbiAgICAvLyA9PiBpZiBtZWRpYSBub3QgYXR0YWNoZWQgYnV0IHN0YXJ0IGZyYWcgcHJlZmV0Y2ggaXMgZW5hYmxlZCBhbmQgc3RhcnQgZnJhZyBub3QgcmVxdWVzdGVkIHlldCwgd2Ugd2lsbCBub3QgZXhpdCBsb29wXG4gICAgaWYgKCFtZWRpYSAmJiAodGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgfHwgIWNvbmZpZy5zdGFydEZyYWdQcmVmZXRjaCkgfHwgIShsZXZlbHMgIT0gbnVsbCAmJiBsZXZlbHNbdHJhY2tJZF0pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxldmVsSW5mbyA9IGxldmVsc1t0cmFja0lkXTtcbiAgICBjb25zdCB0cmFja0RldGFpbHMgPSBsZXZlbEluZm8uZGV0YWlscztcbiAgICBpZiAoIXRyYWNrRGV0YWlscyB8fCB0cmFja0RldGFpbHMubGl2ZSAmJiB0aGlzLmxldmVsTGFzdExvYWRlZCAhPT0gbGV2ZWxJbmZvIHx8IHRoaXMud2FpdEZvckNkblR1bmVJbih0cmFja0RldGFpbHMpKSB7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuV0FJVElOR19UUkFDSztcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYnVmZmVyYWJsZSA9IHRoaXMubWVkaWFCdWZmZXIgPyB0aGlzLm1lZGlhQnVmZmVyIDogdGhpcy5tZWRpYTtcbiAgICBpZiAodGhpcy5idWZmZXJGbHVzaGVkICYmIGJ1ZmZlcmFibGUpIHtcbiAgICAgIHRoaXMuYnVmZmVyRmx1c2hlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5hZnRlckJ1ZmZlckZsdXNoZWQoYnVmZmVyYWJsZSwgRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPLCBQbGF5bGlzdExldmVsVHlwZS5BVURJTyk7XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmZlckluZm8gPSB0aGlzLmdldEZ3ZEJ1ZmZlckluZm8oYnVmZmVyYWJsZSwgUGxheWxpc3RMZXZlbFR5cGUuQVVESU8pO1xuICAgIGlmIChidWZmZXJJbmZvID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGJ1ZmZlcmVkVHJhY2ssXG4gICAgICBzd2l0Y2hpbmdUcmFja1xuICAgIH0gPSB0aGlzO1xuICAgIGlmICghc3dpdGNoaW5nVHJhY2sgJiYgdGhpcy5fc3RyZWFtRW5kZWQoYnVmZmVySW5mbywgdHJhY2tEZXRhaWxzKSkge1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9FT1MsIHtcbiAgICAgICAgdHlwZTogJ2F1ZGlvJ1xuICAgICAgfSk7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuRU5ERUQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1haW5CdWZmZXJJbmZvID0gdGhpcy5nZXRGd2RCdWZmZXJJbmZvKHRoaXMudmlkZW9CdWZmZXIgPyB0aGlzLnZpZGVvQnVmZmVyIDogdGhpcy5tZWRpYSwgUGxheWxpc3RMZXZlbFR5cGUuTUFJTik7XG4gICAgY29uc3QgYnVmZmVyTGVuID0gYnVmZmVySW5mby5sZW47XG4gICAgY29uc3QgbWF4QnVmTGVuID0gdGhpcy5nZXRNYXhCdWZmZXJMZW5ndGgobWFpbkJ1ZmZlckluZm8gPT0gbnVsbCA/IHZvaWQgMCA6IG1haW5CdWZmZXJJbmZvLmxlbik7XG4gICAgY29uc3QgZnJhZ21lbnRzID0gdHJhY2tEZXRhaWxzLmZyYWdtZW50cztcbiAgICBjb25zdCBzdGFydCA9IGZyYWdtZW50c1swXS5zdGFydDtcbiAgICBsZXQgdGFyZ2V0QnVmZmVyVGltZSA9IHRoaXMuZmx1c2hpbmcgPyB0aGlzLmdldExvYWRQb3NpdGlvbigpIDogYnVmZmVySW5mby5lbmQ7XG4gICAgaWYgKHN3aXRjaGluZ1RyYWNrICYmIG1lZGlhKSB7XG4gICAgICBjb25zdCBwb3MgPSB0aGlzLmdldExvYWRQb3NpdGlvbigpO1xuICAgICAgLy8gU1RBQkxFXG4gICAgICBpZiAoYnVmZmVyZWRUcmFjayAmJiAhbWVkaWFBdHRyaWJ1dGVzSWRlbnRpY2FsKHN3aXRjaGluZ1RyYWNrLmF0dHJzLCBidWZmZXJlZFRyYWNrLmF0dHJzKSkge1xuICAgICAgICB0YXJnZXRCdWZmZXJUaW1lID0gcG9zO1xuICAgICAgfVxuICAgICAgLy8gaWYgY3VycmVudFRpbWUgKHBvcykgaXMgbGVzcyB0aGFuIGFsdCBhdWRpbyBwbGF5bGlzdCBzdGFydCB0aW1lLCBpdCBtZWFucyB0aGF0IGFsdCBhdWRpbyBpcyBhaGVhZCBvZiBjdXJyZW50VGltZVxuICAgICAgaWYgKHRyYWNrRGV0YWlscy5QVFNLbm93biAmJiBwb3MgPCBzdGFydCkge1xuICAgICAgICAvLyBpZiBldmVyeXRoaW5nIGlzIGJ1ZmZlcmVkIGZyb20gcG9zIHRvIHN0YXJ0IG9yIGlmIGF1ZGlvIGJ1ZmZlciB1cGZyb250LCBsZXQncyBzZWVrIHRvIHN0YXJ0XG4gICAgICAgIGlmIChidWZmZXJJbmZvLmVuZCA+IHN0YXJ0IHx8IGJ1ZmZlckluZm8ubmV4dFN0YXJ0KSB7XG4gICAgICAgICAgdGhpcy5sb2coJ0FsdCBhdWRpbyB0cmFjayBhaGVhZCBvZiBtYWluIHRyYWNrLCBzZWVrIHRvIHN0YXJ0IG9mIGFsdCBhdWRpbyB0cmFjaycpO1xuICAgICAgICAgIG1lZGlhLmN1cnJlbnRUaW1lID0gc3RhcnQgKyAwLjA1O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgYnVmZmVyIGxlbmd0aCBpcyBsZXNzIHRoYW4gbWF4QnVmTGVuLCBvciBuZWFyIHRoZSBlbmQsIGZpbmQgYSBmcmFnbWVudCB0byBsb2FkXG4gICAgaWYgKGJ1ZmZlckxlbiA+PSBtYXhCdWZMZW4gJiYgIXN3aXRjaGluZ1RyYWNrICYmIHRhcmdldEJ1ZmZlclRpbWUgPCBmcmFnbWVudHNbZnJhZ21lbnRzLmxlbmd0aCAtIDFdLnN0YXJ0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBmcmFnID0gdGhpcy5nZXROZXh0RnJhZ21lbnQodGFyZ2V0QnVmZmVyVGltZSwgdHJhY2tEZXRhaWxzKTtcbiAgICBsZXQgYXRHYXAgPSBmYWxzZTtcbiAgICAvLyBBdm9pZCBsb29wIGxvYWRpbmcgYnkgdXNpbmcgbmV4dExvYWRQb3NpdGlvbiBzZXQgZm9yIGJhY2t0cmFja2luZyBhbmQgc2tpcHBpbmcgY29uc2VjdXRpdmUgR0FQIHRhZ3NcbiAgICBpZiAoZnJhZyAmJiB0aGlzLmlzTG9vcExvYWRpbmcoZnJhZywgdGFyZ2V0QnVmZmVyVGltZSkpIHtcbiAgICAgIGF0R2FwID0gISFmcmFnLmdhcDtcbiAgICAgIGZyYWcgPSB0aGlzLmdldE5leHRGcmFnbWVudExvb3BMb2FkaW5nKGZyYWcsIHRyYWNrRGV0YWlscywgYnVmZmVySW5mbywgUGxheWxpc3RMZXZlbFR5cGUuTUFJTiwgbWF4QnVmTGVuKTtcbiAgICB9XG4gICAgaWYgKCFmcmFnKSB7XG4gICAgICB0aGlzLmJ1ZmZlckZsdXNoZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEJ1ZmZlciBhdWRpbyB1cCB0byBvbmUgdGFyZ2V0IGR1cmF0aW9uIGFoZWFkIG9mIG1haW4gYnVmZmVyXG4gICAgY29uc3QgYXRCdWZmZXJTeW5jTGltaXQgPSBtYWluQnVmZmVySW5mbyAmJiBmcmFnLnN0YXJ0ID4gbWFpbkJ1ZmZlckluZm8uZW5kICsgdHJhY2tEZXRhaWxzLnRhcmdldGR1cmF0aW9uO1xuICAgIGlmIChhdEJ1ZmZlclN5bmNMaW1pdCB8fFxuICAgIC8vIE9yIHdhaXQgZm9yIG1haW4gYnVmZmVyIGFmdGVyIGJ1ZmZpbmcgc29tZSBhdWRpb1xuICAgICEobWFpbkJ1ZmZlckluZm8gIT0gbnVsbCAmJiBtYWluQnVmZmVySW5mby5sZW4pICYmIGJ1ZmZlckluZm8ubGVuKSB7XG4gICAgICAvLyBDaGVjayBmcmFnbWVudC10cmFja2VyIGZvciBtYWluIGZyYWdtZW50cyBzaW5jZSBHQVAgc2VnbWVudHMgZG8gbm90IHNob3cgdXAgaW4gYnVmZmVySW5mb1xuICAgICAgY29uc3QgbWFpbkZyYWcgPSB0aGlzLmdldEFwcGVuZGVkRnJhZyhmcmFnLnN0YXJ0LCBQbGF5bGlzdExldmVsVHlwZS5NQUlOKTtcbiAgICAgIGlmIChtYWluRnJhZyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBCcmlkZ2UgZ2FwcyBpbiBtYWluIGJ1ZmZlclxuICAgICAgYXRHYXAgfHwgKGF0R2FwID0gISFtYWluRnJhZy5nYXAgfHwgISFhdEJ1ZmZlclN5bmNMaW1pdCAmJiBtYWluQnVmZmVySW5mby5sZW4gPT09IDApO1xuICAgICAgaWYgKGF0QnVmZmVyU3luY0xpbWl0ICYmICFhdEdhcCB8fCBhdEdhcCAmJiBidWZmZXJJbmZvLm5leHRTdGFydCAmJiBidWZmZXJJbmZvLm5leHRTdGFydCA8IG1haW5GcmFnLmVuZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubG9hZEZyYWdtZW50KGZyYWcsIGxldmVsSW5mbywgdGFyZ2V0QnVmZmVyVGltZSk7XG4gIH1cbiAgZ2V0TWF4QnVmZmVyTGVuZ3RoKG1haW5CdWZmZXJMZW5ndGgpIHtcbiAgICBjb25zdCBtYXhDb25maWdCdWZmZXIgPSBzdXBlci5nZXRNYXhCdWZmZXJMZW5ndGgoKTtcbiAgICBpZiAoIW1haW5CdWZmZXJMZW5ndGgpIHtcbiAgICAgIHJldHVybiBtYXhDb25maWdCdWZmZXI7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChtYXhDb25maWdCdWZmZXIsIG1haW5CdWZmZXJMZW5ndGgpLCB0aGlzLmNvbmZpZy5tYXhNYXhCdWZmZXJMZW5ndGgpO1xuICB9XG4gIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgdGhpcy52aWRlb0J1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5idWZmZXJGbHVzaGVkID0gdGhpcy5mbHVzaGluZyA9IGZhbHNlO1xuICAgIHN1cGVyLm9uTWVkaWFEZXRhY2hpbmcoKTtcbiAgfVxuICBvbkF1ZGlvVHJhY2tzVXBkYXRlZChldmVudCwge1xuICAgIGF1ZGlvVHJhY2tzXG4gIH0pIHtcbiAgICAvLyBSZXNldCB0cmFueG11eGVyIGlzIGVzc2VudGlhbCBmb3IgbGFyZ2UgY29udGV4dCBzd2l0Y2hlcyAoQ29udGVudCBTdGVlcmluZylcbiAgICB0aGlzLnJlc2V0VHJhbnNtdXhlcigpO1xuICAgIHRoaXMubGV2ZWxzID0gYXVkaW9UcmFja3MubWFwKG1lZGlhUGxheWxpc3QgPT4gbmV3IExldmVsKG1lZGlhUGxheWxpc3QpKTtcbiAgfVxuICBvbkF1ZGlvVHJhY2tTd2l0Y2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICAvLyBpZiBhbnkgVVJMIGZvdW5kIG9uIG5ldyBhdWRpbyB0cmFjaywgaXQgaXMgYW4gYWx0ZXJuYXRlIGF1ZGlvIHRyYWNrXG4gICAgY29uc3QgYWx0QXVkaW8gPSAhIWRhdGEudXJsO1xuICAgIHRoaXMudHJhY2tJZCA9IGRhdGEuaWQ7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZ0N1cnJlbnRcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoZnJhZ0N1cnJlbnQpIHtcbiAgICAgIGZyYWdDdXJyZW50LmFib3J0UmVxdWVzdHMoKTtcbiAgICAgIHRoaXMucmVtb3ZlVW5idWZmZXJlZEZyYWdzKGZyYWdDdXJyZW50LnN0YXJ0KTtcbiAgICB9XG4gICAgdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpO1xuICAgIC8vIGRlc3Ryb3kgdXNlbGVzcyB0cmFuc211eGVyIHdoZW4gc3dpdGNoaW5nIGF1ZGlvIHRvIG1haW5cbiAgICBpZiAoIWFsdEF1ZGlvKSB7XG4gICAgICB0aGlzLnJlc2V0VHJhbnNtdXhlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzd2l0Y2hpbmcgdG8gYXVkaW8gdHJhY2ssIHN0YXJ0IHRpbWVyIGlmIG5vdCBhbHJlYWR5IHN0YXJ0ZWRcbiAgICAgIHRoaXMuc2V0SW50ZXJ2YWwoVElDS19JTlRFUlZBTCQyKTtcbiAgICB9XG5cbiAgICAvLyBzaG91bGQgd2Ugc3dpdGNoIHRyYWNrcyA/XG4gICAgaWYgKGFsdEF1ZGlvKSB7XG4gICAgICB0aGlzLnN3aXRjaGluZ1RyYWNrID0gZGF0YTtcbiAgICAgIC8vIG1haW4gYXVkaW8gdHJhY2sgYXJlIGhhbmRsZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXIsIGp1c3QgZG8gc29tZXRoaW5nIGlmIHN3aXRjaGluZyB0byBhbHQgYXVkaW8gdHJhY2tcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgdGhpcy5mbHVzaEF1ZGlvSWZOZWVkZWQoZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3dpdGNoaW5nVHJhY2sgPSBudWxsO1xuICAgICAgdGhpcy5idWZmZXJlZFRyYWNrID0gZGF0YTtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xuICAgIH1cbiAgICB0aGlzLnRpY2soKTtcbiAgfVxuICBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVBbGxGcmFnbWVudHMoKTtcbiAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmxhc3RDdXJyZW50VGltZSA9IDA7XG4gICAgdGhpcy5idWZmZXJGbHVzaGVkID0gdGhpcy5mbHVzaGluZyA9IGZhbHNlO1xuICAgIHRoaXMubGV2ZWxzID0gdGhpcy5tYWluRGV0YWlscyA9IHRoaXMud2FpdGluZ0RhdGEgPSB0aGlzLmJ1ZmZlcmVkVHJhY2sgPSB0aGlzLmNhY2hlZFRyYWNrTG9hZGVkRGF0YSA9IHRoaXMuc3dpdGNoaW5nVHJhY2sgPSBudWxsO1xuICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgdGhpcy50cmFja0lkID0gdGhpcy52aWRlb1RyYWNrQ0MgPSB0aGlzLndhaXRpbmdWaWRlb0NDID0gLTE7XG4gIH1cbiAgb25MZXZlbExvYWRlZChldmVudCwgZGF0YSkge1xuICAgIHRoaXMubWFpbkRldGFpbHMgPSBkYXRhLmRldGFpbHM7XG4gICAgaWYgKHRoaXMuY2FjaGVkVHJhY2tMb2FkZWREYXRhICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5BVURJT19UUkFDS19MT0FERUQsIHRoaXMuY2FjaGVkVHJhY2tMb2FkZWREYXRhKTtcbiAgICAgIHRoaXMuY2FjaGVkVHJhY2tMb2FkZWREYXRhID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgb25BdWRpb1RyYWNrTG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIF90cmFjayRkZXRhaWxzO1xuICAgIGlmICh0aGlzLm1haW5EZXRhaWxzID09IG51bGwpIHtcbiAgICAgIHRoaXMuY2FjaGVkVHJhY2tMb2FkZWREYXRhID0gZGF0YTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgbGV2ZWxzXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgZGV0YWlsczogbmV3RGV0YWlscyxcbiAgICAgIGlkOiB0cmFja0lkXG4gICAgfSA9IGRhdGE7XG4gICAgaWYgKCFsZXZlbHMpIHtcbiAgICAgIHRoaXMud2FybihgQXVkaW8gdHJhY2tzIHdlcmUgcmVzZXQgd2hpbGUgbG9hZGluZyBsZXZlbCAke3RyYWNrSWR9YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubG9nKGBBdWRpbyB0cmFjayAke3RyYWNrSWR9IGxvYWRlZCBbJHtuZXdEZXRhaWxzLnN0YXJ0U059LCR7bmV3RGV0YWlscy5lbmRTTn1dJHtuZXdEZXRhaWxzLmxhc3RQYXJ0U24gPyBgW3BhcnQtJHtuZXdEZXRhaWxzLmxhc3RQYXJ0U259LSR7bmV3RGV0YWlscy5sYXN0UGFydEluZGV4fV1gIDogJyd9LGR1cmF0aW9uOiR7bmV3RGV0YWlscy50b3RhbGR1cmF0aW9ufWApO1xuICAgIGNvbnN0IHRyYWNrID0gbGV2ZWxzW3RyYWNrSWRdO1xuICAgIGxldCBzbGlkaW5nID0gMDtcbiAgICBpZiAobmV3RGV0YWlscy5saXZlIHx8IChfdHJhY2skZGV0YWlscyA9IHRyYWNrLmRldGFpbHMpICE9IG51bGwgJiYgX3RyYWNrJGRldGFpbHMubGl2ZSkge1xuICAgICAgdGhpcy5jaGVja0xpdmVVcGRhdGUobmV3RGV0YWlscyk7XG4gICAgICBjb25zdCBtYWluRGV0YWlscyA9IHRoaXMubWFpbkRldGFpbHM7XG4gICAgICBpZiAobmV3RGV0YWlscy5kZWx0YVVwZGF0ZUZhaWxlZCB8fCAhbWFpbkRldGFpbHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF0cmFjay5kZXRhaWxzICYmIG5ld0RldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lICYmIG1haW5EZXRhaWxzLmhhc1Byb2dyYW1EYXRlVGltZSkge1xuICAgICAgICAvLyBNYWtlIHN1cmUgb3VyIGF1ZGlvIHJlbmRpdGlvbiBpcyBhbGlnbmVkIHdpdGggdGhlIFwibWFpblwiIHJlbmRpdGlvbiwgdXNpbmdcbiAgICAgICAgLy8gcGR0IGFzIG91ciByZWZlcmVuY2UgdGltZXMuXG4gICAgICAgIGFsaWduTWVkaWFQbGF5bGlzdEJ5UERUKG5ld0RldGFpbHMsIG1haW5EZXRhaWxzKTtcbiAgICAgICAgc2xpZGluZyA9IG5ld0RldGFpbHMuZnJhZ21lbnRzWzBdLnN0YXJ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF90aGlzJGxldmVsTGFzdExvYWRlZDtcbiAgICAgICAgc2xpZGluZyA9IHRoaXMuYWxpZ25QbGF5bGlzdHMobmV3RGV0YWlscywgdHJhY2suZGV0YWlscywgKF90aGlzJGxldmVsTGFzdExvYWRlZCA9IHRoaXMubGV2ZWxMYXN0TG9hZGVkKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkbGV2ZWxMYXN0TG9hZGVkLmRldGFpbHMpO1xuICAgICAgfVxuICAgIH1cbiAgICB0cmFjay5kZXRhaWxzID0gbmV3RGV0YWlscztcbiAgICB0aGlzLmxldmVsTGFzdExvYWRlZCA9IHRyYWNrO1xuXG4gICAgLy8gY29tcHV0ZSBzdGFydCBwb3NpdGlvbiBpZiB3ZSBhcmUgYWxpZ25lZCB3aXRoIHRoZSBtYWluIHBsYXlsaXN0XG4gICAgaWYgKCF0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCAmJiAodGhpcy5tYWluRGV0YWlscyB8fCAhbmV3RGV0YWlscy5saXZlKSkge1xuICAgICAgdGhpcy5zZXRTdGFydFBvc2l0aW9uKHRyYWNrLmRldGFpbHMsIHNsaWRpbmcpO1xuICAgIH1cbiAgICAvLyBvbmx5IHN3aXRjaCBiYWNrIHRvIElETEUgc3RhdGUgaWYgd2Ugd2VyZSB3YWl0aW5nIGZvciB0cmFjayB0byBzdGFydCBkb3dubG9hZGluZyBhIG5ldyBmcmFnbWVudFxuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5XQUlUSU5HX1RSQUNLICYmICF0aGlzLndhaXRGb3JDZG5UdW5lSW4obmV3RGV0YWlscykpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIH1cblxuICAgIC8vIHRyaWdnZXIgaGFuZGxlciByaWdodCBub3dcbiAgICB0aGlzLnRpY2soKTtcbiAgfVxuICBfaGFuZGxlRnJhZ21lbnRMb2FkUHJvZ3Jlc3MoZGF0YSkge1xuICAgIHZhciBfZnJhZyRpbml0U2VnbWVudDtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnLFxuICAgICAgcGFydCxcbiAgICAgIHBheWxvYWRcbiAgICB9ID0gZGF0YTtcbiAgICBjb25zdCB7XG4gICAgICBjb25maWcsXG4gICAgICB0cmFja0lkLFxuICAgICAgbGV2ZWxzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFsZXZlbHMpIHtcbiAgICAgIHRoaXMud2FybihgQXVkaW8gdHJhY2tzIHdlcmUgcmVzZXQgd2hpbGUgZnJhZ21lbnQgbG9hZCB3YXMgaW4gcHJvZ3Jlc3MuIEZyYWdtZW50ICR7ZnJhZy5zbn0gb2YgbGV2ZWwgJHtmcmFnLmxldmVsfSB3aWxsIG5vdCBiZSBidWZmZXJlZGApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0cmFjayA9IGxldmVsc1t0cmFja0lkXTtcbiAgICBpZiAoIXRyYWNrKSB7XG4gICAgICB0aGlzLndhcm4oJ0F1ZGlvIHRyYWNrIGlzIHVuZGVmaW5lZCBvbiBmcmFnbWVudCBsb2FkIHByb2dyZXNzJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRldGFpbHMgPSB0cmFjay5kZXRhaWxzO1xuICAgIGlmICghZGV0YWlscykge1xuICAgICAgdGhpcy53YXJuKCdBdWRpbyB0cmFjayBkZXRhaWxzIHVuZGVmaW5lZCBvbiBmcmFnbWVudCBsb2FkIHByb2dyZXNzJyk7XG4gICAgICB0aGlzLnJlbW92ZVVuYnVmZmVyZWRGcmFncyhmcmFnLnN0YXJ0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYXVkaW9Db2RlYyA9IGNvbmZpZy5kZWZhdWx0QXVkaW9Db2RlYyB8fCB0cmFjay5hdWRpb0NvZGVjIHx8ICdtcDRhLjQwLjInO1xuICAgIGxldCB0cmFuc211eGVyID0gdGhpcy50cmFuc211eGVyO1xuICAgIGlmICghdHJhbnNtdXhlcikge1xuICAgICAgdHJhbnNtdXhlciA9IHRoaXMudHJhbnNtdXhlciA9IG5ldyBUcmFuc211eGVySW50ZXJmYWNlKHRoaXMuaGxzLCBQbGF5bGlzdExldmVsVHlwZS5BVURJTywgdGhpcy5faGFuZGxlVHJhbnNtdXhDb21wbGV0ZS5iaW5kKHRoaXMpLCB0aGlzLl9oYW5kbGVUcmFuc211eGVyRmx1c2guYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSB2aWRlbyBpbml0UFRTXG4gICAgLy8gSWYgbm90IHdlIG5lZWQgdG8gd2FpdCBmb3IgaXRcbiAgICBjb25zdCBpbml0UFRTID0gdGhpcy5pbml0UFRTW2ZyYWcuY2NdO1xuICAgIGNvbnN0IGluaXRTZWdtZW50RGF0YSA9IChfZnJhZyRpbml0U2VnbWVudCA9IGZyYWcuaW5pdFNlZ21lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZnJhZyRpbml0U2VnbWVudC5kYXRhO1xuICAgIGlmIChpbml0UFRTICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHRoaXMubG9nKGBUcmFuc211eGluZyAke3NufSBvZiBbJHtkZXRhaWxzLnN0YXJ0U059ICwke2RldGFpbHMuZW5kU059XSx0cmFjayAke3RyYWNrSWR9YCk7XG4gICAgICAvLyB0aW1lIE9mZnNldCBpcyBhY2N1cmF0ZSBpZiBsZXZlbCBQVFMgaXMga25vd24sIG9yIGlmIHBsYXlsaXN0IGlzIG5vdCBzbGlkaW5nIChub3QgbGl2ZSlcbiAgICAgIGNvbnN0IGFjY3VyYXRlVGltZU9mZnNldCA9IGZhbHNlOyAvLyBkZXRhaWxzLlBUU0tub3duIHx8ICFkZXRhaWxzLmxpdmU7XG4gICAgICBjb25zdCBwYXJ0SW5kZXggPSBwYXJ0ID8gcGFydC5pbmRleCA6IC0xO1xuICAgICAgY29uc3QgcGFydGlhbCA9IHBhcnRJbmRleCAhPT0gLTE7XG4gICAgICBjb25zdCBjaHVua01ldGEgPSBuZXcgQ2h1bmtNZXRhZGF0YShmcmFnLmxldmVsLCBmcmFnLnNuLCBmcmFnLnN0YXRzLmNodW5rQ291bnQsIHBheWxvYWQuYnl0ZUxlbmd0aCwgcGFydEluZGV4LCBwYXJ0aWFsKTtcbiAgICAgIHRyYW5zbXV4ZXIucHVzaChwYXlsb2FkLCBpbml0U2VnbWVudERhdGEsIGF1ZGlvQ29kZWMsICcnLCBmcmFnLCBwYXJ0LCBkZXRhaWxzLnRvdGFsZHVyYXRpb24sIGFjY3VyYXRlVGltZU9mZnNldCwgY2h1bmtNZXRhLCBpbml0UFRTKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2coYFVua25vd24gdmlkZW8gUFRTIGZvciBjYyAke2ZyYWcuY2N9LCB3YWl0aW5nIGZvciB2aWRlbyBQVFMgYmVmb3JlIGRlbXV4aW5nIGF1ZGlvIGZyYWcgJHtmcmFnLnNufSBvZiBbJHtkZXRhaWxzLnN0YXJ0U059ICwke2RldGFpbHMuZW5kU059XSx0cmFjayAke3RyYWNrSWR9YCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNhY2hlXG4gICAgICB9ID0gdGhpcy53YWl0aW5nRGF0YSA9IHRoaXMud2FpdGluZ0RhdGEgfHwge1xuICAgICAgICBmcmFnLFxuICAgICAgICBwYXJ0LFxuICAgICAgICBjYWNoZTogbmV3IENodW5rQ2FjaGUoKSxcbiAgICAgICAgY29tcGxldGU6IGZhbHNlXG4gICAgICB9O1xuICAgICAgY2FjaGUucHVzaChuZXcgVWludDhBcnJheShwYXlsb2FkKSk7XG4gICAgICB0aGlzLndhaXRpbmdWaWRlb0NDID0gdGhpcy52aWRlb1RyYWNrQ0M7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuV0FJVElOR19JTklUX1BUUztcbiAgICB9XG4gIH1cbiAgX2hhbmRsZUZyYWdtZW50TG9hZENvbXBsZXRlKGZyYWdMb2FkZWREYXRhKSB7XG4gICAgaWYgKHRoaXMud2FpdGluZ0RhdGEpIHtcbiAgICAgIHRoaXMud2FpdGluZ0RhdGEuY29tcGxldGUgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5faGFuZGxlRnJhZ21lbnRMb2FkQ29tcGxldGUoZnJhZ0xvYWRlZERhdGEpO1xuICB9XG4gIG9uQnVmZmVyUmVzZXQoIC8qIGV2ZW50OiBFdmVudHMuQlVGRkVSX1JFU0VUICovXG4gICkge1xuICAgIC8vIHJlc2V0IHJlZmVyZW5jZSB0byBzb3VyY2VidWZmZXJzXG4gICAgdGhpcy5tZWRpYUJ1ZmZlciA9IHRoaXMudmlkZW9CdWZmZXIgPSBudWxsO1xuICAgIHRoaXMubG9hZGVkbWV0YWRhdGEgPSBmYWxzZTtcbiAgfVxuICBvbkJ1ZmZlckNyZWF0ZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCBhdWRpb1RyYWNrID0gZGF0YS50cmFja3MuYXVkaW87XG4gICAgaWYgKGF1ZGlvVHJhY2spIHtcbiAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSBhdWRpb1RyYWNrLmJ1ZmZlciB8fCBudWxsO1xuICAgIH1cbiAgICBpZiAoZGF0YS50cmFja3MudmlkZW8pIHtcbiAgICAgIHRoaXMudmlkZW9CdWZmZXIgPSBkYXRhLnRyYWNrcy52aWRlby5idWZmZXIgfHwgbnVsbDtcbiAgICB9XG4gIH1cbiAgb25GcmFnQnVmZmVyZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnLFxuICAgICAgcGFydFxuICAgIH0gPSBkYXRhO1xuICAgIGlmIChmcmFnLnR5cGUgIT09IFBsYXlsaXN0TGV2ZWxUeXBlLkFVRElPKSB7XG4gICAgICBpZiAoIXRoaXMubG9hZGVkbWV0YWRhdGEgJiYgZnJhZy50eXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlcmFibGUgPSB0aGlzLnZpZGVvQnVmZmVyIHx8IHRoaXMubWVkaWE7XG4gICAgICAgIGlmIChidWZmZXJhYmxlKSB7XG4gICAgICAgICAgY29uc3QgYnVmZmVyZWRUaW1lUmFuZ2VzID0gQnVmZmVySGVscGVyLmdldEJ1ZmZlcmVkKGJ1ZmZlcmFibGUpO1xuICAgICAgICAgIGlmIChidWZmZXJlZFRpbWVSYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmxvYWRlZG1ldGFkYXRhID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGZyYWcpKSB7XG4gICAgICAvLyBJZiBhIGxldmVsIHN3aXRjaCB3YXMgcmVxdWVzdGVkIHdoaWxlIGEgZnJhZ21lbnQgd2FzIGJ1ZmZlcmluZywgaXQgd2lsbCBlbWl0IHRoZSBGUkFHX0JVRkZFUkVEIGV2ZW50IHVwb24gY29tcGxldGlvblxuICAgICAgLy8gQXZvaWQgc2V0dGluZyBzdGF0ZSBiYWNrIHRvIElETEUgb3IgY29uY2x1ZGluZyB0aGUgYXVkaW8gc3dpdGNoOyBvdGhlcndpc2UsIHRoZSBzd2l0Y2hlZC10byB0cmFjayB3aWxsIG5vdCBidWZmZXJcbiAgICAgIHRoaXMud2FybihgRnJhZ21lbnQgJHtmcmFnLnNufSR7cGFydCA/ICcgcDogJyArIHBhcnQuaW5kZXggOiAnJ30gb2YgbGV2ZWwgJHtmcmFnLmxldmVsfSBmaW5pc2hlZCBidWZmZXJpbmcsIGJ1dCB3YXMgYWJvcnRlZC4gc3RhdGU6ICR7dGhpcy5zdGF0ZX0sIGF1ZGlvU3dpdGNoOiAke3RoaXMuc3dpdGNoaW5nVHJhY2sgPyB0aGlzLnN3aXRjaGluZ1RyYWNrLm5hbWUgOiAnZmFsc2UnfWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZnJhZy5zbiAhPT0gJ2luaXRTZWdtZW50Jykge1xuICAgICAgdGhpcy5mcmFnUHJldmlvdXMgPSBmcmFnO1xuICAgICAgY29uc3QgdHJhY2sgPSB0aGlzLnN3aXRjaGluZ1RyYWNrO1xuICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyZWRUcmFjayA9IHRyYWNrO1xuICAgICAgICB0aGlzLnN3aXRjaGluZ1RyYWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQVVESU9fVFJBQ0tfU1dJVENIRUQsIF9vYmplY3RTcHJlYWQyKHt9LCB0cmFjaykpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmZyYWdCdWZmZXJlZENvbXBsZXRlKGZyYWcsIHBhcnQpO1xuICB9XG4gIG9uRXJyb3IoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgX2RhdGEkY29udGV4dDtcbiAgICBpZiAoZGF0YS5mYXRhbCkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkVSUk9SO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzd2l0Y2ggKGRhdGEuZGV0YWlscykge1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19HQVA6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0RFQ1JZUFRfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVDpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfVElNRU9VVDpcbiAgICAgICAgdGhpcy5vbkZyYWdtZW50T3JLZXlMb2FkRXJyb3IoUGxheWxpc3RMZXZlbFR5cGUuQVVESU8sIGRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkFVRElPX1RSQUNLX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5BVURJT19UUkFDS19MT0FEX1RJTUVPVVQ6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5MRVZFTF9QQVJTSU5HX0VSUk9SOlxuICAgICAgICAvLyBpbiBjYXNlIG9mIG5vbiBmYXRhbCBlcnJvciB3aGlsZSBsb2FkaW5nIHRyYWNrLCBpZiBub3QgcmV0cnlpbmcgdG8gbG9hZCB0cmFjaywgc3dpdGNoIGJhY2sgdG8gSURMRVxuICAgICAgICBpZiAoIWRhdGEubGV2ZWxSZXRyeSAmJiB0aGlzLnN0YXRlID09PSBTdGF0ZS5XQUlUSU5HX1RSQUNLICYmICgoX2RhdGEkY29udGV4dCA9IGRhdGEuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhJGNvbnRleHQudHlwZSkgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuQVVESU9fVFJBQ0spIHtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfRlVMTF9FUlJPUjpcbiAgICAgICAgaWYgKCFkYXRhLnBhcmVudCB8fCBkYXRhLnBhcmVudCAhPT0gJ2F1ZGlvJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5kZXRhaWxzID09PSBFcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORF9FUlJPUikge1xuICAgICAgICAgIHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVkdWNlTGVuZ3RoQW5kRmx1c2hCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgICB0aGlzLmJ1ZmZlcmVkVHJhY2sgPSBudWxsO1xuICAgICAgICAgIHN1cGVyLmZsdXNoTWFpbkJ1ZmZlcigwLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksICdhdWRpbycpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuSU5URVJOQUxfRVhDRVBUSU9OOlxuICAgICAgICB0aGlzLnJlY292ZXJXb3JrZXJFcnJvcihkYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIG9uQnVmZmVyRmx1c2hpbmcoZXZlbnQsIHtcbiAgICB0eXBlXG4gIH0pIHtcbiAgICBpZiAodHlwZSAhPT0gRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPKSB7XG4gICAgICB0aGlzLmZsdXNoaW5nID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgb25CdWZmZXJGbHVzaGVkKGV2ZW50LCB7XG4gICAgdHlwZVxuICB9KSB7XG4gICAgaWYgKHR5cGUgIT09IEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFTykge1xuICAgICAgdGhpcy5mbHVzaGluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5idWZmZXJGbHVzaGVkID0gdHJ1ZTtcbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5FTkRFRCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1lZGlhQnVmZmVyID0gdGhpcy5tZWRpYUJ1ZmZlciB8fCB0aGlzLm1lZGlhO1xuICAgICAgaWYgKG1lZGlhQnVmZmVyKSB7XG4gICAgICAgIHRoaXMuYWZ0ZXJCdWZmZXJGbHVzaGVkKG1lZGlhQnVmZmVyLCB0eXBlLCBQbGF5bGlzdExldmVsVHlwZS5BVURJTyk7XG4gICAgICAgIHRoaXMudGljaygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfaGFuZGxlVHJhbnNtdXhDb21wbGV0ZSh0cmFuc211eFJlc3VsdCkge1xuICAgIHZhciBfaWQzJHNhbXBsZXM7XG4gICAgY29uc3QgaWQgPSAnYXVkaW8nO1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlbXV4UmVzdWx0LFxuICAgICAgY2h1bmtNZXRhXG4gICAgfSA9IHRyYW5zbXV4UmVzdWx0O1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmdldEN1cnJlbnRDb250ZXh0KGNodW5rTWV0YSk7XG4gICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICB0aGlzLnJlc2V0V2hlbk1pc3NpbmdDb250ZXh0KGNodW5rTWV0YSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGZyYWcsXG4gICAgICBwYXJ0LFxuICAgICAgbGV2ZWxcbiAgICB9ID0gY29udGV4dDtcbiAgICBjb25zdCB7XG4gICAgICBkZXRhaWxzXG4gICAgfSA9IGxldmVsO1xuICAgIGNvbnN0IHtcbiAgICAgIGF1ZGlvLFxuICAgICAgdGV4dCxcbiAgICAgIGlkMyxcbiAgICAgIGluaXRTZWdtZW50XG4gICAgfSA9IHJlbXV4UmVzdWx0O1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIGN1cnJlbnQgZnJhZ21lbnQgaGFzIGJlZW4gYWJvcnRlZC4gV2UgY2hlY2sgdGhpcyBieSBmaXJzdCBzZWVpbmcgaWYgd2UncmUgc3RpbGwgcGxheWluZyB0aGUgY3VycmVudCBsZXZlbC5cbiAgICAvLyBJZiB3ZSBhcmUsIHN1YnNlcXVlbnRseSBjaGVjayBpZiB0aGUgY3VycmVudGx5IGxvYWRpbmcgZnJhZ21lbnQgKGZyYWdDdXJyZW50KSBoYXMgY2hhbmdlZC5cbiAgICBpZiAodGhpcy5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykgfHwgIWRldGFpbHMpIHtcbiAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuUEFSU0lORztcbiAgICBpZiAodGhpcy5zd2l0Y2hpbmdUcmFjayAmJiBhdWRpbykge1xuICAgICAgdGhpcy5jb21wbGV0ZUF1ZGlvU3dpdGNoKHRoaXMuc3dpdGNoaW5nVHJhY2spO1xuICAgIH1cbiAgICBpZiAoaW5pdFNlZ21lbnQgIT0gbnVsbCAmJiBpbml0U2VnbWVudC50cmFja3MpIHtcbiAgICAgIGNvbnN0IG1hcEZyYWdtZW50ID0gZnJhZy5pbml0U2VnbWVudCB8fCBmcmFnO1xuICAgICAgdGhpcy5fYnVmZmVySW5pdFNlZ21lbnQobGV2ZWwsIGluaXRTZWdtZW50LnRyYWNrcywgbWFwRnJhZ21lbnQsIGNodW5rTWV0YSk7XG4gICAgICBobHMudHJpZ2dlcihFdmVudHMuRlJBR19QQVJTSU5HX0lOSVRfU0VHTUVOVCwge1xuICAgICAgICBmcmFnOiBtYXBGcmFnbWVudCxcbiAgICAgICAgaWQsXG4gICAgICAgIHRyYWNrczogaW5pdFNlZ21lbnQudHJhY2tzXG4gICAgICB9KTtcbiAgICAgIC8vIE9ubHkgZmx1c2ggYXVkaW8gZnJvbSBvbGQgYXVkaW8gdHJhY2tzIHdoZW4gUFRTIGlzIGtub3duIG9uIG5ldyBhdWRpbyB0cmFja1xuICAgIH1cbiAgICBpZiAoYXVkaW8pIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3RhcnRQVFMsXG4gICAgICAgIGVuZFBUUyxcbiAgICAgICAgc3RhcnREVFMsXG4gICAgICAgIGVuZERUU1xuICAgICAgfSA9IGF1ZGlvO1xuICAgICAgaWYgKHBhcnQpIHtcbiAgICAgICAgcGFydC5lbGVtZW50YXJ5U3RyZWFtc1tFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU9dID0ge1xuICAgICAgICAgIHN0YXJ0UFRTLFxuICAgICAgICAgIGVuZFBUUyxcbiAgICAgICAgICBzdGFydERUUyxcbiAgICAgICAgICBlbmREVFNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGZyYWcuc2V0RWxlbWVudGFyeVN0cmVhbUluZm8oRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPLCBzdGFydFBUUywgZW5kUFRTLCBzdGFydERUUywgZW5kRFRTKTtcbiAgICAgIHRoaXMuYnVmZmVyRnJhZ21lbnREYXRhKGF1ZGlvLCBmcmFnLCBwYXJ0LCBjaHVua01ldGEpO1xuICAgIH1cbiAgICBpZiAoaWQzICE9IG51bGwgJiYgKF9pZDMkc2FtcGxlcyA9IGlkMy5zYW1wbGVzKSAhPSBudWxsICYmIF9pZDMkc2FtcGxlcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGVtaXR0ZWRJRDMgPSBfZXh0ZW5kcyh7XG4gICAgICAgIGlkLFxuICAgICAgICBmcmFnLFxuICAgICAgICBkZXRhaWxzXG4gICAgICB9LCBpZDMpO1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfUEFSU0lOR19NRVRBREFUQSwgZW1pdHRlZElEMyk7XG4gICAgfVxuICAgIGlmICh0ZXh0KSB7XG4gICAgICBjb25zdCBlbWl0dGVkVGV4dCA9IF9leHRlbmRzKHtcbiAgICAgICAgaWQsXG4gICAgICAgIGZyYWcsXG4gICAgICAgIGRldGFpbHNcbiAgICAgIH0sIHRleHQpO1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfUEFSU0lOR19VU0VSREFUQSwgZW1pdHRlZFRleHQpO1xuICAgIH1cbiAgfVxuICBfYnVmZmVySW5pdFNlZ21lbnQoY3VycmVudExldmVsLCB0cmFja3MsIGZyYWcsIGNodW5rTWV0YSkge1xuICAgIGlmICh0aGlzLnN0YXRlICE9PSBTdGF0ZS5QQVJTSU5HKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGRlbGV0ZSBhbnkgdmlkZW8gdHJhY2sgZm91bmQgb24gYXVkaW8gdHJhbnNtdXhlclxuICAgIGlmICh0cmFja3MudmlkZW8pIHtcbiAgICAgIGRlbGV0ZSB0cmFja3MudmlkZW87XG4gICAgfVxuXG4gICAgLy8gaW5jbHVkZSBsZXZlbENvZGVjIGluIGF1ZGlvIGFuZCB2aWRlbyB0cmFja3NcbiAgICBjb25zdCB0cmFjayA9IHRyYWNrcy5hdWRpbztcbiAgICBpZiAoIXRyYWNrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyYWNrLmlkID0gJ2F1ZGlvJztcbiAgICBjb25zdCB2YXJpYW50QXVkaW9Db2RlY3MgPSBjdXJyZW50TGV2ZWwuYXVkaW9Db2RlYztcbiAgICB0aGlzLmxvZyhgSW5pdCBhdWRpbyBidWZmZXIsIGNvbnRhaW5lcjoke3RyYWNrLmNvbnRhaW5lcn0sIGNvZGVjc1tsZXZlbC9wYXJzZWRdPVske3ZhcmlhbnRBdWRpb0NvZGVjc30vJHt0cmFjay5jb2RlY31dYCk7XG4gICAgLy8gU291cmNlQnVmZmVyIHdpbGwgdXNlIHRyYWNrLmxldmVsQ29kZWMgaWYgZGVmaW5lZFxuICAgIGlmICh2YXJpYW50QXVkaW9Db2RlY3MgJiYgdmFyaWFudEF1ZGlvQ29kZWNzLnNwbGl0KCcsJykubGVuZ3RoID09PSAxKSB7XG4gICAgICB0cmFjay5sZXZlbENvZGVjID0gdmFyaWFudEF1ZGlvQ29kZWNzO1xuICAgIH1cbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfQ09ERUNTLCB0cmFja3MpO1xuICAgIGNvbnN0IGluaXRTZWdtZW50ID0gdHJhY2suaW5pdFNlZ21lbnQ7XG4gICAgaWYgKGluaXRTZWdtZW50ICE9IG51bGwgJiYgaW5pdFNlZ21lbnQuYnl0ZUxlbmd0aCkge1xuICAgICAgY29uc3Qgc2VnbWVudCA9IHtcbiAgICAgICAgdHlwZTogJ2F1ZGlvJyxcbiAgICAgICAgZnJhZyxcbiAgICAgICAgcGFydDogbnVsbCxcbiAgICAgICAgY2h1bmtNZXRhLFxuICAgICAgICBwYXJlbnQ6IGZyYWcudHlwZSxcbiAgICAgICAgZGF0YTogaW5pdFNlZ21lbnRcbiAgICAgIH07XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfQVBQRU5ESU5HLCBzZWdtZW50KTtcbiAgICB9XG4gICAgLy8gdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgIHRoaXMudGlja0ltbWVkaWF0ZSgpO1xuICB9XG4gIGxvYWRGcmFnbWVudChmcmFnLCB0cmFjaywgdGFyZ2V0QnVmZmVyVGltZSkge1xuICAgIC8vIG9ubHkgbG9hZCBpZiBmcmFnbWVudCBpcyBub3QgbG9hZGVkIG9yIGlmIGluIGF1ZGlvIHN3aXRjaFxuICAgIGNvbnN0IGZyYWdTdGF0ZSA9IHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKGZyYWcpO1xuICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBmcmFnO1xuXG4gICAgLy8gd2UgZm9yY2UgYSBmcmFnIGxvYWRpbmcgaW4gYXVkaW8gc3dpdGNoIGFzIGZyYWdtZW50IHRyYWNrZXIgbWlnaHQgbm90IGhhdmUgZXZpY3RlZCBwcmV2aW91cyBmcmFncyBpbiBjYXNlIG9mIHF1aWNrIGF1ZGlvIHN3aXRjaFxuICAgIGlmICh0aGlzLnN3aXRjaGluZ1RyYWNrIHx8IGZyYWdTdGF0ZSA9PT0gRnJhZ21lbnRTdGF0ZS5OT1RfTE9BREVEIHx8IGZyYWdTdGF0ZSA9PT0gRnJhZ21lbnRTdGF0ZS5QQVJUSUFMKSB7XG4gICAgICB2YXIgX3RyYWNrJGRldGFpbHMyO1xuICAgICAgaWYgKGZyYWcuc24gPT09ICdpbml0U2VnbWVudCcpIHtcbiAgICAgICAgdGhpcy5fbG9hZEluaXRTZWdtZW50KGZyYWcsIHRyYWNrKTtcbiAgICAgIH0gZWxzZSBpZiAoKF90cmFjayRkZXRhaWxzMiA9IHRyYWNrLmRldGFpbHMpICE9IG51bGwgJiYgX3RyYWNrJGRldGFpbHMyLmxpdmUgJiYgIXRoaXMuaW5pdFBUU1tmcmFnLmNjXSkge1xuICAgICAgICB0aGlzLmxvZyhgV2FpdGluZyBmb3IgdmlkZW8gUFRTIGluIGNvbnRpbnVpdHkgY291bnRlciAke2ZyYWcuY2N9IG9mIGxpdmUgc3RyZWFtIGJlZm9yZSBsb2FkaW5nIGF1ZGlvIGZyYWdtZW50ICR7ZnJhZy5zbn0gb2YgbGV2ZWwgJHt0aGlzLnRyYWNrSWR9YCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5XQUlUSU5HX0lOSVRfUFRTO1xuICAgICAgICBjb25zdCBtYWluRGV0YWlscyA9IHRoaXMubWFpbkRldGFpbHM7XG4gICAgICAgIGlmIChtYWluRGV0YWlscyAmJiBtYWluRGV0YWlscy5mcmFnbWVudHNbMF0uc3RhcnQgIT09IHRyYWNrLmRldGFpbHMuZnJhZ21lbnRzWzBdLnN0YXJ0KSB7XG4gICAgICAgICAgYWxpZ25NZWRpYVBsYXlsaXN0QnlQRFQodHJhY2suZGV0YWlscywgbWFpbkRldGFpbHMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IHRydWU7XG4gICAgICAgIHN1cGVyLmxvYWRGcmFnbWVudChmcmFnLCB0cmFjaywgdGFyZ2V0QnVmZmVyVGltZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2xlYXJUcmFja2VySWZOZWVkZWQoZnJhZyk7XG4gICAgfVxuICB9XG4gIGZsdXNoQXVkaW9JZk5lZWRlZChzd2l0Y2hpbmdUcmFjaykge1xuICAgIGNvbnN0IHtcbiAgICAgIG1lZGlhLFxuICAgICAgYnVmZmVyZWRUcmFja1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGJ1ZmZlcmVkQXR0cmlidXRlcyA9IGJ1ZmZlcmVkVHJhY2sgPT0gbnVsbCA/IHZvaWQgMCA6IGJ1ZmZlcmVkVHJhY2suYXR0cnM7XG4gICAgY29uc3Qgc3dpdGNoQXR0cmlidXRlcyA9IHN3aXRjaGluZ1RyYWNrLmF0dHJzO1xuICAgIGlmIChtZWRpYSAmJiBidWZmZXJlZEF0dHJpYnV0ZXMgJiYgKGJ1ZmZlcmVkQXR0cmlidXRlcy5DSEFOTkVMUyAhPT0gc3dpdGNoQXR0cmlidXRlcy5DSEFOTkVMUyB8fCBidWZmZXJlZFRyYWNrLm5hbWUgIT09IHN3aXRjaGluZ1RyYWNrLm5hbWUgfHwgYnVmZmVyZWRUcmFjay5sYW5nICE9PSBzd2l0Y2hpbmdUcmFjay5sYW5nKSkge1xuICAgICAgdGhpcy5sb2coJ1N3aXRjaGluZyBhdWRpbyB0cmFjayA6IGZsdXNoaW5nIGFsbCBhdWRpbycpO1xuICAgICAgc3VwZXIuZmx1c2hNYWluQnVmZmVyKDAsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgJ2F1ZGlvJyk7XG4gICAgICB0aGlzLmJ1ZmZlcmVkVHJhY2sgPSBudWxsO1xuICAgIH1cbiAgfVxuICBjb21wbGV0ZUF1ZGlvU3dpdGNoKHN3aXRjaGluZ1RyYWNrKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgdGhpcy5mbHVzaEF1ZGlvSWZOZWVkZWQoc3dpdGNoaW5nVHJhY2spO1xuICAgIHRoaXMuYnVmZmVyZWRUcmFjayA9IHN3aXRjaGluZ1RyYWNrO1xuICAgIHRoaXMuc3dpdGNoaW5nVHJhY2sgPSBudWxsO1xuICAgIGhscy50cmlnZ2VyKEV2ZW50cy5BVURJT19UUkFDS19TV0lUQ0hFRCwgX29iamVjdFNwcmVhZDIoe30sIHN3aXRjaGluZ1RyYWNrKSk7XG4gIH1cbn1cblxuY2xhc3MgQXVkaW9UcmFja0NvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlUGxheWxpc3RDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgc3VwZXIoaGxzLCAnW2F1ZGlvLXRyYWNrLWNvbnRyb2xsZXJdJyk7XG4gICAgdGhpcy50cmFja3MgPSBbXTtcbiAgICB0aGlzLmdyb3VwSWRzID0gbnVsbDtcbiAgICB0aGlzLnRyYWNrc0luR3JvdXAgPSBbXTtcbiAgICB0aGlzLnRyYWNrSWQgPSAtMTtcbiAgICB0aGlzLmN1cnJlbnRUcmFjayA9IG51bGw7XG4gICAgdGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgPSB0cnVlO1xuICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxfTE9BRElORywgdGhpcy5vbkxldmVsTG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9TV0lUQ0hJTkcsIHRoaXMub25MZXZlbFN3aXRjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5BVURJT19UUkFDS19MT0FERUQsIHRoaXMub25BdWRpb1RyYWNrTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICB9XG4gIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX0xPQURJTkcsIHRoaXMub25MZXZlbExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX1NXSVRDSElORywgdGhpcy5vbkxldmVsU3dpdGNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5BVURJT19UUkFDS19MT0FERUQsIHRoaXMub25BdWRpb1RyYWNrTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIHRoaXMudHJhY2tzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy50cmFja3NJbkdyb3VwLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5jdXJyZW50VHJhY2sgPSBudWxsO1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgfVxuICBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICB0aGlzLnRyYWNrcyA9IFtdO1xuICAgIHRoaXMudHJhY2tzSW5Hcm91cCA9IFtdO1xuICAgIHRoaXMuZ3JvdXBJZHMgPSBudWxsO1xuICAgIHRoaXMuY3VycmVudFRyYWNrID0gbnVsbDtcbiAgICB0aGlzLnRyYWNrSWQgPSAtMTtcbiAgICB0aGlzLnNlbGVjdERlZmF1bHRUcmFjayA9IHRydWU7XG4gIH1cbiAgb25NYW5pZmVzdFBhcnNlZChldmVudCwgZGF0YSkge1xuICAgIHRoaXMudHJhY2tzID0gZGF0YS5hdWRpb1RyYWNrcyB8fCBbXTtcbiAgfVxuICBvbkF1ZGlvVHJhY2tMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBpZCxcbiAgICAgIGdyb3VwSWQsXG4gICAgICBkZXRhaWxzXG4gICAgfSA9IGRhdGE7XG4gICAgY29uc3QgdHJhY2tJbkFjdGl2ZUdyb3VwID0gdGhpcy50cmFja3NJbkdyb3VwW2lkXTtcbiAgICBpZiAoIXRyYWNrSW5BY3RpdmVHcm91cCB8fCB0cmFja0luQWN0aXZlR3JvdXAuZ3JvdXBJZCAhPT0gZ3JvdXBJZCkge1xuICAgICAgdGhpcy53YXJuKGBBdWRpbyB0cmFjayB3aXRoIGlkOiR7aWR9IGFuZCBncm91cDoke2dyb3VwSWR9IG5vdCBmb3VuZCBpbiBhY3RpdmUgZ3JvdXAgJHt0cmFja0luQWN0aXZlR3JvdXAgPT0gbnVsbCA/IHZvaWQgMCA6IHRyYWNrSW5BY3RpdmVHcm91cC5ncm91cElkfWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJEZXRhaWxzID0gdHJhY2tJbkFjdGl2ZUdyb3VwLmRldGFpbHM7XG4gICAgdHJhY2tJbkFjdGl2ZUdyb3VwLmRldGFpbHMgPSBkYXRhLmRldGFpbHM7XG4gICAgdGhpcy5sb2coYEF1ZGlvIHRyYWNrICR7aWR9IFwiJHt0cmFja0luQWN0aXZlR3JvdXAubmFtZX1cIiBsYW5nOiR7dHJhY2tJbkFjdGl2ZUdyb3VwLmxhbmd9IGdyb3VwOiR7Z3JvdXBJZH0gbG9hZGVkIFske2RldGFpbHMuc3RhcnRTTn0tJHtkZXRhaWxzLmVuZFNOfV1gKTtcbiAgICBpZiAoaWQgPT09IHRoaXMudHJhY2tJZCkge1xuICAgICAgdGhpcy5wbGF5bGlzdExvYWRlZChpZCwgZGF0YSwgY3VyRGV0YWlscyk7XG4gICAgfVxuICB9XG4gIG9uTGV2ZWxMb2FkaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5zd2l0Y2hMZXZlbChkYXRhLmxldmVsKTtcbiAgfVxuICBvbkxldmVsU3dpdGNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5zd2l0Y2hMZXZlbChkYXRhLmxldmVsKTtcbiAgfVxuICBzd2l0Y2hMZXZlbChsZXZlbEluZGV4KSB7XG4gICAgY29uc3QgbGV2ZWxJbmZvID0gdGhpcy5obHMubGV2ZWxzW2xldmVsSW5kZXhdO1xuICAgIGlmICghbGV2ZWxJbmZvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGF1ZGlvR3JvdXBzID0gbGV2ZWxJbmZvLmF1ZGlvR3JvdXBzIHx8IG51bGw7XG4gICAgY29uc3QgY3VycmVudEdyb3VwcyA9IHRoaXMuZ3JvdXBJZHM7XG4gICAgbGV0IGN1cnJlbnRUcmFjayA9IHRoaXMuY3VycmVudFRyYWNrO1xuICAgIGlmICghYXVkaW9Hcm91cHMgfHwgKGN1cnJlbnRHcm91cHMgPT0gbnVsbCA/IHZvaWQgMCA6IGN1cnJlbnRHcm91cHMubGVuZ3RoKSAhPT0gKGF1ZGlvR3JvdXBzID09IG51bGwgPyB2b2lkIDAgOiBhdWRpb0dyb3Vwcy5sZW5ndGgpIHx8IGF1ZGlvR3JvdXBzICE9IG51bGwgJiYgYXVkaW9Hcm91cHMuc29tZShncm91cElkID0+IChjdXJyZW50R3JvdXBzID09IG51bGwgPyB2b2lkIDAgOiBjdXJyZW50R3JvdXBzLmluZGV4T2YoZ3JvdXBJZCkpID09PSAtMSkpIHtcbiAgICAgIHRoaXMuZ3JvdXBJZHMgPSBhdWRpb0dyb3VwcztcbiAgICAgIHRoaXMudHJhY2tJZCA9IC0xO1xuICAgICAgdGhpcy5jdXJyZW50VHJhY2sgPSBudWxsO1xuICAgICAgY29uc3QgYXVkaW9UcmFja3MgPSB0aGlzLnRyYWNrcy5maWx0ZXIodHJhY2sgPT4gIWF1ZGlvR3JvdXBzIHx8IGF1ZGlvR3JvdXBzLmluZGV4T2YodHJhY2suZ3JvdXBJZCkgIT09IC0xKTtcbiAgICAgIGlmIChhdWRpb1RyYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gRGlzYWJsZSBzZWxlY3REZWZhdWx0VHJhY2sgaWYgdGhlcmUgYXJlIG5vIGRlZmF1bHQgdHJhY2tzXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdERlZmF1bHRUcmFjayAmJiAhYXVkaW9UcmFja3Muc29tZSh0cmFjayA9PiB0cmFjay5kZWZhdWx0KSkge1xuICAgICAgICAgIHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHJhY2suaWQgc2hvdWxkIG1hdGNoIGhscy5hdWRpb1RyYWNrcyBpbmRleFxuICAgICAgICBhdWRpb1RyYWNrcy5mb3JFYWNoKCh0cmFjaywgaSkgPT4ge1xuICAgICAgICAgIHRyYWNrLmlkID0gaTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKCFjdXJyZW50VHJhY2sgJiYgIXRoaXMudHJhY2tzSW5Hcm91cC5sZW5ndGgpIHtcbiAgICAgICAgLy8gRG8gbm90IGRpc3BhdGNoIEFVRElPX1RSQUNLU19VUERBVEVEIHdoZW4gdGhlcmUgd2VyZSBhbmQgYXJlIG5vIHRyYWNrc1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnRyYWNrc0luR3JvdXAgPSBhdWRpb1RyYWNrcztcblxuICAgICAgLy8gRmluZCBwcmVmZXJyZWQgdHJhY2tcbiAgICAgIGNvbnN0IGF1ZGlvUHJlZmVyZW5jZSA9IHRoaXMuaGxzLmNvbmZpZy5hdWRpb1ByZWZlcmVuY2U7XG4gICAgICBpZiAoIWN1cnJlbnRUcmFjayAmJiBhdWRpb1ByZWZlcmVuY2UpIHtcbiAgICAgICAgY29uc3QgZ3JvdXBJbmRleCA9IGZpbmRNYXRjaGluZ09wdGlvbihhdWRpb1ByZWZlcmVuY2UsIGF1ZGlvVHJhY2tzLCBhdWRpb01hdGNoUHJlZGljYXRlKTtcbiAgICAgICAgaWYgKGdyb3VwSW5kZXggPiAtMSkge1xuICAgICAgICAgIGN1cnJlbnRUcmFjayA9IGF1ZGlvVHJhY2tzW2dyb3VwSW5kZXhdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGFsbEluZGV4ID0gZmluZE1hdGNoaW5nT3B0aW9uKGF1ZGlvUHJlZmVyZW5jZSwgdGhpcy50cmFja3MpO1xuICAgICAgICAgIGN1cnJlbnRUcmFjayA9IHRoaXMudHJhY2tzW2FsbEluZGV4XTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBTZWxlY3QgaW5pdGlhbCB0cmFja1xuICAgICAgbGV0IHRyYWNrSWQgPSB0aGlzLmZpbmRUcmFja0lkKGN1cnJlbnRUcmFjayk7XG4gICAgICBpZiAodHJhY2tJZCA9PT0gLTEgJiYgY3VycmVudFRyYWNrKSB7XG4gICAgICAgIHRyYWNrSWQgPSB0aGlzLmZpbmRUcmFja0lkKG51bGwpO1xuICAgICAgfVxuXG4gICAgICAvLyBEaXNwYXRjaCBldmVudHMgYW5kIGxvYWQgdHJhY2sgaWYgbmVlZGVkXG4gICAgICBjb25zdCBhdWRpb1RyYWNrc1VwZGF0ZWQgPSB7XG4gICAgICAgIGF1ZGlvVHJhY2tzXG4gICAgICB9O1xuICAgICAgdGhpcy5sb2coYFVwZGF0aW5nIGF1ZGlvIHRyYWNrcywgJHthdWRpb1RyYWNrcy5sZW5ndGh9IHRyYWNrKHMpIGZvdW5kIGluIGdyb3VwKHMpOiAke2F1ZGlvR3JvdXBzID09IG51bGwgPyB2b2lkIDAgOiBhdWRpb0dyb3Vwcy5qb2luKCcsJyl9YCk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5BVURJT19UUkFDS1NfVVBEQVRFRCwgYXVkaW9UcmFja3NVcGRhdGVkKTtcbiAgICAgIGNvbnN0IHNlbGVjdGVkVHJhY2tJZCA9IHRoaXMudHJhY2tJZDtcbiAgICAgIGlmICh0cmFja0lkICE9PSAtMSAmJiBzZWxlY3RlZFRyYWNrSWQgPT09IC0xKSB7XG4gICAgICAgIHRoaXMuc2V0QXVkaW9UcmFjayh0cmFja0lkKTtcbiAgICAgIH0gZWxzZSBpZiAoYXVkaW9UcmFja3MubGVuZ3RoICYmIHNlbGVjdGVkVHJhY2tJZCA9PT0gLTEpIHtcbiAgICAgICAgdmFyIF90aGlzJGdyb3VwSWRzO1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgTm8gYXVkaW8gdHJhY2sgc2VsZWN0ZWQgZm9yIGN1cnJlbnQgYXVkaW8gZ3JvdXAtSUQocyk6ICR7KF90aGlzJGdyb3VwSWRzID0gdGhpcy5ncm91cElkcykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGdyb3VwSWRzLmpvaW4oJywnKX0gdHJhY2sgY291bnQ6ICR7YXVkaW9UcmFja3MubGVuZ3RofWApO1xuICAgICAgICB0aGlzLndhcm4oZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuQVVESU9fVFJBQ0tfTE9BRF9FUlJPUixcbiAgICAgICAgICBmYXRhbDogdHJ1ZSxcbiAgICAgICAgICBlcnJvclxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuc2hvdWxkUmVsb2FkUGxheWxpc3QoY3VycmVudFRyYWNrKSkge1xuICAgICAgLy8gUmV0cnkgcGxheWxpc3QgbG9hZGluZyBpZiBubyBwbGF5bGlzdCBpcyBvciBoYXMgYmVlbiBsb2FkZWQgeWV0XG4gICAgICB0aGlzLnNldEF1ZGlvVHJhY2sodGhpcy50cmFja0lkKTtcbiAgICB9XG4gIH1cbiAgb25FcnJvcihldmVudCwgZGF0YSkge1xuICAgIGlmIChkYXRhLmZhdGFsIHx8ICFkYXRhLmNvbnRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRhdGEuY29udGV4dC50eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLkFVRElPX1RSQUNLICYmIGRhdGEuY29udGV4dC5pZCA9PT0gdGhpcy50cmFja0lkICYmICghdGhpcy5ncm91cElkcyB8fCB0aGlzLmdyb3VwSWRzLmluZGV4T2YoZGF0YS5jb250ZXh0Lmdyb3VwSWQpICE9PSAtMSkpIHtcbiAgICAgIHRoaXMucmVxdWVzdFNjaGVkdWxlZCA9IC0xO1xuICAgICAgdGhpcy5jaGVja1JldHJ5KGRhdGEpO1xuICAgIH1cbiAgfVxuICBnZXQgYWxsQXVkaW9UcmFja3MoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2tzO1xuICB9XG4gIGdldCBhdWRpb1RyYWNrcygpIHtcbiAgICByZXR1cm4gdGhpcy50cmFja3NJbkdyb3VwO1xuICB9XG4gIGdldCBhdWRpb1RyYWNrKCkge1xuICAgIHJldHVybiB0aGlzLnRyYWNrSWQ7XG4gIH1cbiAgc2V0IGF1ZGlvVHJhY2sobmV3SWQpIHtcbiAgICAvLyBJZiBhdWRpbyB0cmFjayBpcyBzZWxlY3RlZCBmcm9tIEFQSSB0aGVuIGRvbid0IGNob29zZSBmcm9tIHRoZSBtYW5pZmVzdCBkZWZhdWx0IHRyYWNrXG4gICAgdGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgPSBmYWxzZTtcbiAgICB0aGlzLnNldEF1ZGlvVHJhY2sobmV3SWQpO1xuICB9XG4gIHNldEF1ZGlvT3B0aW9uKGF1ZGlvT3B0aW9uKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgaGxzLmNvbmZpZy5hdWRpb1ByZWZlcmVuY2UgPSBhdWRpb09wdGlvbjtcbiAgICBpZiAoYXVkaW9PcHRpb24pIHtcbiAgICAgIGNvbnN0IGFsbEF1ZGlvVHJhY2tzID0gdGhpcy5hbGxBdWRpb1RyYWNrcztcbiAgICAgIHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrID0gZmFsc2U7XG4gICAgICBpZiAoYWxsQXVkaW9UcmFja3MubGVuZ3RoKSB7XG4gICAgICAgIC8vIEZpcnN0IHNlZSBpZiBjdXJyZW50IG9wdGlvbiBtYXRjaGVzIChubyBzd2l0Y2ggb3ApXG4gICAgICAgIGNvbnN0IGN1cnJlbnRUcmFjayA9IHRoaXMuY3VycmVudFRyYWNrO1xuICAgICAgICBpZiAoY3VycmVudFRyYWNrICYmIG1hdGNoZXNPcHRpb24oYXVkaW9PcHRpb24sIGN1cnJlbnRUcmFjaywgYXVkaW9NYXRjaFByZWRpY2F0ZSkpIHtcbiAgICAgICAgICByZXR1cm4gY3VycmVudFRyYWNrO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbmQgb3B0aW9uIGluIGF2YWlsYWJsZSB0cmFja3MgKHRyYWNrc0luR3JvdXApXG4gICAgICAgIGNvbnN0IGdyb3VwSW5kZXggPSBmaW5kTWF0Y2hpbmdPcHRpb24oYXVkaW9PcHRpb24sIHRoaXMudHJhY2tzSW5Hcm91cCwgYXVkaW9NYXRjaFByZWRpY2F0ZSk7XG4gICAgICAgIGlmIChncm91cEluZGV4ID4gLTEpIHtcbiAgICAgICAgICBjb25zdCB0cmFjayA9IHRoaXMudHJhY2tzSW5Hcm91cFtncm91cEluZGV4XTtcbiAgICAgICAgICB0aGlzLnNldEF1ZGlvVHJhY2soZ3JvdXBJbmRleCk7XG4gICAgICAgICAgcmV0dXJuIHRyYWNrO1xuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRUcmFjaykge1xuICAgICAgICAgIC8vIEZpbmQgb3B0aW9uIGluIG5lYXJlc3QgbGV2ZWwgYXVkaW8gZ3JvdXBcbiAgICAgICAgICBsZXQgc2VhcmNoSW5kZXggPSBobHMubG9hZExldmVsO1xuICAgICAgICAgIGlmIChzZWFyY2hJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHNlYXJjaEluZGV4ID0gaGxzLmZpcnN0QXV0b0xldmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzd2l0Y2hJbmRleCA9IGZpbmRDbG9zZXN0TGV2ZWxXaXRoQXVkaW9Hcm91cChhdWRpb09wdGlvbiwgaGxzLmxldmVscywgYWxsQXVkaW9UcmFja3MsIHNlYXJjaEluZGV4LCBhdWRpb01hdGNoUHJlZGljYXRlKTtcbiAgICAgICAgICBpZiAoc3dpdGNoSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBjb3VsZCBub3QgZmluZCBtYXRjaGluZyB2YXJpYW50XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gYW5kIHN3aXRjaCBsZXZlbCB0byBhY2hlaXZlIHRoZSBhdWRpbyBncm91cCBzd2l0Y2hcbiAgICAgICAgICBobHMubmV4dExvYWRMZXZlbCA9IHN3aXRjaEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdWRpb09wdGlvbi5jaGFubmVscyB8fCBhdWRpb09wdGlvbi5hdWRpb0NvZGVjKSB7XG4gICAgICAgICAgLy8gQ291bGQgbm90IGZpbmQgYSBtYXRjaCB3aXRoIGNvZGVjIC8gY2hhbm5lbHMgcHJlZGljYXRlXG4gICAgICAgICAgLy8gRmluZCBhIG1hdGNoIHdpdGhvdXQgY2hhbm5lbHMgb3IgY29kZWNcbiAgICAgICAgICBjb25zdCB3aXRob3V0Q29kZWNBbmRDaGFubmVsc01hdGNoID0gZmluZE1hdGNoaW5nT3B0aW9uKGF1ZGlvT3B0aW9uLCBhbGxBdWRpb1RyYWNrcyk7XG4gICAgICAgICAgaWYgKHdpdGhvdXRDb2RlY0FuZENoYW5uZWxzTWF0Y2ggPiAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIGFsbEF1ZGlvVHJhY2tzW3dpdGhvdXRDb2RlY0FuZENoYW5uZWxzTWF0Y2hdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBzZXRBdWRpb1RyYWNrKG5ld0lkKSB7XG4gICAgY29uc3QgdHJhY2tzID0gdGhpcy50cmFja3NJbkdyb3VwO1xuXG4gICAgLy8gY2hlY2sgaWYgbGV2ZWwgaWR4IGlzIHZhbGlkXG4gICAgaWYgKG5ld0lkIDwgMCB8fCBuZXdJZCA+PSB0cmFja3MubGVuZ3RoKSB7XG4gICAgICB0aGlzLndhcm4oYEludmFsaWQgYXVkaW8gdHJhY2sgaWQ6ICR7bmV3SWR9YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gc3RvcHBpbmcgbGl2ZSByZWxvYWRpbmcgdGltZXIgaWYgYW55XG4gICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgdGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgPSBmYWxzZTtcbiAgICBjb25zdCBsYXN0VHJhY2sgPSB0aGlzLmN1cnJlbnRUcmFjaztcbiAgICBjb25zdCB0cmFjayA9IHRyYWNrc1tuZXdJZF07XG4gICAgY29uc3QgdHJhY2tMb2FkZWQgPSB0cmFjay5kZXRhaWxzICYmICF0cmFjay5kZXRhaWxzLmxpdmU7XG4gICAgaWYgKG5ld0lkID09PSB0aGlzLnRyYWNrSWQgJiYgdHJhY2sgPT09IGxhc3RUcmFjayAmJiB0cmFja0xvYWRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxvZyhgU3dpdGNoaW5nIHRvIGF1ZGlvLXRyYWNrICR7bmV3SWR9IFwiJHt0cmFjay5uYW1lfVwiIGxhbmc6JHt0cmFjay5sYW5nfSBncm91cDoke3RyYWNrLmdyb3VwSWR9IGNoYW5uZWxzOiR7dHJhY2suY2hhbm5lbHN9YCk7XG4gICAgdGhpcy50cmFja0lkID0gbmV3SWQ7XG4gICAgdGhpcy5jdXJyZW50VHJhY2sgPSB0cmFjaztcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5BVURJT19UUkFDS19TV0lUQ0hJTkcsIF9vYmplY3RTcHJlYWQyKHt9LCB0cmFjaykpO1xuICAgIC8vIERvIG5vdCByZWxvYWQgdHJhY2sgdW5sZXNzIGxpdmVcbiAgICBpZiAodHJhY2tMb2FkZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaGxzVXJsUGFyYW1ldGVycyA9IHRoaXMuc3dpdGNoUGFyYW1zKHRyYWNrLnVybCwgbGFzdFRyYWNrID09IG51bGwgPyB2b2lkIDAgOiBsYXN0VHJhY2suZGV0YWlscyk7XG4gICAgdGhpcy5sb2FkUGxheWxpc3QoaGxzVXJsUGFyYW1ldGVycyk7XG4gIH1cbiAgZmluZFRyYWNrSWQoY3VycmVudFRyYWNrKSB7XG4gICAgY29uc3QgYXVkaW9UcmFja3MgPSB0aGlzLnRyYWNrc0luR3JvdXA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdWRpb1RyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdHJhY2sgPSBhdWRpb1RyYWNrc1tpXTtcbiAgICAgIGlmICh0aGlzLnNlbGVjdERlZmF1bHRUcmFjayAmJiAhdHJhY2suZGVmYXVsdCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghY3VycmVudFRyYWNrIHx8IG1hdGNoZXNPcHRpb24oY3VycmVudFRyYWNrLCB0cmFjaywgYXVkaW9NYXRjaFByZWRpY2F0ZSkpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjdXJyZW50VHJhY2spIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgbGFuZyxcbiAgICAgICAgYXNzb2NMYW5nLFxuICAgICAgICBjaGFyYWN0ZXJpc3RpY3MsXG4gICAgICAgIGF1ZGlvQ29kZWMsXG4gICAgICAgIGNoYW5uZWxzXG4gICAgICB9ID0gY3VycmVudFRyYWNrO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdWRpb1RyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB0cmFjayA9IGF1ZGlvVHJhY2tzW2ldO1xuICAgICAgICBpZiAobWF0Y2hlc09wdGlvbih7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBsYW5nLFxuICAgICAgICAgIGFzc29jTGFuZyxcbiAgICAgICAgICBjaGFyYWN0ZXJpc3RpY3MsXG4gICAgICAgICAgYXVkaW9Db2RlYyxcbiAgICAgICAgICBjaGFubmVsc1xuICAgICAgICB9LCB0cmFjaywgYXVkaW9NYXRjaFByZWRpY2F0ZSkpIHtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdWRpb1RyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB0cmFjayA9IGF1ZGlvVHJhY2tzW2ldO1xuICAgICAgICBpZiAobWVkaWFBdHRyaWJ1dGVzSWRlbnRpY2FsKGN1cnJlbnRUcmFjay5hdHRycywgdHJhY2suYXR0cnMsIFsnTEFOR1VBR0UnLCAnQVNTT0MtTEFOR1VBR0UnLCAnQ0hBUkFDVEVSSVNUSUNTJ10pKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXVkaW9UcmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdHJhY2sgPSBhdWRpb1RyYWNrc1tpXTtcbiAgICAgICAgaWYgKG1lZGlhQXR0cmlidXRlc0lkZW50aWNhbChjdXJyZW50VHJhY2suYXR0cnMsIHRyYWNrLmF0dHJzLCBbJ0xBTkdVQUdFJ10pKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGxvYWRQbGF5bGlzdChobHNVcmxQYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgYXVkaW9UcmFjayA9IHRoaXMuY3VycmVudFRyYWNrO1xuICAgIGlmICh0aGlzLnNob3VsZExvYWRQbGF5bGlzdChhdWRpb1RyYWNrKSAmJiBhdWRpb1RyYWNrKSB7XG4gICAgICBzdXBlci5sb2FkUGxheWxpc3QoKTtcbiAgICAgIGNvbnN0IGlkID0gYXVkaW9UcmFjay5pZDtcbiAgICAgIGNvbnN0IGdyb3VwSWQgPSBhdWRpb1RyYWNrLmdyb3VwSWQ7XG4gICAgICBsZXQgdXJsID0gYXVkaW9UcmFjay51cmw7XG4gICAgICBpZiAoaGxzVXJsUGFyYW1ldGVycykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHVybCA9IGhsc1VybFBhcmFtZXRlcnMuYWRkRGlyZWN0aXZlcyh1cmwpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHRoaXMud2FybihgQ291bGQgbm90IGNvbnN0cnVjdCBuZXcgVVJMIHdpdGggSExTIERlbGl2ZXJ5IERpcmVjdGl2ZXM6ICR7ZXJyb3J9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIHRyYWNrIG5vdCByZXRyaWV2ZWQgeWV0LCBvciBsaXZlIHBsYXlsaXN0IHdlIG5lZWQgdG8gKHJlKWxvYWQgaXRcbiAgICAgIHRoaXMubG9nKGBsb2FkaW5nIGF1ZGlvLXRyYWNrIHBsYXlsaXN0ICR7aWR9IFwiJHthdWRpb1RyYWNrLm5hbWV9XCIgbGFuZzoke2F1ZGlvVHJhY2subGFuZ30gZ3JvdXA6JHtncm91cElkfWApO1xuICAgICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5BVURJT19UUkFDS19MT0FESU5HLCB7XG4gICAgICAgIHVybCxcbiAgICAgICAgaWQsXG4gICAgICAgIGdyb3VwSWQsXG4gICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlczogaGxzVXJsUGFyYW1ldGVycyB8fCBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgVElDS19JTlRFUlZBTCQxID0gNTAwOyAvLyBob3cgb2Z0ZW4gdG8gdGljayBpbiBtc1xuXG5jbGFzcyBTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlU3RyZWFtQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGhscywgZnJhZ21lbnRUcmFja2VyLCBrZXlMb2FkZXIpIHtcbiAgICBzdXBlcihobHMsIGZyYWdtZW50VHJhY2tlciwga2V5TG9hZGVyLCAnW3N1YnRpdGxlLXN0cmVhbS1jb250cm9sbGVyXScsIFBsYXlsaXN0TGV2ZWxUeXBlLlNVQlRJVExFKTtcbiAgICB0aGlzLmN1cnJlbnRUcmFja0lkID0gLTE7XG4gICAgdGhpcy50cmFja3NCdWZmZXJlZCA9IFtdO1xuICAgIHRoaXMubWFpbkRldGFpbHMgPSBudWxsO1xuICAgIHRoaXMuX3JlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cbiAgb25IYW5kbGVyRGVzdHJveWluZygpIHtcbiAgICB0aGlzLl91bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgc3VwZXIub25IYW5kbGVyRGVzdHJveWluZygpO1xuICAgIHRoaXMubWFpbkRldGFpbHMgPSBudWxsO1xuICB9XG4gIF9yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub24oRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMX0xPQURFRCwgdGhpcy5vbkxldmVsTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuU1VCVElUTEVfVFJBQ0tTX1VQREFURUQsIHRoaXMub25TdWJ0aXRsZVRyYWNrc1VwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuU1VCVElUTEVfVFJBQ0tfU1dJVENILCB0aGlzLm9uU3VidGl0bGVUcmFja1N3aXRjaCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5TVUJUSVRMRV9UUkFDS19MT0FERUQsIHRoaXMub25TdWJ0aXRsZVRyYWNrTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELCB0aGlzLm9uU3VidGl0bGVGcmFnUHJvY2Vzc2VkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkJVRkZFUl9GTFVTSElORywgdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkZSQUdfQlVGRkVSRUQsIHRoaXMub25GcmFnQnVmZmVyZWQsIHRoaXMpO1xuICB9XG4gIF91bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMX0xPQURFRCwgdGhpcy5vbkxldmVsTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5TVUJUSVRMRV9UUkFDS1NfVVBEQVRFRCwgdGhpcy5vblN1YnRpdGxlVHJhY2tzVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuU1VCVElUTEVfVFJBQ0tfU1dJVENILCB0aGlzLm9uU3VidGl0bGVUcmFja1N3aXRjaCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuU1VCVElUTEVfVFJBQ0tfTE9BREVELCB0aGlzLm9uU3VidGl0bGVUcmFja0xvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsIHRoaXMub25TdWJ0aXRsZUZyYWdQcm9jZXNzZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9GTFVTSElORywgdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5GUkFHX0JVRkZFUkVELCB0aGlzLm9uRnJhZ0J1ZmZlcmVkLCB0aGlzKTtcbiAgfVxuICBzdGFydExvYWQoc3RhcnRQb3NpdGlvbikge1xuICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICB0aGlzLnNldEludGVydmFsKFRJQ0tfSU5URVJWQUwkMSk7XG4gICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSBzdGFydFBvc2l0aW9uO1xuICAgIHRoaXMudGljaygpO1xuICB9XG4gIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIHRoaXMubWFpbkRldGFpbHMgPSBudWxsO1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUFsbEZyYWdtZW50cygpO1xuICB9XG4gIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgdGhpcy50cmFja3NCdWZmZXJlZCA9IFtdO1xuICAgIHN1cGVyLm9uTWVkaWFEZXRhY2hpbmcoKTtcbiAgfVxuICBvbkxldmVsTG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5tYWluRGV0YWlscyA9IGRhdGEuZGV0YWlscztcbiAgfVxuICBvblN1YnRpdGxlRnJhZ1Byb2Nlc3NlZChldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGZyYWcsXG4gICAgICBzdWNjZXNzXG4gICAgfSA9IGRhdGE7XG4gICAgdGhpcy5mcmFnUHJldmlvdXMgPSBmcmFnO1xuICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgIGlmICghc3VjY2Vzcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBidWZmZXJlZCA9IHRoaXMudHJhY2tzQnVmZmVyZWRbdGhpcy5jdXJyZW50VHJhY2tJZF07XG4gICAgaWYgKCFidWZmZXJlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZS91cGRhdGUgYSBidWZmZXJlZCBhcnJheSBtYXRjaGluZyB0aGUgaW50ZXJmYWNlIHVzZWQgYnkgQnVmZmVySGVscGVyLmJ1ZmZlcmVkSW5mb1xuICAgIC8vIHNvIHdlIGNhbiByZS11c2UgdGhlIGxvZ2ljIHVzZWQgdG8gZGV0ZWN0IGhvdyBtdWNoIGhhcyBiZWVuIGJ1ZmZlcmVkXG4gICAgbGV0IHRpbWVSYW5nZTtcbiAgICBjb25zdCBmcmFnU3RhcnQgPSBmcmFnLnN0YXJ0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChmcmFnU3RhcnQgPj0gYnVmZmVyZWRbaV0uc3RhcnQgJiYgZnJhZ1N0YXJ0IDw9IGJ1ZmZlcmVkW2ldLmVuZCkge1xuICAgICAgICB0aW1lUmFuZ2UgPSBidWZmZXJlZFtpXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZyYWdFbmQgPSBmcmFnLnN0YXJ0ICsgZnJhZy5kdXJhdGlvbjtcbiAgICBpZiAodGltZVJhbmdlKSB7XG4gICAgICB0aW1lUmFuZ2UuZW5kID0gZnJhZ0VuZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGltZVJhbmdlID0ge1xuICAgICAgICBzdGFydDogZnJhZ1N0YXJ0LFxuICAgICAgICBlbmQ6IGZyYWdFbmRcbiAgICAgIH07XG4gICAgICBidWZmZXJlZC5wdXNoKHRpbWVSYW5nZSk7XG4gICAgfVxuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLmZyYWdCdWZmZXJlZChmcmFnKTtcbiAgICB0aGlzLmZyYWdCdWZmZXJlZENvbXBsZXRlKGZyYWcsIG51bGwpO1xuICB9XG4gIG9uQnVmZmVyRmx1c2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFydE9mZnNldCxcbiAgICAgIGVuZE9mZnNldFxuICAgIH0gPSBkYXRhO1xuICAgIGlmIChzdGFydE9mZnNldCA9PT0gMCAmJiBlbmRPZmZzZXQgIT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSkge1xuICAgICAgY29uc3QgZW5kT2Zmc2V0U3VidGl0bGVzID0gZW5kT2Zmc2V0IC0gMTtcbiAgICAgIGlmIChlbmRPZmZzZXRTdWJ0aXRsZXMgPD0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkYXRhLmVuZE9mZnNldFN1YnRpdGxlcyA9IE1hdGgubWF4KDAsIGVuZE9mZnNldFN1YnRpdGxlcyk7XG4gICAgICB0aGlzLnRyYWNrc0J1ZmZlcmVkLmZvckVhY2goYnVmZmVyZWQgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlcmVkLmxlbmd0aDspIHtcbiAgICAgICAgICBpZiAoYnVmZmVyZWRbaV0uZW5kIDw9IGVuZE9mZnNldFN1YnRpdGxlcykge1xuICAgICAgICAgICAgYnVmZmVyZWQuc2hpZnQoKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYnVmZmVyZWRbaV0uc3RhcnQgPCBlbmRPZmZzZXRTdWJ0aXRsZXMpIHtcbiAgICAgICAgICAgIGJ1ZmZlcmVkW2ldLnN0YXJ0ID0gZW5kT2Zmc2V0U3VidGl0bGVzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50c0luUmFuZ2Uoc3RhcnRPZmZzZXQsIGVuZE9mZnNldFN1YnRpdGxlcywgUGxheWxpc3RMZXZlbFR5cGUuU1VCVElUTEUpO1xuICAgIH1cbiAgfVxuICBvbkZyYWdCdWZmZXJlZChldmVudCwgZGF0YSkge1xuICAgIGlmICghdGhpcy5sb2FkZWRtZXRhZGF0YSAmJiBkYXRhLmZyYWcudHlwZSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTikge1xuICAgICAgdmFyIF90aGlzJG1lZGlhO1xuICAgICAgaWYgKChfdGhpcyRtZWRpYSA9IHRoaXMubWVkaWEpICE9IG51bGwgJiYgX3RoaXMkbWVkaWEuYnVmZmVyZWQubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMubG9hZGVkbWV0YWRhdGEgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIElmIHNvbWV0aGluZyBnb2VzIHdyb25nLCBwcm9jZWVkIHRvIG5leHQgZnJhZywgaWYgd2Ugd2VyZSBwcm9jZXNzaW5nIG9uZS5cbiAgb25FcnJvcihldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IGZyYWcgPSBkYXRhLmZyYWc7XG4gICAgaWYgKChmcmFnID09IG51bGwgPyB2b2lkIDAgOiBmcmFnLnR5cGUpID09PSBQbGF5bGlzdExldmVsVHlwZS5TVUJUSVRMRSkge1xuICAgICAgaWYgKHRoaXMuZnJhZ0N1cnJlbnQpIHtcbiAgICAgICAgdGhpcy5mcmFnQ3VycmVudC5hYm9ydFJlcXVlc3RzKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU3RhdGUuU1RPUFBFRCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBHb3QgYWxsIG5ldyBzdWJ0aXRsZSBsZXZlbHMuXG4gIG9uU3VidGl0bGVUcmFja3NVcGRhdGVkKGV2ZW50LCB7XG4gICAgc3VidGl0bGVUcmFja3NcbiAgfSkge1xuICAgIGlmICghdGhpcy5sZXZlbHMgfHwgc3VidGl0bGVPcHRpb25zSWRlbnRpY2FsKHRoaXMubGV2ZWxzLCBzdWJ0aXRsZVRyYWNrcykpIHtcbiAgICAgIHRoaXMubGV2ZWxzID0gc3VidGl0bGVUcmFja3MubWFwKG1lZGlhUGxheWxpc3QgPT4gbmV3IExldmVsKG1lZGlhUGxheWxpc3QpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy50cmFja3NCdWZmZXJlZCA9IFtdO1xuICAgIHRoaXMubGV2ZWxzID0gc3VidGl0bGVUcmFja3MubWFwKG1lZGlhUGxheWxpc3QgPT4ge1xuICAgICAgY29uc3QgbGV2ZWwgPSBuZXcgTGV2ZWwobWVkaWFQbGF5bGlzdCk7XG4gICAgICB0aGlzLnRyYWNrc0J1ZmZlcmVkW2xldmVsLmlkXSA9IFtdO1xuICAgICAgcmV0dXJuIGxldmVsO1xuICAgIH0pO1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50c0luUmFuZ2UoMCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBQbGF5bGlzdExldmVsVHlwZS5TVUJUSVRMRSk7XG4gICAgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsO1xuICAgIHRoaXMubWVkaWFCdWZmZXIgPSBudWxsO1xuICB9XG4gIG9uU3VidGl0bGVUcmFja1N3aXRjaChldmVudCwgZGF0YSkge1xuICAgIHZhciBfdGhpcyRsZXZlbHM7XG4gICAgdGhpcy5jdXJyZW50VHJhY2tJZCA9IGRhdGEuaWQ7XG4gICAgaWYgKCEoKF90aGlzJGxldmVscyA9IHRoaXMubGV2ZWxzKSAhPSBudWxsICYmIF90aGlzJGxldmVscy5sZW5ndGgpIHx8IHRoaXMuY3VycmVudFRyYWNrSWQgPT09IC0xKSB7XG4gICAgICB0aGlzLmNsZWFySW50ZXJ2YWwoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiB0cmFjayBoYXMgdGhlIG5lY2Vzc2FyeSBkZXRhaWxzIHRvIGxvYWQgZnJhZ21lbnRzXG4gICAgY29uc3QgY3VycmVudFRyYWNrID0gdGhpcy5sZXZlbHNbdGhpcy5jdXJyZW50VHJhY2tJZF07XG4gICAgaWYgKGN1cnJlbnRUcmFjayAhPSBudWxsICYmIGN1cnJlbnRUcmFjay5kZXRhaWxzKSB7XG4gICAgICB0aGlzLm1lZGlhQnVmZmVyID0gdGhpcy5tZWRpYUJ1ZmZlclRpbWVSYW5nZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoY3VycmVudFRyYWNrKSB7XG4gICAgICB0aGlzLnNldEludGVydmFsKFRJQ0tfSU5URVJWQUwkMSk7XG4gICAgfVxuICB9XG5cbiAgLy8gR290IGEgbmV3IHNldCBvZiBzdWJ0aXRsZSBmcmFnbWVudHMuXG4gIG9uU3VidGl0bGVUcmFja0xvYWRlZChldmVudCwgZGF0YSkge1xuICAgIHZhciBfdHJhY2skZGV0YWlscztcbiAgICBjb25zdCB7XG4gICAgICBjdXJyZW50VHJhY2tJZCxcbiAgICAgIGxldmVsc1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIGRldGFpbHM6IG5ld0RldGFpbHMsXG4gICAgICBpZDogdHJhY2tJZFxuICAgIH0gPSBkYXRhO1xuICAgIGlmICghbGV2ZWxzKSB7XG4gICAgICB0aGlzLndhcm4oYFN1YnRpdGxlIHRyYWNrcyB3ZXJlIHJlc2V0IHdoaWxlIGxvYWRpbmcgbGV2ZWwgJHt0cmFja0lkfWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0cmFjayA9IGxldmVsc1tjdXJyZW50VHJhY2tJZF07XG4gICAgaWYgKHRyYWNrSWQgPj0gbGV2ZWxzLmxlbmd0aCB8fCB0cmFja0lkICE9PSBjdXJyZW50VHJhY2tJZCB8fCAhdHJhY2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sb2coYFN1YnRpdGxlIHRyYWNrICR7dHJhY2tJZH0gbG9hZGVkIFske25ld0RldGFpbHMuc3RhcnRTTn0sJHtuZXdEZXRhaWxzLmVuZFNOfV0ke25ld0RldGFpbHMubGFzdFBhcnRTbiA/IGBbcGFydC0ke25ld0RldGFpbHMubGFzdFBhcnRTbn0tJHtuZXdEZXRhaWxzLmxhc3RQYXJ0SW5kZXh9XWAgOiAnJ30sZHVyYXRpb246JHtuZXdEZXRhaWxzLnRvdGFsZHVyYXRpb259YCk7XG4gICAgdGhpcy5tZWRpYUJ1ZmZlciA9IHRoaXMubWVkaWFCdWZmZXJUaW1lUmFuZ2VzO1xuICAgIGxldCBzbGlkaW5nID0gMDtcbiAgICBpZiAobmV3RGV0YWlscy5saXZlIHx8IChfdHJhY2skZGV0YWlscyA9IHRyYWNrLmRldGFpbHMpICE9IG51bGwgJiYgX3RyYWNrJGRldGFpbHMubGl2ZSkge1xuICAgICAgY29uc3QgbWFpbkRldGFpbHMgPSB0aGlzLm1haW5EZXRhaWxzO1xuICAgICAgaWYgKG5ld0RldGFpbHMuZGVsdGFVcGRhdGVGYWlsZWQgfHwgIW1haW5EZXRhaWxzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1haW5TbGlkaW5nU3RhcnRGcmFnbWVudCA9IG1haW5EZXRhaWxzLmZyYWdtZW50c1swXTtcbiAgICAgIGlmICghdHJhY2suZGV0YWlscykge1xuICAgICAgICBpZiAobmV3RGV0YWlscy5oYXNQcm9ncmFtRGF0ZVRpbWUgJiYgbWFpbkRldGFpbHMuaGFzUHJvZ3JhbURhdGVUaW1lKSB7XG4gICAgICAgICAgYWxpZ25NZWRpYVBsYXlsaXN0QnlQRFQobmV3RGV0YWlscywgbWFpbkRldGFpbHMpO1xuICAgICAgICAgIHNsaWRpbmcgPSBuZXdEZXRhaWxzLmZyYWdtZW50c1swXS5zdGFydDtcbiAgICAgICAgfSBlbHNlIGlmIChtYWluU2xpZGluZ1N0YXJ0RnJhZ21lbnQpIHtcbiAgICAgICAgICAvLyBsaW5lIHVwIGxpdmUgcGxheWxpc3Qgd2l0aCBtYWluIHNvIHRoYXQgZnJhZ21lbnRzIGluIHJhbmdlIGFyZSBsb2FkZWRcbiAgICAgICAgICBzbGlkaW5nID0gbWFpblNsaWRpbmdTdGFydEZyYWdtZW50LnN0YXJ0O1xuICAgICAgICAgIGFkZFNsaWRpbmcobmV3RGV0YWlscywgc2xpZGluZyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfdGhpcyRsZXZlbExhc3RMb2FkZWQ7XG4gICAgICAgIHNsaWRpbmcgPSB0aGlzLmFsaWduUGxheWxpc3RzKG5ld0RldGFpbHMsIHRyYWNrLmRldGFpbHMsIChfdGhpcyRsZXZlbExhc3RMb2FkZWQgPSB0aGlzLmxldmVsTGFzdExvYWRlZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGxldmVsTGFzdExvYWRlZC5kZXRhaWxzKTtcbiAgICAgICAgaWYgKHNsaWRpbmcgPT09IDAgJiYgbWFpblNsaWRpbmdTdGFydEZyYWdtZW50KSB7XG4gICAgICAgICAgLy8gcmVhbGlnbiB3aXRoIG1haW4gd2hlbiB0aGVyZSBpcyBubyBvdmVybGFwIHdpdGggbGFzdCByZWZyZXNoXG4gICAgICAgICAgc2xpZGluZyA9IG1haW5TbGlkaW5nU3RhcnRGcmFnbWVudC5zdGFydDtcbiAgICAgICAgICBhZGRTbGlkaW5nKG5ld0RldGFpbHMsIHNsaWRpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRyYWNrLmRldGFpbHMgPSBuZXdEZXRhaWxzO1xuICAgIHRoaXMubGV2ZWxMYXN0TG9hZGVkID0gdHJhY2s7XG4gICAgaWYgKCF0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCAmJiAodGhpcy5tYWluRGV0YWlscyB8fCAhbmV3RGV0YWlscy5saXZlKSkge1xuICAgICAgdGhpcy5zZXRTdGFydFBvc2l0aW9uKHRyYWNrLmRldGFpbHMsIHNsaWRpbmcpO1xuICAgIH1cblxuICAgIC8vIHRyaWdnZXIgaGFuZGxlciByaWdodCBub3dcbiAgICB0aGlzLnRpY2soKTtcblxuICAgIC8vIElmIHBsYXlsaXN0IGlzIG1pc2FsaWduZWQgYmVjYXVzZSBvZiBiYWQgUERUIG9yIGRyaWZ0LCBkZWxldGUgZGV0YWlscyB0byByZXN5bmMgd2l0aCBtYWluIG9uIHJlbG9hZFxuICAgIGlmIChuZXdEZXRhaWxzLmxpdmUgJiYgIXRoaXMuZnJhZ0N1cnJlbnQgJiYgdGhpcy5tZWRpYSAmJiB0aGlzLnN0YXRlID09PSBTdGF0ZS5JRExFKSB7XG4gICAgICBjb25zdCBmb3VuZEZyYWcgPSBmaW5kRnJhZ21lbnRCeVBUUyhudWxsLCBuZXdEZXRhaWxzLmZyYWdtZW50cywgdGhpcy5tZWRpYS5jdXJyZW50VGltZSwgMCk7XG4gICAgICBpZiAoIWZvdW5kRnJhZykge1xuICAgICAgICB0aGlzLndhcm4oJ1N1YnRpdGxlIHBsYXlsaXN0IG5vdCBhbGlnbmVkIHdpdGggcGxheWJhY2snKTtcbiAgICAgICAgdHJhY2suZGV0YWlscyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX2hhbmRsZUZyYWdtZW50TG9hZENvbXBsZXRlKGZyYWdMb2FkZWREYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZyxcbiAgICAgIHBheWxvYWRcbiAgICB9ID0gZnJhZ0xvYWRlZERhdGE7XG4gICAgY29uc3QgZGVjcnlwdERhdGEgPSBmcmFnLmRlY3J5cHRkYXRhO1xuICAgIGNvbnN0IGhscyA9IHRoaXMuaGxzO1xuICAgIGlmICh0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBjaGVjayB0byBzZWUgaWYgdGhlIHBheWxvYWQgbmVlZHMgdG8gYmUgZGVjcnlwdGVkXG4gICAgaWYgKHBheWxvYWQgJiYgcGF5bG9hZC5ieXRlTGVuZ3RoID4gMCAmJiBkZWNyeXB0RGF0YSAhPSBudWxsICYmIGRlY3J5cHREYXRhLmtleSAmJiBkZWNyeXB0RGF0YS5pdiAmJiBkZWNyeXB0RGF0YS5tZXRob2QgPT09ICdBRVMtMTI4Jykge1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAvLyBkZWNyeXB0IHRoZSBzdWJ0aXRsZXNcbiAgICAgIHRoaXMuZGVjcnlwdGVyLmRlY3J5cHQobmV3IFVpbnQ4QXJyYXkocGF5bG9hZCksIGRlY3J5cHREYXRhLmtleS5idWZmZXIsIGRlY3J5cHREYXRhLml2LmJ1ZmZlcikuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuRlJBR19ERUNSWVBUX0VSUk9SLFxuICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogZXJyLFxuICAgICAgICAgIHJlYXNvbjogZXJyLm1lc3NhZ2UsXG4gICAgICAgICAgZnJhZ1xuICAgICAgICB9KTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfSkudGhlbihkZWNyeXB0ZWREYXRhID0+IHtcbiAgICAgICAgY29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBobHMudHJpZ2dlcihFdmVudHMuRlJBR19ERUNSWVBURUQsIHtcbiAgICAgICAgICBmcmFnLFxuICAgICAgICAgIHBheWxvYWQ6IGRlY3J5cHRlZERhdGEsXG4gICAgICAgICAgc3RhdHM6IHtcbiAgICAgICAgICAgIHRzdGFydDogc3RhcnRUaW1lLFxuICAgICAgICAgICAgdGRlY3J5cHQ6IGVuZFRpbWVcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgdGhpcy53YXJuKGAke2Vyci5uYW1lfTogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZG9UaWNrKCkge1xuICAgIGlmICghdGhpcy5tZWRpYSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5JRExFKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGN1cnJlbnRUcmFja0lkLFxuICAgICAgICBsZXZlbHNcbiAgICAgIH0gPSB0aGlzO1xuICAgICAgY29uc3QgdHJhY2sgPSBsZXZlbHMgPT0gbnVsbCA/IHZvaWQgMCA6IGxldmVsc1tjdXJyZW50VHJhY2tJZF07XG4gICAgICBpZiAoIXRyYWNrIHx8ICFsZXZlbHMubGVuZ3RoIHx8ICF0cmFjay5kZXRhaWxzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29uZmlnXG4gICAgICB9ID0gdGhpcztcbiAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gdGhpcy5nZXRMb2FkUG9zaXRpb24oKTtcbiAgICAgIGNvbnN0IGJ1ZmZlcmVkSW5mbyA9IEJ1ZmZlckhlbHBlci5idWZmZXJlZEluZm8odGhpcy50cmFja3NCdWZmZXJlZFt0aGlzLmN1cnJlbnRUcmFja0lkXSB8fCBbXSwgY3VycmVudFRpbWUsIGNvbmZpZy5tYXhCdWZmZXJIb2xlKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZW5kOiB0YXJnZXRCdWZmZXJUaW1lLFxuICAgICAgICBsZW46IGJ1ZmZlckxlblxuICAgICAgfSA9IGJ1ZmZlcmVkSW5mbztcbiAgICAgIGNvbnN0IG1haW5CdWZmZXJJbmZvID0gdGhpcy5nZXRGd2RCdWZmZXJJbmZvKHRoaXMubWVkaWEsIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pO1xuICAgICAgY29uc3QgdHJhY2tEZXRhaWxzID0gdHJhY2suZGV0YWlscztcbiAgICAgIGNvbnN0IG1heEJ1ZkxlbiA9IHRoaXMuZ2V0TWF4QnVmZmVyTGVuZ3RoKG1haW5CdWZmZXJJbmZvID09IG51bGwgPyB2b2lkIDAgOiBtYWluQnVmZmVySW5mby5sZW4pICsgdHJhY2tEZXRhaWxzLmxldmVsVGFyZ2V0RHVyYXRpb247XG4gICAgICBpZiAoYnVmZmVyTGVuID4gbWF4QnVmTGVuKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZyYWdtZW50cyA9IHRyYWNrRGV0YWlscy5mcmFnbWVudHM7XG4gICAgICBjb25zdCBmcmFnTGVuID0gZnJhZ21lbnRzLmxlbmd0aDtcbiAgICAgIGNvbnN0IGVuZCA9IHRyYWNrRGV0YWlscy5lZGdlO1xuICAgICAgbGV0IGZvdW5kRnJhZyA9IG51bGw7XG4gICAgICBjb25zdCBmcmFnUHJldmlvdXMgPSB0aGlzLmZyYWdQcmV2aW91cztcbiAgICAgIGlmICh0YXJnZXRCdWZmZXJUaW1lIDwgZW5kKSB7XG4gICAgICAgIGNvbnN0IHRvbGVyYW5jZSA9IGNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlO1xuICAgICAgICBjb25zdCBsb29rdXBUb2xlcmFuY2UgPSB0YXJnZXRCdWZmZXJUaW1lID4gZW5kIC0gdG9sZXJhbmNlID8gMCA6IHRvbGVyYW5jZTtcbiAgICAgICAgZm91bmRGcmFnID0gZmluZEZyYWdtZW50QnlQVFMoZnJhZ1ByZXZpb3VzLCBmcmFnbWVudHMsIE1hdGgubWF4KGZyYWdtZW50c1swXS5zdGFydCwgdGFyZ2V0QnVmZmVyVGltZSksIGxvb2t1cFRvbGVyYW5jZSk7XG4gICAgICAgIGlmICghZm91bmRGcmFnICYmIGZyYWdQcmV2aW91cyAmJiBmcmFnUHJldmlvdXMuc3RhcnQgPCBmcmFnbWVudHNbMF0uc3RhcnQpIHtcbiAgICAgICAgICBmb3VuZEZyYWcgPSBmcmFnbWVudHNbMF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvdW5kRnJhZyA9IGZyYWdtZW50c1tmcmFnTGVuIC0gMV07XG4gICAgICB9XG4gICAgICBpZiAoIWZvdW5kRnJhZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3VuZEZyYWcgPSB0aGlzLm1hcFRvSW5pdEZyYWdXaGVuUmVxdWlyZWQoZm91bmRGcmFnKTtcbiAgICAgIGlmIChmb3VuZEZyYWcuc24gIT09ICdpbml0U2VnbWVudCcpIHtcbiAgICAgICAgLy8gTG9hZCBlYXJsaWVyIGZyYWdtZW50IGluIHNhbWUgZGlzY29udGludWl0eSB0byBtYWtlIHVwIGZvciBtaXNhbGlnbmVkIHBsYXlsaXN0cyBhbmQgY3VlcyB0aGF0IGV4dGVuZCBiZXlvbmQgZW5kIG9mIHNlZ21lbnRcbiAgICAgICAgY29uc3QgY3VyU05JZHggPSBmb3VuZEZyYWcuc24gLSB0cmFja0RldGFpbHMuc3RhcnRTTjtcbiAgICAgICAgY29uc3QgcHJldkZyYWcgPSBmcmFnbWVudHNbY3VyU05JZHggLSAxXTtcbiAgICAgICAgaWYgKHByZXZGcmFnICYmIHByZXZGcmFnLmNjID09PSBmb3VuZEZyYWcuY2MgJiYgdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUocHJldkZyYWcpID09PSBGcmFnbWVudFN0YXRlLk5PVF9MT0FERUQpIHtcbiAgICAgICAgICBmb3VuZEZyYWcgPSBwcmV2RnJhZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKGZvdW5kRnJhZykgPT09IEZyYWdtZW50U3RhdGUuTk9UX0xPQURFRCkge1xuICAgICAgICAvLyBvbmx5IGxvYWQgaWYgZnJhZ21lbnQgaXMgbm90IGxvYWRlZFxuICAgICAgICB0aGlzLmxvYWRGcmFnbWVudChmb3VuZEZyYWcsIHRyYWNrLCB0YXJnZXRCdWZmZXJUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0TWF4QnVmZmVyTGVuZ3RoKG1haW5CdWZmZXJMZW5ndGgpIHtcbiAgICBjb25zdCBtYXhDb25maWdCdWZmZXIgPSBzdXBlci5nZXRNYXhCdWZmZXJMZW5ndGgoKTtcbiAgICBpZiAoIW1haW5CdWZmZXJMZW5ndGgpIHtcbiAgICAgIHJldHVybiBtYXhDb25maWdCdWZmZXI7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLm1heChtYXhDb25maWdCdWZmZXIsIG1haW5CdWZmZXJMZW5ndGgpO1xuICB9XG4gIGxvYWRGcmFnbWVudChmcmFnLCBsZXZlbCwgdGFyZ2V0QnVmZmVyVGltZSkge1xuICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBmcmFnO1xuICAgIGlmIChmcmFnLnNuID09PSAnaW5pdFNlZ21lbnQnKSB7XG4gICAgICB0aGlzLl9sb2FkSW5pdFNlZ21lbnQoZnJhZywgbGV2ZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IHRydWU7XG4gICAgICBzdXBlci5sb2FkRnJhZ21lbnQoZnJhZywgbGV2ZWwsIHRhcmdldEJ1ZmZlclRpbWUpO1xuICAgIH1cbiAgfVxuICBnZXQgbWVkaWFCdWZmZXJUaW1lUmFuZ2VzKCkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyYWJsZUluc3RhbmNlKHRoaXMudHJhY2tzQnVmZmVyZWRbdGhpcy5jdXJyZW50VHJhY2tJZF0gfHwgW10pO1xuICB9XG59XG5jbGFzcyBCdWZmZXJhYmxlSW5zdGFuY2Uge1xuICBjb25zdHJ1Y3Rvcih0aW1lcmFuZ2VzKSB7XG4gICAgdGhpcy5idWZmZXJlZCA9IHZvaWQgMDtcbiAgICBjb25zdCBnZXRSYW5nZSA9IChuYW1lLCBpbmRleCwgbGVuZ3RoKSA9PiB7XG4gICAgICBpbmRleCA9IGluZGV4ID4+PiAwO1xuICAgICAgaWYgKGluZGV4ID4gbGVuZ3RoIC0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKGBGYWlsZWQgdG8gZXhlY3V0ZSAnJHtuYW1lfScgb24gJ1RpbWVSYW5nZXMnOiBUaGUgaW5kZXggcHJvdmlkZWQgKCR7aW5kZXh9KSBpcyBncmVhdGVyIHRoYW4gdGhlIG1heGltdW0gYm91bmQgKCR7bGVuZ3RofSlgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aW1lcmFuZ2VzW2luZGV4XVtuYW1lXTtcbiAgICB9O1xuICAgIHRoaXMuYnVmZmVyZWQgPSB7XG4gICAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGltZXJhbmdlcy5sZW5ndGg7XG4gICAgICB9LFxuICAgICAgZW5kKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBnZXRSYW5nZSgnZW5kJywgaW5kZXgsIHRpbWVyYW5nZXMubGVuZ3RoKTtcbiAgICAgIH0sXG4gICAgICBzdGFydChpbmRleCkge1xuICAgICAgICByZXR1cm4gZ2V0UmFuZ2UoJ3N0YXJ0JywgaW5kZXgsIHRpbWVyYW5nZXMubGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5cbmNsYXNzIFN1YnRpdGxlVHJhY2tDb250cm9sbGVyIGV4dGVuZHMgQmFzZVBsYXlsaXN0Q29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHN1cGVyKGhscywgJ1tzdWJ0aXRsZS10cmFjay1jb250cm9sbGVyXScpO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIHRoaXMudHJhY2tzID0gW107XG4gICAgdGhpcy5ncm91cElkcyA9IG51bGw7XG4gICAgdGhpcy50cmFja3NJbkdyb3VwID0gW107XG4gICAgdGhpcy50cmFja0lkID0gLTE7XG4gICAgdGhpcy5jdXJyZW50VHJhY2sgPSBudWxsO1xuICAgIHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrID0gdHJ1ZTtcbiAgICB0aGlzLnF1ZXVlZERlZmF1bHRUcmFjayA9IC0xO1xuICAgIHRoaXMuYXN5bmNQb2xsVHJhY2tDaGFuZ2UgPSAoKSA9PiB0aGlzLnBvbGxUcmFja0NoYW5nZSgwKTtcbiAgICB0aGlzLnVzZVRleHRUcmFja1BvbGxpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnN1YnRpdGxlUG9sbGluZ0ludGVydmFsID0gLTE7XG4gICAgdGhpcy5fc3VidGl0bGVEaXNwbGF5ID0gdHJ1ZTtcbiAgICB0aGlzLm9uVGV4dFRyYWNrc0NoYW5nZWQgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMudXNlVGV4dFRyYWNrUG9sbGluZykge1xuICAgICAgICBzZWxmLmNsZWFySW50ZXJ2YWwodGhpcy5zdWJ0aXRsZVBvbGxpbmdJbnRlcnZhbCk7XG4gICAgICB9XG4gICAgICAvLyBNZWRpYSBpcyB1bmRlZmluZWQgd2hlbiBzd2l0Y2hpbmcgc3RyZWFtcyB2aWEgbG9hZFNvdXJjZSgpXG4gICAgICBpZiAoIXRoaXMubWVkaWEgfHwgIXRoaXMuaGxzLmNvbmZpZy5yZW5kZXJUZXh0VHJhY2tzTmF0aXZlbHkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHRleHRUcmFjayA9IG51bGw7XG4gICAgICBjb25zdCB0cmFja3MgPSBmaWx0ZXJTdWJ0aXRsZVRyYWNrcyh0aGlzLm1lZGlhLnRleHRUcmFja3MpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRyYWNrc1tpXS5tb2RlID09PSAnaGlkZGVuJykge1xuICAgICAgICAgIC8vIERvIG5vdCBicmVhayBpbiBjYXNlIHRoZXJlIGlzIGEgZm9sbG93aW5nIHRyYWNrIHdpdGggc2hvd2luZy5cbiAgICAgICAgICB0ZXh0VHJhY2sgPSB0cmFja3NbaV07XG4gICAgICAgIH0gZWxzZSBpZiAodHJhY2tzW2ldLm1vZGUgPT09ICdzaG93aW5nJykge1xuICAgICAgICAgIHRleHRUcmFjayA9IHRyYWNrc1tpXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBGaW5kIGludGVybmFsIHRyYWNrIGluZGV4IGZvciBUZXh0VHJhY2tcbiAgICAgIGNvbnN0IHRyYWNrSWQgPSB0aGlzLmZpbmRUcmFja0ZvclRleHRUcmFjayh0ZXh0VHJhY2spO1xuICAgICAgaWYgKHRoaXMuc3VidGl0bGVUcmFjayAhPT0gdHJhY2tJZCkge1xuICAgICAgICB0aGlzLnNldFN1YnRpdGxlVHJhY2sodHJhY2tJZCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLnRyYWNrcy5sZW5ndGggPSAwO1xuICAgIHRoaXMudHJhY2tzSW5Hcm91cC5sZW5ndGggPSAwO1xuICAgIHRoaXMuY3VycmVudFRyYWNrID0gbnVsbDtcbiAgICB0aGlzLm9uVGV4dFRyYWNrc0NoYW5nZWQgPSB0aGlzLmFzeW5jUG9sbFRyYWNrQ2hhbmdlID0gbnVsbDtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gIH1cbiAgZ2V0IHN1YnRpdGxlRGlzcGxheSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3VidGl0bGVEaXNwbGF5O1xuICB9XG4gIHNldCBzdWJ0aXRsZURpc3BsYXkodmFsdWUpIHtcbiAgICB0aGlzLl9zdWJ0aXRsZURpc3BsYXkgPSB2YWx1ZTtcbiAgICBpZiAodGhpcy50cmFja0lkID4gLTEpIHtcbiAgICAgIHRoaXMudG9nZ2xlVHJhY2tNb2RlcygpO1xuICAgIH1cbiAgfVxuICByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub24oRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMX0xPQURJTkcsIHRoaXMub25MZXZlbExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxfU1dJVENISU5HLCB0aGlzLm9uTGV2ZWxTd2l0Y2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuU1VCVElUTEVfVFJBQ0tfTE9BREVELCB0aGlzLm9uU3VidGl0bGVUcmFja0xvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfVxuICB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTF9MT0FESU5HLCB0aGlzLm9uTGV2ZWxMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTF9TV0lUQ0hJTkcsIHRoaXMub25MZXZlbFN3aXRjaGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuU1VCVElUTEVfVFJBQ0tfTE9BREVELCB0aGlzLm9uU3VidGl0bGVUcmFja0xvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gIH1cblxuICAvLyBMaXN0ZW4gZm9yIHN1YnRpdGxlIHRyYWNrIGNoYW5nZSwgdGhlbiBleHRyYWN0IHRoZSBjdXJyZW50IHRyYWNrIElELlxuICBvbk1lZGlhQXR0YWNoZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLm1lZGlhID0gZGF0YS5tZWRpYTtcbiAgICBpZiAoIXRoaXMubWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMucXVldWVkRGVmYXVsdFRyYWNrID4gLTEpIHtcbiAgICAgIHRoaXMuc3VidGl0bGVUcmFjayA9IHRoaXMucXVldWVkRGVmYXVsdFRyYWNrO1xuICAgICAgdGhpcy5xdWV1ZWREZWZhdWx0VHJhY2sgPSAtMTtcbiAgICB9XG4gICAgdGhpcy51c2VUZXh0VHJhY2tQb2xsaW5nID0gISh0aGlzLm1lZGlhLnRleHRUcmFja3MgJiYgJ29uY2hhbmdlJyBpbiB0aGlzLm1lZGlhLnRleHRUcmFja3MpO1xuICAgIGlmICh0aGlzLnVzZVRleHRUcmFja1BvbGxpbmcpIHtcbiAgICAgIHRoaXMucG9sbFRyYWNrQ2hhbmdlKDUwMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWVkaWEudGV4dFRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLmFzeW5jUG9sbFRyYWNrQ2hhbmdlKTtcbiAgICB9XG4gIH1cbiAgcG9sbFRyYWNrQ2hhbmdlKHRpbWVvdXQpIHtcbiAgICBzZWxmLmNsZWFySW50ZXJ2YWwodGhpcy5zdWJ0aXRsZVBvbGxpbmdJbnRlcnZhbCk7XG4gICAgdGhpcy5zdWJ0aXRsZVBvbGxpbmdJbnRlcnZhbCA9IHNlbGYuc2V0SW50ZXJ2YWwodGhpcy5vblRleHRUcmFja3NDaGFuZ2VkLCB0aW1lb3V0KTtcbiAgfVxuICBvbk1lZGlhRGV0YWNoaW5nKCkge1xuICAgIGlmICghdGhpcy5tZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZWxmLmNsZWFySW50ZXJ2YWwodGhpcy5zdWJ0aXRsZVBvbGxpbmdJbnRlcnZhbCk7XG4gICAgaWYgKCF0aGlzLnVzZVRleHRUcmFja1BvbGxpbmcpIHtcbiAgICAgIHRoaXMubWVkaWEudGV4dFRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLmFzeW5jUG9sbFRyYWNrQ2hhbmdlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudHJhY2tJZCA+IC0xKSB7XG4gICAgICB0aGlzLnF1ZXVlZERlZmF1bHRUcmFjayA9IHRoaXMudHJhY2tJZDtcbiAgICB9XG4gICAgY29uc3QgdGV4dFRyYWNrcyA9IGZpbHRlclN1YnRpdGxlVHJhY2tzKHRoaXMubWVkaWEudGV4dFRyYWNrcyk7XG4gICAgLy8gQ2xlYXIgbG9hZGVkIGN1ZXMgb24gbWVkaWEgZGV0YWNobWVudCBmcm9tIHRyYWNrc1xuICAgIHRleHRUcmFja3MuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICBjbGVhckN1cnJlbnRDdWVzKHRyYWNrKTtcbiAgICB9KTtcbiAgICAvLyBEaXNhYmxlIGFsbCBzdWJ0aXRsZSB0cmFja3MgYmVmb3JlIGRldGFjaG1lbnQgc28gd2hlbiByZWF0dGFjaGVkIG9ubHkgdHJhY2tzIGluIHRoYXQgY29udGVudCBhcmUgZW5hYmxlZC5cbiAgICB0aGlzLnN1YnRpdGxlVHJhY2sgPSAtMTtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgfVxuICBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICB0aGlzLnRyYWNrcyA9IFtdO1xuICAgIHRoaXMuZ3JvdXBJZHMgPSBudWxsO1xuICAgIHRoaXMudHJhY2tzSW5Hcm91cCA9IFtdO1xuICAgIHRoaXMudHJhY2tJZCA9IC0xO1xuICAgIHRoaXMuY3VycmVudFRyYWNrID0gbnVsbDtcbiAgICB0aGlzLnNlbGVjdERlZmF1bHRUcmFjayA9IHRydWU7XG4gIH1cblxuICAvLyBGaXJlZCB3aGVuZXZlciBhIG5ldyBtYW5pZmVzdCBpcyBsb2FkZWQuXG4gIG9uTWFuaWZlc3RQYXJzZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLnRyYWNrcyA9IGRhdGEuc3VidGl0bGVUcmFja3M7XG4gIH1cbiAgb25TdWJ0aXRsZVRyYWNrTG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgaWQsXG4gICAgICBncm91cElkLFxuICAgICAgZGV0YWlsc1xuICAgIH0gPSBkYXRhO1xuICAgIGNvbnN0IHRyYWNrSW5BY3RpdmVHcm91cCA9IHRoaXMudHJhY2tzSW5Hcm91cFtpZF07XG4gICAgaWYgKCF0cmFja0luQWN0aXZlR3JvdXAgfHwgdHJhY2tJbkFjdGl2ZUdyb3VwLmdyb3VwSWQgIT09IGdyb3VwSWQpIHtcbiAgICAgIHRoaXMud2FybihgU3VidGl0bGUgdHJhY2sgd2l0aCBpZDoke2lkfSBhbmQgZ3JvdXA6JHtncm91cElkfSBub3QgZm91bmQgaW4gYWN0aXZlIGdyb3VwICR7dHJhY2tJbkFjdGl2ZUdyb3VwID09IG51bGwgPyB2b2lkIDAgOiB0cmFja0luQWN0aXZlR3JvdXAuZ3JvdXBJZH1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VyRGV0YWlscyA9IHRyYWNrSW5BY3RpdmVHcm91cC5kZXRhaWxzO1xuICAgIHRyYWNrSW5BY3RpdmVHcm91cC5kZXRhaWxzID0gZGF0YS5kZXRhaWxzO1xuICAgIHRoaXMubG9nKGBTdWJ0aXRsZSB0cmFjayAke2lkfSBcIiR7dHJhY2tJbkFjdGl2ZUdyb3VwLm5hbWV9XCIgbGFuZzoke3RyYWNrSW5BY3RpdmVHcm91cC5sYW5nfSBncm91cDoke2dyb3VwSWR9IGxvYWRlZCBbJHtkZXRhaWxzLnN0YXJ0U059LSR7ZGV0YWlscy5lbmRTTn1dYCk7XG4gICAgaWYgKGlkID09PSB0aGlzLnRyYWNrSWQpIHtcbiAgICAgIHRoaXMucGxheWxpc3RMb2FkZWQoaWQsIGRhdGEsIGN1ckRldGFpbHMpO1xuICAgIH1cbiAgfVxuICBvbkxldmVsTG9hZGluZyhldmVudCwgZGF0YSkge1xuICAgIHRoaXMuc3dpdGNoTGV2ZWwoZGF0YS5sZXZlbCk7XG4gIH1cbiAgb25MZXZlbFN3aXRjaGluZyhldmVudCwgZGF0YSkge1xuICAgIHRoaXMuc3dpdGNoTGV2ZWwoZGF0YS5sZXZlbCk7XG4gIH1cbiAgc3dpdGNoTGV2ZWwobGV2ZWxJbmRleCkge1xuICAgIGNvbnN0IGxldmVsSW5mbyA9IHRoaXMuaGxzLmxldmVsc1tsZXZlbEluZGV4XTtcbiAgICBpZiAoIWxldmVsSW5mbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdWJ0aXRsZUdyb3VwcyA9IGxldmVsSW5mby5zdWJ0aXRsZUdyb3VwcyB8fCBudWxsO1xuICAgIGNvbnN0IGN1cnJlbnRHcm91cHMgPSB0aGlzLmdyb3VwSWRzO1xuICAgIGxldCBjdXJyZW50VHJhY2sgPSB0aGlzLmN1cnJlbnRUcmFjaztcbiAgICBpZiAoIXN1YnRpdGxlR3JvdXBzIHx8IChjdXJyZW50R3JvdXBzID09IG51bGwgPyB2b2lkIDAgOiBjdXJyZW50R3JvdXBzLmxlbmd0aCkgIT09IChzdWJ0aXRsZUdyb3VwcyA9PSBudWxsID8gdm9pZCAwIDogc3VidGl0bGVHcm91cHMubGVuZ3RoKSB8fCBzdWJ0aXRsZUdyb3VwcyAhPSBudWxsICYmIHN1YnRpdGxlR3JvdXBzLnNvbWUoZ3JvdXBJZCA9PiAoY3VycmVudEdyb3VwcyA9PSBudWxsID8gdm9pZCAwIDogY3VycmVudEdyb3Vwcy5pbmRleE9mKGdyb3VwSWQpKSA9PT0gLTEpKSB7XG4gICAgICB0aGlzLmdyb3VwSWRzID0gc3VidGl0bGVHcm91cHM7XG4gICAgICB0aGlzLnRyYWNrSWQgPSAtMTtcbiAgICAgIHRoaXMuY3VycmVudFRyYWNrID0gbnVsbDtcbiAgICAgIGNvbnN0IHN1YnRpdGxlVHJhY2tzID0gdGhpcy50cmFja3MuZmlsdGVyKHRyYWNrID0+ICFzdWJ0aXRsZUdyb3VwcyB8fCBzdWJ0aXRsZUdyb3Vwcy5pbmRleE9mKHRyYWNrLmdyb3VwSWQpICE9PSAtMSk7XG4gICAgICBpZiAoc3VidGl0bGVUcmFja3MubGVuZ3RoKSB7XG4gICAgICAgIC8vIERpc2FibGUgc2VsZWN0RGVmYXVsdFRyYWNrIGlmIHRoZXJlIGFyZSBubyBkZWZhdWx0IHRyYWNrc1xuICAgICAgICBpZiAodGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgJiYgIXN1YnRpdGxlVHJhY2tzLnNvbWUodHJhY2sgPT4gdHJhY2suZGVmYXVsdCkpIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdERlZmF1bHRUcmFjayA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRyYWNrLmlkIHNob3VsZCBtYXRjaCBobHMuYXVkaW9UcmFja3MgaW5kZXhcbiAgICAgICAgc3VidGl0bGVUcmFja3MuZm9yRWFjaCgodHJhY2ssIGkpID0+IHtcbiAgICAgICAgICB0cmFjay5pZCA9IGk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICghY3VycmVudFRyYWNrICYmICF0aGlzLnRyYWNrc0luR3JvdXAubGVuZ3RoKSB7XG4gICAgICAgIC8vIERvIG5vdCBkaXNwYXRjaCBTVUJUSVRMRV9UUkFDS1NfVVBEQVRFRCB3aGVuIHRoZXJlIHdlcmUgYW5kIGFyZSBubyB0cmFja3NcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy50cmFja3NJbkdyb3VwID0gc3VidGl0bGVUcmFja3M7XG5cbiAgICAgIC8vIEZpbmQgcHJlZmVycmVkIHRyYWNrXG4gICAgICBjb25zdCBzdWJ0aXRsZVByZWZlcmVuY2UgPSB0aGlzLmhscy5jb25maWcuc3VidGl0bGVQcmVmZXJlbmNlO1xuICAgICAgaWYgKCFjdXJyZW50VHJhY2sgJiYgc3VidGl0bGVQcmVmZXJlbmNlKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGdyb3VwSW5kZXggPSBmaW5kTWF0Y2hpbmdPcHRpb24oc3VidGl0bGVQcmVmZXJlbmNlLCBzdWJ0aXRsZVRyYWNrcyk7XG4gICAgICAgIGlmIChncm91cEluZGV4ID4gLTEpIHtcbiAgICAgICAgICBjdXJyZW50VHJhY2sgPSBzdWJ0aXRsZVRyYWNrc1tncm91cEluZGV4XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBhbGxJbmRleCA9IGZpbmRNYXRjaGluZ09wdGlvbihzdWJ0aXRsZVByZWZlcmVuY2UsIHRoaXMudHJhY2tzKTtcbiAgICAgICAgICBjdXJyZW50VHJhY2sgPSB0aGlzLnRyYWNrc1thbGxJbmRleF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gU2VsZWN0IGluaXRpYWwgdHJhY2tcbiAgICAgIGxldCB0cmFja0lkID0gdGhpcy5maW5kVHJhY2tJZChjdXJyZW50VHJhY2spO1xuICAgICAgaWYgKHRyYWNrSWQgPT09IC0xICYmIGN1cnJlbnRUcmFjaykge1xuICAgICAgICB0cmFja0lkID0gdGhpcy5maW5kVHJhY2tJZChudWxsKTtcbiAgICAgIH1cblxuICAgICAgLy8gRGlzcGF0Y2ggZXZlbnRzIGFuZCBsb2FkIHRyYWNrIGlmIG5lZWRlZFxuICAgICAgY29uc3Qgc3VidGl0bGVUcmFja3NVcGRhdGVkID0ge1xuICAgICAgICBzdWJ0aXRsZVRyYWNrc1xuICAgICAgfTtcbiAgICAgIHRoaXMubG9nKGBVcGRhdGluZyBzdWJ0aXRsZSB0cmFja3MsICR7c3VidGl0bGVUcmFja3MubGVuZ3RofSB0cmFjayhzKSBmb3VuZCBpbiBcIiR7c3VidGl0bGVHcm91cHMgPT0gbnVsbCA/IHZvaWQgMCA6IHN1YnRpdGxlR3JvdXBzLmpvaW4oJywnKX1cIiBncm91cC1pZGApO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuU1VCVElUTEVfVFJBQ0tTX1VQREFURUQsIHN1YnRpdGxlVHJhY2tzVXBkYXRlZCk7XG4gICAgICBpZiAodHJhY2tJZCAhPT0gLTEgJiYgdGhpcy50cmFja0lkID09PSAtMSkge1xuICAgICAgICB0aGlzLnNldFN1YnRpdGxlVHJhY2sodHJhY2tJZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLnNob3VsZFJlbG9hZFBsYXlsaXN0KGN1cnJlbnRUcmFjaykpIHtcbiAgICAgIC8vIFJldHJ5IHBsYXlsaXN0IGxvYWRpbmcgaWYgbm8gcGxheWxpc3QgaXMgb3IgaGFzIGJlZW4gbG9hZGVkIHlldFxuICAgICAgdGhpcy5zZXRTdWJ0aXRsZVRyYWNrKHRoaXMudHJhY2tJZCk7XG4gICAgfVxuICB9XG4gIGZpbmRUcmFja0lkKGN1cnJlbnRUcmFjaykge1xuICAgIGNvbnN0IHRyYWNrcyA9IHRoaXMudHJhY2tzSW5Hcm91cDtcbiAgICBjb25zdCBzZWxlY3REZWZhdWx0ID0gdGhpcy5zZWxlY3REZWZhdWx0VHJhY2s7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHRyYWNrID0gdHJhY2tzW2ldO1xuICAgICAgaWYgKHNlbGVjdERlZmF1bHQgJiYgIXRyYWNrLmRlZmF1bHQgfHwgIXNlbGVjdERlZmF1bHQgJiYgIWN1cnJlbnRUcmFjaykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghY3VycmVudFRyYWNrIHx8IG1hdGNoZXNPcHRpb24odHJhY2ssIGN1cnJlbnRUcmFjaykpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjdXJyZW50VHJhY2spIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHRyYWNrID0gdHJhY2tzW2ldO1xuICAgICAgICBpZiAobWVkaWFBdHRyaWJ1dGVzSWRlbnRpY2FsKGN1cnJlbnRUcmFjay5hdHRycywgdHJhY2suYXR0cnMsIFsnTEFOR1VBR0UnLCAnQVNTT0MtTEFOR1VBR0UnLCAnQ0hBUkFDVEVSSVNUSUNTJ10pKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHRyYWNrID0gdHJhY2tzW2ldO1xuICAgICAgICBpZiAobWVkaWFBdHRyaWJ1dGVzSWRlbnRpY2FsKGN1cnJlbnRUcmFjay5hdHRycywgdHJhY2suYXR0cnMsIFsnTEFOR1VBR0UnXSkpIHtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgZmluZFRyYWNrRm9yVGV4dFRyYWNrKHRleHRUcmFjaykge1xuICAgIGlmICh0ZXh0VHJhY2spIHtcbiAgICAgIGNvbnN0IHRyYWNrcyA9IHRoaXMudHJhY2tzSW5Hcm91cDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHRyYWNrID0gdHJhY2tzW2ldO1xuICAgICAgICBpZiAoc3VidGl0bGVUcmFja01hdGNoZXNUZXh0VHJhY2sodHJhY2ssIHRleHRUcmFjaykpIHtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgb25FcnJvcihldmVudCwgZGF0YSkge1xuICAgIGlmIChkYXRhLmZhdGFsIHx8ICFkYXRhLmNvbnRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRhdGEuY29udGV4dC50eXBlID09PSBQbGF5bGlzdENvbnRleHRUeXBlLlNVQlRJVExFX1RSQUNLICYmIGRhdGEuY29udGV4dC5pZCA9PT0gdGhpcy50cmFja0lkICYmICghdGhpcy5ncm91cElkcyB8fCB0aGlzLmdyb3VwSWRzLmluZGV4T2YoZGF0YS5jb250ZXh0Lmdyb3VwSWQpICE9PSAtMSkpIHtcbiAgICAgIHRoaXMuY2hlY2tSZXRyeShkYXRhKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGFsbFN1YnRpdGxlVHJhY2tzKCkge1xuICAgIHJldHVybiB0aGlzLnRyYWNrcztcbiAgfVxuXG4gIC8qKiBnZXQgYWx0ZXJuYXRlIHN1YnRpdGxlIHRyYWNrcyBsaXN0IGZyb20gcGxheWxpc3QgKiovXG4gIGdldCBzdWJ0aXRsZVRyYWNrcygpIHtcbiAgICByZXR1cm4gdGhpcy50cmFja3NJbkdyb3VwO1xuICB9XG5cbiAgLyoqIGdldC9zZXQgaW5kZXggb2YgdGhlIHNlbGVjdGVkIHN1YnRpdGxlIHRyYWNrIChiYXNlZCBvbiBpbmRleCBpbiBzdWJ0aXRsZSB0cmFjayBsaXN0cykgKiovXG4gIGdldCBzdWJ0aXRsZVRyYWNrKCkge1xuICAgIHJldHVybiB0aGlzLnRyYWNrSWQ7XG4gIH1cbiAgc2V0IHN1YnRpdGxlVHJhY2sobmV3SWQpIHtcbiAgICB0aGlzLnNlbGVjdERlZmF1bHRUcmFjayA9IGZhbHNlO1xuICAgIHRoaXMuc2V0U3VidGl0bGVUcmFjayhuZXdJZCk7XG4gIH1cbiAgc2V0U3VidGl0bGVPcHRpb24oc3VidGl0bGVPcHRpb24pIHtcbiAgICB0aGlzLmhscy5jb25maWcuc3VidGl0bGVQcmVmZXJlbmNlID0gc3VidGl0bGVPcHRpb247XG4gICAgaWYgKHN1YnRpdGxlT3B0aW9uKSB7XG4gICAgICBjb25zdCBhbGxTdWJ0aXRsZVRyYWNrcyA9IHRoaXMuYWxsU3VidGl0bGVUcmFja3M7XG4gICAgICB0aGlzLnNlbGVjdERlZmF1bHRUcmFjayA9IGZhbHNlO1xuICAgICAgaWYgKGFsbFN1YnRpdGxlVHJhY2tzLmxlbmd0aCkge1xuICAgICAgICAvLyBGaXJzdCBzZWUgaWYgY3VycmVudCBvcHRpb24gbWF0Y2hlcyAobm8gc3dpdGNoIG9wKVxuICAgICAgICBjb25zdCBjdXJyZW50VHJhY2sgPSB0aGlzLmN1cnJlbnRUcmFjaztcbiAgICAgICAgaWYgKGN1cnJlbnRUcmFjayAmJiBtYXRjaGVzT3B0aW9uKHN1YnRpdGxlT3B0aW9uLCBjdXJyZW50VHJhY2spKSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRUcmFjaztcbiAgICAgICAgfVxuICAgICAgICAvLyBGaW5kIG9wdGlvbiBpbiBjdXJyZW50IGdyb3VwXG4gICAgICAgIGNvbnN0IGdyb3VwSW5kZXggPSBmaW5kTWF0Y2hpbmdPcHRpb24oc3VidGl0bGVPcHRpb24sIHRoaXMudHJhY2tzSW5Hcm91cCk7XG4gICAgICAgIGlmIChncm91cEluZGV4ID4gLTEpIHtcbiAgICAgICAgICBjb25zdCB0cmFjayA9IHRoaXMudHJhY2tzSW5Hcm91cFtncm91cEluZGV4XTtcbiAgICAgICAgICB0aGlzLnNldFN1YnRpdGxlVHJhY2soZ3JvdXBJbmRleCk7XG4gICAgICAgICAgcmV0dXJuIHRyYWNrO1xuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRUcmFjaykge1xuICAgICAgICAgIC8vIElmIHRoaXMgaXMgbm90IHRoZSBpbml0aWFsIHNlbGVjdGlvbiByZXR1cm4gbnVsbFxuICAgICAgICAgIC8vIG9wdGlvbiBzaG91bGQgaGF2ZSBtYXRjaGVkIG9uZSBpbiBhY3RpdmUgZ3JvdXBcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBGaW5kIHRoZSBvcHRpb24gaW4gYWxsIHRyYWNrcyBmb3IgaW5pdGlhbCBzZWxlY3Rpb25cbiAgICAgICAgICBjb25zdCBhbGxJbmRleCA9IGZpbmRNYXRjaGluZ09wdGlvbihzdWJ0aXRsZU9wdGlvbiwgYWxsU3VidGl0bGVUcmFja3MpO1xuICAgICAgICAgIGlmIChhbGxJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gYWxsU3VidGl0bGVUcmFja3NbYWxsSW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBsb2FkUGxheWxpc3QoaGxzVXJsUGFyYW1ldGVycykge1xuICAgIHN1cGVyLmxvYWRQbGF5bGlzdCgpO1xuICAgIGNvbnN0IGN1cnJlbnRUcmFjayA9IHRoaXMuY3VycmVudFRyYWNrO1xuICAgIGlmICh0aGlzLnNob3VsZExvYWRQbGF5bGlzdChjdXJyZW50VHJhY2spICYmIGN1cnJlbnRUcmFjaykge1xuICAgICAgY29uc3QgaWQgPSBjdXJyZW50VHJhY2suaWQ7XG4gICAgICBjb25zdCBncm91cElkID0gY3VycmVudFRyYWNrLmdyb3VwSWQ7XG4gICAgICBsZXQgdXJsID0gY3VycmVudFRyYWNrLnVybDtcbiAgICAgIGlmIChobHNVcmxQYXJhbWV0ZXJzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdXJsID0gaGxzVXJsUGFyYW1ldGVycy5hZGREaXJlY3RpdmVzKHVybCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdGhpcy53YXJuKGBDb3VsZCBub3QgY29uc3RydWN0IG5ldyBVUkwgd2l0aCBITFMgRGVsaXZlcnkgRGlyZWN0aXZlczogJHtlcnJvcn1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5sb2coYExvYWRpbmcgc3VidGl0bGUgcGxheWxpc3QgZm9yIGlkICR7aWR9YCk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5TVUJUSVRMRV9UUkFDS19MT0FESU5HLCB7XG4gICAgICAgIHVybCxcbiAgICAgICAgaWQsXG4gICAgICAgIGdyb3VwSWQsXG4gICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlczogaGxzVXJsUGFyYW1ldGVycyB8fCBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGlzYWJsZXMgdGhlIG9sZCBzdWJ0aXRsZVRyYWNrIGFuZCBzZXRzIGN1cnJlbnQgbW9kZSBvbiB0aGUgbmV4dCBzdWJ0aXRsZVRyYWNrLlxuICAgKiBUaGlzIG9wZXJhdGVzIG9uIHRoZSBET00gdGV4dFRyYWNrcy5cbiAgICogQSB2YWx1ZSBvZiAtMSB3aWxsIGRpc2FibGUgYWxsIHN1YnRpdGxlIHRyYWNrcy5cbiAgICovXG4gIHRvZ2dsZVRyYWNrTW9kZXMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgbWVkaWFcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIW1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRleHRUcmFja3MgPSBmaWx0ZXJTdWJ0aXRsZVRyYWNrcyhtZWRpYS50ZXh0VHJhY2tzKTtcbiAgICBjb25zdCBjdXJyZW50VHJhY2sgPSB0aGlzLmN1cnJlbnRUcmFjaztcbiAgICBsZXQgbmV4dFRyYWNrO1xuICAgIGlmIChjdXJyZW50VHJhY2spIHtcbiAgICAgIG5leHRUcmFjayA9IHRleHRUcmFja3MuZmlsdGVyKHRleHRUcmFjayA9PiBzdWJ0aXRsZVRyYWNrTWF0Y2hlc1RleHRUcmFjayhjdXJyZW50VHJhY2ssIHRleHRUcmFjaykpWzBdO1xuICAgICAgaWYgKCFuZXh0VHJhY2spIHtcbiAgICAgICAgdGhpcy53YXJuKGBVbmFibGUgdG8gZmluZCBzdWJ0aXRsZSBUZXh0VHJhY2sgd2l0aCBuYW1lIFwiJHtjdXJyZW50VHJhY2submFtZX1cIiBhbmQgbGFuZ3VhZ2UgXCIke2N1cnJlbnRUcmFjay5sYW5nfVwiYCk7XG4gICAgICB9XG4gICAgfVxuICAgIFtdLnNsaWNlLmNhbGwodGV4dFRyYWNrcykuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICBpZiAodHJhY2subW9kZSAhPT0gJ2Rpc2FibGVkJyAmJiB0cmFjayAhPT0gbmV4dFRyYWNrKSB7XG4gICAgICAgIHRyYWNrLm1vZGUgPSAnZGlzYWJsZWQnO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChuZXh0VHJhY2spIHtcbiAgICAgIGNvbnN0IG1vZGUgPSB0aGlzLnN1YnRpdGxlRGlzcGxheSA/ICdzaG93aW5nJyA6ICdoaWRkZW4nO1xuICAgICAgaWYgKG5leHRUcmFjay5tb2RlICE9PSBtb2RlKSB7XG4gICAgICAgIG5leHRUcmFjay5tb2RlID0gbW9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgaXMgcmVzcG9uc2libGUgZm9yIHZhbGlkYXRpbmcgdGhlIHN1YnRpdGxlIGluZGV4IGFuZCBwZXJpb2RpY2FsbHkgcmVsb2FkaW5nIGlmIGxpdmUuXG4gICAqIERpc3BhdGNoZXMgdGhlIFNVQlRJVExFX1RSQUNLX1NXSVRDSCBldmVudCwgd2hpY2ggaW5zdHJ1Y3RzIHRoZSBzdWJ0aXRsZS1zdHJlYW0tY29udHJvbGxlciB0byBsb2FkIHRoZSBzZWxlY3RlZCB0cmFjay5cbiAgICovXG4gIHNldFN1YnRpdGxlVHJhY2sobmV3SWQpIHtcbiAgICBjb25zdCB0cmFja3MgPSB0aGlzLnRyYWNrc0luR3JvdXA7XG5cbiAgICAvLyBzZXR0aW5nIHRoaXMuc3VidGl0bGVUcmFjayB3aWxsIHRyaWdnZXIgaW50ZXJuYWwgbG9naWNcbiAgICAvLyBpZiBtZWRpYSBoYXMgbm90IGJlZW4gYXR0YWNoZWQgeWV0LCBpdCB3aWxsIGZhaWxcbiAgICAvLyB3ZSBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBkZWZhdWx0IHRyYWNrIGlkXG4gICAgLy8gYW5kIHdlJ2xsIHNldCBzdWJ0aXRsZVRyYWNrIHdoZW4gb25NZWRpYUF0dGFjaGVkIGlzIHRyaWdnZXJlZFxuICAgIGlmICghdGhpcy5tZWRpYSkge1xuICAgICAgdGhpcy5xdWV1ZWREZWZhdWx0VHJhY2sgPSBuZXdJZDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBleGl0IGlmIHRyYWNrIGlkIGFzIGFscmVhZHkgc2V0IG9yIGludmFsaWRcbiAgICBpZiAobmV3SWQgPCAtMSB8fCBuZXdJZCA+PSB0cmFja3MubGVuZ3RoIHx8ICFpc0Zpbml0ZU51bWJlcihuZXdJZCkpIHtcbiAgICAgIHRoaXMud2FybihgSW52YWxpZCBzdWJ0aXRsZSB0cmFjayBpZDogJHtuZXdJZH1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBzdG9wcGluZyBsaXZlIHJlbG9hZGluZyB0aW1lciBpZiBhbnlcbiAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICB0aGlzLnNlbGVjdERlZmF1bHRUcmFjayA9IGZhbHNlO1xuICAgIGNvbnN0IGxhc3RUcmFjayA9IHRoaXMuY3VycmVudFRyYWNrO1xuICAgIGNvbnN0IHRyYWNrID0gdHJhY2tzW25ld0lkXSB8fCBudWxsO1xuICAgIHRoaXMudHJhY2tJZCA9IG5ld0lkO1xuICAgIHRoaXMuY3VycmVudFRyYWNrID0gdHJhY2s7XG4gICAgdGhpcy50b2dnbGVUcmFja01vZGVzKCk7XG4gICAgaWYgKCF0cmFjaykge1xuICAgICAgLy8gc3dpdGNoIHRvIC0xXG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5TVUJUSVRMRV9UUkFDS19TV0lUQ0gsIHtcbiAgICAgICAgaWQ6IG5ld0lkXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdHJhY2tMb2FkZWQgPSAhIXRyYWNrLmRldGFpbHMgJiYgIXRyYWNrLmRldGFpbHMubGl2ZTtcbiAgICBpZiAobmV3SWQgPT09IHRoaXMudHJhY2tJZCAmJiB0cmFjayA9PT0gbGFzdFRyYWNrICYmIHRyYWNrTG9hZGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubG9nKGBTd2l0Y2hpbmcgdG8gc3VidGl0bGUtdHJhY2sgJHtuZXdJZH1gICsgKHRyYWNrID8gYCBcIiR7dHJhY2submFtZX1cIiBsYW5nOiR7dHJhY2subGFuZ30gZ3JvdXA6JHt0cmFjay5ncm91cElkfWAgOiAnJykpO1xuICAgIGNvbnN0IHtcbiAgICAgIGlkLFxuICAgICAgZ3JvdXBJZCA9ICcnLFxuICAgICAgbmFtZSxcbiAgICAgIHR5cGUsXG4gICAgICB1cmxcbiAgICB9ID0gdHJhY2s7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuU1VCVElUTEVfVFJBQ0tfU1dJVENILCB7XG4gICAgICBpZCxcbiAgICAgIGdyb3VwSWQsXG4gICAgICBuYW1lLFxuICAgICAgdHlwZSxcbiAgICAgIHVybFxuICAgIH0pO1xuICAgIGNvbnN0IGhsc1VybFBhcmFtZXRlcnMgPSB0aGlzLnN3aXRjaFBhcmFtcyh0cmFjay51cmwsIGxhc3RUcmFjayA9PSBudWxsID8gdm9pZCAwIDogbGFzdFRyYWNrLmRldGFpbHMpO1xuICAgIHRoaXMubG9hZFBsYXlsaXN0KGhsc1VybFBhcmFtZXRlcnMpO1xuICB9XG59XG5cbmNsYXNzIEJ1ZmZlck9wZXJhdGlvblF1ZXVlIHtcbiAgY29uc3RydWN0b3Ioc291cmNlQnVmZmVyUmVmZXJlbmNlKSB7XG4gICAgdGhpcy5idWZmZXJzID0gdm9pZCAwO1xuICAgIHRoaXMucXVldWVzID0ge1xuICAgICAgdmlkZW86IFtdLFxuICAgICAgYXVkaW86IFtdLFxuICAgICAgYXVkaW92aWRlbzogW11cbiAgICB9O1xuICAgIHRoaXMuYnVmZmVycyA9IHNvdXJjZUJ1ZmZlclJlZmVyZW5jZTtcbiAgfVxuICBhcHBlbmQob3BlcmF0aW9uLCB0eXBlLCBwZW5kaW5nKSB7XG4gICAgY29uc3QgcXVldWUgPSB0aGlzLnF1ZXVlc1t0eXBlXTtcbiAgICBxdWV1ZS5wdXNoKG9wZXJhdGlvbik7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhcGVuZGluZykge1xuICAgICAgdGhpcy5leGVjdXRlTmV4dCh0eXBlKTtcbiAgICB9XG4gIH1cbiAgaW5zZXJ0QWJvcnQob3BlcmF0aW9uLCB0eXBlKSB7XG4gICAgY29uc3QgcXVldWUgPSB0aGlzLnF1ZXVlc1t0eXBlXTtcbiAgICBxdWV1ZS51bnNoaWZ0KG9wZXJhdGlvbik7XG4gICAgdGhpcy5leGVjdXRlTmV4dCh0eXBlKTtcbiAgfVxuICBhcHBlbmRCbG9ja2VyKHR5cGUpIHtcbiAgICBsZXQgZXhlY3V0ZTtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBleGVjdXRlID0gcmVzb2x2ZTtcbiAgICB9KTtcbiAgICBjb25zdCBvcGVyYXRpb24gPSB7XG4gICAgICBleGVjdXRlLFxuICAgICAgb25TdGFydDogKCkgPT4ge30sXG4gICAgICBvbkNvbXBsZXRlOiAoKSA9PiB7fSxcbiAgICAgIG9uRXJyb3I6ICgpID0+IHt9XG4gICAgfTtcbiAgICB0aGlzLmFwcGVuZChvcGVyYXRpb24sIHR5cGUpO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIGV4ZWN1dGVOZXh0KHR5cGUpIHtcbiAgICBjb25zdCBxdWV1ZSA9IHRoaXMucXVldWVzW3R5cGVdO1xuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IHF1ZXVlWzBdO1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gT3BlcmF0aW9ucyBhcmUgZXhwZWN0ZWQgdG8gcmVzdWx0IGluIGFuICd1cGRhdGVlbmQnIGV2ZW50IGJlaW5nIGZpcmVkLiBJZiBub3QsIHRoZSBxdWV1ZSB3aWxsIGxvY2suIE9wZXJhdGlvbnNcbiAgICAgICAgLy8gd2hpY2ggZG8gbm90IGVuZCB3aXRoIHRoaXMgZXZlbnQgbXVzdCBjYWxsIF9vblNCVXBkYXRlRW5kIG1hbnVhbGx5XG4gICAgICAgIG9wZXJhdGlvbi5leGVjdXRlKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dnZXIud2FybihgW2J1ZmZlci1vcGVyYXRpb24tcXVldWVdOiBFeGNlcHRpb24gZXhlY3V0aW5nIFwiJHt0eXBlfVwiIFNvdXJjZUJ1ZmZlciBvcGVyYXRpb246ICR7ZXJyb3J9YCk7XG4gICAgICAgIG9wZXJhdGlvbi5vbkVycm9yKGVycm9yKTtcblxuICAgICAgICAvLyBPbmx5IHNoaWZ0IHRoZSBjdXJyZW50IG9wZXJhdGlvbiBvZmYsIG90aGVyd2lzZSB0aGUgdXBkYXRlZW5kIGhhbmRsZXIgd2lsbCBkbyB0aGlzIGZvciB1c1xuICAgICAgICBjb25zdCBzYiA9IHRoaXMuYnVmZmVyc1t0eXBlXTtcbiAgICAgICAgaWYgKCEoc2IgIT0gbnVsbCAmJiBzYi51cGRhdGluZykpIHtcbiAgICAgICAgICB0aGlzLnNoaWZ0QW5kRXhlY3V0ZU5leHQodHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc2hpZnRBbmRFeGVjdXRlTmV4dCh0eXBlKSB7XG4gICAgdGhpcy5xdWV1ZXNbdHlwZV0uc2hpZnQoKTtcbiAgICB0aGlzLmV4ZWN1dGVOZXh0KHR5cGUpO1xuICB9XG4gIGN1cnJlbnQodHlwZSkge1xuICAgIHJldHVybiB0aGlzLnF1ZXVlc1t0eXBlXVswXTtcbiAgfVxufVxuXG5jb25zdCBWSURFT19DT0RFQ19QUk9GSUxFX1JFUExBQ0UgPSAvKGF2Y1sxMjM0XXxodmMxfGhldjF8ZHZoWzFlXXx2cDA5fGF2MDEpKD86XFwuW14uLF0rKSsvO1xuY2xhc3MgQnVmZmVyQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIC8vIFRoZSBsZXZlbCBkZXRhaWxzIHVzZWQgdG8gZGV0ZXJtaW5lIGR1cmF0aW9uLCB0YXJnZXQtZHVyYXRpb24gYW5kIGxpdmVcbiAgICB0aGlzLmRldGFpbHMgPSBudWxsO1xuICAgIC8vIGNhY2hlIHRoZSBzZWxmIGdlbmVyYXRlZCBvYmplY3QgdXJsIHRvIGRldGVjdCBoaWphY2sgb2YgdmlkZW8gdGFnXG4gICAgdGhpcy5fb2JqZWN0VXJsID0gbnVsbDtcbiAgICAvLyBBIHF1ZXVlIG9mIGJ1ZmZlciBvcGVyYXRpb25zIHdoaWNoIHJlcXVpcmUgdGhlIFNvdXJjZUJ1ZmZlciB0byBub3QgYmUgdXBkYXRpbmcgdXBvbiBleGVjdXRpb25cbiAgICB0aGlzLm9wZXJhdGlvblF1ZXVlID0gdm9pZCAwO1xuICAgIC8vIFJlZmVyZW5jZXMgdG8gZXZlbnQgbGlzdGVuZXJzIGZvciBlYWNoIFNvdXJjZUJ1ZmZlciwgc28gdGhhdCB0aGV5IGNhbiBiZSByZWZlcmVuY2VkIGZvciBldmVudCByZW1vdmFsXG4gICAgdGhpcy5saXN0ZW5lcnMgPSB2b2lkIDA7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgLy8gVGhlIG51bWJlciBvZiBCVUZGRVJfQ09ERUMgZXZlbnRzIHJlY2VpdmVkIGJlZm9yZSBhbnkgc291cmNlQnVmZmVycyBhcmUgY3JlYXRlZFxuICAgIHRoaXMuYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCA9IDA7XG4gICAgLy8gVGhlIHRvdGFsIG51bWJlciBvZiBCVUZGRVJfQ09ERUMgZXZlbnRzIHJlY2VpdmVkXG4gICAgdGhpcy5fYnVmZmVyQ29kZWNFdmVudHNUb3RhbCA9IDA7XG4gICAgLy8gQSByZWZlcmVuY2UgdG8gdGhlIGF0dGFjaGVkIG1lZGlhIGVsZW1lbnRcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICAvLyBBIHJlZmVyZW5jZSB0byB0aGUgYWN0aXZlIG1lZGlhIHNvdXJjZVxuICAgIHRoaXMubWVkaWFTb3VyY2UgPSBudWxsO1xuICAgIC8vIExhc3QgTVAzIGF1ZGlvIGNodW5rIGFwcGVuZGVkXG4gICAgdGhpcy5sYXN0TXBlZ0F1ZGlvQ2h1bmsgPSBudWxsO1xuICAgIHRoaXMuYXBwZW5kU291cmNlID0gdm9pZCAwO1xuICAgIC8vIGNvdW50ZXJzXG4gICAgdGhpcy5hcHBlbmRFcnJvcnMgPSB7XG4gICAgICBhdWRpbzogMCxcbiAgICAgIHZpZGVvOiAwLFxuICAgICAgYXVkaW92aWRlbzogMFxuICAgIH07XG4gICAgdGhpcy50cmFja3MgPSB7fTtcbiAgICB0aGlzLnBlbmRpbmdUcmFja3MgPSB7fTtcbiAgICB0aGlzLnNvdXJjZUJ1ZmZlciA9IHZvaWQgMDtcbiAgICB0aGlzLmxvZyA9IHZvaWQgMDtcbiAgICB0aGlzLndhcm4gPSB2b2lkIDA7XG4gICAgdGhpcy5lcnJvciA9IHZvaWQgMDtcbiAgICB0aGlzLl9vbkVuZFN0cmVhbWluZyA9IGV2ZW50ID0+IHtcbiAgICAgIGlmICghdGhpcy5obHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5obHMucGF1c2VCdWZmZXJpbmcoKTtcbiAgICB9O1xuICAgIHRoaXMuX29uU3RhcnRTdHJlYW1pbmcgPSBldmVudCA9PiB7XG4gICAgICBpZiAoIXRoaXMuaGxzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGxzLnJlc3VtZUJ1ZmZlcmluZygpO1xuICAgIH07XG4gICAgLy8gS2VlcCBhcyBhcnJvdyBmdW5jdGlvbnMgc28gdGhhdCB3ZSBjYW4gZGlyZWN0bHkgcmVmZXJlbmNlIHRoZXNlIGZ1bmN0aW9ucyBkaXJlY3RseSBhcyBldmVudCBsaXN0ZW5lcnNcbiAgICB0aGlzLl9vbk1lZGlhU291cmNlT3BlbiA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWVkaWEsXG4gICAgICAgIG1lZGlhU291cmNlXG4gICAgICB9ID0gdGhpcztcbiAgICAgIHRoaXMubG9nKCdNZWRpYSBzb3VyY2Ugb3BlbmVkJyk7XG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW1wdGllZCcsIHRoaXMuX29uTWVkaWFFbXB0aWVkKTtcbiAgICAgICAgdGhpcy51cGRhdGVNZWRpYUVsZW1lbnREdXJhdGlvbigpO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwge1xuICAgICAgICAgIG1lZGlhLFxuICAgICAgICAgIG1lZGlhU291cmNlOiBtZWRpYVNvdXJjZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChtZWRpYVNvdXJjZSkge1xuICAgICAgICAvLyBvbmNlIHJlY2VpdmVkLCBkb24ndCBsaXN0ZW4gYW55bW9yZSB0byBzb3VyY2VvcGVuIGV2ZW50XG4gICAgICAgIG1lZGlhU291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NvdXJjZW9wZW4nLCB0aGlzLl9vbk1lZGlhU291cmNlT3Blbik7XG4gICAgICB9XG4gICAgICB0aGlzLmNoZWNrUGVuZGluZ1RyYWNrcygpO1xuICAgIH07XG4gICAgdGhpcy5fb25NZWRpYVNvdXJjZUNsb3NlID0gKCkgPT4ge1xuICAgICAgdGhpcy5sb2coJ01lZGlhIHNvdXJjZSBjbG9zZWQnKTtcbiAgICB9O1xuICAgIHRoaXMuX29uTWVkaWFTb3VyY2VFbmRlZCA9ICgpID0+IHtcbiAgICAgIHRoaXMubG9nKCdNZWRpYSBzb3VyY2UgZW5kZWQnKTtcbiAgICB9O1xuICAgIHRoaXMuX29uTWVkaWFFbXB0aWVkID0gKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBtZWRpYVNyYyxcbiAgICAgICAgX29iamVjdFVybFxuICAgICAgfSA9IHRoaXM7XG4gICAgICBpZiAobWVkaWFTcmMgIT09IF9vYmplY3RVcmwpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKGBNZWRpYSBlbGVtZW50IHNyYyB3YXMgc2V0IHdoaWxlIGF0dGFjaGluZyBNZWRpYVNvdXJjZSAoJHtfb2JqZWN0VXJsfSA+ICR7bWVkaWFTcmN9KWApO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgY29uc3QgbG9nUHJlZml4ID0gJ1tidWZmZXItY29udHJvbGxlcl0nO1xuICAgIHRoaXMuYXBwZW5kU291cmNlID0gaGxzLmNvbmZpZy5wcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2U7XG4gICAgdGhpcy5sb2cgPSBsb2dnZXIubG9nLmJpbmQobG9nZ2VyLCBsb2dQcmVmaXgpO1xuICAgIHRoaXMud2FybiA9IGxvZ2dlci53YXJuLmJpbmQobG9nZ2VyLCBsb2dQcmVmaXgpO1xuICAgIHRoaXMuZXJyb3IgPSBsb2dnZXIuZXJyb3IuYmluZChsb2dnZXIsIGxvZ1ByZWZpeCk7XG4gICAgdGhpcy5faW5pdFNvdXJjZUJ1ZmZlcigpO1xuICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICBoYXNTb3VyY2VUeXBlcygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpLmxlbmd0aCA+IDAgfHwgT2JqZWN0LmtleXModGhpcy5wZW5kaW5nVHJhY2tzKS5sZW5ndGggPiAwO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5kZXRhaWxzID0gbnVsbDtcbiAgICB0aGlzLmxhc3RNcGVnQXVkaW9DaHVuayA9IG51bGw7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuaGxzID0gbnVsbDtcbiAgfVxuICByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub24oRXZlbnRzLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQlVGRkVSX1JFU0VULCB0aGlzLm9uQnVmZmVyUmVzZXQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0FQUEVORElORywgdGhpcy5vbkJ1ZmZlckFwcGVuZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfQ09ERUNTLCB0aGlzLm9uQnVmZmVyQ29kZWNzLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkJVRkZFUl9FT1MsIHRoaXMub25CdWZmZXJFb3MsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0ZMVVNISU5HLCB0aGlzLm9uQnVmZmVyRmx1c2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxfVVBEQVRFRCwgdGhpcy5vbkxldmVsVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5GUkFHX1BBUlNFRCwgdGhpcy5vbkZyYWdQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRlJBR19DSEFOR0VELCB0aGlzLm9uRnJhZ0NoYW5nZWQsIHRoaXMpO1xuICB9XG4gIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaGxzLm9mZihFdmVudHMuTUVESUFfQVRUQUNISU5HLCB0aGlzLm9uTWVkaWFBdHRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX1JFU0VULCB0aGlzLm9uQnVmZmVyUmVzZXQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9BUFBFTkRJTkcsIHRoaXMub25CdWZmZXJBcHBlbmRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9DT0RFQ1MsIHRoaXMub25CdWZmZXJDb2RlY3MsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9FT1MsIHRoaXMub25CdWZmZXJFb3MsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9GTFVTSElORywgdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTF9VUERBVEVELCB0aGlzLm9uTGV2ZWxVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5GUkFHX1BBUlNFRCwgdGhpcy5vbkZyYWdQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkZSQUdfQ0hBTkdFRCwgdGhpcy5vbkZyYWdDaGFuZ2VkLCB0aGlzKTtcbiAgfVxuICBfaW5pdFNvdXJjZUJ1ZmZlcigpIHtcbiAgICB0aGlzLnNvdXJjZUJ1ZmZlciA9IHt9O1xuICAgIHRoaXMub3BlcmF0aW9uUXVldWUgPSBuZXcgQnVmZmVyT3BlcmF0aW9uUXVldWUodGhpcy5zb3VyY2VCdWZmZXIpO1xuICAgIHRoaXMubGlzdGVuZXJzID0ge1xuICAgICAgYXVkaW86IFtdLFxuICAgICAgdmlkZW86IFtdLFxuICAgICAgYXVkaW92aWRlbzogW11cbiAgICB9O1xuICAgIHRoaXMuYXBwZW5kRXJyb3JzID0ge1xuICAgICAgYXVkaW86IDAsXG4gICAgICB2aWRlbzogMCxcbiAgICAgIGF1ZGlvdmlkZW86IDBcbiAgICB9O1xuICAgIHRoaXMubGFzdE1wZWdBdWRpb0NodW5rID0gbnVsbDtcbiAgfVxuICBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICB0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQgPSB0aGlzLl9idWZmZXJDb2RlY0V2ZW50c1RvdGFsID0gMDtcbiAgICB0aGlzLmRldGFpbHMgPSBudWxsO1xuICB9XG4gIG9uTWFuaWZlc3RQYXJzZWQoZXZlbnQsIGRhdGEpIHtcbiAgICAvLyBpbiBjYXNlIG9mIGFsdCBhdWRpbyAyIEJVRkZFUl9DT0RFQ1MgZXZlbnRzIHdpbGwgYmUgdHJpZ2dlcmVkLCBvbmUgcGVyIHN0cmVhbSBjb250cm9sbGVyXG4gICAgLy8gc291cmNlYnVmZmVycyB3aWxsIGJlIGNyZWF0ZWQgYWxsIGF0IG9uY2Ugd2hlbiB0aGUgZXhwZWN0ZWQgbmIgb2YgdHJhY2tzIHdpbGwgYmUgcmVhY2hlZFxuICAgIC8vIGluIGNhc2UgYWx0IGF1ZGlvIGlzIG5vdCB1c2VkLCBvbmx5IG9uZSBCVUZGRVJfQ09ERUMgZXZlbnQgd2lsbCBiZSBmaXJlZCBmcm9tIG1haW4gc3RyZWFtIGNvbnRyb2xsZXJcbiAgICAvLyBpdCB3aWxsIGNvbnRhaW4gdGhlIGV4cGVjdGVkIG5iIG9mIHNvdXJjZSBidWZmZXJzLCBubyBuZWVkIHRvIGNvbXB1dGUgaXRcbiAgICBsZXQgY29kZWNFdmVudHMgPSAyO1xuICAgIGlmIChkYXRhLmF1ZGlvICYmICFkYXRhLnZpZGVvIHx8ICFkYXRhLmFsdEF1ZGlvIHx8ICF0cnVlKSB7XG4gICAgICBjb2RlY0V2ZW50cyA9IDE7XG4gICAgfVxuICAgIHRoaXMuYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCA9IHRoaXMuX2J1ZmZlckNvZGVjRXZlbnRzVG90YWwgPSBjb2RlY0V2ZW50cztcbiAgICB0aGlzLmxvZyhgJHt0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWR9IGJ1ZmZlckNvZGVjIGV2ZW50KHMpIGV4cGVjdGVkYCk7XG4gIH1cbiAgb25NZWRpYUF0dGFjaGluZyhldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYSA9IGRhdGEubWVkaWE7XG4gICAgY29uc3QgTWVkaWFTb3VyY2UgPSBnZXRNZWRpYVNvdXJjZSh0aGlzLmFwcGVuZFNvdXJjZSk7XG4gICAgaWYgKG1lZGlhICYmIE1lZGlhU291cmNlKSB7XG4gICAgICB2YXIgX21zJGNvbnN0cnVjdG9yO1xuICAgICAgY29uc3QgbXMgPSB0aGlzLm1lZGlhU291cmNlID0gbmV3IE1lZGlhU291cmNlKCk7XG4gICAgICB0aGlzLmxvZyhgY3JlYXRlZCBtZWRpYSBzb3VyY2U6ICR7KF9tcyRjb25zdHJ1Y3RvciA9IG1zLmNvbnN0cnVjdG9yKSA9PSBudWxsID8gdm9pZCAwIDogX21zJGNvbnN0cnVjdG9yLm5hbWV9YCk7XG4gICAgICAvLyBNZWRpYVNvdXJjZSBsaXN0ZW5lcnMgYXJlIGFycm93IGZ1bmN0aW9ucyB3aXRoIGEgbGV4aWNhbCBzY29wZSwgYW5kIGRvIG5vdCBuZWVkIHRvIGJlIGJvdW5kXG4gICAgICBtcy5hZGRFdmVudExpc3RlbmVyKCdzb3VyY2VvcGVuJywgdGhpcy5fb25NZWRpYVNvdXJjZU9wZW4pO1xuICAgICAgbXMuYWRkRXZlbnRMaXN0ZW5lcignc291cmNlZW5kZWQnLCB0aGlzLl9vbk1lZGlhU291cmNlRW5kZWQpO1xuICAgICAgbXMuYWRkRXZlbnRMaXN0ZW5lcignc291cmNlY2xvc2UnLCB0aGlzLl9vbk1lZGlhU291cmNlQ2xvc2UpO1xuICAgICAgbXMuYWRkRXZlbnRMaXN0ZW5lcignc3RhcnRzdHJlYW1pbmcnLCB0aGlzLl9vblN0YXJ0U3RyZWFtaW5nKTtcbiAgICAgIG1zLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZHN0cmVhbWluZycsIHRoaXMuX29uRW5kU3RyZWFtaW5nKTtcblxuICAgICAgLy8gY2FjaGUgdGhlIGxvY2FsbHkgZ2VuZXJhdGVkIG9iamVjdCB1cmxcbiAgICAgIGNvbnN0IG9iamVjdFVybCA9IHRoaXMuX29iamVjdFVybCA9IHNlbGYuVVJMLmNyZWF0ZU9iamVjdFVSTChtcyk7XG4gICAgICAvLyBsaW5rIHZpZGVvIGFuZCBtZWRpYSBTb3VyY2VcbiAgICAgIGlmICh0aGlzLmFwcGVuZFNvdXJjZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG1lZGlhLnJlbW92ZUF0dHJpYnV0ZSgnc3JjJyk7XG4gICAgICAgICAgLy8gTWFuYWdlZE1lZGlhU291cmNlIHdpbGwgbm90IG9wZW4gd2l0aG91dCBkaXNhYmxlUmVtb3RlUGxheWJhY2sgc2V0IHRvIGZhbHNlIG9yIHNvdXJjZSBhbHRlcm5hdGl2ZXNcbiAgICAgICAgICBjb25zdCBNTVMgPSBzZWxmLk1hbmFnZWRNZWRpYVNvdXJjZTtcbiAgICAgICAgICBtZWRpYS5kaXNhYmxlUmVtb3RlUGxheWJhY2sgPSBtZWRpYS5kaXNhYmxlUmVtb3RlUGxheWJhY2sgfHwgTU1TICYmIG1zIGluc3RhbmNlb2YgTU1TO1xuICAgICAgICAgIHJlbW92ZVNvdXJjZUNoaWxkcmVuKG1lZGlhKTtcbiAgICAgICAgICBhZGRTb3VyY2UobWVkaWEsIG9iamVjdFVybCk7XG4gICAgICAgICAgbWVkaWEubG9hZCgpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIG1lZGlhLnNyYyA9IG9iamVjdFVybDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVkaWEuc3JjID0gb2JqZWN0VXJsO1xuICAgICAgfVxuICAgICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignZW1wdGllZCcsIHRoaXMuX29uTWVkaWFFbXB0aWVkKTtcbiAgICB9XG4gIH1cbiAgb25NZWRpYURldGFjaGluZygpIHtcbiAgICBjb25zdCB7XG4gICAgICBtZWRpYSxcbiAgICAgIG1lZGlhU291cmNlLFxuICAgICAgX29iamVjdFVybFxuICAgIH0gPSB0aGlzO1xuICAgIGlmIChtZWRpYVNvdXJjZSkge1xuICAgICAgdGhpcy5sb2coJ21lZGlhIHNvdXJjZSBkZXRhY2hpbmcnKTtcbiAgICAgIGlmIChtZWRpYVNvdXJjZS5yZWFkeVN0YXRlID09PSAnb3BlbicpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBlbmRPZlN0cmVhbSBjb3VsZCB0cmlnZ2VyIGV4Y2VwdGlvbiBpZiBhbnkgc291cmNlYnVmZmVyIGlzIGluIHVwZGF0aW5nIHN0YXRlXG4gICAgICAgICAgLy8gd2UgZG9uJ3QgcmVhbGx5IGNhcmUgYWJvdXQgY2hlY2tpbmcgc291cmNlYnVmZmVyIHN0YXRlIGhlcmUsXG4gICAgICAgICAgLy8gYXMgd2UgYXJlIGFueXdheSBkZXRhY2hpbmcgdGhlIE1lZGlhU291cmNlXG4gICAgICAgICAgLy8gbGV0J3MganVzdCBhdm9pZCB0aGlzIGV4Y2VwdGlvbiB0byBwcm9wYWdhdGVcbiAgICAgICAgICBtZWRpYVNvdXJjZS5lbmRPZlN0cmVhbSgpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICB0aGlzLndhcm4oYG9uTWVkaWFEZXRhY2hpbmc6ICR7ZXJyLm1lc3NhZ2V9IHdoaWxlIGNhbGxpbmcgZW5kT2ZTdHJlYW1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQ2xlYW4gdXAgdGhlIFNvdXJjZUJ1ZmZlcnMgYnkgaW52b2tpbmcgb25CdWZmZXJSZXNldFxuICAgICAgdGhpcy5vbkJ1ZmZlclJlc2V0KCk7XG4gICAgICBtZWRpYVNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKCdzb3VyY2VvcGVuJywgdGhpcy5fb25NZWRpYVNvdXJjZU9wZW4pO1xuICAgICAgbWVkaWFTb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignc291cmNlZW5kZWQnLCB0aGlzLl9vbk1lZGlhU291cmNlRW5kZWQpO1xuICAgICAgbWVkaWFTb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignc291cmNlY2xvc2UnLCB0aGlzLl9vbk1lZGlhU291cmNlQ2xvc2UpO1xuICAgICAgbWVkaWFTb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignc3RhcnRzdHJlYW1pbmcnLCB0aGlzLl9vblN0YXJ0U3RyZWFtaW5nKTtcbiAgICAgIG1lZGlhU291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZHN0cmVhbWluZycsIHRoaXMuX29uRW5kU3RyZWFtaW5nKTtcblxuICAgICAgLy8gRGV0YWNoIHByb3Blcmx5IHRoZSBNZWRpYVNvdXJjZSBmcm9tIHRoZSBIVE1MTWVkaWFFbGVtZW50IGFzXG4gICAgICAvLyBzdWdnZXN0ZWQgaW4gaHR0cHM6Ly9naXRodWIuY29tL3czYy9tZWRpYS1zb3VyY2UvaXNzdWVzLzUzLlxuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VtcHRpZWQnLCB0aGlzLl9vbk1lZGlhRW1wdGllZCk7XG4gICAgICAgIGlmIChfb2JqZWN0VXJsKSB7XG4gICAgICAgICAgc2VsZi5VUkwucmV2b2tlT2JqZWN0VVJMKF9vYmplY3RVcmwpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYW4gdXAgdmlkZW8gdGFnIHNyYyBvbmx5IGlmIGl0J3Mgb3VyIG93biB1cmwuIHNvbWUgZXh0ZXJuYWwgbGlicmFyaWVzIG1pZ2h0XG4gICAgICAgIC8vIGhpamFjayB0aGUgdmlkZW8gdGFnIGFuZCBjaGFuZ2UgaXRzICdzcmMnIHdpdGhvdXQgZGVzdHJveWluZyB0aGUgSGxzIGluc3RhbmNlIGZpcnN0XG4gICAgICAgIGlmICh0aGlzLm1lZGlhU3JjID09PSBfb2JqZWN0VXJsKSB7XG4gICAgICAgICAgbWVkaWEucmVtb3ZlQXR0cmlidXRlKCdzcmMnKTtcbiAgICAgICAgICBpZiAodGhpcy5hcHBlbmRTb3VyY2UpIHtcbiAgICAgICAgICAgIHJlbW92ZVNvdXJjZUNoaWxkcmVuKG1lZGlhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWVkaWEubG9hZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMud2FybignbWVkaWF8c291cmNlLnNyYyB3YXMgY2hhbmdlZCBieSBhIHRoaXJkIHBhcnR5IC0gc2tpcCBjbGVhbnVwJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubWVkaWFTb3VyY2UgPSBudWxsO1xuICAgICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgICB0aGlzLl9vYmplY3RVcmwgPSBudWxsO1xuICAgICAgdGhpcy5idWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkID0gdGhpcy5fYnVmZmVyQ29kZWNFdmVudHNUb3RhbDtcbiAgICAgIHRoaXMucGVuZGluZ1RyYWNrcyA9IHt9O1xuICAgICAgdGhpcy50cmFja3MgPSB7fTtcbiAgICB9XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTUVESUFfREVUQUNIRUQsIHVuZGVmaW5lZCk7XG4gIH1cbiAgb25CdWZmZXJSZXNldCgpIHtcbiAgICB0aGlzLmdldFNvdXJjZUJ1ZmZlclR5cGVzKCkuZm9yRWFjaCh0eXBlID0+IHtcbiAgICAgIHRoaXMucmVzZXRCdWZmZXIodHlwZSk7XG4gICAgfSk7XG4gICAgdGhpcy5faW5pdFNvdXJjZUJ1ZmZlcigpO1xuICB9XG4gIHJlc2V0QnVmZmVyKHR5cGUpIHtcbiAgICBjb25zdCBzYiA9IHRoaXMuc291cmNlQnVmZmVyW3R5cGVdO1xuICAgIHRyeSB7XG4gICAgICBpZiAoc2IpIHtcbiAgICAgICAgdmFyIF90aGlzJG1lZGlhU291cmNlO1xuICAgICAgICB0aGlzLnJlbW92ZUJ1ZmZlckxpc3RlbmVycyh0eXBlKTtcbiAgICAgICAgLy8gU3luY2hyb25vdXNseSByZW1vdmUgdGhlIFNCIGZyb20gdGhlIG1hcCBiZWZvcmUgdGhlIG5leHQgY2FsbCBpbiBvcmRlciB0byBwcmV2ZW50IGFuIGFzeW5jIGZ1bmN0aW9uIGZyb21cbiAgICAgICAgLy8gYWNjZXNzaW5nIGl0XG4gICAgICAgIHRoaXMuc291cmNlQnVmZmVyW3R5cGVdID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoKF90aGlzJG1lZGlhU291cmNlID0gdGhpcy5tZWRpYVNvdXJjZSkgIT0gbnVsbCAmJiBfdGhpcyRtZWRpYVNvdXJjZS5zb3VyY2VCdWZmZXJzLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMubWVkaWFTb3VyY2UucmVtb3ZlU291cmNlQnVmZmVyKHNiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy53YXJuKGBvbkJ1ZmZlclJlc2V0ICR7dHlwZX1gLCBlcnIpO1xuICAgIH1cbiAgfVxuICBvbkJ1ZmZlckNvZGVjcyhldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHNvdXJjZUJ1ZmZlckNvdW50ID0gdGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpLmxlbmd0aDtcbiAgICBjb25zdCB0cmFja05hbWVzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gICAgdHJhY2tOYW1lcy5mb3JFYWNoKHRyYWNrTmFtZSA9PiB7XG4gICAgICBpZiAoc291cmNlQnVmZmVyQ291bnQpIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgU291cmNlQnVmZmVyIGNvZGVjIG5lZWRzIHRvIGNoYW5nZVxuICAgICAgICBjb25zdCB0cmFjayA9IHRoaXMudHJhY2tzW3RyYWNrTmFtZV07XG4gICAgICAgIGlmICh0cmFjayAmJiB0eXBlb2YgdHJhY2suYnVmZmVyLmNoYW5nZVR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgX3RyYWNrQ29kZWM7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBjb2RlYyxcbiAgICAgICAgICAgIGxldmVsQ29kZWMsXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICBtZXRhZGF0YVxuICAgICAgICAgIH0gPSBkYXRhW3RyYWNrTmFtZV07XG4gICAgICAgICAgY29uc3QgY3VycmVudENvZGVjRnVsbCA9IHBpY2tNb3N0Q29tcGxldGVDb2RlY05hbWUodHJhY2suY29kZWMsIHRyYWNrLmxldmVsQ29kZWMpO1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRDb2RlYyA9IGN1cnJlbnRDb2RlY0Z1bGwgPT0gbnVsbCA/IHZvaWQgMCA6IGN1cnJlbnRDb2RlY0Z1bGwucmVwbGFjZShWSURFT19DT0RFQ19QUk9GSUxFX1JFUExBQ0UsICckMScpO1xuICAgICAgICAgIGxldCB0cmFja0NvZGVjID0gcGlja01vc3RDb21wbGV0ZUNvZGVjTmFtZShjb2RlYywgbGV2ZWxDb2RlYyk7XG4gICAgICAgICAgY29uc3QgbmV4dENvZGVjID0gKF90cmFja0NvZGVjID0gdHJhY2tDb2RlYykgPT0gbnVsbCA/IHZvaWQgMCA6IF90cmFja0NvZGVjLnJlcGxhY2UoVklERU9fQ09ERUNfUFJPRklMRV9SRVBMQUNFLCAnJDEnKTtcbiAgICAgICAgICBpZiAodHJhY2tDb2RlYyAmJiBjdXJyZW50Q29kZWMgIT09IG5leHRDb2RlYykge1xuICAgICAgICAgICAgaWYgKHRyYWNrTmFtZS5zbGljZSgwLCA1KSA9PT0gJ2F1ZGlvJykge1xuICAgICAgICAgICAgICB0cmFja0NvZGVjID0gZ2V0Q29kZWNDb21wYXRpYmxlTmFtZSh0cmFja0NvZGVjLCB0aGlzLmhscy5jb25maWcucHJlZmVyTWFuYWdlZE1lZGlhU291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1pbWVUeXBlID0gYCR7Y29udGFpbmVyfTtjb2RlY3M9JHt0cmFja0NvZGVjfWA7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZENoYW5nZVR5cGUodHJhY2tOYW1lLCBtaW1lVHlwZSk7XG4gICAgICAgICAgICB0aGlzLmxvZyhgc3dpdGNoaW5nIGNvZGVjICR7Y3VycmVudENvZGVjRnVsbH0gdG8gJHt0cmFja0NvZGVjfWApO1xuICAgICAgICAgICAgdGhpcy50cmFja3NbdHJhY2tOYW1lXSA9IHtcbiAgICAgICAgICAgICAgYnVmZmVyOiB0cmFjay5idWZmZXIsXG4gICAgICAgICAgICAgIGNvZGVjLFxuICAgICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICAgIGxldmVsQ29kZWMsXG4gICAgICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICAgICAgICBpZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIHNvdXJjZSBidWZmZXIocykgbm90IGNyZWF0ZWQgeWV0LCBhcHBlbmRlZCBidWZmZXIgdHJhY2tzIGluIHRoaXMucGVuZGluZ1RyYWNrc1xuICAgICAgICB0aGlzLnBlbmRpbmdUcmFja3NbdHJhY2tOYW1lXSA9IGRhdGFbdHJhY2tOYW1lXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGlmIHNvdXJjZWJ1ZmZlcnMgYWxyZWFkeSBjcmVhdGVkLCBkbyBub3RoaW5nIC4uLlxuICAgIGlmIChzb3VyY2VCdWZmZXJDb3VudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBidWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkID0gTWF0aC5tYXgodGhpcy5idWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkIC0gMSwgMCk7XG4gICAgaWYgKHRoaXMuYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCAhPT0gYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCkge1xuICAgICAgdGhpcy5sb2coYCR7YnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZH0gYnVmZmVyQ29kZWMgZXZlbnQocykgZXhwZWN0ZWQgJHt0cmFja05hbWVzLmpvaW4oJywnKX1gKTtcbiAgICAgIHRoaXMuYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCA9IGJ1ZmZlckNvZGVjRXZlbnRzRXhwZWN0ZWQ7XG4gICAgfVxuICAgIGlmICh0aGlzLm1lZGlhU291cmNlICYmIHRoaXMubWVkaWFTb3VyY2UucmVhZHlTdGF0ZSA9PT0gJ29wZW4nKSB7XG4gICAgICB0aGlzLmNoZWNrUGVuZGluZ1RyYWNrcygpO1xuICAgIH1cbiAgfVxuICBhcHBlbmRDaGFuZ2VUeXBlKHR5cGUsIG1pbWVUeXBlKSB7XG4gICAgY29uc3Qge1xuICAgICAgb3BlcmF0aW9uUXVldWVcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBvcGVyYXRpb24gPSB7XG4gICAgICBleGVjdXRlOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHNiID0gdGhpcy5zb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgICAgIGlmIChzYikge1xuICAgICAgICAgIHRoaXMubG9nKGBjaGFuZ2luZyAke3R5cGV9IHNvdXJjZUJ1ZmZlciB0eXBlIHRvICR7bWltZVR5cGV9YCk7XG4gICAgICAgICAgc2IuY2hhbmdlVHlwZShtaW1lVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgb3BlcmF0aW9uUXVldWUuc2hpZnRBbmRFeGVjdXRlTmV4dCh0eXBlKTtcbiAgICAgIH0sXG4gICAgICBvblN0YXJ0OiAoKSA9PiB7fSxcbiAgICAgIG9uQ29tcGxldGU6ICgpID0+IHt9LFxuICAgICAgb25FcnJvcjogZXJyb3IgPT4ge1xuICAgICAgICB0aGlzLndhcm4oYEZhaWxlZCB0byBjaGFuZ2UgJHt0eXBlfSBTb3VyY2VCdWZmZXIgdHlwZWAsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIG9wZXJhdGlvblF1ZXVlLmFwcGVuZChvcGVyYXRpb24sIHR5cGUsICEhdGhpcy5wZW5kaW5nVHJhY2tzW3R5cGVdKTtcbiAgfVxuICBvbkJ1ZmZlckFwcGVuZGluZyhldmVudCwgZXZlbnREYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzLFxuICAgICAgb3BlcmF0aW9uUXVldWUsXG4gICAgICB0cmFja3NcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICBkYXRhLFxuICAgICAgdHlwZSxcbiAgICAgIGZyYWcsXG4gICAgICBwYXJ0LFxuICAgICAgY2h1bmtNZXRhXG4gICAgfSA9IGV2ZW50RGF0YTtcbiAgICBjb25zdCBjaHVua1N0YXRzID0gY2h1bmtNZXRhLmJ1ZmZlcmluZ1t0eXBlXTtcbiAgICBjb25zdCBidWZmZXJBcHBlbmRpbmdTdGFydCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY2h1bmtTdGF0cy5zdGFydCA9IGJ1ZmZlckFwcGVuZGluZ1N0YXJ0O1xuICAgIGNvbnN0IGZyYWdCdWZmZXJpbmcgPSBmcmFnLnN0YXRzLmJ1ZmZlcmluZztcbiAgICBjb25zdCBwYXJ0QnVmZmVyaW5nID0gcGFydCA/IHBhcnQuc3RhdHMuYnVmZmVyaW5nIDogbnVsbDtcbiAgICBpZiAoZnJhZ0J1ZmZlcmluZy5zdGFydCA9PT0gMCkge1xuICAgICAgZnJhZ0J1ZmZlcmluZy5zdGFydCA9IGJ1ZmZlckFwcGVuZGluZ1N0YXJ0O1xuICAgIH1cbiAgICBpZiAocGFydEJ1ZmZlcmluZyAmJiBwYXJ0QnVmZmVyaW5nLnN0YXJ0ID09PSAwKSB7XG4gICAgICBwYXJ0QnVmZmVyaW5nLnN0YXJ0ID0gYnVmZmVyQXBwZW5kaW5nU3RhcnQ7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogT25seSB1cGRhdGUgdGltZXN0YW1wT2Zmc2V0IHdoZW4gYXVkaW8vbXBlZyBmcmFnbWVudCBvciBwYXJ0IGlzIG5vdCBjb250aWd1b3VzIHdpdGggcHJldmlvdXNseSBhcHBlbmRlZFxuICAgIC8vIEFkanVzdGluZyBgU291cmNlQnVmZmVyLnRpbWVzdGFtcE9mZnNldGAgKGRlc2lyZWQgcG9pbnQgaW4gdGhlIHRpbWVsaW5lIHdoZXJlIHRoZSBuZXh0IGZyYW1lcyBzaG91bGQgYmUgYXBwZW5kZWQpXG4gICAgLy8gaW4gQ2hyb21lIGJyb3dzZXIgd2hlbiB3ZSBkZXRlY3QgTVBFRyBhdWRpbyBjb250YWluZXIgYW5kIHRpbWUgZGVsdGEgYmV0d2VlbiBsZXZlbCBQVFMgYW5kIGBTb3VyY2VCdWZmZXIudGltZXN0YW1wT2Zmc2V0YFxuICAgIC8vIGlzIGdyZWF0ZXIgdGhhbiAxMDBtcyAodGhpcyBpcyBlbm91Z2ggdG8gaGFuZGxlIHNlZWsgZm9yIFZPRCBvciBsZXZlbCBjaGFuZ2UgZm9yIExJVkUgdmlkZW9zKS5cbiAgICAvLyBNb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvLWRldi9obHMuanMvaXNzdWVzLzMzMiNpc3N1ZWNvbW1lbnQtMjU3OTg2NDg2XG4gICAgY29uc3QgYXVkaW9UcmFjayA9IHRyYWNrcy5hdWRpbztcbiAgICBsZXQgY2hlY2tUaW1lc3RhbXBPZmZzZXQgPSBmYWxzZTtcbiAgICBpZiAodHlwZSA9PT0gJ2F1ZGlvJyAmJiAoYXVkaW9UcmFjayA9PSBudWxsID8gdm9pZCAwIDogYXVkaW9UcmFjay5jb250YWluZXIpID09PSAnYXVkaW8vbXBlZycpIHtcbiAgICAgIGNoZWNrVGltZXN0YW1wT2Zmc2V0ID0gIXRoaXMubGFzdE1wZWdBdWRpb0NodW5rIHx8IGNodW5rTWV0YS5pZCA9PT0gMSB8fCB0aGlzLmxhc3RNcGVnQXVkaW9DaHVuay5zbiAhPT0gY2h1bmtNZXRhLnNuO1xuICAgICAgdGhpcy5sYXN0TXBlZ0F1ZGlvQ2h1bmsgPSBjaHVua01ldGE7XG4gICAgfVxuICAgIGNvbnN0IGZyYWdTdGFydCA9IGZyYWcuc3RhcnQ7XG4gICAgY29uc3Qgb3BlcmF0aW9uID0ge1xuICAgICAgZXhlY3V0ZTogKCkgPT4ge1xuICAgICAgICBjaHVua1N0YXRzLmV4ZWN1dGVTdGFydCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGlmIChjaGVja1RpbWVzdGFtcE9mZnNldCkge1xuICAgICAgICAgIGNvbnN0IHNiID0gdGhpcy5zb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgICAgICAgaWYgKHNiKSB7XG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IGZyYWdTdGFydCAtIHNiLnRpbWVzdGFtcE9mZnNldDtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhkZWx0YSkgPj0gMC4xKSB7XG4gICAgICAgICAgICAgIHRoaXMubG9nKGBVcGRhdGluZyBhdWRpbyBTb3VyY2VCdWZmZXIgdGltZXN0YW1wT2Zmc2V0IHRvICR7ZnJhZ1N0YXJ0fSAoZGVsdGE6ICR7ZGVsdGF9KSBzbjogJHtmcmFnLnNufSlgKTtcbiAgICAgICAgICAgICAgc2IudGltZXN0YW1wT2Zmc2V0ID0gZnJhZ1N0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFwcGVuZEV4ZWN1dG9yKGRhdGEsIHR5cGUpO1xuICAgICAgfSxcbiAgICAgIG9uU3RhcnQ6ICgpID0+IHtcbiAgICAgICAgLy8gbG9nZ2VyLmRlYnVnKGBbYnVmZmVyLWNvbnRyb2xsZXJdOiAke3R5cGV9IFNvdXJjZUJ1ZmZlciB1cGRhdGVzdGFydGApO1xuICAgICAgfSxcbiAgICAgIG9uQ29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgLy8gbG9nZ2VyLmRlYnVnKGBbYnVmZmVyLWNvbnRyb2xsZXJdOiAke3R5cGV9IFNvdXJjZUJ1ZmZlciB1cGRhdGVlbmRgKTtcbiAgICAgICAgY29uc3QgZW5kID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgY2h1bmtTdGF0cy5leGVjdXRlRW5kID0gY2h1bmtTdGF0cy5lbmQgPSBlbmQ7XG4gICAgICAgIGlmIChmcmFnQnVmZmVyaW5nLmZpcnN0ID09PSAwKSB7XG4gICAgICAgICAgZnJhZ0J1ZmZlcmluZy5maXJzdCA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydEJ1ZmZlcmluZyAmJiBwYXJ0QnVmZmVyaW5nLmZpcnN0ID09PSAwKSB7XG4gICAgICAgICAgcGFydEJ1ZmZlcmluZy5maXJzdCA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgc291cmNlQnVmZmVyXG4gICAgICAgIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB0aW1lUmFuZ2VzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgdHlwZSBpbiBzb3VyY2VCdWZmZXIpIHtcbiAgICAgICAgICB0aW1lUmFuZ2VzW3R5cGVdID0gQnVmZmVySGVscGVyLmdldEJ1ZmZlcmVkKHNvdXJjZUJ1ZmZlclt0eXBlXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hcHBlbmRFcnJvcnNbdHlwZV0gPSAwO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ2F1ZGlvJyB8fCB0eXBlID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgdGhpcy5hcHBlbmRFcnJvcnMuYXVkaW92aWRlbyA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5hcHBlbmRFcnJvcnMuYXVkaW8gPSAwO1xuICAgICAgICAgIHRoaXMuYXBwZW5kRXJyb3JzLnZpZGVvID0gMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfQVBQRU5ERUQsIHtcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgcGFydCxcbiAgICAgICAgICBjaHVua01ldGEsXG4gICAgICAgICAgcGFyZW50OiBmcmFnLnR5cGUsXG4gICAgICAgICAgdGltZVJhbmdlc1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBvbkVycm9yOiBlcnJvciA9PiB7XG4gICAgICAgIC8vIGluIGNhc2UgYW55IGVycm9yIG9jY3VyZWQgd2hpbGUgYXBwZW5kaW5nLCBwdXQgYmFjayBzZWdtZW50IGluIHNlZ21lbnRzIHRhYmxlXG4gICAgICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgICAgcGFyZW50OiBmcmFnLnR5cGUsXG4gICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9BUFBFTkRfRVJST1IsXG4gICAgICAgICAgc291cmNlQnVmZmVyTmFtZTogdHlwZSxcbiAgICAgICAgICBmcmFnLFxuICAgICAgICAgIHBhcnQsXG4gICAgICAgICAgY2h1bmtNZXRhLFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIGVycjogZXJyb3IsXG4gICAgICAgICAgZmF0YWw6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIGlmIChlcnJvci5jb2RlID09PSBET01FeGNlcHRpb24uUVVPVEFfRVhDRUVERURfRVJSKSB7XG4gICAgICAgICAgLy8gUXVvdGFFeGNlZWRlZEVycm9yOiBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9pbmZyYXN0cnVjdHVyZS5odG1sI3F1b3RhZXhjZWVkZWRlcnJvclxuICAgICAgICAgIC8vIGxldCdzIHN0b3AgYXBwZW5kaW5nIGFueSBzZWdtZW50cywgYW5kIHJlcG9ydCBCVUZGRVJfRlVMTF9FUlJPUiBlcnJvclxuICAgICAgICAgIGV2ZW50LmRldGFpbHMgPSBFcnJvckRldGFpbHMuQlVGRkVSX0ZVTExfRVJST1I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgYXBwZW5kRXJyb3JDb3VudCA9ICsrdGhpcy5hcHBlbmRFcnJvcnNbdHlwZV07XG4gICAgICAgICAgZXZlbnQuZGV0YWlscyA9IEVycm9yRGV0YWlscy5CVUZGRVJfQVBQRU5EX0VSUk9SO1xuICAgICAgICAgIC8qIHdpdGggVUhEIGNvbnRlbnQsIHdlIGNvdWxkIGdldCBsb29wIG9mIHF1b3RhIGV4Y2VlZGVkIGVycm9yIHVudGlsXG4gICAgICAgICAgICBicm93c2VyIGlzIGFibGUgdG8gZXZpY3Qgc29tZSBkYXRhIGZyb20gc291cmNlYnVmZmVyLiBSZXRyeWluZyBjYW4gaGVscCByZWNvdmVyLlxuICAgICAgICAgICovXG4gICAgICAgICAgdGhpcy53YXJuKGBGYWlsZWQgJHthcHBlbmRFcnJvckNvdW50fS8ke2hscy5jb25maWcuYXBwZW5kRXJyb3JNYXhSZXRyeX0gdGltZXMgdG8gYXBwZW5kIHNlZ21lbnQgaW4gXCIke3R5cGV9XCIgc291cmNlQnVmZmVyYCk7XG4gICAgICAgICAgaWYgKGFwcGVuZEVycm9yQ291bnQgPj0gaGxzLmNvbmZpZy5hcHBlbmRFcnJvck1heFJldHJ5KSB7XG4gICAgICAgICAgICBldmVudC5mYXRhbCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwgZXZlbnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgb3BlcmF0aW9uUXVldWUuYXBwZW5kKG9wZXJhdGlvbiwgdHlwZSwgISF0aGlzLnBlbmRpbmdUcmFja3NbdHlwZV0pO1xuICB9XG4gIG9uQnVmZmVyRmx1c2hpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBvcGVyYXRpb25RdWV1ZVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGZsdXNoT3BlcmF0aW9uID0gdHlwZSA9PiAoe1xuICAgICAgZXhlY3V0ZTogdGhpcy5yZW1vdmVFeGVjdXRvci5iaW5kKHRoaXMsIHR5cGUsIGRhdGEuc3RhcnRPZmZzZXQsIGRhdGEuZW5kT2Zmc2V0KSxcbiAgICAgIG9uU3RhcnQ6ICgpID0+IHtcbiAgICAgICAgLy8gbG9nZ2VyLmRlYnVnKGBbYnVmZmVyLWNvbnRyb2xsZXJdOiBTdGFydGVkIGZsdXNoaW5nICR7ZGF0YS5zdGFydE9mZnNldH0gLT4gJHtkYXRhLmVuZE9mZnNldH0gZm9yICR7dHlwZX0gU291cmNlIEJ1ZmZlcmApO1xuICAgICAgfSxcbiAgICAgIG9uQ29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgLy8gbG9nZ2VyLmRlYnVnKGBbYnVmZmVyLWNvbnRyb2xsZXJdOiBGaW5pc2hlZCBmbHVzaGluZyAke2RhdGEuc3RhcnRPZmZzZXR9IC0+ICR7ZGF0YS5lbmRPZmZzZXR9IGZvciAke3R5cGV9IFNvdXJjZSBCdWZmZXJgKTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX0ZMVVNIRUQsIHtcbiAgICAgICAgICB0eXBlXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIG9uRXJyb3I6IGVycm9yID0+IHtcbiAgICAgICAgdGhpcy53YXJuKGBGYWlsZWQgdG8gcmVtb3ZlIGZyb20gJHt0eXBlfSBTb3VyY2VCdWZmZXJgLCBlcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGRhdGEudHlwZSkge1xuICAgICAgb3BlcmF0aW9uUXVldWUuYXBwZW5kKGZsdXNoT3BlcmF0aW9uKGRhdGEudHlwZSksIGRhdGEudHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZ2V0U291cmNlQnVmZmVyVHlwZXMoKS5mb3JFYWNoKHR5cGUgPT4ge1xuICAgICAgICBvcGVyYXRpb25RdWV1ZS5hcHBlbmQoZmx1c2hPcGVyYXRpb24odHlwZSksIHR5cGUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIG9uRnJhZ1BhcnNlZChldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGZyYWcsXG4gICAgICBwYXJ0XG4gICAgfSA9IGRhdGE7XG4gICAgY29uc3QgYnVmZmVyc0FwcGVuZGVkVG8gPSBbXTtcbiAgICBjb25zdCBlbGVtZW50YXJ5U3RyZWFtcyA9IHBhcnQgPyBwYXJ0LmVsZW1lbnRhcnlTdHJlYW1zIDogZnJhZy5lbGVtZW50YXJ5U3RyZWFtcztcbiAgICBpZiAoZWxlbWVudGFyeVN0cmVhbXNbRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPVklERU9dKSB7XG4gICAgICBidWZmZXJzQXBwZW5kZWRUby5wdXNoKCdhdWRpb3ZpZGVvJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChlbGVtZW50YXJ5U3RyZWFtc1tFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU9dKSB7XG4gICAgICAgIGJ1ZmZlcnNBcHBlbmRlZFRvLnB1c2goJ2F1ZGlvJyk7XG4gICAgICB9XG4gICAgICBpZiAoZWxlbWVudGFyeVN0cmVhbXNbRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPXSkge1xuICAgICAgICBidWZmZXJzQXBwZW5kZWRUby5wdXNoKCd2aWRlbycpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBvblVuYmxvY2tlZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IG5vdyA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBmcmFnLnN0YXRzLmJ1ZmZlcmluZy5lbmQgPSBub3c7XG4gICAgICBpZiAocGFydCkge1xuICAgICAgICBwYXJ0LnN0YXRzLmJ1ZmZlcmluZy5lbmQgPSBub3c7XG4gICAgICB9XG4gICAgICBjb25zdCBzdGF0cyA9IHBhcnQgPyBwYXJ0LnN0YXRzIDogZnJhZy5zdGF0cztcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfQlVGRkVSRUQsIHtcbiAgICAgICAgZnJhZyxcbiAgICAgICAgcGFydCxcbiAgICAgICAgc3RhdHMsXG4gICAgICAgIGlkOiBmcmFnLnR5cGVcbiAgICAgIH0pO1xuICAgIH07XG4gICAgaWYgKGJ1ZmZlcnNBcHBlbmRlZFRvLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy53YXJuKGBGcmFnbWVudHMgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBFbGVtZW50YXJ5U3RyZWFtVHlwZSBzZXQuIHR5cGU6ICR7ZnJhZy50eXBlfSBsZXZlbDogJHtmcmFnLmxldmVsfSBzbjogJHtmcmFnLnNufWApO1xuICAgIH1cbiAgICB0aGlzLmJsb2NrQnVmZmVycyhvblVuYmxvY2tlZCwgYnVmZmVyc0FwcGVuZGVkVG8pO1xuICB9XG4gIG9uRnJhZ0NoYW5nZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLnRyaW1CdWZmZXJzKCk7XG4gIH1cblxuICAvLyBvbiBCVUZGRVJfRU9TIG1hcmsgbWF0Y2hpbmcgc291cmNlYnVmZmVyKHMpIGFzIGVuZGVkIGFuZCB0cmlnZ2VyIGNoZWNrRW9zKClcbiAgLy8gYW4gdW5kZWZpbmVkIGRhdGEudHlwZSB3aWxsIG1hcmsgYWxsIGJ1ZmZlcnMgYXMgRU9TLlxuICBvbkJ1ZmZlckVvcyhldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IGVuZGVkID0gdGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpLnJlZHVjZSgoYWNjLCB0eXBlKSA9PiB7XG4gICAgICBjb25zdCBzYiA9IHRoaXMuc291cmNlQnVmZmVyW3R5cGVdO1xuICAgICAgaWYgKHNiICYmICghZGF0YS50eXBlIHx8IGRhdGEudHlwZSA9PT0gdHlwZSkpIHtcbiAgICAgICAgc2IuZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFzYi5lbmRlZCkge1xuICAgICAgICAgIHNiLmVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmxvZyhgJHt0eXBlfSBzb3VyY2VCdWZmZXIgbm93IEVPU2ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjICYmICEhKCFzYiB8fCBzYi5lbmRlZCk7XG4gICAgfSwgdHJ1ZSk7XG4gICAgaWYgKGVuZGVkKSB7XG4gICAgICB0aGlzLmxvZyhgUXVldWVpbmcgbWVkaWFTb3VyY2UuZW5kT2ZTdHJlYW0oKWApO1xuICAgICAgdGhpcy5ibG9ja0J1ZmZlcnMoKCkgPT4ge1xuICAgICAgICB0aGlzLmdldFNvdXJjZUJ1ZmZlclR5cGVzKCkuZm9yRWFjaCh0eXBlID0+IHtcbiAgICAgICAgICBjb25zdCBzYiA9IHRoaXMuc291cmNlQnVmZmVyW3R5cGVdO1xuICAgICAgICAgIGlmIChzYikge1xuICAgICAgICAgICAgc2IuZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIG1lZGlhU291cmNlXG4gICAgICAgIH0gPSB0aGlzO1xuICAgICAgICBpZiAoIW1lZGlhU291cmNlIHx8IG1lZGlhU291cmNlLnJlYWR5U3RhdGUgIT09ICdvcGVuJykge1xuICAgICAgICAgIGlmIChtZWRpYVNvdXJjZSkge1xuICAgICAgICAgICAgdGhpcy5sb2coYENvdWxkIG5vdCBjYWxsIG1lZGlhU291cmNlLmVuZE9mU3RyZWFtKCkuIG1lZGlhU291cmNlLnJlYWR5U3RhdGU6ICR7bWVkaWFTb3VyY2UucmVhZHlTdGF0ZX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9nKGBDYWxsaW5nIG1lZGlhU291cmNlLmVuZE9mU3RyZWFtKClgKTtcbiAgICAgICAgLy8gQWxsb3cgdGhpcyB0byB0aHJvdyBhbmQgYmUgY2F1Z2h0IGJ5IHRoZSBlbnF1ZXVlaW5nIGZ1bmN0aW9uXG4gICAgICAgIG1lZGlhU291cmNlLmVuZE9mU3RyZWFtKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgb25MZXZlbFVwZGF0ZWQoZXZlbnQsIHtcbiAgICBkZXRhaWxzXG4gIH0pIHtcbiAgICBpZiAoIWRldGFpbHMuZnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgIGlmICh0aGlzLmdldFNvdXJjZUJ1ZmZlclR5cGVzKCkubGVuZ3RoKSB7XG4gICAgICB0aGlzLmJsb2NrQnVmZmVycyh0aGlzLnVwZGF0ZU1lZGlhRWxlbWVudER1cmF0aW9uLmJpbmQodGhpcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVwZGF0ZU1lZGlhRWxlbWVudER1cmF0aW9uKCk7XG4gICAgfVxuICB9XG4gIHRyaW1CdWZmZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhscyxcbiAgICAgIGRldGFpbHMsXG4gICAgICBtZWRpYVxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghbWVkaWEgfHwgZGV0YWlscyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2VCdWZmZXJUeXBlcyA9IHRoaXMuZ2V0U291cmNlQnVmZmVyVHlwZXMoKTtcbiAgICBpZiAoIXNvdXJjZUJ1ZmZlclR5cGVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjb25maWcgPSBobHMuY29uZmlnO1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbWVkaWEuY3VycmVudFRpbWU7XG4gICAgY29uc3QgdGFyZ2V0RHVyYXRpb24gPSBkZXRhaWxzLmxldmVsVGFyZ2V0RHVyYXRpb247XG5cbiAgICAvLyBTdXBwb3J0IGZvciBkZXByZWNhdGVkIGxpdmVCYWNrQnVmZmVyTGVuZ3RoXG4gICAgY29uc3QgYmFja0J1ZmZlckxlbmd0aCA9IGRldGFpbHMubGl2ZSAmJiBjb25maWcubGl2ZUJhY2tCdWZmZXJMZW5ndGggIT09IG51bGwgPyBjb25maWcubGl2ZUJhY2tCdWZmZXJMZW5ndGggOiBjb25maWcuYmFja0J1ZmZlckxlbmd0aDtcbiAgICBpZiAoaXNGaW5pdGVOdW1iZXIoYmFja0J1ZmZlckxlbmd0aCkgJiYgYmFja0J1ZmZlckxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IG1heEJhY2tCdWZmZXJMZW5ndGggPSBNYXRoLm1heChiYWNrQnVmZmVyTGVuZ3RoLCB0YXJnZXREdXJhdGlvbik7XG4gICAgICBjb25zdCB0YXJnZXRCYWNrQnVmZmVyUG9zaXRpb24gPSBNYXRoLmZsb29yKGN1cnJlbnRUaW1lIC8gdGFyZ2V0RHVyYXRpb24pICogdGFyZ2V0RHVyYXRpb24gLSBtYXhCYWNrQnVmZmVyTGVuZ3RoO1xuICAgICAgdGhpcy5mbHVzaEJhY2tCdWZmZXIoY3VycmVudFRpbWUsIHRhcmdldER1cmF0aW9uLCB0YXJnZXRCYWNrQnVmZmVyUG9zaXRpb24pO1xuICAgIH1cbiAgICBpZiAoaXNGaW5pdGVOdW1iZXIoY29uZmlnLmZyb250QnVmZmVyRmx1c2hUaHJlc2hvbGQpICYmIGNvbmZpZy5mcm9udEJ1ZmZlckZsdXNoVGhyZXNob2xkID4gMCkge1xuICAgICAgY29uc3QgZnJvbnRCdWZmZXJMZW5ndGggPSBNYXRoLm1heChjb25maWcubWF4QnVmZmVyTGVuZ3RoLCBjb25maWcuZnJvbnRCdWZmZXJGbHVzaFRocmVzaG9sZCk7XG4gICAgICBjb25zdCBtYXhGcm9udEJ1ZmZlckxlbmd0aCA9IE1hdGgubWF4KGZyb250QnVmZmVyTGVuZ3RoLCB0YXJnZXREdXJhdGlvbik7XG4gICAgICBjb25zdCB0YXJnZXRGcm9udEJ1ZmZlclBvc2l0aW9uID0gTWF0aC5mbG9vcihjdXJyZW50VGltZSAvIHRhcmdldER1cmF0aW9uKSAqIHRhcmdldER1cmF0aW9uICsgbWF4RnJvbnRCdWZmZXJMZW5ndGg7XG4gICAgICB0aGlzLmZsdXNoRnJvbnRCdWZmZXIoY3VycmVudFRpbWUsIHRhcmdldER1cmF0aW9uLCB0YXJnZXRGcm9udEJ1ZmZlclBvc2l0aW9uKTtcbiAgICB9XG4gIH1cbiAgZmx1c2hCYWNrQnVmZmVyKGN1cnJlbnRUaW1lLCB0YXJnZXREdXJhdGlvbiwgdGFyZ2V0QmFja0J1ZmZlclBvc2l0aW9uKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGV0YWlscyxcbiAgICAgIHNvdXJjZUJ1ZmZlclxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHNvdXJjZUJ1ZmZlclR5cGVzID0gdGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpO1xuICAgIHNvdXJjZUJ1ZmZlclR5cGVzLmZvckVhY2godHlwZSA9PiB7XG4gICAgICBjb25zdCBzYiA9IHNvdXJjZUJ1ZmZlclt0eXBlXTtcbiAgICAgIGlmIChzYikge1xuICAgICAgICBjb25zdCBidWZmZXJlZCA9IEJ1ZmZlckhlbHBlci5nZXRCdWZmZXJlZChzYik7XG4gICAgICAgIC8vIHdoZW4gdGFyZ2V0IGJ1ZmZlciBzdGFydCBleGNlZWRzIGFjdHVhbCBidWZmZXIgc3RhcnRcbiAgICAgICAgaWYgKGJ1ZmZlcmVkLmxlbmd0aCA+IDAgJiYgdGFyZ2V0QmFja0J1ZmZlclBvc2l0aW9uID4gYnVmZmVyZWQuc3RhcnQoMCkpIHtcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5CQUNLX0JVRkZFUl9SRUFDSEVELCB7XG4gICAgICAgICAgICBidWZmZXJFbmQ6IHRhcmdldEJhY2tCdWZmZXJQb3NpdGlvblxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gU3VwcG9ydCBmb3IgZGVwcmVjYXRlZCBldmVudDpcbiAgICAgICAgICBpZiAoZGV0YWlscyAhPSBudWxsICYmIGRldGFpbHMubGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTElWRV9CQUNLX0JVRkZFUl9SRUFDSEVELCB7XG4gICAgICAgICAgICAgIGJ1ZmZlckVuZDogdGFyZ2V0QmFja0J1ZmZlclBvc2l0aW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNiLmVuZGVkICYmIGJ1ZmZlcmVkLmVuZChidWZmZXJlZC5sZW5ndGggLSAxKSAtIGN1cnJlbnRUaW1lIDwgdGFyZ2V0RHVyYXRpb24gKiAyKSB7XG4gICAgICAgICAgICB0aGlzLmxvZyhgQ2Fubm90IGZsdXNoICR7dHlwZX0gYmFjayBidWZmZXIgd2hpbGUgU291cmNlQnVmZmVyIGlzIGluIGVuZGVkIHN0YXRlYCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9GTFVTSElORywge1xuICAgICAgICAgICAgc3RhcnRPZmZzZXQ6IDAsXG4gICAgICAgICAgICBlbmRPZmZzZXQ6IHRhcmdldEJhY2tCdWZmZXJQb3NpdGlvbixcbiAgICAgICAgICAgIHR5cGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGZsdXNoRnJvbnRCdWZmZXIoY3VycmVudFRpbWUsIHRhcmdldER1cmF0aW9uLCB0YXJnZXRGcm9udEJ1ZmZlclBvc2l0aW9uKSB7XG4gICAgY29uc3Qge1xuICAgICAgc291cmNlQnVmZmVyXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgc291cmNlQnVmZmVyVHlwZXMgPSB0aGlzLmdldFNvdXJjZUJ1ZmZlclR5cGVzKCk7XG4gICAgc291cmNlQnVmZmVyVHlwZXMuZm9yRWFjaCh0eXBlID0+IHtcbiAgICAgIGNvbnN0IHNiID0gc291cmNlQnVmZmVyW3R5cGVdO1xuICAgICAgaWYgKHNiKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlcmVkID0gQnVmZmVySGVscGVyLmdldEJ1ZmZlcmVkKHNiKTtcbiAgICAgICAgY29uc3QgbnVtQnVmZmVyZWRSYW5nZXMgPSBidWZmZXJlZC5sZW5ndGg7XG4gICAgICAgIC8vIFRoZSBidWZmZXIgaXMgZWl0aGVyIGVtcHR5IG9yIGNvbnRpZ3VvdXNcbiAgICAgICAgaWYgKG51bUJ1ZmZlcmVkUmFuZ2VzIDwgMikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWZmZXJTdGFydCA9IGJ1ZmZlcmVkLnN0YXJ0KG51bUJ1ZmZlcmVkUmFuZ2VzIC0gMSk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlckVuZCA9IGJ1ZmZlcmVkLmVuZChudW1CdWZmZXJlZFJhbmdlcyAtIDEpO1xuICAgICAgICAvLyBObyBmbHVzaCBpZiB3ZSBjYW4gdG9sZXJhdGUgdGhlIGN1cnJlbnQgYnVmZmVyIGxlbmd0aCBvciB0aGUgY3VycmVudCBidWZmZXIgcmFuZ2Ugd2Ugd291bGQgZmx1c2ggaXMgY29udGlndW91cyB3aXRoIGN1cnJlbnQgcG9zaXRpb25cbiAgICAgICAgaWYgKHRhcmdldEZyb250QnVmZmVyUG9zaXRpb24gPiBidWZmZXJTdGFydCB8fCBjdXJyZW50VGltZSA+PSBidWZmZXJTdGFydCAmJiBjdXJyZW50VGltZSA8PSBidWZmZXJFbmQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAoc2IuZW5kZWQgJiYgY3VycmVudFRpbWUgLSBidWZmZXJFbmQgPCAyICogdGFyZ2V0RHVyYXRpb24pIHtcbiAgICAgICAgICB0aGlzLmxvZyhgQ2Fubm90IGZsdXNoICR7dHlwZX0gZnJvbnQgYnVmZmVyIHdoaWxlIFNvdXJjZUJ1ZmZlciBpcyBpbiBlbmRlZCBzdGF0ZWApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsIHtcbiAgICAgICAgICBzdGFydE9mZnNldDogYnVmZmVyU3RhcnQsXG4gICAgICAgICAgZW5kT2Zmc2V0OiBJbmZpbml0eSxcbiAgICAgICAgICB0eXBlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBNZWRpYSBTb3VyY2UgZHVyYXRpb24gdG8gY3VycmVudCBsZXZlbCBkdXJhdGlvbiBvciBvdmVycmlkZSB0byBJbmZpbml0eSBpZiBjb25maWd1cmF0aW9uIHBhcmFtZXRlclxuICAgKiAnbGl2ZUR1cmF0aW9uSW5maW5pdHlgIGlzIHNldCB0byBgdHJ1ZWBcbiAgICogTW9yZSBkZXRhaWxzOiBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvMzU1XG4gICAqL1xuICB1cGRhdGVNZWRpYUVsZW1lbnREdXJhdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuZGV0YWlscyB8fCAhdGhpcy5tZWRpYSB8fCAhdGhpcy5tZWRpYVNvdXJjZSB8fCB0aGlzLm1lZGlhU291cmNlLnJlYWR5U3RhdGUgIT09ICdvcGVuJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBkZXRhaWxzLFxuICAgICAgaGxzLFxuICAgICAgbWVkaWEsXG4gICAgICBtZWRpYVNvdXJjZVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGxldmVsRHVyYXRpb24gPSBkZXRhaWxzLmZyYWdtZW50c1swXS5zdGFydCArIGRldGFpbHMudG90YWxkdXJhdGlvbjtcbiAgICBjb25zdCBtZWRpYUR1cmF0aW9uID0gbWVkaWEuZHVyYXRpb247XG4gICAgY29uc3QgbXNEdXJhdGlvbiA9IGlzRmluaXRlTnVtYmVyKG1lZGlhU291cmNlLmR1cmF0aW9uKSA/IG1lZGlhU291cmNlLmR1cmF0aW9uIDogMDtcbiAgICBpZiAoZGV0YWlscy5saXZlICYmIGhscy5jb25maWcubGl2ZUR1cmF0aW9uSW5maW5pdHkpIHtcbiAgICAgIC8vIE92ZXJyaWRlIGR1cmF0aW9uIHRvIEluZmluaXR5XG4gICAgICBtZWRpYVNvdXJjZS5kdXJhdGlvbiA9IEluZmluaXR5O1xuICAgICAgdGhpcy51cGRhdGVTZWVrYWJsZVJhbmdlKGRldGFpbHMpO1xuICAgIH0gZWxzZSBpZiAobGV2ZWxEdXJhdGlvbiA+IG1zRHVyYXRpb24gJiYgbGV2ZWxEdXJhdGlvbiA+IG1lZGlhRHVyYXRpb24gfHwgIWlzRmluaXRlTnVtYmVyKG1lZGlhRHVyYXRpb24pKSB7XG4gICAgICAvLyBsZXZlbER1cmF0aW9uIHdhcyB0aGUgbGFzdCB2YWx1ZSB3ZSBzZXQuXG4gICAgICAvLyBub3QgdXNpbmcgbWVkaWFTb3VyY2UuZHVyYXRpb24gYXMgdGhlIGJyb3dzZXIgbWF5IHR3ZWFrIHRoaXMgdmFsdWVcbiAgICAgIC8vIG9ubHkgdXBkYXRlIE1lZGlhIFNvdXJjZSBkdXJhdGlvbiBpZiBpdHMgdmFsdWUgaW5jcmVhc2UsIHRoaXMgaXMgdG8gYXZvaWRcbiAgICAgIC8vIGZsdXNoaW5nIGFscmVhZHkgYnVmZmVyZWQgcG9ydGlvbiB3aGVuIHN3aXRjaGluZyBiZXR3ZWVuIHF1YWxpdHkgbGV2ZWxcbiAgICAgIHRoaXMubG9nKGBVcGRhdGluZyBNZWRpYSBTb3VyY2UgZHVyYXRpb24gdG8gJHtsZXZlbER1cmF0aW9uLnRvRml4ZWQoMyl9YCk7XG4gICAgICBtZWRpYVNvdXJjZS5kdXJhdGlvbiA9IGxldmVsRHVyYXRpb247XG4gICAgfVxuICB9XG4gIHVwZGF0ZVNlZWthYmxlUmFuZ2UobGV2ZWxEZXRhaWxzKSB7XG4gICAgY29uc3QgbWVkaWFTb3VyY2UgPSB0aGlzLm1lZGlhU291cmNlO1xuICAgIGNvbnN0IGZyYWdtZW50cyA9IGxldmVsRGV0YWlscy5mcmFnbWVudHM7XG4gICAgY29uc3QgbGVuID0gZnJhZ21lbnRzLmxlbmd0aDtcbiAgICBpZiAobGVuICYmIGxldmVsRGV0YWlscy5saXZlICYmIG1lZGlhU291cmNlICE9IG51bGwgJiYgbWVkaWFTb3VyY2Uuc2V0TGl2ZVNlZWthYmxlUmFuZ2UpIHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgoMCwgZnJhZ21lbnRzWzBdLnN0YXJ0KTtcbiAgICAgIGNvbnN0IGVuZCA9IE1hdGgubWF4KHN0YXJ0LCBzdGFydCArIGxldmVsRGV0YWlscy50b3RhbGR1cmF0aW9uKTtcbiAgICAgIHRoaXMubG9nKGBNZWRpYSBTb3VyY2UgZHVyYXRpb24gaXMgc2V0IHRvICR7bWVkaWFTb3VyY2UuZHVyYXRpb259LiBTZXR0aW5nIHNlZWthYmxlIHJhbmdlIHRvICR7c3RhcnR9LSR7ZW5kfS5gKTtcbiAgICAgIG1lZGlhU291cmNlLnNldExpdmVTZWVrYWJsZVJhbmdlKHN0YXJ0LCBlbmQpO1xuICAgIH1cbiAgfVxuICBjaGVja1BlbmRpbmdUcmFja3MoKSB7XG4gICAgY29uc3Qge1xuICAgICAgYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCxcbiAgICAgIG9wZXJhdGlvblF1ZXVlLFxuICAgICAgcGVuZGluZ1RyYWNrc1xuICAgIH0gPSB0aGlzO1xuXG4gICAgLy8gQ2hlY2sgaWYgd2UndmUgcmVjZWl2ZWQgYWxsIG9mIHRoZSBleHBlY3RlZCBidWZmZXJDb2RlYyBldmVudHMuIFdoZW4gbm9uZSByZW1haW4sIGNyZWF0ZSBhbGwgdGhlIHNvdXJjZUJ1ZmZlcnMgYXQgb25jZS5cbiAgICAvLyBUaGlzIGlzIGltcG9ydGFudCBiZWNhdXNlIHRoZSBNU0Ugc3BlYyBhbGxvd3MgaW1wbGVtZW50YXRpb25zIHRvIHRocm93IFF1b3RhRXhjZWVkZWRFcnJvcnMgaWYgY3JlYXRpbmcgbmV3IHNvdXJjZUJ1ZmZlcnMgYWZ0ZXJcbiAgICAvLyBkYXRhIGhhcyBiZWVuIGFwcGVuZGVkIHRvIGV4aXN0aW5nIG9uZXMuXG4gICAgLy8gMiB0cmFja3MgaXMgdGhlIG1heCAob25lIGZvciBhdWRpbywgb25lIGZvciB2aWRlbykuIElmIHdlJ3ZlIHJlYWNoIHRoaXMgbWF4IGdvIGFoZWFkIGFuZCBjcmVhdGUgdGhlIGJ1ZmZlcnMuXG4gICAgY29uc3QgcGVuZGluZ1RyYWNrc0NvdW50ID0gT2JqZWN0LmtleXMocGVuZGluZ1RyYWNrcykubGVuZ3RoO1xuICAgIGlmIChwZW5kaW5nVHJhY2tzQ291bnQgJiYgKCFidWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkIHx8IHBlbmRpbmdUcmFja3NDb3VudCA9PT0gMiB8fCAnYXVkaW92aWRlbycgaW4gcGVuZGluZ1RyYWNrcykpIHtcbiAgICAgIC8vIG9rLCBsZXQncyBjcmVhdGUgdGhlbSBub3cgIVxuICAgICAgdGhpcy5jcmVhdGVTb3VyY2VCdWZmZXJzKHBlbmRpbmdUcmFja3MpO1xuICAgICAgdGhpcy5wZW5kaW5nVHJhY2tzID0ge307XG4gICAgICAvLyBhcHBlbmQgYW55IHBlbmRpbmcgc2VnbWVudHMgbm93ICFcbiAgICAgIGNvbnN0IGJ1ZmZlcnMgPSB0aGlzLmdldFNvdXJjZUJ1ZmZlclR5cGVzKCk7XG4gICAgICBpZiAoYnVmZmVycy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX0NSRUFURUQsIHtcbiAgICAgICAgICB0cmFja3M6IHRoaXMudHJhY2tzXG4gICAgICAgIH0pO1xuICAgICAgICBidWZmZXJzLmZvckVhY2godHlwZSA9PiB7XG4gICAgICAgICAgb3BlcmF0aW9uUXVldWUuZXhlY3V0ZU5leHQodHlwZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ2NvdWxkIG5vdCBjcmVhdGUgc291cmNlIGJ1ZmZlciBmb3IgbWVkaWEgY29kZWMocyknKTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfSU5DT01QQVRJQkxFX0NPREVDU19FUlJPUixcbiAgICAgICAgICBmYXRhbDogdHJ1ZSxcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgICByZWFzb246IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNyZWF0ZVNvdXJjZUJ1ZmZlcnModHJhY2tzKSB7XG4gICAgY29uc3Qge1xuICAgICAgc291cmNlQnVmZmVyLFxuICAgICAgbWVkaWFTb3VyY2VcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIW1lZGlhU291cmNlKSB7XG4gICAgICB0aHJvdyBFcnJvcignY3JlYXRlU291cmNlQnVmZmVycyBjYWxsZWQgd2hlbiBtZWRpYVNvdXJjZSB3YXMgbnVsbCcpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHRyYWNrTmFtZSBpbiB0cmFja3MpIHtcbiAgICAgIGlmICghc291cmNlQnVmZmVyW3RyYWNrTmFtZV0pIHtcbiAgICAgICAgY29uc3QgdHJhY2sgPSB0cmFja3NbdHJhY2tOYW1lXTtcbiAgICAgICAgaWYgKCF0cmFjaykge1xuICAgICAgICAgIHRocm93IEVycm9yKGBzb3VyY2UgYnVmZmVyIGV4aXN0cyBmb3IgdHJhY2sgJHt0cmFja05hbWV9LCBob3dldmVyIHRyYWNrIGRvZXMgbm90YCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdXNlIGxldmVsQ29kZWMgYXMgZmlyc3QgcHJpb3JpdHlcbiAgICAgICAgbGV0IGNvZGVjID0gdHJhY2subGV2ZWxDb2RlYyB8fCB0cmFjay5jb2RlYztcbiAgICAgICAgaWYgKGNvZGVjKSB7XG4gICAgICAgICAgaWYgKHRyYWNrTmFtZS5zbGljZSgwLCA1KSA9PT0gJ2F1ZGlvJykge1xuICAgICAgICAgICAgY29kZWMgPSBnZXRDb2RlY0NvbXBhdGlibGVOYW1lKGNvZGVjLCB0aGlzLmhscy5jb25maWcucHJlZmVyTWFuYWdlZE1lZGlhU291cmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWltZVR5cGUgPSBgJHt0cmFjay5jb250YWluZXJ9O2NvZGVjcz0ke2NvZGVjfWA7XG4gICAgICAgIHRoaXMubG9nKGBjcmVhdGluZyBzb3VyY2VCdWZmZXIoJHttaW1lVHlwZX0pYCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qgc2IgPSBzb3VyY2VCdWZmZXJbdHJhY2tOYW1lXSA9IG1lZGlhU291cmNlLmFkZFNvdXJjZUJ1ZmZlcihtaW1lVHlwZSk7XG4gICAgICAgICAgY29uc3Qgc2JOYW1lID0gdHJhY2tOYW1lO1xuICAgICAgICAgIHRoaXMuYWRkQnVmZmVyTGlzdGVuZXIoc2JOYW1lLCAndXBkYXRlc3RhcnQnLCB0aGlzLl9vblNCVXBkYXRlU3RhcnQpO1xuICAgICAgICAgIHRoaXMuYWRkQnVmZmVyTGlzdGVuZXIoc2JOYW1lLCAndXBkYXRlZW5kJywgdGhpcy5fb25TQlVwZGF0ZUVuZCk7XG4gICAgICAgICAgdGhpcy5hZGRCdWZmZXJMaXN0ZW5lcihzYk5hbWUsICdlcnJvcicsIHRoaXMuX29uU0JVcGRhdGVFcnJvcik7XG4gICAgICAgICAgLy8gTWFuYWdlZFNvdXJjZUJ1ZmZlciBidWZmZXJlZGNoYW5nZSBldmVudFxuICAgICAgICAgIHRoaXMuYWRkQnVmZmVyTGlzdGVuZXIoc2JOYW1lLCAnYnVmZmVyZWRjaGFuZ2UnLCAodHlwZSwgZXZlbnQpID0+IHtcbiAgICAgICAgICAgIC8vIElmIG1lZGlhIHdhcyBlamVjdGVkIGNoZWNrIGZvciBhIGNoYW5nZS4gQWRkZWQgcmFuZ2VzIGFyZSByZWR1bmRhbnQgd2l0aCBjaGFuZ2VzIG9uICd1cGRhdGVlbmQnIGV2ZW50LlxuICAgICAgICAgICAgY29uc3QgcmVtb3ZlZFJhbmdlcyA9IGV2ZW50LnJlbW92ZWRSYW5nZXM7XG4gICAgICAgICAgICBpZiAocmVtb3ZlZFJhbmdlcyAhPSBudWxsICYmIHJlbW92ZWRSYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9GTFVTSEVELCB7XG4gICAgICAgICAgICAgICAgdHlwZTogdHJhY2tOYW1lXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMudHJhY2tzW3RyYWNrTmFtZV0gPSB7XG4gICAgICAgICAgICBidWZmZXI6IHNiLFxuICAgICAgICAgICAgY29kZWM6IGNvZGVjLFxuICAgICAgICAgICAgY29udGFpbmVyOiB0cmFjay5jb250YWluZXIsXG4gICAgICAgICAgICBsZXZlbENvZGVjOiB0cmFjay5sZXZlbENvZGVjLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHRyYWNrLm1ldGFkYXRhLFxuICAgICAgICAgICAgaWQ6IHRyYWNrLmlkXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhpcy5lcnJvcihgZXJyb3Igd2hpbGUgdHJ5aW5nIHRvIGFkZCBzb3VyY2VCdWZmZXI6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuQlVGRkVSX0FERF9DT0RFQ19FUlJPUixcbiAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiBlcnIsXG4gICAgICAgICAgICBzb3VyY2VCdWZmZXJOYW1lOiB0cmFja05hbWUsXG4gICAgICAgICAgICBtaW1lVHlwZTogbWltZVR5cGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQgbWVkaWFTcmMoKSB7XG4gICAgdmFyIF90aGlzJG1lZGlhO1xuICAgIGNvbnN0IG1lZGlhID0gKChfdGhpcyRtZWRpYSA9IHRoaXMubWVkaWEpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRtZWRpYS5maXJzdENoaWxkKSB8fCB0aGlzLm1lZGlhO1xuICAgIHJldHVybiBtZWRpYSA9PSBudWxsID8gdm9pZCAwIDogbWVkaWEuc3JjO1xuICB9XG4gIF9vblNCVXBkYXRlU3RhcnQodHlwZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIG9wZXJhdGlvblF1ZXVlXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgb3BlcmF0aW9uID0gb3BlcmF0aW9uUXVldWUuY3VycmVudCh0eXBlKTtcbiAgICBvcGVyYXRpb24ub25TdGFydCgpO1xuICB9XG4gIF9vblNCVXBkYXRlRW5kKHR5cGUpIHtcbiAgICB2YXIgX3RoaXMkbWVkaWFTb3VyY2UyO1xuICAgIGlmICgoKF90aGlzJG1lZGlhU291cmNlMiA9IHRoaXMubWVkaWFTb3VyY2UpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRtZWRpYVNvdXJjZTIucmVhZHlTdGF0ZSkgPT09ICdjbG9zZWQnKSB7XG4gICAgICB0aGlzLnJlc2V0QnVmZmVyKHR5cGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBvcGVyYXRpb25RdWV1ZVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IG9wZXJhdGlvbiA9IG9wZXJhdGlvblF1ZXVlLmN1cnJlbnQodHlwZSk7XG4gICAgb3BlcmF0aW9uLm9uQ29tcGxldGUoKTtcbiAgICBvcGVyYXRpb25RdWV1ZS5zaGlmdEFuZEV4ZWN1dGVOZXh0KHR5cGUpO1xuICB9XG4gIF9vblNCVXBkYXRlRXJyb3IodHlwZSwgZXZlbnQpIHtcbiAgICB2YXIgX3RoaXMkbWVkaWFTb3VyY2UzO1xuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGAke3R5cGV9IFNvdXJjZUJ1ZmZlciBlcnJvci4gTWVkaWFTb3VyY2UgcmVhZHlTdGF0ZTogJHsoX3RoaXMkbWVkaWFTb3VyY2UzID0gdGhpcy5tZWRpYVNvdXJjZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG1lZGlhU291cmNlMy5yZWFkeVN0YXRlfWApO1xuICAgIHRoaXMuZXJyb3IoYCR7ZXJyb3J9YCwgZXZlbnQpO1xuICAgIC8vIGFjY29yZGluZyB0byBodHRwOi8vd3d3LnczLm9yZy9UUi9tZWRpYS1zb3VyY2UvI3NvdXJjZWJ1ZmZlci1hcHBlbmQtZXJyb3JcbiAgICAvLyBTb3VyY2VCdWZmZXIgZXJyb3JzIGFyZSBub3QgbmVjZXNzYXJpbHkgZmF0YWw7IGlmIHNvLCB0aGUgSFRNTE1lZGlhRWxlbWVudCB3aWxsIGZpcmUgYW4gZXJyb3IgZXZlbnRcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5FUlJPUiwge1xuICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfQVBQRU5ESU5HX0VSUk9SLFxuICAgICAgc291cmNlQnVmZmVyTmFtZTogdHlwZSxcbiAgICAgIGVycm9yLFxuICAgICAgZmF0YWw6IGZhbHNlXG4gICAgfSk7XG4gICAgLy8gdXBkYXRlZW5kIGlzIGFsd2F5cyBmaXJlZCBhZnRlciBlcnJvciwgc28gd2UnbGwgYWxsb3cgdGhhdCB0byBzaGlmdCB0aGUgY3VycmVudCBvcGVyYXRpb24gb2ZmIG9mIHRoZSBxdWV1ZVxuICAgIGNvbnN0IG9wZXJhdGlvbiA9IHRoaXMub3BlcmF0aW9uUXVldWUuY3VycmVudCh0eXBlKTtcbiAgICBpZiAob3BlcmF0aW9uKSB7XG4gICAgICBvcGVyYXRpb24ub25FcnJvcihlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgLy8gVGhpcyBtZXRob2QgbXVzdCByZXN1bHQgaW4gYW4gdXBkYXRlZW5kIGV2ZW50OyBpZiByZW1vdmUgaXMgbm90IGNhbGxlZCwgX29uU0JVcGRhdGVFbmQgbXVzdCBiZSBjYWxsZWQgbWFudWFsbHlcbiAgcmVtb3ZlRXhlY3V0b3IodHlwZSwgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1lZGlhLFxuICAgICAgbWVkaWFTb3VyY2UsXG4gICAgICBvcGVyYXRpb25RdWV1ZSxcbiAgICAgIHNvdXJjZUJ1ZmZlclxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHNiID0gc291cmNlQnVmZmVyW3R5cGVdO1xuICAgIGlmICghbWVkaWEgfHwgIW1lZGlhU291cmNlIHx8ICFzYikge1xuICAgICAgdGhpcy53YXJuKGBBdHRlbXB0aW5nIHRvIHJlbW92ZSBmcm9tIHRoZSAke3R5cGV9IFNvdXJjZUJ1ZmZlciwgYnV0IGl0IGRvZXMgbm90IGV4aXN0YCk7XG4gICAgICBvcGVyYXRpb25RdWV1ZS5zaGlmdEFuZEV4ZWN1dGVOZXh0KHR5cGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtZWRpYUR1cmF0aW9uID0gaXNGaW5pdGVOdW1iZXIobWVkaWEuZHVyYXRpb24pID8gbWVkaWEuZHVyYXRpb24gOiBJbmZpbml0eTtcbiAgICBjb25zdCBtc0R1cmF0aW9uID0gaXNGaW5pdGVOdW1iZXIobWVkaWFTb3VyY2UuZHVyYXRpb24pID8gbWVkaWFTb3VyY2UuZHVyYXRpb24gOiBJbmZpbml0eTtcbiAgICBjb25zdCByZW1vdmVTdGFydCA9IE1hdGgubWF4KDAsIHN0YXJ0T2Zmc2V0KTtcbiAgICBjb25zdCByZW1vdmVFbmQgPSBNYXRoLm1pbihlbmRPZmZzZXQsIG1lZGlhRHVyYXRpb24sIG1zRHVyYXRpb24pO1xuICAgIGlmIChyZW1vdmVFbmQgPiByZW1vdmVTdGFydCAmJiAoIXNiLmVuZGluZyB8fCBzYi5lbmRlZCkpIHtcbiAgICAgIHNiLmVuZGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmxvZyhgUmVtb3ZpbmcgWyR7cmVtb3ZlU3RhcnR9LCR7cmVtb3ZlRW5kfV0gZnJvbSB0aGUgJHt0eXBlfSBTb3VyY2VCdWZmZXJgKTtcbiAgICAgIHNiLnJlbW92ZShyZW1vdmVTdGFydCwgcmVtb3ZlRW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ3ljbGUgdGhlIHF1ZXVlXG4gICAgICBvcGVyYXRpb25RdWV1ZS5zaGlmdEFuZEV4ZWN1dGVOZXh0KHR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRoaXMgbWV0aG9kIG11c3QgcmVzdWx0IGluIGFuIHVwZGF0ZWVuZCBldmVudDsgaWYgYXBwZW5kIGlzIG5vdCBjYWxsZWQsIF9vblNCVXBkYXRlRW5kIG11c3QgYmUgY2FsbGVkIG1hbnVhbGx5XG4gIGFwcGVuZEV4ZWN1dG9yKGRhdGEsIHR5cGUpIHtcbiAgICBjb25zdCBzYiA9IHRoaXMuc291cmNlQnVmZmVyW3R5cGVdO1xuICAgIGlmICghc2IpIHtcbiAgICAgIGlmICghdGhpcy5wZW5kaW5nVHJhY2tzW3R5cGVdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQXR0ZW1wdGluZyB0byBhcHBlbmQgdG8gdGhlICR7dHlwZX0gU291cmNlQnVmZmVyLCBidXQgaXQgZG9lcyBub3QgZXhpc3RgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2IuZW5kZWQgPSBmYWxzZTtcbiAgICBzYi5hcHBlbmRCdWZmZXIoZGF0YSk7XG4gIH1cblxuICAvLyBFbnF1ZXVlcyBhbiBvcGVyYXRpb24gdG8gZWFjaCBTb3VyY2VCdWZmZXIgcXVldWUgd2hpY2gsIHVwb24gZXhlY3V0aW9uLCByZXNvbHZlcyBhIHByb21pc2UuIFdoZW4gYWxsIHByb21pc2VzXG4gIC8vIHJlc29sdmUsIHRoZSBvblVuYmxvY2tlZCBmdW5jdGlvbiBpcyBleGVjdXRlZC4gRnVuY3Rpb25zIGNhbGxpbmcgdGhpcyBtZXRob2QgZG8gbm90IG5lZWQgdG8gdW5ibG9jayB0aGUgcXVldWVcbiAgLy8gdXBvbiBjb21wbGV0aW9uLCBzaW5jZSB3ZSBhbHJlYWR5IGRvIGl0IGhlcmVcbiAgYmxvY2tCdWZmZXJzKG9uVW5ibG9ja2VkLCBidWZmZXJzID0gdGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpKSB7XG4gICAgaWYgKCFidWZmZXJzLmxlbmd0aCkge1xuICAgICAgdGhpcy5sb2coJ0Jsb2NraW5nIG9wZXJhdGlvbiByZXF1ZXN0ZWQsIGJ1dCBubyBTb3VyY2VCdWZmZXJzIGV4aXN0Jyk7XG4gICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKG9uVW5ibG9ja2VkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgb3BlcmF0aW9uUXVldWVcbiAgICB9ID0gdGhpcztcblxuICAgIC8vIGxvZ2dlci5kZWJ1ZyhgW2J1ZmZlci1jb250cm9sbGVyXTogQmxvY2tpbmcgJHtidWZmZXJzfSBTb3VyY2VCdWZmZXJgKTtcbiAgICBjb25zdCBibG9ja2luZ09wZXJhdGlvbnMgPSBidWZmZXJzLm1hcCh0eXBlID0+IG9wZXJhdGlvblF1ZXVlLmFwcGVuZEJsb2NrZXIodHlwZSkpO1xuICAgIFByb21pc2UuYWxsKGJsb2NraW5nT3BlcmF0aW9ucykudGhlbigoKSA9PiB7XG4gICAgICAvLyBsb2dnZXIuZGVidWcoYFtidWZmZXItY29udHJvbGxlcl06IEJsb2NraW5nIG9wZXJhdGlvbiByZXNvbHZlZDsgdW5ibG9ja2luZyAke2J1ZmZlcnN9IFNvdXJjZUJ1ZmZlcmApO1xuICAgICAgb25VbmJsb2NrZWQoKTtcbiAgICAgIGJ1ZmZlcnMuZm9yRWFjaCh0eXBlID0+IHtcbiAgICAgICAgY29uc3Qgc2IgPSB0aGlzLnNvdXJjZUJ1ZmZlclt0eXBlXTtcbiAgICAgICAgLy8gT25seSBjeWNsZSB0aGUgcXVldWUgaWYgdGhlIFNCIGlzIG5vdCB1cGRhdGluZy4gVGhlcmUncyBhIGJ1ZyBpbiBDaHJvbWUgd2hpY2ggc2V0cyB0aGUgU0IgdXBkYXRpbmcgZmxhZyB0b1xuICAgICAgICAvLyB0cnVlIHdoZW4gY2hhbmdpbmcgdGhlIE1lZGlhU291cmNlIGR1cmF0aW9uIChodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD05NTkzNTkmY2FuPTImcT1tZWRpYXNvdXJjZSUyMGR1cmF0aW9uKVxuICAgICAgICAvLyBXaGlsZSB0aGlzIGlzIGEgd29ya2Fyb3VuZCwgaXQncyBwcm9iYWJseSB1c2VmdWwgdG8gaGF2ZSBhcm91bmRcbiAgICAgICAgaWYgKCEoc2IgIT0gbnVsbCAmJiBzYi51cGRhdGluZykpIHtcbiAgICAgICAgICBvcGVyYXRpb25RdWV1ZS5zaGlmdEFuZEV4ZWN1dGVOZXh0KHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBnZXRTb3VyY2VCdWZmZXJUeXBlcygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5zb3VyY2VCdWZmZXIpO1xuICB9XG4gIGFkZEJ1ZmZlckxpc3RlbmVyKHR5cGUsIGV2ZW50LCBmbikge1xuICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuc291cmNlQnVmZmVyW3R5cGVdO1xuICAgIGlmICghYnVmZmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxpc3RlbmVyID0gZm4uYmluZCh0aGlzLCB0eXBlKTtcbiAgICB0aGlzLmxpc3RlbmVyc1t0eXBlXS5wdXNoKHtcbiAgICAgIGV2ZW50LFxuICAgICAgbGlzdGVuZXJcbiAgICB9KTtcbiAgICBidWZmZXIuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpO1xuICB9XG4gIHJlbW92ZUJ1ZmZlckxpc3RlbmVycyh0eXBlKSB7XG4gICAgY29uc3QgYnVmZmVyID0gdGhpcy5zb3VyY2VCdWZmZXJbdHlwZV07XG4gICAgaWYgKCFidWZmZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0uZm9yRWFjaChsID0+IHtcbiAgICAgIGJ1ZmZlci5yZW1vdmVFdmVudExpc3RlbmVyKGwuZXZlbnQsIGwubGlzdGVuZXIpO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiByZW1vdmVTb3VyY2VDaGlsZHJlbihub2RlKSB7XG4gIGNvbnN0IHNvdXJjZUNoaWxkcmVuID0gbm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdzb3VyY2UnKTtcbiAgW10uc2xpY2UuY2FsbChzb3VyY2VDaGlsZHJlbikuZm9yRWFjaChzb3VyY2UgPT4ge1xuICAgIG5vZGUucmVtb3ZlQ2hpbGQoc291cmNlKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBhZGRTb3VyY2UobWVkaWEsIHVybCkge1xuICBjb25zdCBzb3VyY2UgPSBzZWxmLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NvdXJjZScpO1xuICBzb3VyY2UudHlwZSA9ICd2aWRlby9tcDQnO1xuICBzb3VyY2Uuc3JjID0gdXJsO1xuICBtZWRpYS5hcHBlbmRDaGlsZChzb3VyY2UpO1xufVxuXG4vKipcbiAqXG4gKiBUaGlzIGNvZGUgd2FzIHBvcnRlZCBmcm9tIHRoZSBkYXNoLmpzIHByb2plY3QgYXQ6XG4gKiAgIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXNoLUluZHVzdHJ5LUZvcnVtL2Rhc2guanMvYmxvYi9kZXZlbG9wbWVudC9leHRlcm5hbHMvY2VhNjA4LXBhcnNlci5qc1xuICogICBodHRwczovL2dpdGh1Yi5jb20vRGFzaC1JbmR1c3RyeS1Gb3J1bS9kYXNoLmpzL2NvbW1pdC84MjY5YjI2YTc2MWUwODUzYmIyMWQ3ODc4MGVkOTQ1MTQ0ZWNkZDRkI2RpZmYtNzFiYzI5NWEyZDZiNmI3MDkzYTFkMzI5MGQ1M2E0YjJcbiAqXG4gKiBUaGUgb3JpZ2luYWwgY29weXJpZ2h0IGFwcGVhcnMgYmVsb3c6XG4gKlxuICogVGhlIGNvcHlyaWdodCBpbiB0aGlzIHNvZnR3YXJlIGlzIGJlaW5nIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZSBCU0QgTGljZW5zZSxcbiAqIGluY2x1ZGVkIGJlbG93LiBUaGlzIHNvZnR3YXJlIG1heSBiZSBzdWJqZWN0IHRvIG90aGVyIHRoaXJkIHBhcnR5IGFuZCBjb250cmlidXRvclxuICogcmlnaHRzLCBpbmNsdWRpbmcgcGF0ZW50IHJpZ2h0cywgYW5kIG5vIHN1Y2ggcmlnaHRzIGFyZSBncmFudGVkIHVuZGVyIHRoaXMgbGljZW5zZS5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtMjAxNiwgREFTSCBJbmR1c3RyeSBGb3J1bS5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcbiAqIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAqICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vclxuICogIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKiAgMi4gTmVpdGhlciB0aGUgbmFtZSBvZiBEYXNoIEluZHVzdHJ5IEZvcnVtIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZVxuICogIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIEFTIElTIEFORCBBTllcbiAqICBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG4gKiAgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELlxuICogIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsXG4gKiAgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVFxuICogIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAqICBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSxcbiAqICBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpXG4gKiAgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcbiAqICBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuLyoqXG4gKiAgRXhjZXB0aW9ucyBmcm9tIHJlZ3VsYXIgQVNDSUkuIENvZGVQb2ludHMgYXJlIG1hcHBlZCB0byBVVEYtMTYgY29kZXNcbiAqL1xuXG5jb25zdCBzcGVjaWFsQ2VhNjA4Q2hhcnNDb2RlcyA9IHtcbiAgMHgyYTogMHhlMSxcbiAgLy8gbG93ZXJjYXNlIGEsIGFjdXRlIGFjY2VudFxuICAweDVjOiAweGU5LFxuICAvLyBsb3dlcmNhc2UgZSwgYWN1dGUgYWNjZW50XG4gIDB4NWU6IDB4ZWQsXG4gIC8vIGxvd2VyY2FzZSBpLCBhY3V0ZSBhY2NlbnRcbiAgMHg1ZjogMHhmMyxcbiAgLy8gbG93ZXJjYXNlIG8sIGFjdXRlIGFjY2VudFxuICAweDYwOiAweGZhLFxuICAvLyBsb3dlcmNhc2UgdSwgYWN1dGUgYWNjZW50XG4gIDB4N2I6IDB4ZTcsXG4gIC8vIGxvd2VyY2FzZSBjIHdpdGggY2VkaWxsYVxuICAweDdjOiAweGY3LFxuICAvLyBkaXZpc2lvbiBzeW1ib2xcbiAgMHg3ZDogMHhkMSxcbiAgLy8gdXBwZXJjYXNlIE4gdGlsZGVcbiAgMHg3ZTogMHhmMSxcbiAgLy8gbG93ZXJjYXNlIG4gdGlsZGVcbiAgMHg3ZjogMHgyNTg4LFxuICAvLyBGdWxsIGJsb2NrXG4gIC8vIFRISVMgQkxPQ0sgSU5DTFVERVMgVEhFIDE2IEVYVEVOREVEIChUV08tQllURSkgTElORSAyMSBDSEFSQUNURVJTXG4gIC8vIFRIQVQgQ09NRSBGUk9NIEhJIEJZVEU9MHgxMSBBTkQgTE9XIEJFVFdFRU4gMHgzMCBBTkQgMHgzRlxuICAvLyBUSElTIE1FQU5TIFRIQVQgXFx4NTAgTVVTVCBCRSBBRERFRCBUTyBUSEUgVkFMVUVTXG4gIDB4ODA6IDB4YWUsXG4gIC8vIFJlZ2lzdGVyZWQgc3ltYm9sIChSKVxuICAweDgxOiAweGIwLFxuICAvLyBkZWdyZWUgc2lnblxuICAweDgyOiAweGJkLFxuICAvLyAxLzIgc3ltYm9sXG4gIDB4ODM6IDB4YmYsXG4gIC8vIEludmVydGVkIChvcGVuKSBxdWVzdGlvbiBtYXJrXG4gIDB4ODQ6IDB4MjEyMixcbiAgLy8gVHJhZGVtYXJrIHN5bWJvbCAoVE0pXG4gIDB4ODU6IDB4YTIsXG4gIC8vIENlbnRzIHN5bWJvbFxuICAweDg2OiAweGEzLFxuICAvLyBQb3VuZHMgc3RlcmxpbmdcbiAgMHg4NzogMHgyNjZhLFxuICAvLyBNdXNpYyA4J3RoIG5vdGVcbiAgMHg4ODogMHhlMCxcbiAgLy8gbG93ZXJjYXNlIGEsIGdyYXZlIGFjY2VudFxuICAweDg5OiAweDIwLFxuICAvLyB0cmFuc3BhcmVudCBzcGFjZSAocmVndWxhcilcbiAgMHg4YTogMHhlOCxcbiAgLy8gbG93ZXJjYXNlIGUsIGdyYXZlIGFjY2VudFxuICAweDhiOiAweGUyLFxuICAvLyBsb3dlcmNhc2UgYSwgY2lyY3VtZmxleCBhY2NlbnRcbiAgMHg4YzogMHhlYSxcbiAgLy8gbG93ZXJjYXNlIGUsIGNpcmN1bWZsZXggYWNjZW50XG4gIDB4OGQ6IDB4ZWUsXG4gIC8vIGxvd2VyY2FzZSBpLCBjaXJjdW1mbGV4IGFjY2VudFxuICAweDhlOiAweGY0LFxuICAvLyBsb3dlcmNhc2UgbywgY2lyY3VtZmxleCBhY2NlbnRcbiAgMHg4ZjogMHhmYixcbiAgLy8gbG93ZXJjYXNlIHUsIGNpcmN1bWZsZXggYWNjZW50XG4gIC8vIFRISVMgQkxPQ0sgSU5DTFVERVMgVEhFIDMyIEVYVEVOREVEIChUV08tQllURSkgTElORSAyMSBDSEFSQUNURVJTXG4gIC8vIFRIQVQgQ09NRSBGUk9NIEhJIEJZVEU9MHgxMiBBTkQgTE9XIEJFVFdFRU4gMHgyMCBBTkQgMHgzRlxuICAweDkwOiAweGMxLFxuICAvLyBjYXBpdGFsIGxldHRlciBBIHdpdGggYWN1dGVcbiAgMHg5MTogMHhjOSxcbiAgLy8gY2FwaXRhbCBsZXR0ZXIgRSB3aXRoIGFjdXRlXG4gIDB4OTI6IDB4ZDMsXG4gIC8vIGNhcGl0YWwgbGV0dGVyIE8gd2l0aCBhY3V0ZVxuICAweDkzOiAweGRhLFxuICAvLyBjYXBpdGFsIGxldHRlciBVIHdpdGggYWN1dGVcbiAgMHg5NDogMHhkYyxcbiAgLy8gY2FwaXRhbCBsZXR0ZXIgVSB3aXRoIGRpYXJlc2lzXG4gIDB4OTU6IDB4ZmMsXG4gIC8vIGxvd2VyY2FzZSBsZXR0ZXIgVSB3aXRoIGRpYWVyZXNpc1xuICAweDk2OiAweDIwMTgsXG4gIC8vIG9wZW5pbmcgc2luZ2xlIHF1b3RlXG4gIDB4OTc6IDB4YTEsXG4gIC8vIGludmVydGVkIGV4Y2xhbWF0aW9uIG1hcmtcbiAgMHg5ODogMHgyYSxcbiAgLy8gYXN0ZXJpc2tcbiAgMHg5OTogMHgyMDE5LFxuICAvLyBjbG9zaW5nIHNpbmdsZSBxdW90ZVxuICAweDlhOiAweDI1MDEsXG4gIC8vIGJveCBkcmF3aW5ncyBoZWF2eSBob3Jpem9udGFsXG4gIDB4OWI6IDB4YTksXG4gIC8vIGNvcHlyaWdodCBzaWduXG4gIDB4OWM6IDB4MjEyMCxcbiAgLy8gU2VydmljZSBtYXJrXG4gIDB4OWQ6IDB4MjAyMixcbiAgLy8gKHJvdW5kKSBidWxsZXRcbiAgMHg5ZTogMHgyMDFjLFxuICAvLyBMZWZ0IGRvdWJsZSBxdW90YXRpb24gbWFya1xuICAweDlmOiAweDIwMWQsXG4gIC8vIFJpZ2h0IGRvdWJsZSBxdW90YXRpb24gbWFya1xuICAweGEwOiAweGMwLFxuICAvLyB1cHBlcmNhc2UgQSwgZ3JhdmUgYWNjZW50XG4gIDB4YTE6IDB4YzIsXG4gIC8vIHVwcGVyY2FzZSBBLCBjaXJjdW1mbGV4XG4gIDB4YTI6IDB4YzcsXG4gIC8vIHVwcGVyY2FzZSBDIHdpdGggY2VkaWxsYVxuICAweGEzOiAweGM4LFxuICAvLyB1cHBlcmNhc2UgRSwgZ3JhdmUgYWNjZW50XG4gIDB4YTQ6IDB4Y2EsXG4gIC8vIHVwcGVyY2FzZSBFLCBjaXJjdW1mbGV4XG4gIDB4YTU6IDB4Y2IsXG4gIC8vIGNhcGl0YWwgbGV0dGVyIEUgd2l0aCBkaWFyZXNpc1xuICAweGE2OiAweGViLFxuICAvLyBsb3dlcmNhc2UgbGV0dGVyIGUgd2l0aCBkaWFyZXNpc1xuICAweGE3OiAweGNlLFxuICAvLyB1cHBlcmNhc2UgSSwgY2lyY3VtZmxleFxuICAweGE4OiAweGNmLFxuICAvLyB1cHBlcmNhc2UgSSwgd2l0aCBkaWFyZXNpc1xuICAweGE5OiAweGVmLFxuICAvLyBsb3dlcmNhc2UgaSwgd2l0aCBkaWFyZXNpc1xuICAweGFhOiAweGQ0LFxuICAvLyB1cHBlcmNhc2UgTywgY2lyY3VtZmxleFxuICAweGFiOiAweGQ5LFxuICAvLyB1cHBlcmNhc2UgVSwgZ3JhdmUgYWNjZW50XG4gIDB4YWM6IDB4ZjksXG4gIC8vIGxvd2VyY2FzZSB1LCBncmF2ZSBhY2NlbnRcbiAgMHhhZDogMHhkYixcbiAgLy8gdXBwZXJjYXNlIFUsIGNpcmN1bWZsZXhcbiAgMHhhZTogMHhhYixcbiAgLy8gbGVmdC1wb2ludGluZyBkb3VibGUgYW5nbGUgcXVvdGF0aW9uIG1hcmtcbiAgMHhhZjogMHhiYixcbiAgLy8gcmlnaHQtcG9pbnRpbmcgZG91YmxlIGFuZ2xlIHF1b3RhdGlvbiBtYXJrXG4gIC8vIFRISVMgQkxPQ0sgSU5DTFVERVMgVEhFIDMyIEVYVEVOREVEIChUV08tQllURSkgTElORSAyMSBDSEFSQUNURVJTXG4gIC8vIFRIQVQgQ09NRSBGUk9NIEhJIEJZVEU9MHgxMyBBTkQgTE9XIEJFVFdFRU4gMHgyMCBBTkQgMHgzRlxuICAweGIwOiAweGMzLFxuICAvLyBVcHBlcmNhc2UgQSwgdGlsZGVcbiAgMHhiMTogMHhlMyxcbiAgLy8gTG93ZXJjYXNlIGEsIHRpbGRlXG4gIDB4YjI6IDB4Y2QsXG4gIC8vIFVwcGVyY2FzZSBJLCBhY3V0ZSBhY2NlbnRcbiAgMHhiMzogMHhjYyxcbiAgLy8gVXBwZXJjYXNlIEksIGdyYXZlIGFjY2VudFxuICAweGI0OiAweGVjLFxuICAvLyBMb3dlcmNhc2UgaSwgZ3JhdmUgYWNjZW50XG4gIDB4YjU6IDB4ZDIsXG4gIC8vIFVwcGVyY2FzZSBPLCBncmF2ZSBhY2NlbnRcbiAgMHhiNjogMHhmMixcbiAgLy8gTG93ZXJjYXNlIG8sIGdyYXZlIGFjY2VudFxuICAweGI3OiAweGQ1LFxuICAvLyBVcHBlcmNhc2UgTywgdGlsZGVcbiAgMHhiODogMHhmNSxcbiAgLy8gTG93ZXJjYXNlIG8sIHRpbGRlXG4gIDB4Yjk6IDB4N2IsXG4gIC8vIE9wZW4gY3VybHkgYnJhY2VcbiAgMHhiYTogMHg3ZCxcbiAgLy8gQ2xvc2luZyBjdXJseSBicmFjZVxuICAweGJiOiAweDVjLFxuICAvLyBCYWNrc2xhc2hcbiAgMHhiYzogMHg1ZSxcbiAgLy8gQ2FyZXRcbiAgMHhiZDogMHg1ZixcbiAgLy8gVW5kZXJzY29yZVxuICAweGJlOiAweDdjLFxuICAvLyBQaXBlICh2ZXJ0aWNhbCBsaW5lKVxuICAweGJmOiAweDIyM2MsXG4gIC8vIFRpbGRlIG9wZXJhdG9yXG4gIDB4YzA6IDB4YzQsXG4gIC8vIFVwcGVyY2FzZSBBLCB1bWxhdXRcbiAgMHhjMTogMHhlNCxcbiAgLy8gTG93ZXJjYXNlIEEsIHVtbGF1dFxuICAweGMyOiAweGQ2LFxuICAvLyBVcHBlcmNhc2UgTywgdW1sYXV0XG4gIDB4YzM6IDB4ZjYsXG4gIC8vIExvd2VyY2FzZSBvLCB1bWxhdXRcbiAgMHhjNDogMHhkZixcbiAgLy8gRXNzemV0dCAoc2hhcnAgUylcbiAgMHhjNTogMHhhNSxcbiAgLy8gWWVuIHN5bWJvbFxuICAweGM2OiAweGE0LFxuICAvLyBHZW5lcmljIGN1cnJlbmN5IHNpZ25cbiAgMHhjNzogMHgyNTAzLFxuICAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgdmVydGljYWxcbiAgMHhjODogMHhjNSxcbiAgLy8gVXBwZXJjYXNlIEEsIHJpbmdcbiAgMHhjOTogMHhlNSxcbiAgLy8gTG93ZXJjYXNlIEEsIHJpbmdcbiAgMHhjYTogMHhkOCxcbiAgLy8gVXBwZXJjYXNlIE8sIHN0cm9rZVxuICAweGNiOiAweGY4LFxuICAvLyBMb3dlcmNhc2Ugbywgc3Ryb2tcbiAgMHhjYzogMHgyNTBmLFxuICAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgZG93biBhbmQgcmlnaHRcbiAgMHhjZDogMHgyNTEzLFxuICAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgZG93biBhbmQgbGVmdFxuICAweGNlOiAweDI1MTcsXG4gIC8vIEJveCBkcmF3aW5ncyBoZWF2eSB1cCBhbmQgcmlnaHRcbiAgMHhjZjogMHgyNTFiIC8vIEJveCBkcmF3aW5ncyBoZWF2eSB1cCBhbmQgbGVmdFxufTtcblxuLyoqXG4gKiBVdGlsc1xuICovXG5jb25zdCBnZXRDaGFyRm9yQnl0ZSA9IGZ1bmN0aW9uIGdldENoYXJGb3JCeXRlKGJ5dGUpIHtcbiAgbGV0IGNoYXJDb2RlID0gYnl0ZTtcbiAgaWYgKHNwZWNpYWxDZWE2MDhDaGFyc0NvZGVzLmhhc093blByb3BlcnR5KGJ5dGUpKSB7XG4gICAgY2hhckNvZGUgPSBzcGVjaWFsQ2VhNjA4Q2hhcnNDb2Rlc1tieXRlXTtcbiAgfVxuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG59O1xuY29uc3QgTlJfUk9XUyA9IDE1O1xuY29uc3QgTlJfQ09MUyA9IDEwMDtcbi8vIFRhYmxlcyB0byBsb29rIHVwIHJvdyBmcm9tIFBBQyBkYXRhXG5jb25zdCByb3dzTG93Q2gxID0ge1xuICAweDExOiAxLFxuICAweDEyOiAzLFxuICAweDE1OiA1LFxuICAweDE2OiA3LFxuICAweDE3OiA5LFxuICAweDEwOiAxMSxcbiAgMHgxMzogMTIsXG4gIDB4MTQ6IDE0XG59O1xuY29uc3Qgcm93c0hpZ2hDaDEgPSB7XG4gIDB4MTE6IDIsXG4gIDB4MTI6IDQsXG4gIDB4MTU6IDYsXG4gIDB4MTY6IDgsXG4gIDB4MTc6IDEwLFxuICAweDEzOiAxMyxcbiAgMHgxNDogMTVcbn07XG5jb25zdCByb3dzTG93Q2gyID0ge1xuICAweDE5OiAxLFxuICAweDFhOiAzLFxuICAweDFkOiA1LFxuICAweDFlOiA3LFxuICAweDFmOiA5LFxuICAweDE4OiAxMSxcbiAgMHgxYjogMTIsXG4gIDB4MWM6IDE0XG59O1xuY29uc3Qgcm93c0hpZ2hDaDIgPSB7XG4gIDB4MTk6IDIsXG4gIDB4MWE6IDQsXG4gIDB4MWQ6IDYsXG4gIDB4MWU6IDgsXG4gIDB4MWY6IDEwLFxuICAweDFiOiAxMyxcbiAgMHgxYzogMTVcbn07XG5jb25zdCBiYWNrZ3JvdW5kQ29sb3JzID0gWyd3aGl0ZScsICdncmVlbicsICdibHVlJywgJ2N5YW4nLCAncmVkJywgJ3llbGxvdycsICdtYWdlbnRhJywgJ2JsYWNrJywgJ3RyYW5zcGFyZW50J107XG5jbGFzcyBDYXB0aW9uc0xvZ2dlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMudGltZSA9IG51bGw7XG4gICAgdGhpcy52ZXJib3NlTGV2ZWwgPSAwO1xuICB9XG4gIGxvZyhzZXZlcml0eSwgbXNnKSB7XG4gICAgaWYgKHRoaXMudmVyYm9zZUxldmVsID49IHNldmVyaXR5KSB7XG4gICAgICBjb25zdCBtID0gdHlwZW9mIG1zZyA9PT0gJ2Z1bmN0aW9uJyA/IG1zZygpIDogbXNnO1xuICAgICAgbG9nZ2VyLmxvZyhgJHt0aGlzLnRpbWV9IFske3NldmVyaXR5fV0gJHttfWApO1xuICAgIH1cbiAgfVxufVxuY29uc3QgbnVtQXJyYXlUb0hleEFycmF5ID0gZnVuY3Rpb24gbnVtQXJyYXlUb0hleEFycmF5KG51bUFycmF5KSB7XG4gIGNvbnN0IGhleEFycmF5ID0gW107XG4gIGZvciAobGV0IGogPSAwOyBqIDwgbnVtQXJyYXkubGVuZ3RoOyBqKyspIHtcbiAgICBoZXhBcnJheS5wdXNoKG51bUFycmF5W2pdLnRvU3RyaW5nKDE2KSk7XG4gIH1cbiAgcmV0dXJuIGhleEFycmF5O1xufTtcbmNsYXNzIFBlblN0YXRlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5mb3JlZ3JvdW5kID0gJ3doaXRlJztcbiAgICB0aGlzLnVuZGVybGluZSA9IGZhbHNlO1xuICAgIHRoaXMuaXRhbGljcyA9IGZhbHNlO1xuICAgIHRoaXMuYmFja2dyb3VuZCA9ICdibGFjayc7XG4gICAgdGhpcy5mbGFzaCA9IGZhbHNlO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuZm9yZWdyb3VuZCA9ICd3aGl0ZSc7XG4gICAgdGhpcy51bmRlcmxpbmUgPSBmYWxzZTtcbiAgICB0aGlzLml0YWxpY3MgPSBmYWxzZTtcbiAgICB0aGlzLmJhY2tncm91bmQgPSAnYmxhY2snO1xuICAgIHRoaXMuZmxhc2ggPSBmYWxzZTtcbiAgfVxuICBzZXRTdHlsZXMoc3R5bGVzKSB7XG4gICAgY29uc3QgYXR0cmlicyA9IFsnZm9yZWdyb3VuZCcsICd1bmRlcmxpbmUnLCAnaXRhbGljcycsICdiYWNrZ3JvdW5kJywgJ2ZsYXNoJ107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdHRyaWJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzdHlsZSA9IGF0dHJpYnNbaV07XG4gICAgICBpZiAoc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlKSkge1xuICAgICAgICB0aGlzW3N0eWxlXSA9IHN0eWxlc1tzdHlsZV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlzRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gdGhpcy5mb3JlZ3JvdW5kID09PSAnd2hpdGUnICYmICF0aGlzLnVuZGVybGluZSAmJiAhdGhpcy5pdGFsaWNzICYmIHRoaXMuYmFja2dyb3VuZCA9PT0gJ2JsYWNrJyAmJiAhdGhpcy5mbGFzaDtcbiAgfVxuICBlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5mb3JlZ3JvdW5kID09PSBvdGhlci5mb3JlZ3JvdW5kICYmIHRoaXMudW5kZXJsaW5lID09PSBvdGhlci51bmRlcmxpbmUgJiYgdGhpcy5pdGFsaWNzID09PSBvdGhlci5pdGFsaWNzICYmIHRoaXMuYmFja2dyb3VuZCA9PT0gb3RoZXIuYmFja2dyb3VuZCAmJiB0aGlzLmZsYXNoID09PSBvdGhlci5mbGFzaDtcbiAgfVxuICBjb3B5KG5ld1BlblN0YXRlKSB7XG4gICAgdGhpcy5mb3JlZ3JvdW5kID0gbmV3UGVuU3RhdGUuZm9yZWdyb3VuZDtcbiAgICB0aGlzLnVuZGVybGluZSA9IG5ld1BlblN0YXRlLnVuZGVybGluZTtcbiAgICB0aGlzLml0YWxpY3MgPSBuZXdQZW5TdGF0ZS5pdGFsaWNzO1xuICAgIHRoaXMuYmFja2dyb3VuZCA9IG5ld1BlblN0YXRlLmJhY2tncm91bmQ7XG4gICAgdGhpcy5mbGFzaCA9IG5ld1BlblN0YXRlLmZsYXNoO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnY29sb3I9JyArIHRoaXMuZm9yZWdyb3VuZCArICcsIHVuZGVybGluZT0nICsgdGhpcy51bmRlcmxpbmUgKyAnLCBpdGFsaWNzPScgKyB0aGlzLml0YWxpY3MgKyAnLCBiYWNrZ3JvdW5kPScgKyB0aGlzLmJhY2tncm91bmQgKyAnLCBmbGFzaD0nICsgdGhpcy5mbGFzaDtcbiAgfVxufVxuXG4vKipcbiAqIFVuaWNvZGUgY2hhcmFjdGVyIHdpdGggc3R5bGluZyBhbmQgYmFja2dyb3VuZC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBTdHlsZWRVbmljb2RlQ2hhciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMudWNoYXIgPSAnICc7XG4gICAgdGhpcy5wZW5TdGF0ZSA9IG5ldyBQZW5TdGF0ZSgpO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMudWNoYXIgPSAnICc7XG4gICAgdGhpcy5wZW5TdGF0ZS5yZXNldCgpO1xuICB9XG4gIHNldENoYXIodWNoYXIsIG5ld1BlblN0YXRlKSB7XG4gICAgdGhpcy51Y2hhciA9IHVjaGFyO1xuICAgIHRoaXMucGVuU3RhdGUuY29weShuZXdQZW5TdGF0ZSk7XG4gIH1cbiAgc2V0UGVuU3RhdGUobmV3UGVuU3RhdGUpIHtcbiAgICB0aGlzLnBlblN0YXRlLmNvcHkobmV3UGVuU3RhdGUpO1xuICB9XG4gIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzLnVjaGFyID09PSBvdGhlci51Y2hhciAmJiB0aGlzLnBlblN0YXRlLmVxdWFscyhvdGhlci5wZW5TdGF0ZSk7XG4gIH1cbiAgY29weShuZXdDaGFyKSB7XG4gICAgdGhpcy51Y2hhciA9IG5ld0NoYXIudWNoYXI7XG4gICAgdGhpcy5wZW5TdGF0ZS5jb3B5KG5ld0NoYXIucGVuU3RhdGUpO1xuICB9XG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMudWNoYXIgPT09ICcgJyAmJiB0aGlzLnBlblN0YXRlLmlzRGVmYXVsdCgpO1xuICB9XG59XG5cbi8qKlxuICogQ0VBLTYwOCByb3cgY29uc2lzdGluZyBvZiBOUl9DT0xTIGluc3RhbmNlcyBvZiBTdHlsZWRVbmljb2RlQ2hhci5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBSb3cge1xuICBjb25zdHJ1Y3Rvcihsb2dnZXIpIHtcbiAgICB0aGlzLmNoYXJzID0gW107XG4gICAgdGhpcy5wb3MgPSAwO1xuICAgIHRoaXMuY3VyclBlblN0YXRlID0gbmV3IFBlblN0YXRlKCk7XG4gICAgdGhpcy5jdWVTdGFydFRpbWUgPSBudWxsO1xuICAgIHRoaXMubG9nZ2VyID0gdm9pZCAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlJfQ09MUzsgaSsrKSB7XG4gICAgICB0aGlzLmNoYXJzLnB1c2gobmV3IFN0eWxlZFVuaWNvZGVDaGFyKCkpO1xuICAgIH1cbiAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgfVxuICBlcXVhbHMob3RoZXIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5SX0NPTFM7IGkrKykge1xuICAgICAgaWYgKCF0aGlzLmNoYXJzW2ldLmVxdWFscyhvdGhlci5jaGFyc1tpXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb3B5KG90aGVyKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOUl9DT0xTOyBpKyspIHtcbiAgICAgIHRoaXMuY2hhcnNbaV0uY29weShvdGhlci5jaGFyc1tpXSk7XG4gICAgfVxuICB9XG4gIGlzRW1wdHkoKSB7XG4gICAgbGV0IGVtcHR5ID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5SX0NPTFM7IGkrKykge1xuICAgICAgaWYgKCF0aGlzLmNoYXJzW2ldLmlzRW1wdHkoKSkge1xuICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVtcHR5O1xuICB9XG5cbiAgLyoqXG4gICAqICBTZXQgdGhlIGN1cnNvciB0byBhIHZhbGlkIGNvbHVtbi5cbiAgICovXG4gIHNldEN1cnNvcihhYnNQb3MpIHtcbiAgICBpZiAodGhpcy5wb3MgIT09IGFic1Bvcykge1xuICAgICAgdGhpcy5wb3MgPSBhYnNQb3M7XG4gICAgfVxuICAgIGlmICh0aGlzLnBvcyA8IDApIHtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZygzLCAnTmVnYXRpdmUgY3Vyc29yIHBvc2l0aW9uICcgKyB0aGlzLnBvcyk7XG4gICAgICB0aGlzLnBvcyA9IDA7XG4gICAgfSBlbHNlIGlmICh0aGlzLnBvcyA+IE5SX0NPTFMpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZygzLCAnVG9vIGxhcmdlIGN1cnNvciBwb3NpdGlvbiAnICsgdGhpcy5wb3MpO1xuICAgICAgdGhpcy5wb3MgPSBOUl9DT0xTO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlIHRoZSBjdXJzb3IgcmVsYXRpdmUgdG8gY3VycmVudCBwb3NpdGlvbi5cbiAgICovXG4gIG1vdmVDdXJzb3IocmVsUG9zKSB7XG4gICAgY29uc3QgbmV3UG9zID0gdGhpcy5wb3MgKyByZWxQb3M7XG4gICAgaWYgKHJlbFBvcyA+IDEpIHtcbiAgICAgIGZvciAobGV0IGkgPSB0aGlzLnBvcyArIDE7IGkgPCBuZXdQb3MgKyAxOyBpKyspIHtcbiAgICAgICAgdGhpcy5jaGFyc1tpXS5zZXRQZW5TdGF0ZSh0aGlzLmN1cnJQZW5TdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuc2V0Q3Vyc29yKG5ld1Bvcyk7XG4gIH1cblxuICAvKipcbiAgICogQmFja3NwYWNlLCBtb3ZlIG9uZSBzdGVwIGJhY2sgYW5kIGNsZWFyIGNoYXJhY3Rlci5cbiAgICovXG4gIGJhY2tTcGFjZSgpIHtcbiAgICB0aGlzLm1vdmVDdXJzb3IoLTEpO1xuICAgIHRoaXMuY2hhcnNbdGhpcy5wb3NdLnNldENoYXIoJyAnLCB0aGlzLmN1cnJQZW5TdGF0ZSk7XG4gIH1cbiAgaW5zZXJ0Q2hhcihieXRlKSB7XG4gICAgaWYgKGJ5dGUgPj0gMHg5MCkge1xuICAgICAgLy8gRXh0ZW5kZWQgY2hhclxuICAgICAgdGhpcy5iYWNrU3BhY2UoKTtcbiAgICB9XG4gICAgY29uc3QgY2hhciA9IGdldENoYXJGb3JCeXRlKGJ5dGUpO1xuICAgIGlmICh0aGlzLnBvcyA+PSBOUl9DT0xTKSB7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coMCwgKCkgPT4gJ0Nhbm5vdCBpbnNlcnQgJyArIGJ5dGUudG9TdHJpbmcoMTYpICsgJyAoJyArIGNoYXIgKyAnKSBhdCBwb3NpdGlvbiAnICsgdGhpcy5wb3MgKyAnLiBTa2lwcGluZyBpdCEnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jaGFyc1t0aGlzLnBvc10uc2V0Q2hhcihjaGFyLCB0aGlzLmN1cnJQZW5TdGF0ZSk7XG4gICAgdGhpcy5tb3ZlQ3Vyc29yKDEpO1xuICB9XG4gIGNsZWFyRnJvbVBvcyhzdGFydFBvcykge1xuICAgIGxldCBpO1xuICAgIGZvciAoaSA9IHN0YXJ0UG9zOyBpIDwgTlJfQ09MUzsgaSsrKSB7XG4gICAgICB0aGlzLmNoYXJzW2ldLnJlc2V0KCk7XG4gICAgfVxuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMuY2xlYXJGcm9tUG9zKDApO1xuICAgIHRoaXMucG9zID0gMDtcbiAgICB0aGlzLmN1cnJQZW5TdGF0ZS5yZXNldCgpO1xuICB9XG4gIGNsZWFyVG9FbmRPZlJvdygpIHtcbiAgICB0aGlzLmNsZWFyRnJvbVBvcyh0aGlzLnBvcyk7XG4gIH1cbiAgZ2V0VGV4dFN0cmluZygpIHtcbiAgICBjb25zdCBjaGFycyA9IFtdO1xuICAgIGxldCBlbXB0eSA9IHRydWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOUl9DT0xTOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoYXIgPSB0aGlzLmNoYXJzW2ldLnVjaGFyO1xuICAgICAgaWYgKGNoYXIgIT09ICcgJykge1xuICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgY2hhcnMucHVzaChjaGFyKTtcbiAgICB9XG4gICAgaWYgKGVtcHR5KSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjaGFycy5qb2luKCcnKTtcbiAgICB9XG4gIH1cbiAgc2V0UGVuU3R5bGVzKHN0eWxlcykge1xuICAgIHRoaXMuY3VyclBlblN0YXRlLnNldFN0eWxlcyhzdHlsZXMpO1xuICAgIGNvbnN0IGN1cnJDaGFyID0gdGhpcy5jaGFyc1t0aGlzLnBvc107XG4gICAgY3VyckNoYXIuc2V0UGVuU3RhdGUodGhpcy5jdXJyUGVuU3RhdGUpO1xuICB9XG59XG5cbi8qKlxuICogS2VlcCBhIENFQS02MDggc2NyZWVuIG9mIDMyeDE1IHN0eWxlZCBjaGFyYWN0ZXJzXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgQ2FwdGlvblNjcmVlbiB7XG4gIGNvbnN0cnVjdG9yKGxvZ2dlcikge1xuICAgIHRoaXMucm93cyA9IFtdO1xuICAgIHRoaXMuY3VyclJvdyA9IE5SX1JPV1MgLSAxO1xuICAgIHRoaXMubnJSb2xsVXBSb3dzID0gbnVsbDtcbiAgICB0aGlzLmxhc3RPdXRwdXRTY3JlZW4gPSBudWxsO1xuICAgIHRoaXMubG9nZ2VyID0gdm9pZCAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlJfUk9XUzsgaSsrKSB7XG4gICAgICB0aGlzLnJvd3MucHVzaChuZXcgUm93KGxvZ2dlcikpO1xuICAgIH1cbiAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgfVxuICByZXNldCgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5SX1JPV1M7IGkrKykge1xuICAgICAgdGhpcy5yb3dzW2ldLmNsZWFyKCk7XG4gICAgfVxuICAgIHRoaXMuY3VyclJvdyA9IE5SX1JPV1MgLSAxO1xuICB9XG4gIGVxdWFscyhvdGhlcikge1xuICAgIGxldCBlcXVhbCA9IHRydWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOUl9ST1dTOyBpKyspIHtcbiAgICAgIGlmICghdGhpcy5yb3dzW2ldLmVxdWFscyhvdGhlci5yb3dzW2ldKSkge1xuICAgICAgICBlcXVhbCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVxdWFsO1xuICB9XG4gIGNvcHkob3RoZXIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5SX1JPV1M7IGkrKykge1xuICAgICAgdGhpcy5yb3dzW2ldLmNvcHkob3RoZXIucm93c1tpXSk7XG4gICAgfVxuICB9XG4gIGlzRW1wdHkoKSB7XG4gICAgbGV0IGVtcHR5ID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5SX1JPV1M7IGkrKykge1xuICAgICAgaWYgKCF0aGlzLnJvd3NbaV0uaXNFbXB0eSgpKSB7XG4gICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW1wdHk7XG4gIH1cbiAgYmFja1NwYWNlKCkge1xuICAgIGNvbnN0IHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgIHJvdy5iYWNrU3BhY2UoKTtcbiAgfVxuICBjbGVhclRvRW5kT2ZSb3coKSB7XG4gICAgY29uc3Qgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgcm93LmNsZWFyVG9FbmRPZlJvdygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydCBhIGNoYXJhY3RlciAod2l0aG91dCBzdHlsaW5nKSBpbiB0aGUgY3VycmVudCByb3cuXG4gICAqL1xuICBpbnNlcnRDaGFyKGNoYXIpIHtcbiAgICBjb25zdCByb3cgPSB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XTtcbiAgICByb3cuaW5zZXJ0Q2hhcihjaGFyKTtcbiAgfVxuICBzZXRQZW4oc3R5bGVzKSB7XG4gICAgY29uc3Qgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgcm93LnNldFBlblN0eWxlcyhzdHlsZXMpO1xuICB9XG4gIG1vdmVDdXJzb3IocmVsUG9zKSB7XG4gICAgY29uc3Qgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgcm93Lm1vdmVDdXJzb3IocmVsUG9zKTtcbiAgfVxuICBzZXRDdXJzb3IoYWJzUG9zKSB7XG4gICAgdGhpcy5sb2dnZXIubG9nKDIsICdzZXRDdXJzb3I6ICcgKyBhYnNQb3MpO1xuICAgIGNvbnN0IHJvdyA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgIHJvdy5zZXRDdXJzb3IoYWJzUG9zKTtcbiAgfVxuICBzZXRQQUMocGFjRGF0YSkge1xuICAgIHRoaXMubG9nZ2VyLmxvZygyLCAoKSA9PiAncGFjRGF0YSA9ICcgKyBKU09OLnN0cmluZ2lmeShwYWNEYXRhKSk7XG4gICAgbGV0IG5ld1JvdyA9IHBhY0RhdGEucm93IC0gMTtcbiAgICBpZiAodGhpcy5uclJvbGxVcFJvd3MgJiYgbmV3Um93IDwgdGhpcy5uclJvbGxVcFJvd3MgLSAxKSB7XG4gICAgICBuZXdSb3cgPSB0aGlzLm5yUm9sbFVwUm93cyAtIDE7XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIHRoaXMgb25seSBhZmZlY3RzIFJvbGwtdXAgQ2FwdGlvbnMgYnkgY2hlY2tpbmcgdGhpcy5uclJvbGxVcFJvd3NcbiAgICBpZiAodGhpcy5uclJvbGxVcFJvd3MgJiYgdGhpcy5jdXJyUm93ICE9PSBuZXdSb3cpIHtcbiAgICAgIC8vIGNsZWFyIGFsbCByb3dzIGZpcnN0XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5SX1JPV1M7IGkrKykge1xuICAgICAgICB0aGlzLnJvd3NbaV0uY2xlYXIoKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ29weSB0aGlzLm5yUm9sbFVwUm93cyByb3dzIGZyb20gbGFzdE91dHB1dFNjcmVlbiBhbmQgcGxhY2UgaXQgaW4gdGhlIG5ld1JvdyBsb2NhdGlvblxuICAgICAgLy8gdG9wUm93SW5kZXggLSB0aGUgc3RhcnQgb2Ygcm93cyB0byBjb3B5IChpbmNsdXNpdmUgaW5kZXgpXG4gICAgICBjb25zdCB0b3BSb3dJbmRleCA9IHRoaXMuY3VyclJvdyArIDEgLSB0aGlzLm5yUm9sbFVwUm93cztcbiAgICAgIC8vIFdlIG9ubHkgY29weSBpZiB0aGUgbGFzdCBwb3NpdGlvbiB3YXMgYWxyZWFkeSBzaG93bi5cbiAgICAgIC8vIFdlIHVzZSB0aGUgY3VlU3RhcnRUaW1lIHZhbHVlIHRvIGNoZWNrIHRoaXMuXG4gICAgICBjb25zdCBsYXN0T3V0cHV0U2NyZWVuID0gdGhpcy5sYXN0T3V0cHV0U2NyZWVuO1xuICAgICAgaWYgKGxhc3RPdXRwdXRTY3JlZW4pIHtcbiAgICAgICAgY29uc3QgcHJldkxpbmVUaW1lID0gbGFzdE91dHB1dFNjcmVlbi5yb3dzW3RvcFJvd0luZGV4XS5jdWVTdGFydFRpbWU7XG4gICAgICAgIGNvbnN0IHRpbWUgPSB0aGlzLmxvZ2dlci50aW1lO1xuICAgICAgICBpZiAocHJldkxpbmVUaW1lICE9PSBudWxsICYmIHRpbWUgIT09IG51bGwgJiYgcHJldkxpbmVUaW1lIDwgdGltZSkge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uclJvbGxVcFJvd3M7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5yb3dzW25ld1JvdyAtIHRoaXMubnJSb2xsVXBSb3dzICsgaSArIDFdLmNvcHkobGFzdE91dHB1dFNjcmVlbi5yb3dzW3RvcFJvd0luZGV4ICsgaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmN1cnJSb3cgPSBuZXdSb3c7XG4gICAgY29uc3Qgcm93ID0gdGhpcy5yb3dzW3RoaXMuY3VyclJvd107XG4gICAgaWYgKHBhY0RhdGEuaW5kZW50ICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBpbmRlbnQgPSBwYWNEYXRhLmluZGVudDtcbiAgICAgIGNvbnN0IHByZXZQb3MgPSBNYXRoLm1heChpbmRlbnQgLSAxLCAwKTtcbiAgICAgIHJvdy5zZXRDdXJzb3IocGFjRGF0YS5pbmRlbnQpO1xuICAgICAgcGFjRGF0YS5jb2xvciA9IHJvdy5jaGFyc1twcmV2UG9zXS5wZW5TdGF0ZS5mb3JlZ3JvdW5kO1xuICAgIH1cbiAgICBjb25zdCBzdHlsZXMgPSB7XG4gICAgICBmb3JlZ3JvdW5kOiBwYWNEYXRhLmNvbG9yLFxuICAgICAgdW5kZXJsaW5lOiBwYWNEYXRhLnVuZGVybGluZSxcbiAgICAgIGl0YWxpY3M6IHBhY0RhdGEuaXRhbGljcyxcbiAgICAgIGJhY2tncm91bmQ6ICdibGFjaycsXG4gICAgICBmbGFzaDogZmFsc2VcbiAgICB9O1xuICAgIHRoaXMuc2V0UGVuKHN0eWxlcyk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IGJhY2tncm91bmQvZXh0cmEgZm9yZWdyb3VuZCwgYnV0IGZpcnN0IGRvIGJhY2tfc3BhY2UsIGFuZCB0aGVuIGluc2VydCBzcGFjZSAoYmFja3dhcmRzIGNvbXBhdGliaWxpdHkpLlxuICAgKi9cbiAgc2V0QmtnRGF0YShia2dEYXRhKSB7XG4gICAgdGhpcy5sb2dnZXIubG9nKDIsICgpID0+ICdia2dEYXRhID0gJyArIEpTT04uc3RyaW5naWZ5KGJrZ0RhdGEpKTtcbiAgICB0aGlzLmJhY2tTcGFjZSgpO1xuICAgIHRoaXMuc2V0UGVuKGJrZ0RhdGEpO1xuICAgIHRoaXMuaW5zZXJ0Q2hhcigweDIwKTsgLy8gU3BhY2VcbiAgfVxuICBzZXRSb2xsVXBSb3dzKG5yUm93cykge1xuICAgIHRoaXMubnJSb2xsVXBSb3dzID0gbnJSb3dzO1xuICB9XG4gIHJvbGxVcCgpIHtcbiAgICBpZiAodGhpcy5uclJvbGxVcFJvd3MgPT09IG51bGwpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZygzLCAncm9sbF91cCBidXQgbnJSb2xsVXBSb3dzIG5vdCBzZXQgeWV0Jyk7XG4gICAgICByZXR1cm47IC8vIE5vdCBwcm9wZXJseSBzZXR1cFxuICAgIH1cbiAgICB0aGlzLmxvZ2dlci5sb2coMSwgKCkgPT4gdGhpcy5nZXREaXNwbGF5VGV4dCgpKTtcbiAgICBjb25zdCB0b3BSb3dJbmRleCA9IHRoaXMuY3VyclJvdyArIDEgLSB0aGlzLm5yUm9sbFVwUm93cztcbiAgICBjb25zdCB0b3BSb3cgPSB0aGlzLnJvd3Muc3BsaWNlKHRvcFJvd0luZGV4LCAxKVswXTtcbiAgICB0b3BSb3cuY2xlYXIoKTtcbiAgICB0aGlzLnJvd3Muc3BsaWNlKHRoaXMuY3VyclJvdywgMCwgdG9wUm93KTtcbiAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ1JvbGxpbmcgdXAnKTtcbiAgICAvLyB0aGlzLmxvZ2dlci5sb2coVmVyYm9zZUxldmVsLlRFWFQsIHRoaXMuZ2V0X2Rpc3BsYXlfdGV4dCgpKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbGwgbm9uLWVtcHR5IHJvd3Mgd2l0aCBhcyB1bmljb2RlIHRleHQuXG4gICAqL1xuICBnZXREaXNwbGF5VGV4dChhc09uZVJvdykge1xuICAgIGFzT25lUm93ID0gYXNPbmVSb3cgfHwgZmFsc2U7XG4gICAgY29uc3QgZGlzcGxheVRleHQgPSBbXTtcbiAgICBsZXQgdGV4dCA9ICcnO1xuICAgIGxldCByb3dOciA9IC0xO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTlJfUk9XUzsgaSsrKSB7XG4gICAgICBjb25zdCByb3dUZXh0ID0gdGhpcy5yb3dzW2ldLmdldFRleHRTdHJpbmcoKTtcbiAgICAgIGlmIChyb3dUZXh0KSB7XG4gICAgICAgIHJvd05yID0gaSArIDE7XG4gICAgICAgIGlmIChhc09uZVJvdykge1xuICAgICAgICAgIGRpc3BsYXlUZXh0LnB1c2goJ1JvdyAnICsgcm93TnIgKyBcIjogJ1wiICsgcm93VGV4dCArIFwiJ1wiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkaXNwbGF5VGV4dC5wdXNoKHJvd1RleHQudHJpbSgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGlzcGxheVRleHQubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKGFzT25lUm93KSB7XG4gICAgICAgIHRleHQgPSAnWycgKyBkaXNwbGF5VGV4dC5qb2luKCcgfCAnKSArICddJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHQgPSBkaXNwbGF5VGV4dC5qb2luKCdcXG4nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cbiAgZ2V0VGV4dEFuZEZvcm1hdCgpIHtcbiAgICByZXR1cm4gdGhpcy5yb3dzO1xuICB9XG59XG5cbi8vIHZhciBtb2RlcyA9IFsnTU9ERV9ST0xMLVVQJywgJ01PREVfUE9QLU9OJywgJ01PREVfUEFJTlQtT04nLCAnTU9ERV9URVhUJ107XG5cbmNsYXNzIENlYTYwOENoYW5uZWwge1xuICBjb25zdHJ1Y3RvcihjaGFubmVsTnVtYmVyLCBvdXRwdXRGaWx0ZXIsIGxvZ2dlcikge1xuICAgIHRoaXMuY2hOciA9IHZvaWQgMDtcbiAgICB0aGlzLm91dHB1dEZpbHRlciA9IHZvaWQgMDtcbiAgICB0aGlzLm1vZGUgPSB2b2lkIDA7XG4gICAgdGhpcy52ZXJib3NlID0gdm9pZCAwO1xuICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5ID0gdm9pZCAwO1xuICAgIHRoaXMubm9uRGlzcGxheWVkTWVtb3J5ID0gdm9pZCAwO1xuICAgIHRoaXMubGFzdE91dHB1dFNjcmVlbiA9IHZvaWQgMDtcbiAgICB0aGlzLmN1cnJSb2xsVXBSb3cgPSB2b2lkIDA7XG4gICAgdGhpcy53cml0ZVNjcmVlbiA9IHZvaWQgMDtcbiAgICB0aGlzLmN1ZVN0YXJ0VGltZSA9IHZvaWQgMDtcbiAgICB0aGlzLmxvZ2dlciA9IHZvaWQgMDtcbiAgICB0aGlzLmNoTnIgPSBjaGFubmVsTnVtYmVyO1xuICAgIHRoaXMub3V0cHV0RmlsdGVyID0gb3V0cHV0RmlsdGVyO1xuICAgIHRoaXMubW9kZSA9IG51bGw7XG4gICAgdGhpcy52ZXJib3NlID0gMDtcbiAgICB0aGlzLmRpc3BsYXllZE1lbW9yeSA9IG5ldyBDYXB0aW9uU2NyZWVuKGxvZ2dlcik7XG4gICAgdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnkgPSBuZXcgQ2FwdGlvblNjcmVlbihsb2dnZXIpO1xuICAgIHRoaXMubGFzdE91dHB1dFNjcmVlbiA9IG5ldyBDYXB0aW9uU2NyZWVuKGxvZ2dlcik7XG4gICAgdGhpcy5jdXJyUm9sbFVwUm93ID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnkucm93c1tOUl9ST1dTIC0gMV07XG4gICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xuICAgIHRoaXMubW9kZSA9IG51bGw7XG4gICAgdGhpcy5jdWVTdGFydFRpbWUgPSBudWxsOyAvLyBLZWVwcyB0cmFjayBvZiB3aGVyZSBhIGN1ZSBzdGFydGVkLlxuICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMubW9kZSA9IG51bGw7XG4gICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkucmVzZXQoKTtcbiAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeS5yZXNldCgpO1xuICAgIHRoaXMubGFzdE91dHB1dFNjcmVlbi5yZXNldCgpO1xuICAgIHRoaXMub3V0cHV0RmlsdGVyLnJlc2V0KCk7XG4gICAgdGhpcy5jdXJyUm9sbFVwUm93ID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnkucm93c1tOUl9ST1dTIC0gMV07XG4gICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xuICAgIHRoaXMubW9kZSA9IG51bGw7XG4gICAgdGhpcy5jdWVTdGFydFRpbWUgPSBudWxsO1xuICB9XG4gIGdldEhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMub3V0cHV0RmlsdGVyO1xuICB9XG4gIHNldEhhbmRsZXIobmV3SGFuZGxlcikge1xuICAgIHRoaXMub3V0cHV0RmlsdGVyID0gbmV3SGFuZGxlcjtcbiAgfVxuICBzZXRQQUMocGFjRGF0YSkge1xuICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0UEFDKHBhY0RhdGEpO1xuICB9XG4gIHNldEJrZ0RhdGEoYmtnRGF0YSkge1xuICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0QmtnRGF0YShia2dEYXRhKTtcbiAgfVxuICBzZXRNb2RlKG5ld01vZGUpIHtcbiAgICBpZiAobmV3TW9kZSA9PT0gdGhpcy5tb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubW9kZSA9IG5ld01vZGU7XG4gICAgdGhpcy5sb2dnZXIubG9nKDIsICgpID0+ICdNT0RFPScgKyBuZXdNb2RlKTtcbiAgICBpZiAodGhpcy5tb2RlID09PSAnTU9ERV9QT1AtT04nKSB7XG4gICAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLmRpc3BsYXllZE1lbW9yeTtcbiAgICAgIHRoaXMud3JpdGVTY3JlZW4ucmVzZXQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubW9kZSAhPT0gJ01PREVfUk9MTC1VUCcpIHtcbiAgICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5Lm5yUm9sbFVwUm93cyA9IG51bGw7XG4gICAgICB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeS5uclJvbGxVcFJvd3MgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLm1vZGUgPSBuZXdNb2RlO1xuICB9XG4gIGluc2VydENoYXJzKGNoYXJzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53cml0ZVNjcmVlbi5pbnNlcnRDaGFyKGNoYXJzW2ldKTtcbiAgICB9XG4gICAgY29uc3Qgc2NyZWVuID0gdGhpcy53cml0ZVNjcmVlbiA9PT0gdGhpcy5kaXNwbGF5ZWRNZW1vcnkgPyAnRElTUCcgOiAnTk9OX0RJU1AnO1xuICAgIHRoaXMubG9nZ2VyLmxvZygyLCAoKSA9PiBzY3JlZW4gKyAnOiAnICsgdGhpcy53cml0ZVNjcmVlbi5nZXREaXNwbGF5VGV4dCh0cnVlKSk7XG4gICAgaWYgKHRoaXMubW9kZSA9PT0gJ01PREVfUEFJTlQtT04nIHx8IHRoaXMubW9kZSA9PT0gJ01PREVfUk9MTC1VUCcpIHtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZygxLCAoKSA9PiAnRElTUExBWUVEOiAnICsgdGhpcy5kaXNwbGF5ZWRNZW1vcnkuZ2V0RGlzcGxheVRleHQodHJ1ZSkpO1xuICAgICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKCk7XG4gICAgfVxuICB9XG4gIGNjUkNMKCkge1xuICAgIC8vIFJlc3VtZSBDYXB0aW9uIExvYWRpbmcgKHN3aXRjaCBtb2RlIHRvIFBvcCBPbilcbiAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ1JDTCAtIFJlc3VtZSBDYXB0aW9uIExvYWRpbmcnKTtcbiAgICB0aGlzLnNldE1vZGUoJ01PREVfUE9QLU9OJyk7XG4gIH1cbiAgY2NCUygpIHtcbiAgICAvLyBCYWNrU3BhY2VcbiAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ0JTIC0gQmFja1NwYWNlJyk7XG4gICAgaWYgKHRoaXMubW9kZSA9PT0gJ01PREVfVEVYVCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy53cml0ZVNjcmVlbi5iYWNrU3BhY2UoKTtcbiAgICBpZiAodGhpcy53cml0ZVNjcmVlbiA9PT0gdGhpcy5kaXNwbGF5ZWRNZW1vcnkpIHtcbiAgICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSgpO1xuICAgIH1cbiAgfVxuICBjY0FPRigpIHtcbiAgICAvLyBSZXNlcnZlZCAoZm9ybWVybHkgQWxhcm0gT2ZmKVxuICB9XG4gIGNjQU9OKCkge1xuICAgIC8vIFJlc2VydmVkIChmb3JtZXJseSBBbGFybSBPbilcbiAgfVxuICBjY0RFUigpIHtcbiAgICAvLyBEZWxldGUgdG8gRW5kIG9mIFJvd1xuICAgIHRoaXMubG9nZ2VyLmxvZygyLCAnREVSLSBEZWxldGUgdG8gRW5kIG9mIFJvdycpO1xuICAgIHRoaXMud3JpdGVTY3JlZW4uY2xlYXJUb0VuZE9mUm93KCk7XG4gICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKCk7XG4gIH1cbiAgY2NSVShuclJvd3MpIHtcbiAgICAvLyBSb2xsLVVwIENhcHRpb25zLTIsMyxvciA0IFJvd3NcbiAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ1JVKCcgKyBuclJvd3MgKyAnKSAtIFJvbGwgVXAnKTtcbiAgICB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnk7XG4gICAgdGhpcy5zZXRNb2RlKCdNT0RFX1JPTEwtVVAnKTtcbiAgICB0aGlzLndyaXRlU2NyZWVuLnNldFJvbGxVcFJvd3MobnJSb3dzKTtcbiAgfVxuICBjY0ZPTigpIHtcbiAgICAvLyBGbGFzaCBPblxuICAgIHRoaXMubG9nZ2VyLmxvZygyLCAnRk9OIC0gRmxhc2ggT24nKTtcbiAgICB0aGlzLndyaXRlU2NyZWVuLnNldFBlbih7XG4gICAgICBmbGFzaDogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIGNjUkRDKCkge1xuICAgIC8vIFJlc3VtZSBEaXJlY3QgQ2FwdGlvbmluZyAoc3dpdGNoIG1vZGUgdG8gUGFpbnRPbilcbiAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ1JEQyAtIFJlc3VtZSBEaXJlY3QgQ2FwdGlvbmluZycpO1xuICAgIHRoaXMuc2V0TW9kZSgnTU9ERV9QQUlOVC1PTicpO1xuICB9XG4gIGNjVFIoKSB7XG4gICAgLy8gVGV4dCBSZXN0YXJ0IGluIHRleHQgbW9kZSAobm90IHN1cHBvcnRlZCwgaG93ZXZlcilcbiAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ1RSJyk7XG4gICAgdGhpcy5zZXRNb2RlKCdNT0RFX1RFWFQnKTtcbiAgfVxuICBjY1JURCgpIHtcbiAgICAvLyBSZXN1bWUgVGV4dCBEaXNwbGF5IGluIFRleHQgbW9kZSAobm90IHN1cHBvcnRlZCwgaG93ZXZlcilcbiAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ1JURCcpO1xuICAgIHRoaXMuc2V0TW9kZSgnTU9ERV9URVhUJyk7XG4gIH1cbiAgY2NFRE0oKSB7XG4gICAgLy8gRXJhc2UgRGlzcGxheWVkIE1lbW9yeVxuICAgIHRoaXMubG9nZ2VyLmxvZygyLCAnRURNIC0gRXJhc2UgRGlzcGxheWVkIE1lbW9yeScpO1xuICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5LnJlc2V0KCk7XG4gICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKHRydWUpO1xuICB9XG4gIGNjQ1IoKSB7XG4gICAgLy8gQ2FycmlhZ2UgUmV0dXJuXG4gICAgdGhpcy5sb2dnZXIubG9nKDIsICdDUiAtIENhcnJpYWdlIFJldHVybicpO1xuICAgIHRoaXMud3JpdGVTY3JlZW4ucm9sbFVwKCk7XG4gICAgdGhpcy5vdXRwdXREYXRhVXBkYXRlKHRydWUpO1xuICB9XG4gIGNjRU5NKCkge1xuICAgIC8vIEVyYXNlIE5vbi1EaXNwbGF5ZWQgTWVtb3J5XG4gICAgdGhpcy5sb2dnZXIubG9nKDIsICdFTk0gLSBFcmFzZSBOb24tZGlzcGxheWVkIE1lbW9yeScpO1xuICAgIHRoaXMubm9uRGlzcGxheWVkTWVtb3J5LnJlc2V0KCk7XG4gIH1cbiAgY2NFT0MoKSB7XG4gICAgLy8gRW5kIG9mIENhcHRpb24gKEZsaXAgTWVtb3JpZXMpXG4gICAgdGhpcy5sb2dnZXIubG9nKDIsICdFT0MgLSBFbmQgT2YgQ2FwdGlvbicpO1xuICAgIGlmICh0aGlzLm1vZGUgPT09ICdNT0RFX1BPUC1PTicpIHtcbiAgICAgIGNvbnN0IHRtcCA9IHRoaXMuZGlzcGxheWVkTWVtb3J5O1xuICAgICAgdGhpcy5kaXNwbGF5ZWRNZW1vcnkgPSB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeTtcbiAgICAgIHRoaXMubm9uRGlzcGxheWVkTWVtb3J5ID0gdG1wO1xuICAgICAgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMubm9uRGlzcGxheWVkTWVtb3J5O1xuICAgICAgdGhpcy5sb2dnZXIubG9nKDEsICgpID0+ICdESVNQOiAnICsgdGhpcy5kaXNwbGF5ZWRNZW1vcnkuZ2V0RGlzcGxheVRleHQoKSk7XG4gICAgfVxuICAgIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSh0cnVlKTtcbiAgfVxuICBjY1RPKG5yQ29scykge1xuICAgIC8vIFRhYiBPZmZzZXQgMSwyLCBvciAzIGNvbHVtbnNcbiAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ1RPKCcgKyBuckNvbHMgKyAnKSAtIFRhYiBPZmZzZXQnKTtcbiAgICB0aGlzLndyaXRlU2NyZWVuLm1vdmVDdXJzb3IobnJDb2xzKTtcbiAgfVxuICBjY01JRFJPVyhzZWNvbmRCeXRlKSB7XG4gICAgLy8gUGFyc2UgTUlEUk9XIGNvbW1hbmRcbiAgICBjb25zdCBzdHlsZXMgPSB7XG4gICAgICBmbGFzaDogZmFsc2VcbiAgICB9O1xuICAgIHN0eWxlcy51bmRlcmxpbmUgPSBzZWNvbmRCeXRlICUgMiA9PT0gMTtcbiAgICBzdHlsZXMuaXRhbGljcyA9IHNlY29uZEJ5dGUgPj0gMHgyZTtcbiAgICBpZiAoIXN0eWxlcy5pdGFsaWNzKSB7XG4gICAgICBjb25zdCBjb2xvckluZGV4ID0gTWF0aC5mbG9vcihzZWNvbmRCeXRlIC8gMikgLSAweDEwO1xuICAgICAgY29uc3QgY29sb3JzID0gWyd3aGl0ZScsICdncmVlbicsICdibHVlJywgJ2N5YW4nLCAncmVkJywgJ3llbGxvdycsICdtYWdlbnRhJ107XG4gICAgICBzdHlsZXMuZm9yZWdyb3VuZCA9IGNvbG9yc1tjb2xvckluZGV4XTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVzLmZvcmVncm91bmQgPSAnd2hpdGUnO1xuICAgIH1cbiAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ01JRFJPVzogJyArIEpTT04uc3RyaW5naWZ5KHN0eWxlcykpO1xuICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0UGVuKHN0eWxlcyk7XG4gIH1cbiAgb3V0cHV0RGF0YVVwZGF0ZShkaXNwYXRjaCA9IGZhbHNlKSB7XG4gICAgY29uc3QgdGltZSA9IHRoaXMubG9nZ2VyLnRpbWU7XG4gICAgaWYgKHRpbWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMub3V0cHV0RmlsdGVyKSB7XG4gICAgICBpZiAodGhpcy5jdWVTdGFydFRpbWUgPT09IG51bGwgJiYgIXRoaXMuZGlzcGxheWVkTWVtb3J5LmlzRW1wdHkoKSkge1xuICAgICAgICAvLyBTdGFydCBvZiBhIG5ldyBjdWVcbiAgICAgICAgdGhpcy5jdWVTdGFydFRpbWUgPSB0aW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF0aGlzLmRpc3BsYXllZE1lbW9yeS5lcXVhbHModGhpcy5sYXN0T3V0cHV0U2NyZWVuKSkge1xuICAgICAgICAgIHRoaXMub3V0cHV0RmlsdGVyLm5ld0N1ZSh0aGlzLmN1ZVN0YXJ0VGltZSwgdGltZSwgdGhpcy5sYXN0T3V0cHV0U2NyZWVuKTtcbiAgICAgICAgICBpZiAoZGlzcGF0Y2ggJiYgdGhpcy5vdXRwdXRGaWx0ZXIuZGlzcGF0Y2hDdWUpIHtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0RmlsdGVyLmRpc3BhdGNoQ3VlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnkuaXNFbXB0eSgpID8gbnVsbCA6IHRpbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubGFzdE91dHB1dFNjcmVlbi5jb3B5KHRoaXMuZGlzcGxheWVkTWVtb3J5KTtcbiAgICB9XG4gIH1cbiAgY3VlU3BsaXRBdFRpbWUodCkge1xuICAgIGlmICh0aGlzLm91dHB1dEZpbHRlcikge1xuICAgICAgaWYgKCF0aGlzLmRpc3BsYXllZE1lbW9yeS5pc0VtcHR5KCkpIHtcbiAgICAgICAgaWYgKHRoaXMub3V0cHV0RmlsdGVyLm5ld0N1ZSkge1xuICAgICAgICAgIHRoaXMub3V0cHV0RmlsdGVyLm5ld0N1ZSh0aGlzLmN1ZVN0YXJ0VGltZSwgdCwgdGhpcy5kaXNwbGF5ZWRNZW1vcnkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VlU3RhcnRUaW1lID0gdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gV2lsbCBiZSAxIG9yIDIgd2hlbiBwYXJzaW5nIGNhcHRpb25zXG5cbmNsYXNzIENlYTYwOFBhcnNlciB7XG4gIGNvbnN0cnVjdG9yKGZpZWxkLCBvdXQxLCBvdXQyKSB7XG4gICAgdGhpcy5jaGFubmVscyA9IHZvaWQgMDtcbiAgICB0aGlzLmN1cnJlbnRDaGFubmVsID0gMDtcbiAgICB0aGlzLmNtZEhpc3RvcnkgPSBjcmVhdGVDbWRIaXN0b3J5KCk7XG4gICAgdGhpcy5sb2dnZXIgPSB2b2lkIDA7XG4gICAgY29uc3QgbG9nZ2VyID0gdGhpcy5sb2dnZXIgPSBuZXcgQ2FwdGlvbnNMb2dnZXIoKTtcbiAgICB0aGlzLmNoYW5uZWxzID0gW251bGwsIG5ldyBDZWE2MDhDaGFubmVsKGZpZWxkLCBvdXQxLCBsb2dnZXIpLCBuZXcgQ2VhNjA4Q2hhbm5lbChmaWVsZCArIDEsIG91dDIsIGxvZ2dlcildO1xuICB9XG4gIGdldEhhbmRsZXIoY2hhbm5lbCkge1xuICAgIHJldHVybiB0aGlzLmNoYW5uZWxzW2NoYW5uZWxdLmdldEhhbmRsZXIoKTtcbiAgfVxuICBzZXRIYW5kbGVyKGNoYW5uZWwsIG5ld0hhbmRsZXIpIHtcbiAgICB0aGlzLmNoYW5uZWxzW2NoYW5uZWxdLnNldEhhbmRsZXIobmV3SGFuZGxlcik7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGRhdGEgZm9yIHRpbWUgdCBpbiBmb3JtcyBvZiBsaXN0IG9mIGJ5dGVzICh1bnNpZ25lZCBpbnRzKS4gVGhlIGJ5dGVzIGFyZSB0cmVhdGVkIGFzIHBhaXJzLlxuICAgKi9cbiAgYWRkRGF0YSh0aW1lLCBieXRlTGlzdCkge1xuICAgIGxldCBjbWRGb3VuZDtcbiAgICBsZXQgYTtcbiAgICBsZXQgYjtcbiAgICBsZXQgY2hhcnNGb3VuZCA9IGZhbHNlO1xuICAgIHRoaXMubG9nZ2VyLnRpbWUgPSB0aW1lO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZUxpc3QubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGEgPSBieXRlTGlzdFtpXSAmIDB4N2Y7XG4gICAgICBiID0gYnl0ZUxpc3RbaSArIDFdICYgMHg3ZjtcbiAgICAgIGlmIChhID09PSAwICYmIGIgPT09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coMywgJ1snICsgbnVtQXJyYXlUb0hleEFycmF5KFtieXRlTGlzdFtpXSwgYnl0ZUxpc3RbaSArIDFdXSkgKyAnXSAtPiAoJyArIG51bUFycmF5VG9IZXhBcnJheShbYSwgYl0pICsgJyknKTtcbiAgICAgIH1cbiAgICAgIGNtZEZvdW5kID0gdGhpcy5wYXJzZUNtZChhLCBiKTtcbiAgICAgIGlmICghY21kRm91bmQpIHtcbiAgICAgICAgY21kRm91bmQgPSB0aGlzLnBhcnNlTWlkcm93KGEsIGIpO1xuICAgICAgfVxuICAgICAgaWYgKCFjbWRGb3VuZCkge1xuICAgICAgICBjbWRGb3VuZCA9IHRoaXMucGFyc2VQQUMoYSwgYik7XG4gICAgICB9XG4gICAgICBpZiAoIWNtZEZvdW5kKSB7XG4gICAgICAgIGNtZEZvdW5kID0gdGhpcy5wYXJzZUJhY2tncm91bmRBdHRyaWJ1dGVzKGEsIGIpO1xuICAgICAgfVxuICAgICAgaWYgKCFjbWRGb3VuZCkge1xuICAgICAgICBjaGFyc0ZvdW5kID0gdGhpcy5wYXJzZUNoYXJzKGEsIGIpO1xuICAgICAgICBpZiAoY2hhcnNGb3VuZCkge1xuICAgICAgICAgIGNvbnN0IGN1cnJDaE5yID0gdGhpcy5jdXJyZW50Q2hhbm5lbDtcbiAgICAgICAgICBpZiAoY3VyckNoTnIgJiYgY3VyckNoTnIgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tjdXJyQ2hOcl07XG4gICAgICAgICAgICBjaGFubmVsLmluc2VydENoYXJzKGNoYXJzRm91bmQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coMiwgJ05vIGNoYW5uZWwgZm91bmQgeWV0LiBURVhULU1PREU/Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWNtZEZvdW5kICYmICFjaGFyc0ZvdW5kKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZygyLCBcIkNvdWxkbid0IHBhcnNlIGNsZWFuZWQgZGF0YSBcIiArIG51bUFycmF5VG9IZXhBcnJheShbYSwgYl0pICsgJyBvcmlnOiAnICsgbnVtQXJyYXlUb0hleEFycmF5KFtieXRlTGlzdFtpXSwgYnl0ZUxpc3RbaSArIDFdXSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBDb21tYW5kLlxuICAgKiBAcmV0dXJucyBUcnVlIGlmIGEgY29tbWFuZCB3YXMgZm91bmRcbiAgICovXG4gIHBhcnNlQ21kKGEsIGIpIHtcbiAgICBjb25zdCB7XG4gICAgICBjbWRIaXN0b3J5XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgY29uZDEgPSAoYSA9PT0gMHgxNCB8fCBhID09PSAweDFjIHx8IGEgPT09IDB4MTUgfHwgYSA9PT0gMHgxZCkgJiYgYiA+PSAweDIwICYmIGIgPD0gMHgyZjtcbiAgICBjb25zdCBjb25kMiA9IChhID09PSAweDE3IHx8IGEgPT09IDB4MWYpICYmIGIgPj0gMHgyMSAmJiBiIDw9IDB4MjM7XG4gICAgaWYgKCEoY29uZDEgfHwgY29uZDIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChoYXNDbWRSZXBlYXRlZChhLCBiLCBjbWRIaXN0b3J5KSkge1xuICAgICAgc2V0TGFzdENtZChudWxsLCBudWxsLCBjbWRIaXN0b3J5KTtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZygzLCAnUmVwZWF0ZWQgY29tbWFuZCAoJyArIG51bUFycmF5VG9IZXhBcnJheShbYSwgYl0pICsgJykgaXMgZHJvcHBlZCcpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGNoTnIgPSBhID09PSAweDE0IHx8IGEgPT09IDB4MTUgfHwgYSA9PT0gMHgxNyA/IDEgOiAyO1xuICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2NoTnJdO1xuICAgIGlmIChhID09PSAweDE0IHx8IGEgPT09IDB4MTUgfHwgYSA9PT0gMHgxYyB8fCBhID09PSAweDFkKSB7XG4gICAgICBpZiAoYiA9PT0gMHgyMCkge1xuICAgICAgICBjaGFubmVsLmNjUkNMKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjEpIHtcbiAgICAgICAgY2hhbm5lbC5jY0JTKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjIpIHtcbiAgICAgICAgY2hhbm5lbC5jY0FPRigpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDIzKSB7XG4gICAgICAgIGNoYW5uZWwuY2NBT04oKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyNCkge1xuICAgICAgICBjaGFubmVsLmNjREVSKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjUpIHtcbiAgICAgICAgY2hhbm5lbC5jY1JVKDIpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDI2KSB7XG4gICAgICAgIGNoYW5uZWwuY2NSVSgzKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyNykge1xuICAgICAgICBjaGFubmVsLmNjUlUoNCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MjgpIHtcbiAgICAgICAgY2hhbm5lbC5jY0ZPTigpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDI5KSB7XG4gICAgICAgIGNoYW5uZWwuY2NSREMoKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyYSkge1xuICAgICAgICBjaGFubmVsLmNjVFIoKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyYikge1xuICAgICAgICBjaGFubmVsLmNjUlREKCk7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IDB4MmMpIHtcbiAgICAgICAgY2hhbm5lbC5jY0VETSgpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDJkKSB7XG4gICAgICAgIGNoYW5uZWwuY2NDUigpO1xuICAgICAgfSBlbHNlIGlmIChiID09PSAweDJlKSB7XG4gICAgICAgIGNoYW5uZWwuY2NFTk0oKTtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyZikge1xuICAgICAgICBjaGFubmVsLmNjRU9DKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGEgPT0gMHgxNyB8fCBhID09IDB4MUZcbiAgICAgIGNoYW5uZWwuY2NUTyhiIC0gMHgyMCk7XG4gICAgfVxuICAgIHNldExhc3RDbWQoYSwgYiwgY21kSGlzdG9yeSk7XG4gICAgdGhpcy5jdXJyZW50Q2hhbm5lbCA9IGNoTnI7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgbWlkcm93IHN0eWxpbmcgY29tbWFuZFxuICAgKi9cbiAgcGFyc2VNaWRyb3coYSwgYikge1xuICAgIGxldCBjaE5yID0gMDtcbiAgICBpZiAoKGEgPT09IDB4MTEgfHwgYSA9PT0gMHgxOSkgJiYgYiA+PSAweDIwICYmIGIgPD0gMHgyZikge1xuICAgICAgaWYgKGEgPT09IDB4MTEpIHtcbiAgICAgICAgY2hOciA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaE5yID0gMjtcbiAgICAgIH1cbiAgICAgIGlmIChjaE5yICE9PSB0aGlzLmN1cnJlbnRDaGFubmVsKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZygwLCAnTWlzbWF0Y2ggY2hhbm5lbCBpbiBtaWRyb3cgcGFyc2luZycpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tjaE5yXTtcbiAgICAgIGlmICghY2hhbm5lbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjaGFubmVsLmNjTUlEUk9XKGIpO1xuICAgICAgdGhpcy5sb2dnZXIubG9nKDMsICdNSURST1cgKCcgKyBudW1BcnJheVRvSGV4QXJyYXkoW2EsIGJdKSArICcpJyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIFByZWFibGUgQWNjZXNzIENvZGVzIChUYWJsZSA1MykuXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBUZWxscyBpZiBQQUMgZm91bmRcbiAgICovXG4gIHBhcnNlUEFDKGEsIGIpIHtcbiAgICBsZXQgcm93O1xuICAgIGNvbnN0IGNtZEhpc3RvcnkgPSB0aGlzLmNtZEhpc3Rvcnk7XG4gICAgY29uc3QgY2FzZTEgPSAoYSA+PSAweDExICYmIGEgPD0gMHgxNyB8fCBhID49IDB4MTkgJiYgYSA8PSAweDFmKSAmJiBiID49IDB4NDAgJiYgYiA8PSAweDdmO1xuICAgIGNvbnN0IGNhc2UyID0gKGEgPT09IDB4MTAgfHwgYSA9PT0gMHgxOCkgJiYgYiA+PSAweDQwICYmIGIgPD0gMHg1ZjtcbiAgICBpZiAoIShjYXNlMSB8fCBjYXNlMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGhhc0NtZFJlcGVhdGVkKGEsIGIsIGNtZEhpc3RvcnkpKSB7XG4gICAgICBzZXRMYXN0Q21kKG51bGwsIG51bGwsIGNtZEhpc3RvcnkpO1xuICAgICAgcmV0dXJuIHRydWU7IC8vIFJlcGVhdGVkIGNvbW1hbmRzIGFyZSBkcm9wcGVkIChvbmNlKVxuICAgIH1cbiAgICBjb25zdCBjaE5yID0gYSA8PSAweDE3ID8gMSA6IDI7XG4gICAgaWYgKGIgPj0gMHg0MCAmJiBiIDw9IDB4NWYpIHtcbiAgICAgIHJvdyA9IGNoTnIgPT09IDEgPyByb3dzTG93Q2gxW2FdIDogcm93c0xvd0NoMlthXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gMHg2MCA8PSBiIDw9IDB4N0ZcbiAgICAgIHJvdyA9IGNoTnIgPT09IDEgPyByb3dzSGlnaENoMVthXSA6IHJvd3NIaWdoQ2gyW2FdO1xuICAgIH1cbiAgICBjb25zdCBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tjaE5yXTtcbiAgICBpZiAoIWNoYW5uZWwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY2hhbm5lbC5zZXRQQUModGhpcy5pbnRlcnByZXRQQUMocm93LCBiKSk7XG4gICAgc2V0TGFzdENtZChhLCBiLCBjbWRIaXN0b3J5KTtcbiAgICB0aGlzLmN1cnJlbnRDaGFubmVsID0gY2hOcjtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcnByZXQgdGhlIHNlY29uZCBieXRlIG9mIHRoZSBwYWMsIGFuZCByZXR1cm4gdGhlIGluZm9ybWF0aW9uLlxuICAgKiBAcmV0dXJucyBwYWNEYXRhIHdpdGggc3R5bGUgcGFyYW1ldGVyc1xuICAgKi9cbiAgaW50ZXJwcmV0UEFDKHJvdywgYnl0ZSkge1xuICAgIGxldCBwYWNJbmRleDtcbiAgICBjb25zdCBwYWNEYXRhID0ge1xuICAgICAgY29sb3I6IG51bGwsXG4gICAgICBpdGFsaWNzOiBmYWxzZSxcbiAgICAgIGluZGVudDogbnVsbCxcbiAgICAgIHVuZGVybGluZTogZmFsc2UsXG4gICAgICByb3c6IHJvd1xuICAgIH07XG4gICAgaWYgKGJ5dGUgPiAweDVmKSB7XG4gICAgICBwYWNJbmRleCA9IGJ5dGUgLSAweDYwO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWNJbmRleCA9IGJ5dGUgLSAweDQwO1xuICAgIH1cbiAgICBwYWNEYXRhLnVuZGVybGluZSA9IChwYWNJbmRleCAmIDEpID09PSAxO1xuICAgIGlmIChwYWNJbmRleCA8PSAweGQpIHtcbiAgICAgIHBhY0RhdGEuY29sb3IgPSBbJ3doaXRlJywgJ2dyZWVuJywgJ2JsdWUnLCAnY3lhbicsICdyZWQnLCAneWVsbG93JywgJ21hZ2VudGEnLCAnd2hpdGUnXVtNYXRoLmZsb29yKHBhY0luZGV4IC8gMildO1xuICAgIH0gZWxzZSBpZiAocGFjSW5kZXggPD0gMHhmKSB7XG4gICAgICBwYWNEYXRhLml0YWxpY3MgPSB0cnVlO1xuICAgICAgcGFjRGF0YS5jb2xvciA9ICd3aGl0ZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhY0RhdGEuaW5kZW50ID0gTWF0aC5mbG9vcigocGFjSW5kZXggLSAweDEwKSAvIDIpICogNDtcbiAgICB9XG4gICAgcmV0dXJuIHBhY0RhdGE7IC8vIE5vdGUgdGhhdCByb3cgaGFzIHplcm8gb2Zmc2V0LiBUaGUgc3BlYyB1c2VzIDEuXG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgY2hhcmFjdGVycy5cbiAgICogQHJldHVybnMgQW4gYXJyYXkgd2l0aCAxIHRvIDIgY29kZXMgY29ycmVzcG9uZGluZyB0byBjaGFycywgaWYgZm91bmQuIG51bGwgb3RoZXJ3aXNlLlxuICAgKi9cbiAgcGFyc2VDaGFycyhhLCBiKSB7XG4gICAgbGV0IGNoYW5uZWxOcjtcbiAgICBsZXQgY2hhckNvZGVzID0gbnVsbDtcbiAgICBsZXQgY2hhckNvZGUxID0gbnVsbDtcbiAgICBpZiAoYSA+PSAweDE5KSB7XG4gICAgICBjaGFubmVsTnIgPSAyO1xuICAgICAgY2hhckNvZGUxID0gYSAtIDg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoYW5uZWxOciA9IDE7XG4gICAgICBjaGFyQ29kZTEgPSBhO1xuICAgIH1cbiAgICBpZiAoY2hhckNvZGUxID49IDB4MTEgJiYgY2hhckNvZGUxIDw9IDB4MTMpIHtcbiAgICAgIC8vIFNwZWNpYWwgY2hhcmFjdGVyXG4gICAgICBsZXQgb25lQ29kZTtcbiAgICAgIGlmIChjaGFyQ29kZTEgPT09IDB4MTEpIHtcbiAgICAgICAgb25lQ29kZSA9IGIgKyAweDUwO1xuICAgICAgfSBlbHNlIGlmIChjaGFyQ29kZTEgPT09IDB4MTIpIHtcbiAgICAgICAgb25lQ29kZSA9IGIgKyAweDcwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25lQ29kZSA9IGIgKyAweDkwO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2dnZXIubG9nKDIsIFwiU3BlY2lhbCBjaGFyICdcIiArIGdldENoYXJGb3JCeXRlKG9uZUNvZGUpICsgXCInIGluIGNoYW5uZWwgXCIgKyBjaGFubmVsTnIpO1xuICAgICAgY2hhckNvZGVzID0gW29uZUNvZGVdO1xuICAgIH0gZWxzZSBpZiAoYSA+PSAweDIwICYmIGEgPD0gMHg3Zikge1xuICAgICAgY2hhckNvZGVzID0gYiA9PT0gMCA/IFthXSA6IFthLCBiXTtcbiAgICB9XG4gICAgaWYgKGNoYXJDb2Rlcykge1xuICAgICAgY29uc3QgaGV4Q29kZXMgPSBudW1BcnJheVRvSGV4QXJyYXkoY2hhckNvZGVzKTtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZygzLCAnQ2hhciBjb2RlcyA9ICAnICsgaGV4Q29kZXMuam9pbignLCcpKTtcbiAgICAgIHNldExhc3RDbWQoYSwgYiwgdGhpcy5jbWRIaXN0b3J5KTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJDb2RlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBleHRlbmRlZCBiYWNrZ3JvdW5kIGF0dHJpYnV0ZXMgYXMgd2VsbCBhcyBuZXcgZm9yZWdyb3VuZCBjb2xvciBibGFjay5cbiAgICogQHJldHVybnMgVHJ1ZSBpZiBiYWNrZ3JvdW5kIGF0dHJpYnV0ZXMgYXJlIGZvdW5kXG4gICAqL1xuICBwYXJzZUJhY2tncm91bmRBdHRyaWJ1dGVzKGEsIGIpIHtcbiAgICBjb25zdCBjYXNlMSA9IChhID09PSAweDEwIHx8IGEgPT09IDB4MTgpICYmIGIgPj0gMHgyMCAmJiBiIDw9IDB4MmY7XG4gICAgY29uc3QgY2FzZTIgPSAoYSA9PT0gMHgxNyB8fCBhID09PSAweDFmKSAmJiBiID49IDB4MmQgJiYgYiA8PSAweDJmO1xuICAgIGlmICghKGNhc2UxIHx8IGNhc2UyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgaW5kZXg7XG4gICAgY29uc3QgYmtnRGF0YSA9IHt9O1xuICAgIGlmIChhID09PSAweDEwIHx8IGEgPT09IDB4MTgpIHtcbiAgICAgIGluZGV4ID0gTWF0aC5mbG9vcigoYiAtIDB4MjApIC8gMik7XG4gICAgICBia2dEYXRhLmJhY2tncm91bmQgPSBiYWNrZ3JvdW5kQ29sb3JzW2luZGV4XTtcbiAgICAgIGlmIChiICUgMiA9PT0gMSkge1xuICAgICAgICBia2dEYXRhLmJhY2tncm91bmQgPSBia2dEYXRhLmJhY2tncm91bmQgKyAnX3NlbWknO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYiA9PT0gMHgyZCkge1xuICAgICAgYmtnRGF0YS5iYWNrZ3JvdW5kID0gJ3RyYW5zcGFyZW50JztcbiAgICB9IGVsc2Uge1xuICAgICAgYmtnRGF0YS5mb3JlZ3JvdW5kID0gJ2JsYWNrJztcbiAgICAgIGlmIChiID09PSAweDJmKSB7XG4gICAgICAgIGJrZ0RhdGEudW5kZXJsaW5lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY2hOciA9IGEgPD0gMHgxNyA/IDEgOiAyO1xuICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2NoTnJdO1xuICAgIGNoYW5uZWwuc2V0QmtnRGF0YShia2dEYXRhKTtcbiAgICBzZXRMYXN0Q21kKGEsIGIsIHRoaXMuY21kSGlzdG9yeSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogUmVzZXQgc3RhdGUgb2YgcGFyc2VyIGFuZCBpdHMgY2hhbm5lbHMuXG4gICAqL1xuICByZXNldCgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE9iamVjdC5rZXlzKHRoaXMuY2hhbm5lbHMpLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tpXTtcbiAgICAgIGlmIChjaGFubmVsKSB7XG4gICAgICAgIGNoYW5uZWwucmVzZXQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jbWRIaXN0b3J5ID0gY3JlYXRlQ21kSGlzdG9yeSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyaWdnZXIgdGhlIGdlbmVyYXRpb24gb2YgYSBjdWUsIGFuZCB0aGUgc3RhcnQgb2YgYSBuZXcgb25lIGlmIGRpc3BsYXlTY3JlZW5zIGFyZSBub3QgZW1wdHkuXG4gICAqL1xuICBjdWVTcGxpdEF0VGltZSh0KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoYW5uZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tpXTtcbiAgICAgIGlmIChjaGFubmVsKSB7XG4gICAgICAgIGNoYW5uZWwuY3VlU3BsaXRBdFRpbWUodCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzZXRMYXN0Q21kKGEsIGIsIGNtZEhpc3RvcnkpIHtcbiAgY21kSGlzdG9yeS5hID0gYTtcbiAgY21kSGlzdG9yeS5iID0gYjtcbn1cbmZ1bmN0aW9uIGhhc0NtZFJlcGVhdGVkKGEsIGIsIGNtZEhpc3RvcnkpIHtcbiAgcmV0dXJuIGNtZEhpc3RvcnkuYSA9PT0gYSAmJiBjbWRIaXN0b3J5LmIgPT09IGI7XG59XG5mdW5jdGlvbiBjcmVhdGVDbWRIaXN0b3J5KCkge1xuICByZXR1cm4ge1xuICAgIGE6IG51bGwsXG4gICAgYjogbnVsbFxuICB9O1xufVxuXG5jbGFzcyBPdXRwdXRGaWx0ZXIge1xuICBjb25zdHJ1Y3Rvcih0aW1lbGluZUNvbnRyb2xsZXIsIHRyYWNrTmFtZSkge1xuICAgIHRoaXMudGltZWxpbmVDb250cm9sbGVyID0gdm9pZCAwO1xuICAgIHRoaXMuY3VlUmFuZ2VzID0gW107XG4gICAgdGhpcy50cmFja05hbWUgPSB2b2lkIDA7XG4gICAgdGhpcy5zdGFydFRpbWUgPSBudWxsO1xuICAgIHRoaXMuZW5kVGltZSA9IG51bGw7XG4gICAgdGhpcy5zY3JlZW4gPSBudWxsO1xuICAgIHRoaXMudGltZWxpbmVDb250cm9sbGVyID0gdGltZWxpbmVDb250cm9sbGVyO1xuICAgIHRoaXMudHJhY2tOYW1lID0gdHJhY2tOYW1lO1xuICB9XG4gIGRpc3BhdGNoQ3VlKCkge1xuICAgIGlmICh0aGlzLnN0YXJ0VGltZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnRpbWVsaW5lQ29udHJvbGxlci5hZGRDdWVzKHRoaXMudHJhY2tOYW1lLCB0aGlzLnN0YXJ0VGltZSwgdGhpcy5lbmRUaW1lLCB0aGlzLnNjcmVlbiwgdGhpcy5jdWVSYW5nZXMpO1xuICAgIHRoaXMuc3RhcnRUaW1lID0gbnVsbDtcbiAgfVxuICBuZXdDdWUoc3RhcnRUaW1lLCBlbmRUaW1lLCBzY3JlZW4pIHtcbiAgICBpZiAodGhpcy5zdGFydFRpbWUgPT09IG51bGwgfHwgdGhpcy5zdGFydFRpbWUgPiBzdGFydFRpbWUpIHtcbiAgICAgIHRoaXMuc3RhcnRUaW1lID0gc3RhcnRUaW1lO1xuICAgIH1cbiAgICB0aGlzLmVuZFRpbWUgPSBlbmRUaW1lO1xuICAgIHRoaXMuc2NyZWVuID0gc2NyZWVuO1xuICAgIHRoaXMudGltZWxpbmVDb250cm9sbGVyLmNyZWF0ZUNhcHRpb25zVHJhY2sodGhpcy50cmFja05hbWUpO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuY3VlUmFuZ2VzID0gW107XG4gICAgdGhpcy5zdGFydFRpbWUgPSBudWxsO1xuICB9XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMTMgdnR0LmpzIENvbnRyaWJ1dG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAnTGljZW5zZScpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAnQVMgSVMnIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG52YXIgVlRUQ3VlID0gKGZ1bmN0aW9uICgpIHtcbiAgaWYgKG9wdGlvbmFsU2VsZiAhPSBudWxsICYmIG9wdGlvbmFsU2VsZi5WVFRDdWUpIHtcbiAgICByZXR1cm4gc2VsZi5WVFRDdWU7XG4gIH1cbiAgY29uc3QgQWxsb3dlZERpcmVjdGlvbnMgPSBbJycsICdscicsICdybCddO1xuICBjb25zdCBBbGxvd2VkQWxpZ25tZW50cyA9IFsnc3RhcnQnLCAnbWlkZGxlJywgJ2VuZCcsICdsZWZ0JywgJ3JpZ2h0J107XG4gIGZ1bmN0aW9uIGlzQWxsb3dlZFZhbHVlKGFsbG93ZWQsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gbmVjZXNzYXJ5IGZvciBhc3N1cmluZyB0aGUgZ2VuZXJpYyBjb25mb3JtcyB0byB0aGUgQXJyYXkgaW50ZXJmYWNlXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFsbG93ZWQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIHJlc2V0IHRoZSB0eXBlIHNvIHRoYXQgdGhlIG5leHQgbmFycm93aW5nIHdvcmtzIHdlbGxcbiAgICBjb25zdCBsY1ZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAvLyB1c2UgdGhlIGFsbG93IGxpc3QgdG8gbmFycm93IHRoZSB0eXBlIHRvIGEgc3BlY2lmaWMgc3Vic2V0IG9mIHN0cmluZ3NcbiAgICBpZiAofmFsbG93ZWQuaW5kZXhPZihsY1ZhbHVlKSkge1xuICAgICAgcmV0dXJuIGxjVmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiBmaW5kRGlyZWN0aW9uU2V0dGluZyh2YWx1ZSkge1xuICAgIHJldHVybiBpc0FsbG93ZWRWYWx1ZShBbGxvd2VkRGlyZWN0aW9ucywgdmFsdWUpO1xuICB9XG4gIGZ1bmN0aW9uIGZpbmRBbGlnblNldHRpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gaXNBbGxvd2VkVmFsdWUoQWxsb3dlZEFsaWdubWVudHMsIHZhbHVlKTtcbiAgfVxuICBmdW5jdGlvbiBleHRlbmQob2JqLCAuLi5yZXN0KSB7XG4gICAgbGV0IGkgPSAxO1xuICAgIGZvciAoOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjb2JqID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9yIChjb25zdCBwIGluIGNvYmopIHtcbiAgICAgICAgb2JqW3BdID0gY29ialtwXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICBmdW5jdGlvbiBWVFRDdWUoc3RhcnRUaW1lLCBlbmRUaW1lLCB0ZXh0KSB7XG4gICAgY29uc3QgY3VlID0gdGhpcztcbiAgICBjb25zdCBiYXNlT2JqID0ge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU2hpbSBpbXBsZW1lbnRhdGlvbiBzcGVjaWZpYyBwcm9wZXJ0aWVzLiBUaGVzZSBwcm9wZXJ0aWVzIGFyZSBub3QgaW5cbiAgICAgKiB0aGUgc3BlYy5cbiAgICAgKi9cblxuICAgIC8vIExldHMgdXMga25vdyB3aGVuIHRoZSBWVFRDdWUncyBkYXRhIGhhcyBjaGFuZ2VkIGluIHN1Y2ggYSB3YXkgdGhhdCB3ZSBuZWVkXG4gICAgLy8gdG8gcmVjb21wdXRlIGl0cyBkaXNwbGF5IHN0YXRlLiBUaGlzIGxldHMgdXMgY29tcHV0ZSBpdHMgZGlzcGxheSBzdGF0ZVxuICAgIC8vIGxhemlseS5cbiAgICBjdWUuaGFzQmVlblJlc2V0ID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBWVFRDdWUgYW5kIFRleHRUcmFja0N1ZSBwcm9wZXJ0aWVzXG4gICAgICogaHR0cDovL2Rldi53My5vcmcvaHRtbDUvd2VidnR0LyN2dHRjdWUtaW50ZXJmYWNlXG4gICAgICovXG5cbiAgICBsZXQgX2lkID0gJyc7XG4gICAgbGV0IF9wYXVzZU9uRXhpdCA9IGZhbHNlO1xuICAgIGxldCBfc3RhcnRUaW1lID0gc3RhcnRUaW1lO1xuICAgIGxldCBfZW5kVGltZSA9IGVuZFRpbWU7XG4gICAgbGV0IF90ZXh0ID0gdGV4dDtcbiAgICBsZXQgX3JlZ2lvbiA9IG51bGw7XG4gICAgbGV0IF92ZXJ0aWNhbCA9ICcnO1xuICAgIGxldCBfc25hcFRvTGluZXMgPSB0cnVlO1xuICAgIGxldCBfbGluZSA9ICdhdXRvJztcbiAgICBsZXQgX2xpbmVBbGlnbiA9ICdzdGFydCc7XG4gICAgbGV0IF9wb3NpdGlvbiA9IDUwO1xuICAgIGxldCBfcG9zaXRpb25BbGlnbiA9ICdtaWRkbGUnO1xuICAgIGxldCBfc2l6ZSA9IDUwO1xuICAgIGxldCBfYWxpZ24gPSAnbWlkZGxlJztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnaWQnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX2lkO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIF9pZCA9ICcnICsgdmFsdWU7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdwYXVzZU9uRXhpdCcsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfcGF1c2VPbkV4aXQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgX3BhdXNlT25FeGl0ID0gISF2YWx1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3N0YXJ0VGltZScsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfc3RhcnRUaW1lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU3RhcnQgdGltZSBtdXN0IGJlIHNldCB0byBhIG51bWJlci4nKTtcbiAgICAgICAgfVxuICAgICAgICBfc3RhcnRUaW1lID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ2VuZFRpbWUnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX2VuZFRpbWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFbmQgdGltZSBtdXN0IGJlIHNldCB0byBhIG51bWJlci4nKTtcbiAgICAgICAgfVxuICAgICAgICBfZW5kVGltZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICd0ZXh0JywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90ZXh0O1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIF90ZXh0ID0gJycgKyB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIC8vIHRvZG86IGltcGxlbWVudCBWVFRSZWdpb24gcG9seWZpbGw/XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3JlZ2lvbicsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfcmVnaW9uO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIF9yZWdpb24gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAndmVydGljYWwnLCBleHRlbmQoe30sIGJhc2VPYmosIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3ZlcnRpY2FsO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHNldHRpbmcgPSBmaW5kRGlyZWN0aW9uU2V0dGluZyh2YWx1ZSk7XG4gICAgICAgIC8vIEhhdmUgdG8gY2hlY2sgZm9yIGZhbHNlIGJlY2F1c2UgdGhlIHNldHRpbmcgYW4gYmUgYW4gZW1wdHkgc3RyaW5nLlxuICAgICAgICBpZiAoc2V0dGluZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0FuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBfdmVydGljYWwgPSBzZXR0aW5nO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdzbmFwVG9MaW5lcycsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfc25hcFRvTGluZXM7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgX3NuYXBUb0xpbmVzID0gISF2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLCAnbGluZScsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfbGluZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyAmJiB2YWx1ZSAhPT0gJ2F1dG8nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdBbiBpbnZhbGlkIG51bWJlciBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLicpO1xuICAgICAgICB9XG4gICAgICAgIF9saW5lID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ2xpbmVBbGlnbicsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfbGluZUFsaWduO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHNldHRpbmcgPSBmaW5kQWxpZ25TZXR0aW5nKHZhbHVlKTtcbiAgICAgICAgaWYgKCFzZXR0aW5nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgX2xpbmVBbGlnbiA9IHNldHRpbmc7XG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSwgJ3Bvc2l0aW9uJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9wb3NpdGlvbjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID4gMTAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb3NpdGlvbiBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAwLicpO1xuICAgICAgICB9XG4gICAgICAgIF9wb3NpdGlvbiA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdwb3NpdGlvbkFsaWduJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9wb3NpdGlvbkFsaWduO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHNldHRpbmcgPSBmaW5kQWxpZ25TZXR0aW5nKHZhbHVlKTtcbiAgICAgICAgaWYgKCFzZXR0aW5nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgX3Bvc2l0aW9uQWxpZ24gPSBzZXR0aW5nO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdzaXplJywgZXh0ZW5kKHt9LCBiYXNlT2JqLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9zaXplO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPiAxMDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NpemUgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEwMC4nKTtcbiAgICAgICAgfVxuICAgICAgICBfc2l6ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsICdhbGlnbicsIGV4dGVuZCh7fSwgYmFzZU9iaiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfYWxpZ247XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY29uc3Qgc2V0dGluZyA9IGZpbmRBbGlnblNldHRpbmcodmFsdWUpO1xuICAgICAgICBpZiAoIXNldHRpbmcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0FuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBfYWxpZ24gPSBzZXR0aW5nO1xuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgLyoqXG4gICAgICogT3RoZXIgPHRyYWNrPiBzcGVjIGRlZmluZWQgcHJvcGVydGllc1xuICAgICAqL1xuXG4gICAgLy8gaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLXZpZGVvLWVsZW1lbnQuaHRtbCN0ZXh0LXRyYWNrLWN1ZS1kaXNwbGF5LXN0YXRlXG4gICAgY3VlLmRpc3BsYXlTdGF0ZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBWVFRDdWUgbWV0aG9kc1xuICAgKi9cblxuICBWVFRDdWUucHJvdG90eXBlLmdldEN1ZUFzSFRNTCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBBc3N1bWUgV2ViVlRULmNvbnZlcnRDdWVUb0RPTVRyZWUgaXMgb24gdGhlIGdsb2JhbC5cbiAgICBjb25zdCBXZWJWVFQgPSBzZWxmLldlYlZUVDtcbiAgICByZXR1cm4gV2ViVlRULmNvbnZlcnRDdWVUb0RPTVRyZWUoc2VsZiwgdGhpcy50ZXh0KTtcbiAgfTtcbiAgLy8gdGhpcyBpcyBhIHBvbHlmaWxsIGhhY2tcbiAgcmV0dXJuIFZUVEN1ZTtcbn0pKCk7XG5cbi8qXG4gKiBTb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3Z0dC5qcy9ibG9iL21hc3Rlci9kaXN0L3Z0dC5qc1xuICovXG5cbmNsYXNzIFN0cmluZ0RlY29kZXIge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIGRlY29kZShkYXRhLCBvcHRpb25zKSB7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgLSBleHBlY3RlZCBzdHJpbmcgZGF0YS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlbmNvZGVVUklDb21wb25lbnQoZGF0YSkpO1xuICB9XG59XG5cbi8vIFRyeSB0byBwYXJzZSBpbnB1dCBhcyBhIHRpbWUgc3RhbXAuXG5mdW5jdGlvbiBwYXJzZVRpbWVTdGFtcChpbnB1dCkge1xuICBmdW5jdGlvbiBjb21wdXRlU2Vjb25kcyhoLCBtLCBzLCBmKSB7XG4gICAgcmV0dXJuIChoIHwgMCkgKiAzNjAwICsgKG0gfCAwKSAqIDYwICsgKHMgfCAwKSArIHBhcnNlRmxvYXQoZiB8fCAwKTtcbiAgfVxuICBjb25zdCBtID0gaW5wdXQubWF0Y2goL14oPzooXFxkKyk6KT8oXFxkezJ9KTooXFxkezJ9KShcXC5cXGQrKT8vKTtcbiAgaWYgKCFtKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHBhcnNlRmxvYXQobVsyXSkgPiA1OSkge1xuICAgIC8vIFRpbWVzdGFtcCB0YWtlcyB0aGUgZm9ybSBvZiBbaG91cnNdOlttaW51dGVzXS5bbWlsbGlzZWNvbmRzXVxuICAgIC8vIEZpcnN0IHBvc2l0aW9uIGlzIGhvdXJzIGFzIGl0J3Mgb3ZlciA1OS5cbiAgICByZXR1cm4gY29tcHV0ZVNlY29uZHMobVsyXSwgbVszXSwgMCwgbVs0XSk7XG4gIH1cbiAgLy8gVGltZXN0YW1wIHRha2VzIHRoZSBmb3JtIG9mIFtob3VycyAob3B0aW9uYWwpXTpbbWludXRlc106W3NlY29uZHNdLlttaWxsaXNlY29uZHNdXG4gIHJldHVybiBjb21wdXRlU2Vjb25kcyhtWzFdLCBtWzJdLCBtWzNdLCBtWzRdKTtcbn1cblxuLy8gQSBzZXR0aW5ncyBvYmplY3QgaG9sZHMga2V5L3ZhbHVlIHBhaXJzIGFuZCB3aWxsIGlnbm9yZSBhbnl0aGluZyBidXQgdGhlIGZpcnN0XG4vLyBhc3NpZ25tZW50IHRvIGEgc3BlY2lmaWMga2V5LlxuY2xhc3MgU2V0dGluZ3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnZhbHVlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgLy8gT25seSBhY2NlcHQgdGhlIGZpcnN0IGFzc2lnbm1lbnQgdG8gYW55IGtleS5cbiAgc2V0KGssIHYpIHtcbiAgICBpZiAoIXRoaXMuZ2V0KGspICYmIHYgIT09ICcnKSB7XG4gICAgICB0aGlzLnZhbHVlc1trXSA9IHY7XG4gICAgfVxuICB9XG4gIC8vIFJldHVybiB0aGUgdmFsdWUgZm9yIGEga2V5LCBvciBhIGRlZmF1bHQgdmFsdWUuXG4gIC8vIElmICdkZWZhdWx0S2V5JyBpcyBwYXNzZWQgdGhlbiAnZGZsdCcgaXMgYXNzdW1lZCB0byBiZSBhbiBvYmplY3Qgd2l0aFxuICAvLyBhIG51bWJlciBvZiBwb3NzaWJsZSBkZWZhdWx0IHZhbHVlcyBhcyBwcm9wZXJ0aWVzIHdoZXJlICdkZWZhdWx0S2V5JyBpc1xuICAvLyB0aGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0aGF0IHdpbGwgYmUgY2hvc2VuOyBvdGhlcndpc2UgaXQncyBhc3N1bWVkIHRvIGJlXG4gIC8vIGEgc2luZ2xlIHZhbHVlLlxuICBnZXQoaywgZGZsdCwgZGVmYXVsdEtleSkge1xuICAgIGlmIChkZWZhdWx0S2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5oYXMoaykgPyB0aGlzLnZhbHVlc1trXSA6IGRmbHRbZGVmYXVsdEtleV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmhhcyhrKSA/IHRoaXMudmFsdWVzW2tdIDogZGZsdDtcbiAgfVxuICAvLyBDaGVjayB3aGV0aGVyIHdlIGhhdmUgYSB2YWx1ZSBmb3IgYSBrZXkuXG4gIGhhcyhrKSB7XG4gICAgcmV0dXJuIGsgaW4gdGhpcy52YWx1ZXM7XG4gIH1cbiAgLy8gQWNjZXB0IGEgc2V0dGluZyBpZiBpdHMgb25lIG9mIHRoZSBnaXZlbiBhbHRlcm5hdGl2ZXMuXG4gIGFsdChrLCB2LCBhKSB7XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCBhLmxlbmd0aDsgKytuKSB7XG4gICAgICBpZiAodiA9PT0gYVtuXSkge1xuICAgICAgICB0aGlzLnNldChrLCB2KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIEFjY2VwdCBhIHNldHRpbmcgaWYgaXRzIGEgdmFsaWQgKHNpZ25lZCkgaW50ZWdlci5cbiAgaW50ZWdlcihrLCB2KSB7XG4gICAgaWYgKC9eLT9cXGQrJC8udGVzdCh2KSkge1xuICAgICAgLy8gaW50ZWdlclxuICAgICAgdGhpcy5zZXQoaywgcGFyc2VJbnQodiwgMTApKTtcbiAgICB9XG4gIH1cbiAgLy8gQWNjZXB0IGEgc2V0dGluZyBpZiBpdHMgYSB2YWxpZCBwZXJjZW50YWdlLlxuICBwZXJjZW50KGssIHYpIHtcbiAgICBpZiAoL14oW1xcZF17MSwzfSkoXFwuW1xcZF0qKT8lJC8udGVzdCh2KSkge1xuICAgICAgY29uc3QgcGVyY2VudCA9IHBhcnNlRmxvYXQodik7XG4gICAgICBpZiAocGVyY2VudCA+PSAwICYmIHBlcmNlbnQgPD0gMTAwKSB7XG4gICAgICAgIHRoaXMuc2V0KGssIHBlcmNlbnQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBwYXJzZSBpbnB1dCBpbnRvIGdyb3VwcyBzZXBhcmF0ZWQgYnkgJ2dyb3VwRGVsaW0nLCBhbmRcbi8vIGludGVycHJldCBlYWNoIGdyb3VwIGFzIGEga2V5L3ZhbHVlIHBhaXIgc2VwYXJhdGVkIGJ5ICdrZXlWYWx1ZURlbGltJy5cbmZ1bmN0aW9uIHBhcnNlT3B0aW9ucyhpbnB1dCwgY2FsbGJhY2ssIGtleVZhbHVlRGVsaW0sIGdyb3VwRGVsaW0pIHtcbiAgY29uc3QgZ3JvdXBzID0gZ3JvdXBEZWxpbSA/IGlucHV0LnNwbGl0KGdyb3VwRGVsaW0pIDogW2lucHV0XTtcbiAgZm9yIChjb25zdCBpIGluIGdyb3Vwcykge1xuICAgIGlmICh0eXBlb2YgZ3JvdXBzW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGt2ID0gZ3JvdXBzW2ldLnNwbGl0KGtleVZhbHVlRGVsaW0pO1xuICAgIGlmIChrdi5sZW5ndGggIT09IDIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBrID0ga3ZbMF07XG4gICAgY29uc3QgdiA9IGt2WzFdO1xuICAgIGNhbGxiYWNrKGssIHYpO1xuICB9XG59XG5jb25zdCBkZWZhdWx0cyA9IG5ldyBWVFRDdWUoMCwgMCwgJycpO1xuLy8gJ21pZGRsZScgd2FzIGNoYW5nZWQgdG8gJ2NlbnRlcicgaW4gdGhlIHNwZWM6IGh0dHBzOi8vZ2l0aHViLmNvbS93M2Mvd2VidnR0L3B1bGwvMjQ0XG4vLyAgU2FmYXJpIGRvZXNuJ3QgeWV0IHN1cHBvcnQgdGhpcyBjaGFuZ2UsIGJ1dCBGRiBhbmQgQ2hyb21lIGRvLlxuY29uc3QgY2VudGVyID0gZGVmYXVsdHMuYWxpZ24gPT09ICdtaWRkbGUnID8gJ21pZGRsZScgOiAnY2VudGVyJztcbmZ1bmN0aW9uIHBhcnNlQ3VlKGlucHV0LCBjdWUsIHJlZ2lvbkxpc3QpIHtcbiAgLy8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIGlucHV0IGlmIHdlIG5lZWQgdG8gdGhyb3cgYW4gZXJyb3IuXG4gIGNvbnN0IG9JbnB1dCA9IGlucHV0O1xuICAvLyA0LjEgV2ViVlRUIHRpbWVzdGFtcFxuICBmdW5jdGlvbiBjb25zdW1lVGltZVN0YW1wKCkge1xuICAgIGNvbnN0IHRzID0gcGFyc2VUaW1lU3RhbXAoaW5wdXQpO1xuICAgIGlmICh0cyA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYWxmb3JtZWQgdGltZXN0YW1wOiAnICsgb0lucHV0KTtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgdGltZSBzdGFtcCBmcm9tIGlucHV0LlxuICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvXlteXFxzYS16QS1aLV0rLywgJycpO1xuICAgIHJldHVybiB0cztcbiAgfVxuXG4gIC8vIDQuNC4yIFdlYlZUVCBjdWUgc2V0dGluZ3NcbiAgZnVuY3Rpb24gY29uc3VtZUN1ZVNldHRpbmdzKGlucHV0LCBjdWUpIHtcbiAgICBjb25zdCBzZXR0aW5ncyA9IG5ldyBTZXR0aW5ncygpO1xuICAgIHBhcnNlT3B0aW9ucyhpbnB1dCwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICAgIGxldCB2YWxzO1xuICAgICAgc3dpdGNoIChrKSB7XG4gICAgICAgIGNhc2UgJ3JlZ2lvbic6XG4gICAgICAgICAgLy8gRmluZCB0aGUgbGFzdCByZWdpb24gd2UgcGFyc2VkIHdpdGggdGhlIHNhbWUgcmVnaW9uIGlkLlxuICAgICAgICAgIGZvciAobGV0IGkgPSByZWdpb25MaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAocmVnaW9uTGlzdFtpXS5pZCA9PT0gdikge1xuICAgICAgICAgICAgICBzZXR0aW5ncy5zZXQoaywgcmVnaW9uTGlzdFtpXS5yZWdpb24pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3ZlcnRpY2FsJzpcbiAgICAgICAgICBzZXR0aW5ncy5hbHQoaywgdiwgWydybCcsICdsciddKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbGluZSc6XG4gICAgICAgICAgdmFscyA9IHYuc3BsaXQoJywnKTtcbiAgICAgICAgICBzZXR0aW5ncy5pbnRlZ2VyKGssIHZhbHNbMF0pO1xuICAgICAgICAgIGlmIChzZXR0aW5ncy5wZXJjZW50KGssIHZhbHNbMF0pKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5zZXQoJ3NuYXBUb0xpbmVzJywgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZXR0aW5ncy5hbHQoaywgdmFsc1swXSwgWydhdXRvJ10pO1xuICAgICAgICAgIGlmICh2YWxzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgc2V0dGluZ3MuYWx0KCdsaW5lQWxpZ24nLCB2YWxzWzFdLCBbJ3N0YXJ0JywgY2VudGVyLCAnZW5kJ10pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncG9zaXRpb24nOlxuICAgICAgICAgIHZhbHMgPSB2LnNwbGl0KCcsJyk7XG4gICAgICAgICAgc2V0dGluZ3MucGVyY2VudChrLCB2YWxzWzBdKTtcbiAgICAgICAgICBpZiAodmFscy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLmFsdCgncG9zaXRpb25BbGlnbicsIHZhbHNbMV0sIFsnc3RhcnQnLCBjZW50ZXIsICdlbmQnLCAnbGluZS1sZWZ0JywgJ2xpbmUtcmlnaHQnLCAnYXV0byddKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NpemUnOlxuICAgICAgICAgIHNldHRpbmdzLnBlcmNlbnQoaywgdik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2FsaWduJzpcbiAgICAgICAgICBzZXR0aW5ncy5hbHQoaywgdiwgWydzdGFydCcsIGNlbnRlciwgJ2VuZCcsICdsZWZ0JywgJ3JpZ2h0J10pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0sIC86LywgL1xccy8pO1xuXG4gICAgLy8gQXBwbHkgZGVmYXVsdCB2YWx1ZXMgZm9yIGFueSBtaXNzaW5nIGZpZWxkcy5cbiAgICBjdWUucmVnaW9uID0gc2V0dGluZ3MuZ2V0KCdyZWdpb24nLCBudWxsKTtcbiAgICBjdWUudmVydGljYWwgPSBzZXR0aW5ncy5nZXQoJ3ZlcnRpY2FsJywgJycpO1xuICAgIGxldCBsaW5lID0gc2V0dGluZ3MuZ2V0KCdsaW5lJywgJ2F1dG8nKTtcbiAgICBpZiAobGluZSA9PT0gJ2F1dG8nICYmIGRlZmF1bHRzLmxpbmUgPT09IC0xKSB7XG4gICAgICAvLyBzZXQgbnVtZXJpYyBsaW5lIG51bWJlciBmb3IgU2FmYXJpXG4gICAgICBsaW5lID0gLTE7XG4gICAgfVxuICAgIGN1ZS5saW5lID0gbGluZTtcbiAgICBjdWUubGluZUFsaWduID0gc2V0dGluZ3MuZ2V0KCdsaW5lQWxpZ24nLCAnc3RhcnQnKTtcbiAgICBjdWUuc25hcFRvTGluZXMgPSBzZXR0aW5ncy5nZXQoJ3NuYXBUb0xpbmVzJywgdHJ1ZSk7XG4gICAgY3VlLnNpemUgPSBzZXR0aW5ncy5nZXQoJ3NpemUnLCAxMDApO1xuICAgIGN1ZS5hbGlnbiA9IHNldHRpbmdzLmdldCgnYWxpZ24nLCBjZW50ZXIpO1xuICAgIGxldCBwb3NpdGlvbiA9IHNldHRpbmdzLmdldCgncG9zaXRpb24nLCAnYXV0bycpO1xuICAgIGlmIChwb3NpdGlvbiA9PT0gJ2F1dG8nICYmIGRlZmF1bHRzLnBvc2l0aW9uID09PSA1MCkge1xuICAgICAgLy8gc2V0IG51bWVyaWMgcG9zaXRpb24gZm9yIFNhZmFyaVxuICAgICAgcG9zaXRpb24gPSBjdWUuYWxpZ24gPT09ICdzdGFydCcgfHwgY3VlLmFsaWduID09PSAnbGVmdCcgPyAwIDogY3VlLmFsaWduID09PSAnZW5kJyB8fCBjdWUuYWxpZ24gPT09ICdyaWdodCcgPyAxMDAgOiA1MDtcbiAgICB9XG4gICAgY3VlLnBvc2l0aW9uID0gcG9zaXRpb247XG4gIH1cbiAgZnVuY3Rpb24gc2tpcFdoaXRlc3BhY2UoKSB7XG4gICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9eXFxzKy8sICcnKTtcbiAgfVxuXG4gIC8vIDQuMSBXZWJWVFQgY3VlIHRpbWluZ3MuXG4gIHNraXBXaGl0ZXNwYWNlKCk7XG4gIGN1ZS5zdGFydFRpbWUgPSBjb25zdW1lVGltZVN0YW1wKCk7IC8vICgxKSBjb2xsZWN0IGN1ZSBzdGFydCB0aW1lXG4gIHNraXBXaGl0ZXNwYWNlKCk7XG4gIGlmIChpbnB1dC5zbGljZSgwLCAzKSAhPT0gJy0tPicpIHtcbiAgICAvLyAoMykgbmV4dCBjaGFyYWN0ZXJzIG11c3QgbWF0Y2ggJy0tPidcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWxmb3JtZWQgdGltZSBzdGFtcCAodGltZSBzdGFtcHMgbXVzdCBiZSBzZXBhcmF0ZWQgYnkgJy0tPicpOiBcIiArIG9JbnB1dCk7XG4gIH1cbiAgaW5wdXQgPSBpbnB1dC5zbGljZSgzKTtcbiAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgY3VlLmVuZFRpbWUgPSBjb25zdW1lVGltZVN0YW1wKCk7IC8vICg1KSBjb2xsZWN0IGN1ZSBlbmQgdGltZVxuXG4gIC8vIDQuMSBXZWJWVFQgY3VlIHNldHRpbmdzIGxpc3QuXG4gIHNraXBXaGl0ZXNwYWNlKCk7XG4gIGNvbnN1bWVDdWVTZXR0aW5ncyhpbnB1dCwgY3VlKTtcbn1cbmZ1bmN0aW9uIGZpeExpbmVCcmVha3MoaW5wdXQpIHtcbiAgcmV0dXJuIGlucHV0LnJlcGxhY2UoLzxicig/OiBcXC8pPz4vZ2ksICdcXG4nKTtcbn1cbmNsYXNzIFZUVFBhcnNlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc3RhdGUgPSAnSU5JVElBTCc7XG4gICAgdGhpcy5idWZmZXIgPSAnJztcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcigpO1xuICAgIHRoaXMucmVnaW9uTGlzdCA9IFtdO1xuICAgIHRoaXMuY3VlID0gbnVsbDtcbiAgICB0aGlzLm9uY3VlID0gdm9pZCAwO1xuICAgIHRoaXMub25wYXJzaW5nZXJyb3IgPSB2b2lkIDA7XG4gICAgdGhpcy5vbmZsdXNoID0gdm9pZCAwO1xuICB9XG4gIHBhcnNlKGRhdGEpIHtcbiAgICBjb25zdCBfdGhpcyA9IHRoaXM7XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBubyBkYXRhIHRoZW4gd2Ugd29uJ3QgZGVjb2RlIGl0LCBidXQgd2lsbCBqdXN0IHRyeSB0byBwYXJzZVxuICAgIC8vIHdoYXRldmVyIGlzIGluIGJ1ZmZlciBhbHJlYWR5LiBUaGlzIG1heSBvY2N1ciBpbiBjaXJjdW1zdGFuY2VzLCBmb3JcbiAgICAvLyBleGFtcGxlIHdoZW4gZmx1c2goKSBpcyBjYWxsZWQuXG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIC8vIFRyeSB0byBkZWNvZGUgdGhlIGRhdGEgdGhhdCB3ZSByZWNlaXZlZC5cbiAgICAgIF90aGlzLmJ1ZmZlciArPSBfdGhpcy5kZWNvZGVyLmRlY29kZShkYXRhLCB7XG4gICAgICAgIHN0cmVhbTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbGxlY3ROZXh0TGluZSgpIHtcbiAgICAgIGxldCBidWZmZXIgPSBfdGhpcy5idWZmZXI7XG4gICAgICBsZXQgcG9zID0gMDtcbiAgICAgIGJ1ZmZlciA9IGZpeExpbmVCcmVha3MoYnVmZmVyKTtcbiAgICAgIHdoaWxlIChwb3MgPCBidWZmZXIubGVuZ3RoICYmIGJ1ZmZlcltwb3NdICE9PSAnXFxyJyAmJiBidWZmZXJbcG9zXSAhPT0gJ1xcbicpIHtcbiAgICAgICAgKytwb3M7XG4gICAgICB9XG4gICAgICBjb25zdCBsaW5lID0gYnVmZmVyLnNsaWNlKDAsIHBvcyk7XG4gICAgICAvLyBBZHZhbmNlIHRoZSBidWZmZXIgZWFybHkgaW4gY2FzZSB3ZSBmYWlsIGJlbG93LlxuICAgICAgaWYgKGJ1ZmZlcltwb3NdID09PSAnXFxyJykge1xuICAgICAgICArK3BvcztcbiAgICAgIH1cbiAgICAgIGlmIChidWZmZXJbcG9zXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgKytwb3M7XG4gICAgICB9XG4gICAgICBfdGhpcy5idWZmZXIgPSBidWZmZXIuc2xpY2UocG9zKTtcbiAgICAgIHJldHVybiBsaW5lO1xuICAgIH1cblxuICAgIC8vIDMuMiBXZWJWVFQgbWV0YWRhdGEgaGVhZGVyIHN5bnRheFxuICAgIGZ1bmN0aW9uIHBhcnNlSGVhZGVyKGlucHV0KSB7XG4gICAgICBwYXJzZU9wdGlvbnMoaW5wdXQsIGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICAgIC8vIHN3aXRjaCAoaykge1xuICAgICAgICAvLyBjYXNlICdyZWdpb24nOlxuICAgICAgICAvLyAzLjMgV2ViVlRUIHJlZ2lvbiBtZXRhZGF0YSBoZWFkZXIgc3ludGF4XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdwYXJzZSByZWdpb24nLCB2KTtcbiAgICAgICAgLy8gcGFyc2VSZWdpb24odik7XG4gICAgICAgIC8vIGJyZWFrO1xuICAgICAgICAvLyB9XG4gICAgICB9LCAvOi8pO1xuICAgIH1cblxuICAgIC8vIDUuMSBXZWJWVFQgZmlsZSBwYXJzaW5nLlxuICAgIHRyeSB7XG4gICAgICBsZXQgbGluZSA9ICcnO1xuICAgICAgaWYgKF90aGlzLnN0YXRlID09PSAnSU5JVElBTCcpIHtcbiAgICAgICAgLy8gV2UgY2FuJ3Qgc3RhcnQgcGFyc2luZyB1bnRpbCB3ZSBoYXZlIHRoZSBmaXJzdCBsaW5lLlxuICAgICAgICBpZiAoIS9cXHJcXG58XFxuLy50ZXN0KF90aGlzLmJ1ZmZlcikpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBsaW5lID0gY29sbGVjdE5leHRMaW5lKCk7XG4gICAgICAgIC8vIHN0cmlwIG9mIFVURi04IEJPTSBpZiBhbnlcbiAgICAgICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQnl0ZV9vcmRlcl9tYXJrI1VURi04XG4gICAgICAgIGNvbnN0IG0gPSBsaW5lLm1hdGNoKC9eKMOvwrvCvyk/V0VCVlRUKFsgXFx0XS4qKT8kLyk7XG4gICAgICAgIGlmICghKG0gIT0gbnVsbCAmJiBtWzBdKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWFsZm9ybWVkIFdlYlZUVCBzaWduYXR1cmUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuc3RhdGUgPSAnSEVBREVSJztcbiAgICAgIH1cbiAgICAgIGxldCBhbHJlYWR5Q29sbGVjdGVkTGluZSA9IGZhbHNlO1xuICAgICAgd2hpbGUgKF90aGlzLmJ1ZmZlcikge1xuICAgICAgICAvLyBXZSBjYW4ndCBwYXJzZSBhIGxpbmUgdW50aWwgd2UgaGF2ZSB0aGUgZnVsbCBsaW5lLlxuICAgICAgICBpZiAoIS9cXHJcXG58XFxuLy50ZXN0KF90aGlzLmJ1ZmZlcikpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFscmVhZHlDb2xsZWN0ZWRMaW5lKSB7XG4gICAgICAgICAgbGluZSA9IGNvbGxlY3ROZXh0TGluZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFscmVhZHlDb2xsZWN0ZWRMaW5lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChfdGhpcy5zdGF0ZSkge1xuICAgICAgICAgIGNhc2UgJ0hFQURFUic6XG4gICAgICAgICAgICAvLyAxMy0xOCAtIEFsbG93IGEgaGVhZGVyIChtZXRhZGF0YSkgdW5kZXIgdGhlIFdFQlZUVCBsaW5lLlxuICAgICAgICAgICAgaWYgKC86Ly50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICAgIHBhcnNlSGVhZGVyKGxpbmUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghbGluZSkge1xuICAgICAgICAgICAgICAvLyBBbiBlbXB0eSBsaW5lIHRlcm1pbmF0ZXMgdGhlIGhlYWRlciBhbmQgc3RhcnRzIHRoZSBib2R5IChjdWVzKS5cbiAgICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSAnSUQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSAnTk9URSc6XG4gICAgICAgICAgICAvLyBJZ25vcmUgTk9URSBibG9ja3MuXG4gICAgICAgICAgICBpZiAoIWxpbmUpIHtcbiAgICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSAnSUQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSAnSUQnOlxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHRoZSBzdGFydCBvZiBOT1RFIGJsb2Nrcy5cbiAgICAgICAgICAgIGlmICgvXk5PVEUoJHxbIFxcdF0pLy50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICAgIF90aGlzLnN0YXRlID0gJ05PVEUnO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDE5LTI5IC0gQWxsb3cgYW55IG51bWJlciBvZiBsaW5lIHRlcm1pbmF0b3JzLCB0aGVuIGluaXRpYWxpemUgbmV3IGN1ZSB2YWx1ZXMuXG4gICAgICAgICAgICBpZiAoIWxpbmUpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5jdWUgPSBuZXcgVlRUQ3VlKDAsIDAsICcnKTtcbiAgICAgICAgICAgIF90aGlzLnN0YXRlID0gJ0NVRSc7XG4gICAgICAgICAgICAvLyAzMC0zOSAtIENoZWNrIGlmIHNlbGYgbGluZSBjb250YWlucyBhbiBvcHRpb25hbCBpZGVudGlmaWVyIG9yIHRpbWluZyBkYXRhLlxuICAgICAgICAgICAgaWYgKGxpbmUuaW5kZXhPZignLS0+JykgPT09IC0xKSB7XG4gICAgICAgICAgICAgIF90aGlzLmN1ZS5pZCA9IGxpbmU7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIC8vIFByb2Nlc3MgbGluZSBhcyBzdGFydCBvZiBhIGN1ZS5cbiAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgY2FzZSAnQ1VFJzpcbiAgICAgICAgICAgIC8vIDQwIC0gQ29sbGVjdCBjdWUgdGltaW5ncyBhbmQgc2V0dGluZ3MuXG4gICAgICAgICAgICBpZiAoIV90aGlzLmN1ZSkge1xuICAgICAgICAgICAgICBfdGhpcy5zdGF0ZSA9ICdCQURDVUUnO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHBhcnNlQ3VlKGxpbmUsIF90aGlzLmN1ZSwgX3RoaXMucmVnaW9uTGlzdCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIC8vIEluIGNhc2Ugb2YgYW4gZXJyb3IgaWdub3JlIHJlc3Qgb2YgdGhlIGN1ZS5cbiAgICAgICAgICAgICAgX3RoaXMuY3VlID0gbnVsbDtcbiAgICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSAnQkFEQ1VFJztcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5zdGF0ZSA9ICdDVUVURVhUJztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgJ0NVRVRFWFQnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCBoYXNTdWJzdHJpbmcgPSBsaW5lLmluZGV4T2YoJy0tPicpICE9PSAtMTtcbiAgICAgICAgICAgICAgLy8gMzQgLSBJZiB3ZSBoYXZlIGFuIGVtcHR5IGxpbmUgdGhlbiByZXBvcnQgdGhlIGN1ZS5cbiAgICAgICAgICAgICAgLy8gMzUgLSBJZiB3ZSBoYXZlIHRoZSBzcGVjaWFsIHN1YnN0cmluZyAnLS0+JyB0aGVuIHJlcG9ydCB0aGUgY3VlLFxuICAgICAgICAgICAgICAvLyBidXQgZG8gbm90IGNvbGxlY3QgdGhlIGxpbmUgYXMgd2UgbmVlZCB0byBwcm9jZXNzIHRoZSBjdXJyZW50XG4gICAgICAgICAgICAgIC8vIG9uZSBhcyBhIG5ldyBjdWUuXG4gICAgICAgICAgICAgIGlmICghbGluZSB8fCBoYXNTdWJzdHJpbmcgJiYgKGFscmVhZHlDb2xsZWN0ZWRMaW5lID0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBhcmUgZG9uZSBwYXJzaW5nIHNlbGYgY3VlLlxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5vbmN1ZSAmJiBfdGhpcy5jdWUpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzLm9uY3VlKF90aGlzLmN1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLmN1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSAnSUQnO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChfdGhpcy5jdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoX3RoaXMuY3VlLnRleHQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jdWUudGV4dCArPSAnXFxuJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfdGhpcy5jdWUudGV4dCArPSBsaW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSAnQkFEQ1VFJzpcbiAgICAgICAgICAgIC8vIDU0LTYyIC0gQ29sbGVjdCBhbmQgZGlzY2FyZCB0aGUgcmVtYWluaW5nIGN1ZS5cbiAgICAgICAgICAgIGlmICghbGluZSkge1xuICAgICAgICAgICAgICBfdGhpcy5zdGF0ZSA9ICdJRCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IHBhcnNpbmcgYSBjdWUsIHJlcG9ydCB3aGF0IHdlIGhhdmUuXG4gICAgICBpZiAoX3RoaXMuc3RhdGUgPT09ICdDVUVURVhUJyAmJiBfdGhpcy5jdWUgJiYgX3RoaXMub25jdWUpIHtcbiAgICAgICAgX3RoaXMub25jdWUoX3RoaXMuY3VlKTtcbiAgICAgIH1cbiAgICAgIF90aGlzLmN1ZSA9IG51bGw7XG4gICAgICAvLyBFbnRlciBCQURXRUJWVFQgc3RhdGUgaWYgaGVhZGVyIHdhcyBub3QgcGFyc2VkIGNvcnJlY3RseSBvdGhlcndpc2VcbiAgICAgIC8vIGFub3RoZXIgZXhjZXB0aW9uIG9jY3VycmVkIHNvIGVudGVyIEJBRENVRSBzdGF0ZS5cbiAgICAgIF90aGlzLnN0YXRlID0gX3RoaXMuc3RhdGUgPT09ICdJTklUSUFMJyA/ICdCQURXRUJWVFQnIDogJ0JBRENVRSc7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGZsdXNoKCkge1xuICAgIGNvbnN0IF90aGlzID0gdGhpcztcbiAgICB0cnkge1xuICAgICAgLy8gRmluaXNoIGRlY29kaW5nIHRoZSBzdHJlYW0uXG4gICAgICAvLyBfdGhpcy5idWZmZXIgKz0gX3RoaXMuZGVjb2Rlci5kZWNvZGUoKTtcbiAgICAgIC8vIFN5bnRoZXNpemUgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBjdWUgb3IgcmVnaW9uLlxuICAgICAgaWYgKF90aGlzLmN1ZSB8fCBfdGhpcy5zdGF0ZSA9PT0gJ0hFQURFUicpIHtcbiAgICAgICAgX3RoaXMuYnVmZmVyICs9ICdcXG5cXG4nO1xuICAgICAgICBfdGhpcy5wYXJzZSgpO1xuICAgICAgfVxuICAgICAgLy8gSWYgd2UndmUgZmx1c2hlZCwgcGFyc2VkLCBhbmQgd2UncmUgc3RpbGwgb24gdGhlIElOSVRJQUwgc3RhdGUgdGhlblxuICAgICAgLy8gdGhhdCBtZWFucyB3ZSBkb24ndCBoYXZlIGVub3VnaCBvZiB0aGUgc3RyZWFtIHRvIHBhcnNlIHRoZSBmaXJzdFxuICAgICAgLy8gbGluZS5cbiAgICAgIGlmIChfdGhpcy5zdGF0ZSA9PT0gJ0lOSVRJQUwnIHx8IF90aGlzLnN0YXRlID09PSAnQkFEV0VCVlRUJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBXZWJWVFQgc2lnbmF0dXJlLicpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChfdGhpcy5vbnBhcnNpbmdlcnJvcikge1xuICAgICAgICBfdGhpcy5vbnBhcnNpbmdlcnJvcihlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKF90aGlzLm9uZmx1c2gpIHtcbiAgICAgIF90aGlzLm9uZmx1c2goKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuY29uc3QgTElORUJSRUFLUyA9IC9cXHJcXG58XFxuXFxyfFxcbnxcXHIvZztcblxuLy8gU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gSUUxMVxuY29uc3Qgc3RhcnRzV2l0aCA9IGZ1bmN0aW9uIHN0YXJ0c1dpdGgoaW5wdXRTdHJpbmcsIHNlYXJjaFN0cmluZywgcG9zaXRpb24gPSAwKSB7XG4gIHJldHVybiBpbnB1dFN0cmluZy5zbGljZShwb3NpdGlvbiwgcG9zaXRpb24gKyBzZWFyY2hTdHJpbmcubGVuZ3RoKSA9PT0gc2VhcmNoU3RyaW5nO1xufTtcbmNvbnN0IGN1ZVN0cmluZzJtaWxsaXMgPSBmdW5jdGlvbiBjdWVTdHJpbmcybWlsbGlzKHRpbWVTdHJpbmcpIHtcbiAgbGV0IHRzID0gcGFyc2VJbnQodGltZVN0cmluZy5zbGljZSgtMykpO1xuICBjb25zdCBzZWNzID0gcGFyc2VJbnQodGltZVN0cmluZy5zbGljZSgtNiwgLTQpKTtcbiAgY29uc3QgbWlucyA9IHBhcnNlSW50KHRpbWVTdHJpbmcuc2xpY2UoLTksIC03KSk7XG4gIGNvbnN0IGhvdXJzID0gdGltZVN0cmluZy5sZW5ndGggPiA5ID8gcGFyc2VJbnQodGltZVN0cmluZy5zdWJzdHJpbmcoMCwgdGltZVN0cmluZy5pbmRleE9mKCc6JykpKSA6IDA7XG4gIGlmICghaXNGaW5pdGVOdW1iZXIodHMpIHx8ICFpc0Zpbml0ZU51bWJlcihzZWNzKSB8fCAhaXNGaW5pdGVOdW1iZXIobWlucykgfHwgIWlzRmluaXRlTnVtYmVyKGhvdXJzKSkge1xuICAgIHRocm93IEVycm9yKGBNYWxmb3JtZWQgWC1USU1FU1RBTVAtTUFQOiBMb2NhbDoke3RpbWVTdHJpbmd9YCk7XG4gIH1cbiAgdHMgKz0gMTAwMCAqIHNlY3M7XG4gIHRzICs9IDYwICogMTAwMCAqIG1pbnM7XG4gIHRzICs9IDYwICogNjAgKiAxMDAwICogaG91cnM7XG4gIHJldHVybiB0cztcbn07XG5cbi8vIEZyb20gaHR0cHM6Ly9naXRodWIuY29tL2Rhcmtza3lhcHAvc3RyaW5nLWhhc2hcbmNvbnN0IGhhc2ggPSBmdW5jdGlvbiBoYXNoKHRleHQpIHtcbiAgbGV0IF9oYXNoID0gNTM4MTtcbiAgbGV0IGkgPSB0ZXh0Lmxlbmd0aDtcbiAgd2hpbGUgKGkpIHtcbiAgICBfaGFzaCA9IF9oYXNoICogMzMgXiB0ZXh0LmNoYXJDb2RlQXQoLS1pKTtcbiAgfVxuICByZXR1cm4gKF9oYXNoID4+PiAwKS50b1N0cmluZygpO1xufTtcblxuLy8gQ3JlYXRlIGEgdW5pcXVlIGhhc2ggaWQgZm9yIGEgY3VlIGJhc2VkIG9uIHN0YXJ0L2VuZCB0aW1lcyBhbmQgdGV4dC5cbi8vIFRoaXMgaGVscHMgdGltZWxpbmUtY29udHJvbGxlciB0byBhdm9pZCBzaG93aW5nIHJlcGVhdGVkIGNhcHRpb25zLlxuZnVuY3Rpb24gZ2VuZXJhdGVDdWVJZChzdGFydFRpbWUsIGVuZFRpbWUsIHRleHQpIHtcbiAgcmV0dXJuIGhhc2goc3RhcnRUaW1lLnRvU3RyaW5nKCkpICsgaGFzaChlbmRUaW1lLnRvU3RyaW5nKCkpICsgaGFzaCh0ZXh0KTtcbn1cbmNvbnN0IGNhbGN1bGF0ZU9mZnNldCA9IGZ1bmN0aW9uIGNhbGN1bGF0ZU9mZnNldCh2dHRDQ3MsIGNjLCBwcmVzZW50YXRpb25UaW1lKSB7XG4gIGxldCBjdXJyQ0MgPSB2dHRDQ3NbY2NdO1xuICBsZXQgcHJldkNDID0gdnR0Q0NzW2N1cnJDQy5wcmV2Q0NdO1xuXG4gIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGRpc2NvbnRpbnVpdHkgb3IgY3VlcyBoYXZlIGJlZW4gcHJvY2Vzc2VkIHNpbmNlIHRoZSBsYXN0IGRpc2NvbnRpbnVpdHlcbiAgLy8gT2Zmc2V0ID0gY3VycmVudCBkaXNjb250aW51aXR5IHRpbWVcbiAgaWYgKCFwcmV2Q0MgfHwgIXByZXZDQy5uZXcgJiYgY3VyckNDLm5ldykge1xuICAgIHZ0dENDcy5jY09mZnNldCA9IHZ0dENDcy5wcmVzZW50YXRpb25PZmZzZXQgPSBjdXJyQ0Muc3RhcnQ7XG4gICAgY3VyckNDLm5ldyA9IGZhbHNlO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFRoZXJlIGhhdmUgYmVlbiBkaXNjb250aW51aXRpZXMgc2luY2UgY3VlcyB3ZXJlIGxhc3QgcGFyc2VkLlxuICAvLyBPZmZzZXQgPSB0aW1lIGVsYXBzZWRcbiAgd2hpbGUgKChfcHJldkNDID0gcHJldkNDKSAhPSBudWxsICYmIF9wcmV2Q0MubmV3KSB7XG4gICAgdmFyIF9wcmV2Q0M7XG4gICAgdnR0Q0NzLmNjT2Zmc2V0ICs9IGN1cnJDQy5zdGFydCAtIHByZXZDQy5zdGFydDtcbiAgICBjdXJyQ0MubmV3ID0gZmFsc2U7XG4gICAgY3VyckNDID0gcHJldkNDO1xuICAgIHByZXZDQyA9IHZ0dENDc1tjdXJyQ0MucHJldkNDXTtcbiAgfVxuICB2dHRDQ3MucHJlc2VudGF0aW9uT2Zmc2V0ID0gcHJlc2VudGF0aW9uVGltZTtcbn07XG5mdW5jdGlvbiBwYXJzZVdlYlZUVCh2dHRCeXRlQXJyYXksIGluaXRQVFMsIHZ0dENDcywgY2MsIHRpbWVPZmZzZXQsIGNhbGxCYWNrLCBlcnJvckNhbGxCYWNrKSB7XG4gIGNvbnN0IHBhcnNlciA9IG5ldyBWVFRQYXJzZXIoKTtcbiAgLy8gQ29udmVydCBieXRlQXJyYXkgaW50byBzdHJpbmcsIHJlcGxhY2luZyBhbnkgc29tZXdoYXQgZXhvdGljIGxpbmVmZWVkcyB3aXRoIFwiXFxuXCIsIHRoZW4gc3BsaXQgb24gdGhhdCBjaGFyYWN0ZXIuXG4gIC8vIFVpbnQ4QXJyYXkucHJvdG90eXBlLnJlZHVjZSBpcyBub3QgaW1wbGVtZW50ZWQgaW4gSUUxMVxuICBjb25zdCB2dHRMaW5lcyA9IHV0ZjhBcnJheVRvU3RyKG5ldyBVaW50OEFycmF5KHZ0dEJ5dGVBcnJheSkpLnRyaW0oKS5yZXBsYWNlKExJTkVCUkVBS1MsICdcXG4nKS5zcGxpdCgnXFxuJyk7XG4gIGNvbnN0IGN1ZXMgPSBbXTtcbiAgY29uc3QgaW5pdDkwa0h6ID0gaW5pdFBUUyA/IHRvTXBlZ1RzQ2xvY2tGcm9tVGltZXNjYWxlKGluaXRQVFMuYmFzZVRpbWUsIGluaXRQVFMudGltZXNjYWxlKSA6IDA7XG4gIGxldCBjdWVUaW1lID0gJzAwOjAwLjAwMCc7XG4gIGxldCB0aW1lc3RhbXBNYXBNUEVHVFMgPSAwO1xuICBsZXQgdGltZXN0YW1wTWFwTE9DQUwgPSAwO1xuICBsZXQgcGFyc2luZ0Vycm9yO1xuICBsZXQgaW5IZWFkZXIgPSB0cnVlO1xuICBwYXJzZXIub25jdWUgPSBmdW5jdGlvbiAoY3VlKSB7XG4gICAgLy8gQWRqdXN0IGN1ZSB0aW1pbmc7IGNsYW1wIGN1ZXMgdG8gc3RhcnQgbm8gZWFybGllciB0aGFuIC0gYW5kIGRyb3AgY3VlcyB0aGF0IGRvbid0IGVuZCBhZnRlciAtIDAgb24gdGltZWxpbmUuXG4gICAgY29uc3QgY3VyckNDID0gdnR0Q0NzW2NjXTtcbiAgICBsZXQgY3VlT2Zmc2V0ID0gdnR0Q0NzLmNjT2Zmc2V0O1xuXG4gICAgLy8gQ2FsY3VsYXRlIHN1YnRpdGxlIFBUUyBvZmZzZXRcbiAgICBjb25zdCB3ZWJWdHRNcGVnVHNNYXBPZmZzZXQgPSAodGltZXN0YW1wTWFwTVBFR1RTIC0gaW5pdDkwa0h6KSAvIDkwMDAwO1xuXG4gICAgLy8gVXBkYXRlIG9mZnNldHMgZm9yIG5ldyBkaXNjb250aW51aXRpZXNcbiAgICBpZiAoY3VyckNDICE9IG51bGwgJiYgY3VyckNDLm5ldykge1xuICAgICAgaWYgKHRpbWVzdGFtcE1hcExPQ0FMICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gV2hlbiBsb2NhbCB0aW1lIGlzIHByb3ZpZGVkLCBvZmZzZXQgPSBkaXNjb250aW51aXR5IHN0YXJ0IHRpbWUgLSBsb2NhbCB0aW1lXG4gICAgICAgIGN1ZU9mZnNldCA9IHZ0dENDcy5jY09mZnNldCA9IGN1cnJDQy5zdGFydDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGN1bGF0ZU9mZnNldCh2dHRDQ3MsIGNjLCB3ZWJWdHRNcGVnVHNNYXBPZmZzZXQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAod2ViVnR0TXBlZ1RzTWFwT2Zmc2V0KSB7XG4gICAgICBpZiAoIWluaXRQVFMpIHtcbiAgICAgICAgcGFyc2luZ0Vycm9yID0gbmV3IEVycm9yKCdNaXNzaW5nIGluaXRQVFMgZm9yIFZUVCBNUEVHVFMnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gSWYgd2UgaGF2ZSBNUEVHVFMsIG9mZnNldCA9IHByZXNlbnRhdGlvbiB0aW1lICsgZGlzY29udGludWl0eSBvZmZzZXRcbiAgICAgIGN1ZU9mZnNldCA9IHdlYlZ0dE1wZWdUc01hcE9mZnNldCAtIHZ0dENDcy5wcmVzZW50YXRpb25PZmZzZXQ7XG4gICAgfVxuICAgIGNvbnN0IGR1cmF0aW9uID0gY3VlLmVuZFRpbWUgLSBjdWUuc3RhcnRUaW1lO1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IG5vcm1hbGl6ZVB0cygoY3VlLnN0YXJ0VGltZSArIGN1ZU9mZnNldCAtIHRpbWVzdGFtcE1hcExPQ0FMKSAqIDkwMDAwLCB0aW1lT2Zmc2V0ICogOTAwMDApIC8gOTAwMDA7XG4gICAgY3VlLnN0YXJ0VGltZSA9IE1hdGgubWF4KHN0YXJ0VGltZSwgMCk7XG4gICAgY3VlLmVuZFRpbWUgPSBNYXRoLm1heChzdGFydFRpbWUgKyBkdXJhdGlvbiwgMCk7XG5cbiAgICAvL3RyaW0gdHJhaWxpbmcgd2VidnR0IGJsb2NrIHdoaXRlc3BhY2VzXG4gICAgY29uc3QgdGV4dCA9IGN1ZS50ZXh0LnRyaW0oKTtcblxuICAgIC8vIEZpeCBlbmNvZGluZyBvZiBzcGVjaWFsIGNoYXJhY3RlcnNcbiAgICBjdWUudGV4dCA9IGRlY29kZVVSSUNvbXBvbmVudChlbmNvZGVVUklDb21wb25lbnQodGV4dCkpO1xuXG4gICAgLy8gSWYgdGhlIGN1ZSB3YXMgbm90IGFzc2lnbmVkIGFuIGlkIGZyb20gdGhlIFZUVCBmaWxlIChsaW5lIGFib3ZlIHRoZSBjb250ZW50KSwgY3JlYXRlIG9uZS5cbiAgICBpZiAoIWN1ZS5pZCkge1xuICAgICAgY3VlLmlkID0gZ2VuZXJhdGVDdWVJZChjdWUuc3RhcnRUaW1lLCBjdWUuZW5kVGltZSwgdGV4dCk7XG4gICAgfVxuICAgIGlmIChjdWUuZW5kVGltZSA+IDApIHtcbiAgICAgIGN1ZXMucHVzaChjdWUpO1xuICAgIH1cbiAgfTtcbiAgcGFyc2VyLm9ucGFyc2luZ2Vycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgcGFyc2luZ0Vycm9yID0gZXJyb3I7XG4gIH07XG4gIHBhcnNlci5vbmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChwYXJzaW5nRXJyb3IpIHtcbiAgICAgIGVycm9yQ2FsbEJhY2socGFyc2luZ0Vycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbEJhY2soY3Vlcyk7XG4gIH07XG5cbiAgLy8gR28gdGhyb3VnaCBjb250ZW50cyBsaW5lIGJ5IGxpbmUuXG4gIHZ0dExpbmVzLmZvckVhY2gobGluZSA9PiB7XG4gICAgaWYgKGluSGVhZGVyKSB7XG4gICAgICAvLyBMb29rIGZvciBYLVRJTUVTVEFNUC1NQVAgaW4gaGVhZGVyLlxuICAgICAgaWYgKHN0YXJ0c1dpdGgobGluZSwgJ1gtVElNRVNUQU1QLU1BUD0nKSkge1xuICAgICAgICAvLyBPbmNlIGZvdW5kLCBubyBtb3JlIGFyZSBhbGxvd2VkIGFueXdheSwgc28gc3RvcCBzZWFyY2hpbmcuXG4gICAgICAgIGluSGVhZGVyID0gZmFsc2U7XG4gICAgICAgIC8vIEV4dHJhY3QgTE9DQUwgYW5kIE1QRUdUUy5cbiAgICAgICAgbGluZS5zbGljZSgxNikuc3BsaXQoJywnKS5mb3JFYWNoKHRpbWVzdGFtcCA9PiB7XG4gICAgICAgICAgaWYgKHN0YXJ0c1dpdGgodGltZXN0YW1wLCAnTE9DQUw6JykpIHtcbiAgICAgICAgICAgIGN1ZVRpbWUgPSB0aW1lc3RhbXAuc2xpY2UoNik7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdGFydHNXaXRoKHRpbWVzdGFtcCwgJ01QRUdUUzonKSkge1xuICAgICAgICAgICAgdGltZXN0YW1wTWFwTVBFR1RTID0gcGFyc2VJbnQodGltZXN0YW1wLnNsaWNlKDcpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIENvbnZlcnQgY3VlIHRpbWUgdG8gc2Vjb25kc1xuICAgICAgICAgIHRpbWVzdGFtcE1hcExPQ0FMID0gY3VlU3RyaW5nMm1pbGxpcyhjdWVUaW1lKSAvIDEwMDA7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgcGFyc2luZ0Vycm9yID0gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIHdpdGhvdXQgcGFyc2luZyBYLVRJTUVTVEFNUC1NQVAgbGluZS5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChsaW5lID09PSAnJykge1xuICAgICAgICBpbkhlYWRlciA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBQYXJzZSBsaW5lIGJ5IGRlZmF1bHQuXG4gICAgcGFyc2VyLnBhcnNlKGxpbmUgKyAnXFxuJyk7XG4gIH0pO1xuICBwYXJzZXIuZmx1c2goKTtcbn1cblxuY29uc3QgSU1TQzFfQ09ERUMgPSAnc3RwcC50dG1sLmltMXQnO1xuXG4vLyBUaW1lIGZvcm1hdDogaDptOnM6ZnJhbWVzKC5zdWJmcmFtZXMpXG5jb25zdCBITVNGX1JFR0VYID0gL14oXFxkezIsfSk6KFxcZHsyfSk6KFxcZHsyfSk6KFxcZHsyfSlcXC4/KFxcZCspPyQvO1xuXG4vLyBUaW1lIGZvcm1hdDogaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgZnJhbWVzLCB0aWNrc1xuY29uc3QgVElNRV9VTklUX1JFR0VYID0gL14oXFxkKig/OlxcLlxcZCopPykoaHxtfHN8bXN8Znx0KSQvO1xuY29uc3QgdGV4dEFsaWduVG9MaW5lQWxpZ24gPSB7XG4gIGxlZnQ6ICdzdGFydCcsXG4gIGNlbnRlcjogJ2NlbnRlcicsXG4gIHJpZ2h0OiAnZW5kJyxcbiAgc3RhcnQ6ICdzdGFydCcsXG4gIGVuZDogJ2VuZCdcbn07XG5mdW5jdGlvbiBwYXJzZUlNU0MxKHBheWxvYWQsIGluaXRQVFMsIGNhbGxCYWNrLCBlcnJvckNhbGxCYWNrKSB7XG4gIGNvbnN0IHJlc3VsdHMgPSBmaW5kQm94KG5ldyBVaW50OEFycmF5KHBheWxvYWQpLCBbJ21kYXQnXSk7XG4gIGlmIChyZXN1bHRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGVycm9yQ2FsbEJhY2sobmV3IEVycm9yKCdDb3VsZCBub3QgcGFyc2UgSU1TQzEgbWRhdCcpKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdHRtbExpc3QgPSByZXN1bHRzLm1hcChtZGF0ID0+IHV0ZjhBcnJheVRvU3RyKG1kYXQpKTtcbiAgY29uc3Qgc3luY1RpbWUgPSB0b1RpbWVzY2FsZUZyb21TY2FsZShpbml0UFRTLmJhc2VUaW1lLCAxLCBpbml0UFRTLnRpbWVzY2FsZSk7XG4gIHRyeSB7XG4gICAgdHRtbExpc3QuZm9yRWFjaCh0dG1sID0+IGNhbGxCYWNrKHBhcnNlVFRNTCh0dG1sLCBzeW5jVGltZSkpKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBlcnJvckNhbGxCYWNrKGVycm9yKTtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VUVE1MKHR0bWwsIHN5bmNUaW1lKSB7XG4gIGNvbnN0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgY29uc3QgeG1sRG9jID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyh0dG1sLCAndGV4dC94bWwnKTtcbiAgY29uc3QgdHQgPSB4bWxEb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3R0JylbMF07XG4gIGlmICghdHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHRtbCcpO1xuICB9XG4gIGNvbnN0IGRlZmF1bHRSYXRlSW5mbyA9IHtcbiAgICBmcmFtZVJhdGU6IDMwLFxuICAgIHN1YkZyYW1lUmF0ZTogMSxcbiAgICBmcmFtZVJhdGVNdWx0aXBsaWVyOiAwLFxuICAgIHRpY2tSYXRlOiAwXG4gIH07XG4gIGNvbnN0IHJhdGVJbmZvID0gT2JqZWN0LmtleXMoZGVmYXVsdFJhdGVJbmZvKS5yZWR1Y2UoKHJlc3VsdCwga2V5KSA9PiB7XG4gICAgcmVzdWx0W2tleV0gPSB0dC5nZXRBdHRyaWJ1dGUoYHR0cDoke2tleX1gKSB8fCBkZWZhdWx0UmF0ZUluZm9ba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LCB7fSk7XG4gIGNvbnN0IHRyaW0gPSB0dC5nZXRBdHRyaWJ1dGUoJ3htbDpzcGFjZScpICE9PSAncHJlc2VydmUnO1xuICBjb25zdCBzdHlsZUVsZW1lbnRzID0gY29sbGVjdGlvblRvRGljdGlvbmFyeShnZXRFbGVtZW50Q29sbGVjdGlvbih0dCwgJ3N0eWxpbmcnLCAnc3R5bGUnKSk7XG4gIGNvbnN0IHJlZ2lvbkVsZW1lbnRzID0gY29sbGVjdGlvblRvRGljdGlvbmFyeShnZXRFbGVtZW50Q29sbGVjdGlvbih0dCwgJ2xheW91dCcsICdyZWdpb24nKSk7XG4gIGNvbnN0IGN1ZUVsZW1lbnRzID0gZ2V0RWxlbWVudENvbGxlY3Rpb24odHQsICdib2R5JywgJ1tiZWdpbl0nKTtcbiAgcmV0dXJuIFtdLm1hcC5jYWxsKGN1ZUVsZW1lbnRzLCBjdWVFbGVtZW50ID0+IHtcbiAgICBjb25zdCBjdWVUZXh0ID0gZ2V0VGV4dENvbnRlbnQoY3VlRWxlbWVudCwgdHJpbSk7XG4gICAgaWYgKCFjdWVUZXh0IHx8ICFjdWVFbGVtZW50Lmhhc0F0dHJpYnV0ZSgnYmVnaW4nKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBhcnNlVHRtbFRpbWUoY3VlRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2JlZ2luJyksIHJhdGVJbmZvKTtcbiAgICBjb25zdCBkdXJhdGlvbiA9IHBhcnNlVHRtbFRpbWUoY3VlRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2R1cicpLCByYXRlSW5mbyk7XG4gICAgbGV0IGVuZFRpbWUgPSBwYXJzZVR0bWxUaW1lKGN1ZUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdlbmQnKSwgcmF0ZUluZm8pO1xuICAgIGlmIChzdGFydFRpbWUgPT09IG51bGwpIHtcbiAgICAgIHRocm93IHRpbWVzdGFtcFBhcnNpbmdFcnJvcihjdWVFbGVtZW50KTtcbiAgICB9XG4gICAgaWYgKGVuZFRpbWUgPT09IG51bGwpIHtcbiAgICAgIGlmIChkdXJhdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyB0aW1lc3RhbXBQYXJzaW5nRXJyb3IoY3VlRWxlbWVudCk7XG4gICAgICB9XG4gICAgICBlbmRUaW1lID0gc3RhcnRUaW1lICsgZHVyYXRpb247XG4gICAgfVxuICAgIGNvbnN0IGN1ZSA9IG5ldyBWVFRDdWUoc3RhcnRUaW1lIC0gc3luY1RpbWUsIGVuZFRpbWUgLSBzeW5jVGltZSwgY3VlVGV4dCk7XG4gICAgY3VlLmlkID0gZ2VuZXJhdGVDdWVJZChjdWUuc3RhcnRUaW1lLCBjdWUuZW5kVGltZSwgY3VlLnRleHQpO1xuICAgIGNvbnN0IHJlZ2lvbiA9IHJlZ2lvbkVsZW1lbnRzW2N1ZUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdyZWdpb24nKV07XG4gICAgY29uc3Qgc3R5bGUgPSBzdHlsZUVsZW1lbnRzW2N1ZUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzdHlsZScpXTtcblxuICAgIC8vIEFwcGx5IHN0eWxlcyB0byBjdWVcbiAgICBjb25zdCBzdHlsZXMgPSBnZXRUdG1sU3R5bGVzKHJlZ2lvbiwgc3R5bGUsIHN0eWxlRWxlbWVudHMpO1xuICAgIGNvbnN0IHtcbiAgICAgIHRleHRBbGlnblxuICAgIH0gPSBzdHlsZXM7XG4gICAgaWYgKHRleHRBbGlnbikge1xuICAgICAgLy8gY3VlLnBvc2l0aW9uQWxpZ24gbm90IHNldHRhYmxlIGluIEZGfjIwMTZcbiAgICAgIGNvbnN0IGxpbmVBbGlnbiA9IHRleHRBbGlnblRvTGluZUFsaWduW3RleHRBbGlnbl07XG4gICAgICBpZiAobGluZUFsaWduKSB7XG4gICAgICAgIGN1ZS5saW5lQWxpZ24gPSBsaW5lQWxpZ247XG4gICAgICB9XG4gICAgICBjdWUuYWxpZ24gPSB0ZXh0QWxpZ247XG4gICAgfVxuICAgIF9leHRlbmRzKGN1ZSwgc3R5bGVzKTtcbiAgICByZXR1cm4gY3VlO1xuICB9KS5maWx0ZXIoY3VlID0+IGN1ZSAhPT0gbnVsbCk7XG59XG5mdW5jdGlvbiBnZXRFbGVtZW50Q29sbGVjdGlvbihmcm9tRWxlbWVudCwgcGFyZW50TmFtZSwgY2hpbGROYW1lKSB7XG4gIGNvbnN0IHBhcmVudCA9IGZyb21FbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKHBhcmVudE5hbWUpWzBdO1xuICBpZiAocGFyZW50KSB7XG4gICAgcmV0dXJuIFtdLnNsaWNlLmNhbGwocGFyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoY2hpbGROYW1lKSk7XG4gIH1cbiAgcmV0dXJuIFtdO1xufVxuZnVuY3Rpb24gY29sbGVjdGlvblRvRGljdGlvbmFyeShlbGVtZW50c1dpdGhJZCkge1xuICByZXR1cm4gZWxlbWVudHNXaXRoSWQucmVkdWNlKChkaWN0LCBlbGVtZW50KSA9PiB7XG4gICAgY29uc3QgaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgneG1sOmlkJyk7XG4gICAgaWYgKGlkKSB7XG4gICAgICBkaWN0W2lkXSA9IGVsZW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiBkaWN0O1xuICB9LCB7fSk7XG59XG5mdW5jdGlvbiBnZXRUZXh0Q29udGVudChlbGVtZW50LCB0cmltKSB7XG4gIHJldHVybiBbXS5zbGljZS5jYWxsKGVsZW1lbnQuY2hpbGROb2RlcykucmVkdWNlKChzdHIsIG5vZGUsIGkpID0+IHtcbiAgICB2YXIgX25vZGUkY2hpbGROb2RlcztcbiAgICBpZiAobm9kZS5ub2RlTmFtZSA9PT0gJ2JyJyAmJiBpKSB7XG4gICAgICByZXR1cm4gc3RyICsgJ1xcbic7XG4gICAgfVxuICAgIGlmICgoX25vZGUkY2hpbGROb2RlcyA9IG5vZGUuY2hpbGROb2RlcykgIT0gbnVsbCAmJiBfbm9kZSRjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGdldFRleHRDb250ZW50KG5vZGUsIHRyaW0pO1xuICAgIH0gZWxzZSBpZiAodHJpbSkge1xuICAgICAgcmV0dXJuIHN0ciArIG5vZGUudGV4dENvbnRlbnQudHJpbSgpLnJlcGxhY2UoL1xccysvZywgJyAnKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0ciArIG5vZGUudGV4dENvbnRlbnQ7XG4gIH0sICcnKTtcbn1cbmZ1bmN0aW9uIGdldFR0bWxTdHlsZXMocmVnaW9uLCBzdHlsZSwgc3R5bGVFbGVtZW50cykge1xuICBjb25zdCB0dHNOcyA9ICdodHRwOi8vd3d3LnczLm9yZy9ucy90dG1sI3N0eWxpbmcnO1xuICBsZXQgcmVnaW9uU3R5bGUgPSBudWxsO1xuICBjb25zdCBzdHlsZUF0dHJpYnV0ZXMgPSBbJ2Rpc3BsYXlBbGlnbicsICd0ZXh0QWxpZ24nLCAnY29sb3InLCAnYmFja2dyb3VuZENvbG9yJywgJ2ZvbnRTaXplJywgJ2ZvbnRGYW1pbHknXG4gIC8vICdmb250V2VpZ2h0JyxcbiAgLy8gJ2xpbmVIZWlnaHQnLFxuICAvLyAnd3JhcE9wdGlvbicsXG4gIC8vICdmb250U3R5bGUnLFxuICAvLyAnZGlyZWN0aW9uJyxcbiAgLy8gJ3dyaXRpbmdNb2RlJ1xuICBdO1xuICBjb25zdCByZWdpb25TdHlsZU5hbWUgPSByZWdpb24gIT0gbnVsbCAmJiByZWdpb24uaGFzQXR0cmlidXRlKCdzdHlsZScpID8gcmVnaW9uLmdldEF0dHJpYnV0ZSgnc3R5bGUnKSA6IG51bGw7XG4gIGlmIChyZWdpb25TdHlsZU5hbWUgJiYgc3R5bGVFbGVtZW50cy5oYXNPd25Qcm9wZXJ0eShyZWdpb25TdHlsZU5hbWUpKSB7XG4gICAgcmVnaW9uU3R5bGUgPSBzdHlsZUVsZW1lbnRzW3JlZ2lvblN0eWxlTmFtZV07XG4gIH1cbiAgcmV0dXJuIHN0eWxlQXR0cmlidXRlcy5yZWR1Y2UoKHN0eWxlcywgbmFtZSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gZ2V0QXR0cmlidXRlTlMoc3R5bGUsIHR0c05zLCBuYW1lKSB8fCBnZXRBdHRyaWJ1dGVOUyhyZWdpb24sIHR0c05zLCBuYW1lKSB8fCBnZXRBdHRyaWJ1dGVOUyhyZWdpb25TdHlsZSwgdHRzTnMsIG5hbWUpO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgc3R5bGVzW25hbWVdID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBzdHlsZXM7XG4gIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZU5TKGVsZW1lbnQsIG5zLCBuYW1lKSB7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBlbGVtZW50Lmhhc0F0dHJpYnV0ZU5TKG5zLCBuYW1lKSA/IGVsZW1lbnQuZ2V0QXR0cmlidXRlTlMobnMsIG5hbWUpIDogbnVsbDtcbn1cbmZ1bmN0aW9uIHRpbWVzdGFtcFBhcnNpbmdFcnJvcihub2RlKSB7XG4gIHJldHVybiBuZXcgRXJyb3IoYENvdWxkIG5vdCBwYXJzZSB0dG1sIHRpbWVzdGFtcCAke25vZGV9YCk7XG59XG5mdW5jdGlvbiBwYXJzZVR0bWxUaW1lKHRpbWVBdHRyaWJ1dGVWYWx1ZSwgcmF0ZUluZm8pIHtcbiAgaWYgKCF0aW1lQXR0cmlidXRlVmFsdWUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBsZXQgc2Vjb25kcyA9IHBhcnNlVGltZVN0YW1wKHRpbWVBdHRyaWJ1dGVWYWx1ZSk7XG4gIGlmIChzZWNvbmRzID09PSBudWxsKSB7XG4gICAgaWYgKEhNU0ZfUkVHRVgudGVzdCh0aW1lQXR0cmlidXRlVmFsdWUpKSB7XG4gICAgICBzZWNvbmRzID0gcGFyc2VIb3Vyc01pbnV0ZXNTZWNvbmRzRnJhbWVzKHRpbWVBdHRyaWJ1dGVWYWx1ZSwgcmF0ZUluZm8pO1xuICAgIH0gZWxzZSBpZiAoVElNRV9VTklUX1JFR0VYLnRlc3QodGltZUF0dHJpYnV0ZVZhbHVlKSkge1xuICAgICAgc2Vjb25kcyA9IHBhcnNlVGltZVVuaXRzKHRpbWVBdHRyaWJ1dGVWYWx1ZSwgcmF0ZUluZm8pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2Vjb25kcztcbn1cbmZ1bmN0aW9uIHBhcnNlSG91cnNNaW51dGVzU2Vjb25kc0ZyYW1lcyh0aW1lQXR0cmlidXRlVmFsdWUsIHJhdGVJbmZvKSB7XG4gIGNvbnN0IG0gPSBITVNGX1JFR0VYLmV4ZWModGltZUF0dHJpYnV0ZVZhbHVlKTtcbiAgY29uc3QgZnJhbWVzID0gKG1bNF0gfCAwKSArIChtWzVdIHwgMCkgLyByYXRlSW5mby5zdWJGcmFtZVJhdGU7XG4gIHJldHVybiAobVsxXSB8IDApICogMzYwMCArIChtWzJdIHwgMCkgKiA2MCArIChtWzNdIHwgMCkgKyBmcmFtZXMgLyByYXRlSW5mby5mcmFtZVJhdGU7XG59XG5mdW5jdGlvbiBwYXJzZVRpbWVVbml0cyh0aW1lQXR0cmlidXRlVmFsdWUsIHJhdGVJbmZvKSB7XG4gIGNvbnN0IG0gPSBUSU1FX1VOSVRfUkVHRVguZXhlYyh0aW1lQXR0cmlidXRlVmFsdWUpO1xuICBjb25zdCB2YWx1ZSA9IE51bWJlcihtWzFdKTtcbiAgY29uc3QgdW5pdCA9IG1bMl07XG4gIHN3aXRjaCAodW5pdCkge1xuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIHZhbHVlICogMzYwMDtcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiB2YWx1ZSAqIDYwO1xuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiB2YWx1ZSAqIDEwMDA7XG4gICAgY2FzZSAnZic6XG4gICAgICByZXR1cm4gdmFsdWUgLyByYXRlSW5mby5mcmFtZVJhdGU7XG4gICAgY2FzZSAndCc6XG4gICAgICByZXR1cm4gdmFsdWUgLyByYXRlSW5mby50aWNrUmF0ZTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbmNsYXNzIFRpbWVsaW5lQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIHRoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5DdWVzID0gdm9pZCAwO1xuICAgIHRoaXMudGV4dFRyYWNrcyA9IFtdO1xuICAgIHRoaXMudHJhY2tzID0gW107XG4gICAgdGhpcy5pbml0UFRTID0gW107XG4gICAgdGhpcy51bnBhcnNlZFZ0dEZyYWdzID0gW107XG4gICAgdGhpcy5jYXB0aW9uc1RyYWNrcyA9IHt9O1xuICAgIHRoaXMubm9uTmF0aXZlQ2FwdGlvbnNUcmFja3MgPSB7fTtcbiAgICB0aGlzLmNlYTYwOFBhcnNlcjEgPSB2b2lkIDA7XG4gICAgdGhpcy5jZWE2MDhQYXJzZXIyID0gdm9pZCAwO1xuICAgIHRoaXMubGFzdENjID0gLTE7XG4gICAgLy8gTGFzdCB2aWRlbyAoQ0VBLTYwOCkgZnJhZ21lbnQgQ0NcbiAgICB0aGlzLmxhc3RTbiA9IC0xO1xuICAgIC8vIExhc3QgdmlkZW8gKENFQS02MDgpIGZyYWdtZW50IE1TTlxuICAgIHRoaXMubGFzdFBhcnRJbmRleCA9IC0xO1xuICAgIC8vIExhc3QgdmlkZW8gKENFQS02MDgpIGZyYWdtZW50IFBhcnQgSW5kZXhcbiAgICB0aGlzLnByZXZDQyA9IC0xO1xuICAgIC8vIExhc3Qgc3VidGl0bGUgZnJhZ21lbnQgQ0NcbiAgICB0aGlzLnZ0dENDcyA9IG5ld1ZUVENDcygpO1xuICAgIHRoaXMuY2FwdGlvbnNQcm9wZXJ0aWVzID0gdm9pZCAwO1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMuY29uZmlnID0gaGxzLmNvbmZpZztcbiAgICB0aGlzLkN1ZXMgPSBobHMuY29uZmlnLmN1ZUhhbmRsZXI7XG4gICAgdGhpcy5jYXB0aW9uc1Byb3BlcnRpZXMgPSB7XG4gICAgICB0ZXh0VHJhY2sxOiB7XG4gICAgICAgIGxhYmVsOiB0aGlzLmNvbmZpZy5jYXB0aW9uc1RleHRUcmFjazFMYWJlbCxcbiAgICAgICAgbGFuZ3VhZ2VDb2RlOiB0aGlzLmNvbmZpZy5jYXB0aW9uc1RleHRUcmFjazFMYW5ndWFnZUNvZGVcbiAgICAgIH0sXG4gICAgICB0ZXh0VHJhY2syOiB7XG4gICAgICAgIGxhYmVsOiB0aGlzLmNvbmZpZy5jYXB0aW9uc1RleHRUcmFjazJMYWJlbCxcbiAgICAgICAgbGFuZ3VhZ2VDb2RlOiB0aGlzLmNvbmZpZy5jYXB0aW9uc1RleHRUcmFjazJMYW5ndWFnZUNvZGVcbiAgICAgIH0sXG4gICAgICB0ZXh0VHJhY2szOiB7XG4gICAgICAgIGxhYmVsOiB0aGlzLmNvbmZpZy5jYXB0aW9uc1RleHRUcmFjazNMYWJlbCxcbiAgICAgICAgbGFuZ3VhZ2VDb2RlOiB0aGlzLmNvbmZpZy5jYXB0aW9uc1RleHRUcmFjazNMYW5ndWFnZUNvZGVcbiAgICAgIH0sXG4gICAgICB0ZXh0VHJhY2s0OiB7XG4gICAgICAgIGxhYmVsOiB0aGlzLmNvbmZpZy5jYXB0aW9uc1RleHRUcmFjazRMYWJlbCxcbiAgICAgICAgbGFuZ3VhZ2VDb2RlOiB0aGlzLmNvbmZpZy5jYXB0aW9uc1RleHRUcmFjazRMYW5ndWFnZUNvZGVcbiAgICAgIH1cbiAgICB9O1xuICAgIGhscy5vbihFdmVudHMuTUVESUFfQVRUQUNISU5HLCB0aGlzLm9uTWVkaWFBdHRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FERUQsIHRoaXMub25NYW5pZmVzdExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5TVUJUSVRMRV9UUkFDS1NfVVBEQVRFRCwgdGhpcy5vblN1YnRpdGxlVHJhY2tzVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5GUkFHX0xPQURJTkcsIHRoaXMub25GcmFnTG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5GUkFHX0xPQURFRCwgdGhpcy5vbkZyYWdMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRlJBR19QQVJTSU5HX1VTRVJEQVRBLCB0aGlzLm9uRnJhZ1BhcnNpbmdVc2VyZGF0YSwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5GUkFHX0RFQ1JZUFRFRCwgdGhpcy5vbkZyYWdEZWNyeXB0ZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuSU5JVF9QVFNfRk9VTkQsIHRoaXMub25Jbml0UHRzRm91bmQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuU1VCVElUTEVfVFJBQ0tTX0NMRUFSRUQsIHRoaXMub25TdWJ0aXRsZVRyYWNrc0NsZWFyZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuQlVGRkVSX0ZMVVNISU5HLCB0aGlzLm9uQnVmZmVyRmx1c2hpbmcsIHRoaXMpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaGxzLm9mZihFdmVudHMuTUVESUFfQVRUQUNISU5HLCB0aGlzLm9uTWVkaWFBdHRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FERUQsIHRoaXMub25NYW5pZmVzdExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuU1VCVElUTEVfVFJBQ0tTX1VQREFURUQsIHRoaXMub25TdWJ0aXRsZVRyYWNrc1VwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkZSQUdfTE9BRElORywgdGhpcy5vbkZyYWdMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5GUkFHX0xPQURFRCwgdGhpcy5vbkZyYWdMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkZSQUdfUEFSU0lOR19VU0VSREFUQSwgdGhpcy5vbkZyYWdQYXJzaW5nVXNlcmRhdGEsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkZSQUdfREVDUllQVEVELCB0aGlzLm9uRnJhZ0RlY3J5cHRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuSU5JVF9QVFNfRk9VTkQsIHRoaXMub25Jbml0UHRzRm91bmQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLlNVQlRJVExFX1RSQUNLU19DTEVBUkVELCB0aGlzLm9uU3VidGl0bGVUcmFja3NDbGVhcmVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfRkxVU0hJTkcsIHRoaXMub25CdWZmZXJGbHVzaGluZywgdGhpcyk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuaGxzID0gdGhpcy5jb25maWcgPSBudWxsO1xuICAgIHRoaXMuY2VhNjA4UGFyc2VyMSA9IHRoaXMuY2VhNjA4UGFyc2VyMiA9IHVuZGVmaW5lZDtcbiAgfVxuICBpbml0Q2VhNjA4UGFyc2VycygpIHtcbiAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlQ0VBNzA4Q2FwdGlvbnMgJiYgKCF0aGlzLmNlYTYwOFBhcnNlcjEgfHwgIXRoaXMuY2VhNjA4UGFyc2VyMikpIHtcbiAgICAgIGNvbnN0IGNoYW5uZWwxID0gbmV3IE91dHB1dEZpbHRlcih0aGlzLCAndGV4dFRyYWNrMScpO1xuICAgICAgY29uc3QgY2hhbm5lbDIgPSBuZXcgT3V0cHV0RmlsdGVyKHRoaXMsICd0ZXh0VHJhY2syJyk7XG4gICAgICBjb25zdCBjaGFubmVsMyA9IG5ldyBPdXRwdXRGaWx0ZXIodGhpcywgJ3RleHRUcmFjazMnKTtcbiAgICAgIGNvbnN0IGNoYW5uZWw0ID0gbmV3IE91dHB1dEZpbHRlcih0aGlzLCAndGV4dFRyYWNrNCcpO1xuICAgICAgdGhpcy5jZWE2MDhQYXJzZXIxID0gbmV3IENlYTYwOFBhcnNlcigxLCBjaGFubmVsMSwgY2hhbm5lbDIpO1xuICAgICAgdGhpcy5jZWE2MDhQYXJzZXIyID0gbmV3IENlYTYwOFBhcnNlcigzLCBjaGFubmVsMywgY2hhbm5lbDQpO1xuICAgIH1cbiAgfVxuICBhZGRDdWVzKHRyYWNrTmFtZSwgc3RhcnRUaW1lLCBlbmRUaW1lLCBzY3JlZW4sIGN1ZVJhbmdlcykge1xuICAgIC8vIHNraXAgY3VlcyB3aGljaCBvdmVybGFwIG1vcmUgdGhhbiA1MCUgd2l0aCBwcmV2aW91c2x5IHBhcnNlZCB0aW1lIHJhbmdlc1xuICAgIGxldCBtZXJnZWQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gY3VlUmFuZ2VzLmxlbmd0aDsgaS0tOykge1xuICAgICAgY29uc3QgY3VlUmFuZ2UgPSBjdWVSYW5nZXNbaV07XG4gICAgICBjb25zdCBvdmVybGFwID0gaW50ZXJzZWN0aW9uKGN1ZVJhbmdlWzBdLCBjdWVSYW5nZVsxXSwgc3RhcnRUaW1lLCBlbmRUaW1lKTtcbiAgICAgIGlmIChvdmVybGFwID49IDApIHtcbiAgICAgICAgY3VlUmFuZ2VbMF0gPSBNYXRoLm1pbihjdWVSYW5nZVswXSwgc3RhcnRUaW1lKTtcbiAgICAgICAgY3VlUmFuZ2VbMV0gPSBNYXRoLm1heChjdWVSYW5nZVsxXSwgZW5kVGltZSk7XG4gICAgICAgIG1lcmdlZCA9IHRydWU7XG4gICAgICAgIGlmIChvdmVybGFwIC8gKGVuZFRpbWUgLSBzdGFydFRpbWUpID4gMC41KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghbWVyZ2VkKSB7XG4gICAgICBjdWVSYW5nZXMucHVzaChbc3RhcnRUaW1lLCBlbmRUaW1lXSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbmZpZy5yZW5kZXJUZXh0VHJhY2tzTmF0aXZlbHkpIHtcbiAgICAgIGNvbnN0IHRyYWNrID0gdGhpcy5jYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdO1xuICAgICAgdGhpcy5DdWVzLm5ld0N1ZSh0cmFjaywgc3RhcnRUaW1lLCBlbmRUaW1lLCBzY3JlZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjdWVzID0gdGhpcy5DdWVzLm5ld0N1ZShudWxsLCBzdGFydFRpbWUsIGVuZFRpbWUsIHNjcmVlbik7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5DVUVTX1BBUlNFRCwge1xuICAgICAgICB0eXBlOiAnY2FwdGlvbnMnLFxuICAgICAgICBjdWVzLFxuICAgICAgICB0cmFjazogdHJhY2tOYW1lXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvLyBUcmlnZ2VyZWQgd2hlbiBhbiBpbml0aWFsIFBUUyBpcyBmb3VuZDsgdXNlZCBmb3Igc3luY2hyb25pc2F0aW9uIG9mIFdlYlZUVC5cbiAgb25Jbml0UHRzRm91bmQoZXZlbnQsIHtcbiAgICBmcmFnLFxuICAgIGlkLFxuICAgIGluaXRQVFMsXG4gICAgdGltZXNjYWxlXG4gIH0pIHtcbiAgICBjb25zdCB7XG4gICAgICB1bnBhcnNlZFZ0dEZyYWdzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKGlkID09PSAnbWFpbicpIHtcbiAgICAgIHRoaXMuaW5pdFBUU1tmcmFnLmNjXSA9IHtcbiAgICAgICAgYmFzZVRpbWU6IGluaXRQVFMsXG4gICAgICAgIHRpbWVzY2FsZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBEdWUgdG8gYXN5bmNocm9ub3VzIHByb2Nlc3NpbmcsIGluaXRpYWwgUFRTIG1heSBhcnJpdmUgbGF0ZXIgdGhhbiB0aGUgZmlyc3QgVlRUIGZyYWdtZW50cyBhcmUgbG9hZGVkLlxuICAgIC8vIFBhcnNlIGFueSB1bnBhcnNlZCBmcmFnbWVudHMgdXBvbiByZWNlaXZpbmcgdGhlIGluaXRpYWwgUFRTLlxuICAgIGlmICh1bnBhcnNlZFZ0dEZyYWdzLmxlbmd0aCkge1xuICAgICAgdGhpcy51bnBhcnNlZFZ0dEZyYWdzID0gW107XG4gICAgICB1bnBhcnNlZFZ0dEZyYWdzLmZvckVhY2goZnJhZyA9PiB7XG4gICAgICAgIHRoaXMub25GcmFnTG9hZGVkKEV2ZW50cy5GUkFHX0xPQURFRCwgZnJhZyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZ2V0RXhpc3RpbmdUcmFjayhsYWJlbCwgbGFuZ3VhZ2UpIHtcbiAgICBjb25zdCB7XG4gICAgICBtZWRpYVxuICAgIH0gPSB0aGlzO1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZWRpYS50ZXh0VHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHRleHRUcmFjayA9IG1lZGlhLnRleHRUcmFja3NbaV07XG4gICAgICAgIGlmIChjYW5SZXVzZVZ0dFRleHRUcmFjayh0ZXh0VHJhY2ssIHtcbiAgICAgICAgICBuYW1lOiBsYWJlbCxcbiAgICAgICAgICBsYW5nOiBsYW5ndWFnZSxcbiAgICAgICAgICBhdHRyczoge31cbiAgICAgICAgfSkpIHtcbiAgICAgICAgICByZXR1cm4gdGV4dFRyYWNrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNyZWF0ZUNhcHRpb25zVHJhY2sodHJhY2tOYW1lKSB7XG4gICAgaWYgKHRoaXMuY29uZmlnLnJlbmRlclRleHRUcmFja3NOYXRpdmVseSkge1xuICAgICAgdGhpcy5jcmVhdGVOYXRpdmVUcmFjayh0cmFja05hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNyZWF0ZU5vbk5hdGl2ZVRyYWNrKHRyYWNrTmFtZSk7XG4gICAgfVxuICB9XG4gIGNyZWF0ZU5hdGl2ZVRyYWNrKHRyYWNrTmFtZSkge1xuICAgIGlmICh0aGlzLmNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY2FwdGlvbnNQcm9wZXJ0aWVzLFxuICAgICAgY2FwdGlvbnNUcmFja3MsXG4gICAgICBtZWRpYVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIGxhYmVsLFxuICAgICAgbGFuZ3VhZ2VDb2RlXG4gICAgfSA9IGNhcHRpb25zUHJvcGVydGllc1t0cmFja05hbWVdO1xuICAgIC8vIEVuYWJsZSByZXVzZSBvZiBleGlzdGluZyB0ZXh0IHRyYWNrLlxuICAgIGNvbnN0IGV4aXN0aW5nVHJhY2sgPSB0aGlzLmdldEV4aXN0aW5nVHJhY2sobGFiZWwsIGxhbmd1YWdlQ29kZSk7XG4gICAgaWYgKCFleGlzdGluZ1RyYWNrKSB7XG4gICAgICBjb25zdCB0ZXh0VHJhY2sgPSB0aGlzLmNyZWF0ZVRleHRUcmFjaygnY2FwdGlvbnMnLCBsYWJlbCwgbGFuZ3VhZ2VDb2RlKTtcbiAgICAgIGlmICh0ZXh0VHJhY2spIHtcbiAgICAgICAgLy8gU2V0IGEgc3BlY2lhbCBwcm9wZXJ0eSBvbiB0aGUgdHJhY2sgc28gd2Uga25vdyBpdCdzIG1hbmFnZWQgYnkgSGxzLmpzXG4gICAgICAgIHRleHRUcmFja1t0cmFja05hbWVdID0gdHJ1ZTtcbiAgICAgICAgY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSA9IHRleHRUcmFjaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSA9IGV4aXN0aW5nVHJhY2s7XG4gICAgICBjbGVhckN1cnJlbnRDdWVzKGNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0pO1xuICAgICAgc2VuZEFkZFRyYWNrRXZlbnQoY2FwdGlvbnNUcmFja3NbdHJhY2tOYW1lXSwgbWVkaWEpO1xuICAgIH1cbiAgfVxuICBjcmVhdGVOb25OYXRpdmVUcmFjayh0cmFja05hbWUpIHtcbiAgICBpZiAodGhpcy5ub25OYXRpdmVDYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIENyZWF0ZSBhIGxpc3Qgb2YgYSBzaW5nbGUgdHJhY2sgZm9yIHRoZSBwcm92aWRlciB0byBjb25zdW1lXG4gICAgY29uc3QgdHJhY2tQcm9wZXJ0aWVzID0gdGhpcy5jYXB0aW9uc1Byb3BlcnRpZXNbdHJhY2tOYW1lXTtcbiAgICBpZiAoIXRyYWNrUHJvcGVydGllcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsYWJlbCA9IHRyYWNrUHJvcGVydGllcy5sYWJlbDtcbiAgICBjb25zdCB0cmFjayA9IHtcbiAgICAgIF9pZDogdHJhY2tOYW1lLFxuICAgICAgbGFiZWwsXG4gICAgICBraW5kOiAnY2FwdGlvbnMnLFxuICAgICAgZGVmYXVsdDogdHJhY2tQcm9wZXJ0aWVzLm1lZGlhID8gISF0cmFja1Byb3BlcnRpZXMubWVkaWEuZGVmYXVsdCA6IGZhbHNlLFxuICAgICAgY2xvc2VkQ2FwdGlvbnM6IHRyYWNrUHJvcGVydGllcy5tZWRpYVxuICAgIH07XG4gICAgdGhpcy5ub25OYXRpdmVDYXB0aW9uc1RyYWNrc1t0cmFja05hbWVdID0gdHJhY2s7XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTk9OX05BVElWRV9URVhUX1RSQUNLU19GT1VORCwge1xuICAgICAgdHJhY2tzOiBbdHJhY2tdXG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlVGV4dFRyYWNrKGtpbmQsIGxhYmVsLCBsYW5nKSB7XG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIGlmICghbWVkaWEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIG1lZGlhLmFkZFRleHRUcmFjayhraW5kLCBsYWJlbCwgbGFuZyk7XG4gIH1cbiAgb25NZWRpYUF0dGFjaGluZyhldmVudCwgZGF0YSkge1xuICAgIHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhO1xuICAgIHRoaXMuX2NsZWFuVHJhY2tzKCk7XG4gIH1cbiAgb25NZWRpYURldGFjaGluZygpIHtcbiAgICBjb25zdCB7XG4gICAgICBjYXB0aW9uc1RyYWNrc1xuICAgIH0gPSB0aGlzO1xuICAgIE9iamVjdC5rZXlzKGNhcHRpb25zVHJhY2tzKS5mb3JFYWNoKHRyYWNrTmFtZSA9PiB7XG4gICAgICBjbGVhckN1cnJlbnRDdWVzKGNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0pO1xuICAgICAgZGVsZXRlIGNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV07XG4gICAgfSk7XG4gICAgdGhpcy5ub25OYXRpdmVDYXB0aW9uc1RyYWNrcyA9IHt9O1xuICB9XG4gIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIC8vIERldGVjdCBkaXNjb250aW51aXR5IGluIHZpZGVvIGZyYWdtZW50IChDRUEtNjA4KSBwYXJzaW5nXG4gICAgdGhpcy5sYXN0Q2MgPSAtMTtcbiAgICB0aGlzLmxhc3RTbiA9IC0xO1xuICAgIHRoaXMubGFzdFBhcnRJbmRleCA9IC0xO1xuICAgIC8vIERldGVjdCBkaXNjb250aW51aXR5IGluIHN1YnRpdGxlIG1hbmlmZXN0c1xuICAgIHRoaXMucHJldkNDID0gLTE7XG4gICAgdGhpcy52dHRDQ3MgPSBuZXdWVFRDQ3MoKTtcbiAgICAvLyBSZXNldCB0cmFja3NcbiAgICB0aGlzLl9jbGVhblRyYWNrcygpO1xuICAgIHRoaXMudHJhY2tzID0gW107XG4gICAgdGhpcy5jYXB0aW9uc1RyYWNrcyA9IHt9O1xuICAgIHRoaXMubm9uTmF0aXZlQ2FwdGlvbnNUcmFja3MgPSB7fTtcbiAgICB0aGlzLnRleHRUcmFja3MgPSBbXTtcbiAgICB0aGlzLnVucGFyc2VkVnR0RnJhZ3MgPSBbXTtcbiAgICB0aGlzLmluaXRQVFMgPSBbXTtcbiAgICBpZiAodGhpcy5jZWE2MDhQYXJzZXIxICYmIHRoaXMuY2VhNjA4UGFyc2VyMikge1xuICAgICAgdGhpcy5jZWE2MDhQYXJzZXIxLnJlc2V0KCk7XG4gICAgICB0aGlzLmNlYTYwOFBhcnNlcjIucmVzZXQoKTtcbiAgICB9XG4gIH1cbiAgX2NsZWFuVHJhY2tzKCkge1xuICAgIC8vIGNsZWFyIG91dGRhdGVkIHN1YnRpdGxlc1xuICAgIGNvbnN0IHtcbiAgICAgIG1lZGlhXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFtZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0ZXh0VHJhY2tzID0gbWVkaWEudGV4dFRyYWNrcztcbiAgICBpZiAodGV4dFRyYWNrcykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0VHJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNsZWFyQ3VycmVudEN1ZXModGV4dFRyYWNrc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIG9uU3VidGl0bGVUcmFja3NVcGRhdGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3QgdHJhY2tzID0gZGF0YS5zdWJ0aXRsZVRyYWNrcyB8fCBbXTtcbiAgICBjb25zdCBoYXNJTVNDMSA9IHRyYWNrcy5zb21lKHRyYWNrID0+IHRyYWNrLnRleHRDb2RlYyA9PT0gSU1TQzFfQ09ERUMpO1xuICAgIGlmICh0aGlzLmNvbmZpZy5lbmFibGVXZWJWVFQgfHwgaGFzSU1TQzEgJiYgdGhpcy5jb25maWcuZW5hYmxlSU1TQzEpIHtcbiAgICAgIGNvbnN0IGxpc3RJc0lkZW50aWNhbCA9IHN1YnRpdGxlT3B0aW9uc0lkZW50aWNhbCh0aGlzLnRyYWNrcywgdHJhY2tzKTtcbiAgICAgIGlmIChsaXN0SXNJZGVudGljYWwpIHtcbiAgICAgICAgdGhpcy50cmFja3MgPSB0cmFja3M7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMudGV4dFRyYWNrcyA9IFtdO1xuICAgICAgdGhpcy50cmFja3MgPSB0cmFja3M7XG4gICAgICBpZiAodGhpcy5jb25maWcucmVuZGVyVGV4dFRyYWNrc05hdGl2ZWx5KSB7XG4gICAgICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICAgICAgY29uc3QgaW5Vc2VUcmFja3MgPSBtZWRpYSA/IGZpbHRlclN1YnRpdGxlVHJhY2tzKG1lZGlhLnRleHRUcmFja3MpIDogbnVsbDtcbiAgICAgICAgdGhpcy50cmFja3MuZm9yRWFjaCgodHJhY2ssIGluZGV4KSA9PiB7XG4gICAgICAgICAgLy8gUmV1c2UgdHJhY2tzIHdpdGggdGhlIHNhbWUgbGFiZWwgYW5kIGxhbmcsIGJ1dCBkbyBub3QgcmV1c2UgNjA4LzcwOCB0cmFja3NcbiAgICAgICAgICBsZXQgdGV4dFRyYWNrO1xuICAgICAgICAgIGlmIChpblVzZVRyYWNrcykge1xuICAgICAgICAgICAgbGV0IGluVXNlVHJhY2sgPSBudWxsO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpblVzZVRyYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBpZiAoaW5Vc2VUcmFja3NbaV0gJiYgY2FuUmV1c2VWdHRUZXh0VHJhY2soaW5Vc2VUcmFja3NbaV0sIHRyYWNrKSkge1xuICAgICAgICAgICAgICAgIGluVXNlVHJhY2sgPSBpblVzZVRyYWNrc1tpXTtcbiAgICAgICAgICAgICAgICBpblVzZVRyYWNrc1tpXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpblVzZVRyYWNrKSB7XG4gICAgICAgICAgICAgIHRleHRUcmFjayA9IGluVXNlVHJhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0ZXh0VHJhY2spIHtcbiAgICAgICAgICAgIGNsZWFyQ3VycmVudEN1ZXModGV4dFRyYWNrKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdGV4dFRyYWNrS2luZCA9IGNhcHRpb25zT3JTdWJ0aXRsZXNGcm9tQ2hhcmFjdGVyaXN0aWNzKHRyYWNrKTtcbiAgICAgICAgICAgIHRleHRUcmFjayA9IHRoaXMuY3JlYXRlVGV4dFRyYWNrKHRleHRUcmFja0tpbmQsIHRyYWNrLm5hbWUsIHRyYWNrLmxhbmcpO1xuICAgICAgICAgICAgaWYgKHRleHRUcmFjaykge1xuICAgICAgICAgICAgICB0ZXh0VHJhY2subW9kZSA9ICdkaXNhYmxlZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0ZXh0VHJhY2spIHtcbiAgICAgICAgICAgIHRoaXMudGV4dFRyYWNrcy5wdXNoKHRleHRUcmFjayk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gV2FybiB3aGVuIHZpZGVvIGVsZW1lbnQgaGFzIGNhcHRpb25zIG9yIHN1YnRpdGxlIFRleHRUcmFja3MgY2FycmllZCBvdmVyIGZyb20gYW5vdGhlciBzb3VyY2VcbiAgICAgICAgaWYgKGluVXNlVHJhY2tzICE9IG51bGwgJiYgaW5Vc2VUcmFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgdW51c2VkVGV4dFRyYWNrcyA9IGluVXNlVHJhY2tzLmZpbHRlcih0ID0+IHQgIT09IG51bGwpLm1hcCh0ID0+IHQubGFiZWwpO1xuICAgICAgICAgIGlmICh1bnVzZWRUZXh0VHJhY2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oYE1lZGlhIGVsZW1lbnQgY29udGFpbnMgdW51c2VkIHN1YnRpdGxlIHRyYWNrczogJHt1bnVzZWRUZXh0VHJhY2tzLmpvaW4oJywgJyl9LiBSZXBsYWNlIG1lZGlhIGVsZW1lbnQgZm9yIGVhY2ggc291cmNlIHRvIGNsZWFyIFRleHRUcmFja3MgYW5kIGNhcHRpb25zIG1lbnUuYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMudHJhY2tzLmxlbmd0aCkge1xuICAgICAgICAvLyBDcmVhdGUgYSBsaXN0IG9mIHRyYWNrcyBmb3IgdGhlIHByb3ZpZGVyIHRvIGNvbnN1bWVcbiAgICAgICAgY29uc3QgdHJhY2tzTGlzdCA9IHRoaXMudHJhY2tzLm1hcCh0cmFjayA9PiB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxhYmVsOiB0cmFjay5uYW1lLFxuICAgICAgICAgICAga2luZDogdHJhY2sudHlwZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgZGVmYXVsdDogdHJhY2suZGVmYXVsdCxcbiAgICAgICAgICAgIHN1YnRpdGxlVHJhY2s6IHRyYWNrXG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLk5PTl9OQVRJVkVfVEVYVF9UUkFDS1NfRk9VTkQsIHtcbiAgICAgICAgICB0cmFja3M6IHRyYWNrc0xpc3RcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIG9uTWFuaWZlc3RMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlQ0VBNzA4Q2FwdGlvbnMgJiYgZGF0YS5jYXB0aW9ucykge1xuICAgICAgZGF0YS5jYXB0aW9ucy5mb3JFYWNoKGNhcHRpb25zVHJhY2sgPT4ge1xuICAgICAgICBjb25zdCBpbnN0cmVhbUlkTWF0Y2ggPSAvKD86Q0N8U0VSVklDRSkoWzEtNF0pLy5leGVjKGNhcHRpb25zVHJhY2suaW5zdHJlYW1JZCk7XG4gICAgICAgIGlmICghaW5zdHJlYW1JZE1hdGNoKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYWNrTmFtZSA9IGB0ZXh0VHJhY2ske2luc3RyZWFtSWRNYXRjaFsxXX1gO1xuICAgICAgICBjb25zdCB0cmFja1Byb3BlcnRpZXMgPSB0aGlzLmNhcHRpb25zUHJvcGVydGllc1t0cmFja05hbWVdO1xuICAgICAgICBpZiAoIXRyYWNrUHJvcGVydGllcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cmFja1Byb3BlcnRpZXMubGFiZWwgPSBjYXB0aW9uc1RyYWNrLm5hbWU7XG4gICAgICAgIGlmIChjYXB0aW9uc1RyYWNrLmxhbmcpIHtcbiAgICAgICAgICAvLyBvcHRpb25hbCBhdHRyaWJ1dGVcbiAgICAgICAgICB0cmFja1Byb3BlcnRpZXMubGFuZ3VhZ2VDb2RlID0gY2FwdGlvbnNUcmFjay5sYW5nO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNrUHJvcGVydGllcy5tZWRpYSA9IGNhcHRpb25zVHJhY2s7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgY2xvc2VkQ2FwdGlvbnNGb3JMZXZlbChmcmFnKSB7XG4gICAgY29uc3QgbGV2ZWwgPSB0aGlzLmhscy5sZXZlbHNbZnJhZy5sZXZlbF07XG4gICAgcmV0dXJuIGxldmVsID09IG51bGwgPyB2b2lkIDAgOiBsZXZlbC5hdHRyc1snQ0xPU0VELUNBUFRJT05TJ107XG4gIH1cbiAgb25GcmFnTG9hZGluZyhldmVudCwgZGF0YSkge1xuICAgIHRoaXMuaW5pdENlYTYwOFBhcnNlcnMoKTtcbiAgICBjb25zdCB7XG4gICAgICBjZWE2MDhQYXJzZXIxLFxuICAgICAgY2VhNjA4UGFyc2VyMixcbiAgICAgIGxhc3RDYyxcbiAgICAgIGxhc3RTbixcbiAgICAgIGxhc3RQYXJ0SW5kZXhcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIXRoaXMuZW5hYmxlZCB8fCAhY2VhNjA4UGFyc2VyMSB8fCAhY2VhNjA4UGFyc2VyMikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBpZiB0aGlzIGZyYWcgaXNuJ3QgY29udGlndW91cywgY2xlYXIgdGhlIHBhcnNlciBzbyBjdWVzIHdpdGggYmFkIHN0YXJ0L2VuZCB0aW1lcyBhcmVuJ3QgYWRkZWQgdG8gdGhlIHRleHRUcmFja1xuICAgIGlmIChkYXRhLmZyYWcudHlwZSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTikge1xuICAgICAgdmFyIF9kYXRhJHBhcnQkaW5kZXgsIF9kYXRhJHBhcnQ7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNjLFxuICAgICAgICBzblxuICAgICAgfSA9IGRhdGEuZnJhZztcbiAgICAgIGNvbnN0IHBhcnRJbmRleCA9IChfZGF0YSRwYXJ0JGluZGV4ID0gZGF0YSA9PSBudWxsID8gdm9pZCAwIDogKF9kYXRhJHBhcnQgPSBkYXRhLnBhcnQpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YSRwYXJ0LmluZGV4KSAhPSBudWxsID8gX2RhdGEkcGFydCRpbmRleCA6IC0xO1xuICAgICAgaWYgKCEoc24gPT09IGxhc3RTbiArIDEgfHwgc24gPT09IGxhc3RTbiAmJiBwYXJ0SW5kZXggPT09IGxhc3RQYXJ0SW5kZXggKyAxIHx8IGNjID09PSBsYXN0Q2MpKSB7XG4gICAgICAgIGNlYTYwOFBhcnNlcjEucmVzZXQoKTtcbiAgICAgICAgY2VhNjA4UGFyc2VyMi5yZXNldCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5sYXN0Q2MgPSBjYztcbiAgICAgIHRoaXMubGFzdFNuID0gc247XG4gICAgICB0aGlzLmxhc3RQYXJ0SW5kZXggPSBwYXJ0SW5kZXg7XG4gICAgfVxuICB9XG4gIG9uRnJhZ0xvYWRlZChldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGZyYWcsXG4gICAgICBwYXlsb2FkXG4gICAgfSA9IGRhdGE7XG4gICAgaWYgKGZyYWcudHlwZSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuU1VCVElUTEUpIHtcbiAgICAgIC8vIElmIGZyYWdtZW50IGlzIHN1YnRpdGxlIHR5cGUsIHBhcnNlIGFzIFdlYlZUVC5cbiAgICAgIGlmIChwYXlsb2FkLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgY29uc3QgZGVjcnlwdERhdGEgPSBmcmFnLmRlY3J5cHRkYXRhO1xuICAgICAgICAvLyBmcmFnbWVudCBhZnRlciBkZWNyeXB0aW9uIGhhcyBhIHN0YXRzIG9iamVjdFxuICAgICAgICBjb25zdCBkZWNyeXB0ZWQgPSAoJ3N0YXRzJyBpbiBkYXRhKTtcbiAgICAgICAgLy8gSWYgdGhlIHN1YnRpdGxlcyBhcmUgbm90IGVuY3J5cHRlZCwgcGFyc2UgVlRUcyBub3cuIE90aGVyd2lzZSwgd2UgbmVlZCB0byB3YWl0LlxuICAgICAgICBpZiAoZGVjcnlwdERhdGEgPT0gbnVsbCB8fCAhZGVjcnlwdERhdGEuZW5jcnlwdGVkIHx8IGRlY3J5cHRlZCkge1xuICAgICAgICAgIGNvbnN0IHRyYWNrUGxheWxpc3RNZWRpYSA9IHRoaXMudHJhY2tzW2ZyYWcubGV2ZWxdO1xuICAgICAgICAgIGNvbnN0IHZ0dENDcyA9IHRoaXMudnR0Q0NzO1xuICAgICAgICAgIGlmICghdnR0Q0NzW2ZyYWcuY2NdKSB7XG4gICAgICAgICAgICB2dHRDQ3NbZnJhZy5jY10gPSB7XG4gICAgICAgICAgICAgIHN0YXJ0OiBmcmFnLnN0YXJ0LFxuICAgICAgICAgICAgICBwcmV2Q0M6IHRoaXMucHJldkNDLFxuICAgICAgICAgICAgICBuZXc6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnByZXZDQyA9IGZyYWcuY2M7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0cmFja1BsYXlsaXN0TWVkaWEgJiYgdHJhY2tQbGF5bGlzdE1lZGlhLnRleHRDb2RlYyA9PT0gSU1TQzFfQ09ERUMpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlSU1TQzEoZnJhZywgcGF5bG9hZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlVlRUcyhkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEluIGNhc2UgdGhlcmUgaXMgbm8gcGF5bG9hZCwgZmluaXNoIHVuc3VjY2Vzc2Z1bGx5LlxuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwge1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcignRW1wdHkgc3VidGl0bGUgcGF5bG9hZCcpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfcGFyc2VJTVNDMShmcmFnLCBwYXlsb2FkKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgcGFyc2VJTVNDMShwYXlsb2FkLCB0aGlzLmluaXRQVFNbZnJhZy5jY10sIGN1ZXMgPT4ge1xuICAgICAgdGhpcy5fYXBwZW5kQ3VlcyhjdWVzLCBmcmFnLmxldmVsKTtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwge1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBmcmFnOiBmcmFnXG4gICAgICB9KTtcbiAgICB9LCBlcnJvciA9PiB7XG4gICAgICBsb2dnZXIubG9nKGBGYWlsZWQgdG8gcGFyc2UgSU1TQzE6ICR7ZXJyb3J9YCk7XG4gICAgICBobHMudHJpZ2dlcihFdmVudHMuU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGZyYWc6IGZyYWcsXG4gICAgICAgIGVycm9yXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfcGFyc2VWVFRzKGRhdGEpIHtcbiAgICB2YXIgX2ZyYWckaW5pdFNlZ21lbnQ7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZyxcbiAgICAgIHBheWxvYWRcbiAgICB9ID0gZGF0YTtcbiAgICAvLyBXZSBuZWVkIGFuIGluaXRpYWwgc3luY2hyb25pc2F0aW9uIFBUUy4gU3RvcmUgZnJhZ21lbnRzIGFzIGxvbmcgYXMgbm9uZSBoYXMgYXJyaXZlZFxuICAgIGNvbnN0IHtcbiAgICAgIGluaXRQVFMsXG4gICAgICB1bnBhcnNlZFZ0dEZyYWdzXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgbWF4QXZDQyA9IGluaXRQVFMubGVuZ3RoIC0gMTtcbiAgICBpZiAoIWluaXRQVFNbZnJhZy5jY10gJiYgbWF4QXZDQyA9PT0gLTEpIHtcbiAgICAgIHVucGFyc2VkVnR0RnJhZ3MucHVzaChkYXRhKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgLy8gUGFyc2UgdGhlIFdlYlZUVCBmaWxlIGNvbnRlbnRzLlxuICAgIGNvbnN0IHBheWxvYWRXZWJWVFQgPSAoX2ZyYWckaW5pdFNlZ21lbnQgPSBmcmFnLmluaXRTZWdtZW50KSAhPSBudWxsICYmIF9mcmFnJGluaXRTZWdtZW50LmRhdGEgPyBhcHBlbmRVaW50OEFycmF5KGZyYWcuaW5pdFNlZ21lbnQuZGF0YSwgbmV3IFVpbnQ4QXJyYXkocGF5bG9hZCkpIDogcGF5bG9hZDtcbiAgICBwYXJzZVdlYlZUVChwYXlsb2FkV2ViVlRULCB0aGlzLmluaXRQVFNbZnJhZy5jY10sIHRoaXMudnR0Q0NzLCBmcmFnLmNjLCBmcmFnLnN0YXJ0LCBjdWVzID0+IHtcbiAgICAgIHRoaXMuX2FwcGVuZEN1ZXMoY3VlcywgZnJhZy5sZXZlbCk7XG4gICAgICBobHMudHJpZ2dlcihFdmVudHMuU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgZnJhZzogZnJhZ1xuICAgICAgfSk7XG4gICAgfSwgZXJyb3IgPT4ge1xuICAgICAgY29uc3QgbWlzc2luZ0luaXRQVFMgPSBlcnJvci5tZXNzYWdlID09PSAnTWlzc2luZyBpbml0UFRTIGZvciBWVFQgTVBFR1RTJztcbiAgICAgIGlmIChtaXNzaW5nSW5pdFBUUykge1xuICAgICAgICB1bnBhcnNlZFZ0dEZyYWdzLnB1c2goZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9mYWxsYmFja1RvSU1TQzEoZnJhZywgcGF5bG9hZCk7XG4gICAgICB9XG4gICAgICAvLyBTb21ldGhpbmcgd2VudCB3cm9uZyB3aGlsZSBwYXJzaW5nLiBUcmlnZ2VyIGV2ZW50IHdpdGggc3VjY2VzcyBmYWxzZS5cbiAgICAgIGxvZ2dlci5sb2coYEZhaWxlZCB0byBwYXJzZSBWVFQgY3VlOiAke2Vycm9yfWApO1xuICAgICAgaWYgKG1pc3NpbmdJbml0UFRTICYmIG1heEF2Q0MgPiBmcmFnLmNjKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZnJhZzogZnJhZyxcbiAgICAgICAgZXJyb3JcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIF9mYWxsYmFja1RvSU1TQzEoZnJhZywgcGF5bG9hZCkge1xuICAgIC8vIElmIHRleHRDb2RlYyBpcyB1bmtub3duLCB0cnkgcGFyc2luZyBhcyBJTVNDMS4gU2V0IHRleHRDb2RlYyBiYXNlZCBvbiB0aGUgcmVzdWx0XG4gICAgY29uc3QgdHJhY2tQbGF5bGlzdE1lZGlhID0gdGhpcy50cmFja3NbZnJhZy5sZXZlbF07XG4gICAgaWYgKCF0cmFja1BsYXlsaXN0TWVkaWEudGV4dENvZGVjKSB7XG4gICAgICBwYXJzZUlNU0MxKHBheWxvYWQsIHRoaXMuaW5pdFBUU1tmcmFnLmNjXSwgKCkgPT4ge1xuICAgICAgICB0cmFja1BsYXlsaXN0TWVkaWEudGV4dENvZGVjID0gSU1TQzFfQ09ERUM7XG4gICAgICAgIHRoaXMuX3BhcnNlSU1TQzEoZnJhZywgcGF5bG9hZCk7XG4gICAgICB9LCAoKSA9PiB7XG4gICAgICAgIHRyYWNrUGxheWxpc3RNZWRpYS50ZXh0Q29kZWMgPSAnd3Z0dCc7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgX2FwcGVuZEN1ZXMoY3VlcywgZnJhZ0xldmVsKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgaWYgKHRoaXMuY29uZmlnLnJlbmRlclRleHRUcmFja3NOYXRpdmVseSkge1xuICAgICAgY29uc3QgdGV4dFRyYWNrID0gdGhpcy50ZXh0VHJhY2tzW2ZyYWdMZXZlbF07XG4gICAgICAvLyBXZWJWVFRQYXJzZXIucGFyc2UgaXMgYW4gYXN5bmMgbWV0aG9kIGFuZCBpZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHRleHQgdHJhY2sgbW9kZSBpcyBzZXQgdG8gXCJkaXNhYmxlZFwiXG4gICAgICAvLyBiZWZvcmUgcGFyc2luZyBpcyBkb25lIHRoZW4gZG9uJ3QgdHJ5IHRvIGFjY2VzcyBjdXJyZW50VHJhY2suY3Vlcy5nZXRDdWVCeUlkIGFzIGN1ZXMgd2lsbCBiZSBudWxsXG4gICAgICAvLyBhbmQgdHJ5aW5nIHRvIGFjY2VzcyBnZXRDdWVCeUlkIG1ldGhvZCBvZiBjdWVzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uXG4gICAgICAvLyBCZWNhdXNlIHdlIGNoZWNrIGlmIHRoZSBtb2RlIGlzIGRpc2FibGVkLCB3ZSBjYW4gZm9yY2UgY2hlY2sgYGN1ZXNgIGJlbG93LiBUaGV5IGNhbid0IGJlIG51bGwuXG4gICAgICBpZiAoIXRleHRUcmFjayB8fCB0ZXh0VHJhY2subW9kZSA9PT0gJ2Rpc2FibGVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjdWVzLmZvckVhY2goY3VlID0+IGFkZEN1ZVRvVHJhY2sodGV4dFRyYWNrLCBjdWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY3VycmVudFRyYWNrID0gdGhpcy50cmFja3NbZnJhZ0xldmVsXTtcbiAgICAgIGlmICghY3VycmVudFRyYWNrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRyYWNrID0gY3VycmVudFRyYWNrLmRlZmF1bHQgPyAnZGVmYXVsdCcgOiAnc3VidGl0bGVzJyArIGZyYWdMZXZlbDtcbiAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5DVUVTX1BBUlNFRCwge1xuICAgICAgICB0eXBlOiAnc3VidGl0bGVzJyxcbiAgICAgICAgY3VlcyxcbiAgICAgICAgdHJhY2tcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBvbkZyYWdEZWNyeXB0ZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnXG4gICAgfSA9IGRhdGE7XG4gICAgaWYgKGZyYWcudHlwZSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuU1VCVElUTEUpIHtcbiAgICAgIHRoaXMub25GcmFnTG9hZGVkKEV2ZW50cy5GUkFHX0xPQURFRCwgZGF0YSk7XG4gICAgfVxuICB9XG4gIG9uU3VidGl0bGVUcmFja3NDbGVhcmVkKCkge1xuICAgIHRoaXMudHJhY2tzID0gW107XG4gICAgdGhpcy5jYXB0aW9uc1RyYWNrcyA9IHt9O1xuICB9XG4gIG9uRnJhZ1BhcnNpbmdVc2VyZGF0YShldmVudCwgZGF0YSkge1xuICAgIHRoaXMuaW5pdENlYTYwOFBhcnNlcnMoKTtcbiAgICBjb25zdCB7XG4gICAgICBjZWE2MDhQYXJzZXIxLFxuICAgICAgY2VhNjA4UGFyc2VyMlxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghdGhpcy5lbmFibGVkIHx8ICFjZWE2MDhQYXJzZXIxIHx8ICFjZWE2MDhQYXJzZXIyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGZyYWcsXG4gICAgICBzYW1wbGVzXG4gICAgfSA9IGRhdGE7XG4gICAgaWYgKGZyYWcudHlwZSA9PT0gUGxheWxpc3RMZXZlbFR5cGUuTUFJTiAmJiB0aGlzLmNsb3NlZENhcHRpb25zRm9yTGV2ZWwoZnJhZykgPT09ICdOT05FJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgZXZlbnQgY29udGFpbnMgY2FwdGlvbnMgKGZvdW5kIGluIHRoZSBieXRlcyBwcm9wZXJ0eSksIHB1c2ggYWxsIGJ5dGVzIGludG8gdGhlIHBhcnNlciBpbW1lZGlhdGVseVxuICAgIC8vIEl0IHdpbGwgY3JlYXRlIHRoZSBwcm9wZXIgdGltZXN0YW1wcyBiYXNlZCBvbiB0aGUgUFRTIHZhbHVlXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjY0J5dGVzID0gc2FtcGxlc1tpXS5ieXRlcztcbiAgICAgIGlmIChjY0J5dGVzKSB7XG4gICAgICAgIGNvbnN0IGNjZGF0YXMgPSB0aGlzLmV4dHJhY3RDZWE2MDhEYXRhKGNjQnl0ZXMpO1xuICAgICAgICBjZWE2MDhQYXJzZXIxLmFkZERhdGEoc2FtcGxlc1tpXS5wdHMsIGNjZGF0YXNbMF0pO1xuICAgICAgICBjZWE2MDhQYXJzZXIyLmFkZERhdGEoc2FtcGxlc1tpXS5wdHMsIGNjZGF0YXNbMV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBvbkJ1ZmZlckZsdXNoaW5nKGV2ZW50LCB7XG4gICAgc3RhcnRPZmZzZXQsXG4gICAgZW5kT2Zmc2V0LFxuICAgIGVuZE9mZnNldFN1YnRpdGxlcyxcbiAgICB0eXBlXG4gIH0pIHtcbiAgICBjb25zdCB7XG4gICAgICBtZWRpYVxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghbWVkaWEgfHwgbWVkaWEuY3VycmVudFRpbWUgPCBlbmRPZmZzZXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gQ2xlYXIgNjA4IGNhcHRpb24gY3VlcyBmcm9tIHRoZSBjYXB0aW9ucyBUZXh0VHJhY2tzIHdoZW4gdGhlIHZpZGVvIGJhY2sgYnVmZmVyIGlzIGZsdXNoZWRcbiAgICAvLyBGb3J3YXJkIGN1ZXMgYXJlIG5ldmVyIHJlbW92ZWQgYmVjYXVzZSB3ZSBjYW4gbG9vc2Ugc3RyZWFtZWQgNjA4IGNvbnRlbnQgZnJvbSByZWNlbnQgZnJhZ21lbnRzXG4gICAgaWYgKCF0eXBlIHx8IHR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2FwdGlvbnNUcmFja3NcbiAgICAgIH0gPSB0aGlzO1xuICAgICAgT2JqZWN0LmtleXMoY2FwdGlvbnNUcmFja3MpLmZvckVhY2godHJhY2tOYW1lID0+IHJlbW92ZUN1ZXNJblJhbmdlKGNhcHRpb25zVHJhY2tzW3RyYWNrTmFtZV0sIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY29uZmlnLnJlbmRlclRleHRUcmFja3NOYXRpdmVseSkge1xuICAgICAgLy8gQ2xlYXIgVlRUL0lNU0MxIHN1YnRpdGxlIGN1ZXMgZnJvbSB0aGUgc3VidGl0bGUgVGV4dFRyYWNrcyB3aGVuIHRoZSBiYWNrIGJ1ZmZlciBpcyBmbHVzaGVkXG4gICAgICBpZiAoc3RhcnRPZmZzZXQgPT09IDAgJiYgZW5kT2Zmc2V0U3VidGl0bGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHRleHRUcmFja3NcbiAgICAgICAgfSA9IHRoaXM7XG4gICAgICAgIE9iamVjdC5rZXlzKHRleHRUcmFja3MpLmZvckVhY2godHJhY2tOYW1lID0+IHJlbW92ZUN1ZXNJblJhbmdlKHRleHRUcmFja3NbdHJhY2tOYW1lXSwgc3RhcnRPZmZzZXQsIGVuZE9mZnNldFN1YnRpdGxlcykpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBleHRyYWN0Q2VhNjA4RGF0YShieXRlQXJyYXkpIHtcbiAgICBjb25zdCBhY3R1YWxDQ0J5dGVzID0gW1tdLCBbXV07XG4gICAgY29uc3QgY291bnQgPSBieXRlQXJyYXlbMF0gJiAweDFmO1xuICAgIGxldCBwb3NpdGlvbiA9IDI7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG4gICAgICBjb25zdCB0bXBCeXRlID0gYnl0ZUFycmF5W3Bvc2l0aW9uKytdO1xuICAgICAgY29uc3QgY2NieXRlMSA9IDB4N2YgJiBieXRlQXJyYXlbcG9zaXRpb24rK107XG4gICAgICBjb25zdCBjY2J5dGUyID0gMHg3ZiAmIGJ5dGVBcnJheVtwb3NpdGlvbisrXTtcbiAgICAgIGlmIChjY2J5dGUxID09PSAwICYmIGNjYnl0ZTIgPT09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBjY1ZhbGlkID0gKDB4MDQgJiB0bXBCeXRlKSAhPT0gMDsgLy8gU3VwcG9ydCBhbGwgZm91ciBjaGFubmVsc1xuICAgICAgaWYgKGNjVmFsaWQpIHtcbiAgICAgICAgY29uc3QgY2NUeXBlID0gMHgwMyAmIHRtcEJ5dGU7XG4gICAgICAgIGlmICgweDAwIC8qIENFQTYwOCBmaWVsZDEqLyA9PT0gY2NUeXBlIHx8IDB4MDEgLyogQ0VBNjA4IGZpZWxkMiovID09PSBjY1R5cGUpIHtcbiAgICAgICAgICAvLyBFeGNsdWRlIENFQTcwOCBDQyBkYXRhLlxuICAgICAgICAgIGFjdHVhbENDQnl0ZXNbY2NUeXBlXS5wdXNoKGNjYnl0ZTEpO1xuICAgICAgICAgIGFjdHVhbENDQnl0ZXNbY2NUeXBlXS5wdXNoKGNjYnl0ZTIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhY3R1YWxDQ0J5dGVzO1xuICB9XG59XG5mdW5jdGlvbiBjYXB0aW9uc09yU3VidGl0bGVzRnJvbUNoYXJhY3RlcmlzdGljcyh0cmFjaykge1xuICBpZiAodHJhY2suY2hhcmFjdGVyaXN0aWNzKSB7XG4gICAgaWYgKC90cmFuc2NyaWJlcy1zcG9rZW4tZGlhbG9nL2dpLnRlc3QodHJhY2suY2hhcmFjdGVyaXN0aWNzKSAmJiAvZGVzY3JpYmVzLW11c2ljLWFuZC1zb3VuZC9naS50ZXN0KHRyYWNrLmNoYXJhY3RlcmlzdGljcykpIHtcbiAgICAgIHJldHVybiAnY2FwdGlvbnMnO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJ3N1YnRpdGxlcyc7XG59XG5mdW5jdGlvbiBjYW5SZXVzZVZ0dFRleHRUcmFjayhpblVzZVRyYWNrLCBtYW5pZmVzdFRyYWNrKSB7XG4gIHJldHVybiAhIWluVXNlVHJhY2sgJiYgaW5Vc2VUcmFjay5raW5kID09PSBjYXB0aW9uc09yU3VidGl0bGVzRnJvbUNoYXJhY3RlcmlzdGljcyhtYW5pZmVzdFRyYWNrKSAmJiBzdWJ0aXRsZVRyYWNrTWF0Y2hlc1RleHRUcmFjayhtYW5pZmVzdFRyYWNrLCBpblVzZVRyYWNrKTtcbn1cbmZ1bmN0aW9uIGludGVyc2VjdGlvbih4MSwgeDIsIHkxLCB5Mikge1xuICByZXR1cm4gTWF0aC5taW4oeDIsIHkyKSAtIE1hdGgubWF4KHgxLCB5MSk7XG59XG5mdW5jdGlvbiBuZXdWVFRDQ3MoKSB7XG4gIHJldHVybiB7XG4gICAgY2NPZmZzZXQ6IDAsXG4gICAgcHJlc2VudGF0aW9uT2Zmc2V0OiAwLFxuICAgIDA6IHtcbiAgICAgIHN0YXJ0OiAwLFxuICAgICAgcHJldkNDOiAtMSxcbiAgICAgIG5ldzogdHJ1ZVxuICAgIH1cbiAgfTtcbn1cblxuY2xhc3MgQ2FwTGV2ZWxDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5hdXRvTGV2ZWxDYXBwaW5nID0gdm9pZCAwO1xuICAgIHRoaXMuZmlyc3RMZXZlbCA9IHZvaWQgMDtcbiAgICB0aGlzLm1lZGlhID0gdm9pZCAwO1xuICAgIHRoaXMucmVzdHJpY3RlZExldmVscyA9IHZvaWQgMDtcbiAgICB0aGlzLnRpbWVyID0gdm9pZCAwO1xuICAgIHRoaXMuY2xpZW50UmVjdCA9IHZvaWQgMDtcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5hdXRvTGV2ZWxDYXBwaW5nID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIHRoaXMuZmlyc3RMZXZlbCA9IC0xO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIHRoaXMucmVzdHJpY3RlZExldmVscyA9IFtdO1xuICAgIHRoaXMudGltZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jbGllbnRSZWN0ID0gbnVsbDtcbiAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cbiAgc2V0U3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyKSB7XG4gICAgdGhpcy5zdHJlYW1Db250cm9sbGVyID0gc3RyZWFtQ29udHJvbGxlcjtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLmhscykge1xuICAgICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXIoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgIHRoaXMuc3RvcENhcHBpbmcoKTtcbiAgICB9XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5jbGllbnRSZWN0ID0gbnVsbDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5obHMgPSB0aGlzLnN0cmVhbUNvbnRyb2xsZXIgPSBudWxsO1xuICB9XG4gIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGhscy5vbihFdmVudHMuRlBTX0RST1BfTEVWRUxfQ0FQUElORywgdGhpcy5vbkZwc0Ryb3BMZXZlbENhcHBpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUVESUFfQVRUQUNISU5HLCB0aGlzLm9uTWVkaWFBdHRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxTX1VQREFURUQsIHRoaXMub25MZXZlbHNVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkJVRkZFUl9DT0RFQ1MsIHRoaXMub25CdWZmZXJDb2RlY3MsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICB9XG4gIHVucmVnaXN0ZXJMaXN0ZW5lcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHNcbiAgICB9ID0gdGhpcztcbiAgICBobHMub2ZmKEV2ZW50cy5GUFNfRFJPUF9MRVZFTF9DQVBQSU5HLCB0aGlzLm9uRnBzRHJvcExldmVsQ2FwcGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUVESUFfQVRUQUNISU5HLCB0aGlzLm9uTWVkaWFBdHRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTFNfVVBEQVRFRCwgdGhpcy5vbkxldmVsc1VwZGF0ZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkJVRkZFUl9DT0RFQ1MsIHRoaXMub25CdWZmZXJDb2RlY3MsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgfVxuICBvbkZwc0Ryb3BMZXZlbENhcHBpbmcoZXZlbnQsIGRhdGEpIHtcbiAgICAvLyBEb24ndCBhZGQgYSByZXN0cmljdGVkIGxldmVsIG1vcmUgdGhhbiBvbmNlXG4gICAgY29uc3QgbGV2ZWwgPSB0aGlzLmhscy5sZXZlbHNbZGF0YS5kcm9wcGVkTGV2ZWxdO1xuICAgIGlmICh0aGlzLmlzTGV2ZWxBbGxvd2VkKGxldmVsKSkge1xuICAgICAgdGhpcy5yZXN0cmljdGVkTGV2ZWxzLnB1c2goe1xuICAgICAgICBiaXRyYXRlOiBsZXZlbC5iaXRyYXRlLFxuICAgICAgICBoZWlnaHQ6IGxldmVsLmhlaWdodCxcbiAgICAgICAgd2lkdGg6IGxldmVsLndpZHRoXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgb25NZWRpYUF0dGFjaGluZyhldmVudCwgZGF0YSkge1xuICAgIHRoaXMubWVkaWEgPSBkYXRhLm1lZGlhIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCA/IGRhdGEubWVkaWEgOiBudWxsO1xuICAgIHRoaXMuY2xpZW50UmVjdCA9IG51bGw7XG4gICAgaWYgKHRoaXMudGltZXIgJiYgdGhpcy5obHMubGV2ZWxzLmxlbmd0aCkge1xuICAgICAgdGhpcy5kZXRlY3RQbGF5ZXJTaXplKCk7XG4gICAgfVxuICB9XG4gIG9uTWFuaWZlc3RQYXJzZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICB0aGlzLnJlc3RyaWN0ZWRMZXZlbHMgPSBbXTtcbiAgICB0aGlzLmZpcnN0TGV2ZWwgPSBkYXRhLmZpcnN0TGV2ZWw7XG4gICAgaWYgKGhscy5jb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemUgJiYgZGF0YS52aWRlbykge1xuICAgICAgLy8gU3RhcnQgY2FwcGluZyBpbW1lZGlhdGVseSBpZiB0aGUgbWFuaWZlc3QgaGFzIHNpZ25hbGVkIHZpZGVvIGNvZGVjc1xuICAgICAgdGhpcy5zdGFydENhcHBpbmcoKTtcbiAgICB9XG4gIH1cbiAgb25MZXZlbHNVcGRhdGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgaWYgKHRoaXMudGltZXIgJiYgaXNGaW5pdGVOdW1iZXIodGhpcy5hdXRvTGV2ZWxDYXBwaW5nKSkge1xuICAgICAgdGhpcy5kZXRlY3RQbGF5ZXJTaXplKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gT25seSBhY3RpdmF0ZSBjYXBwaW5nIHdoZW4gcGxheWluZyBhIHZpZGVvIHN0cmVhbTsgb3RoZXJ3aXNlLCBtdWx0aS1iaXRyYXRlIGF1ZGlvLW9ubHkgc3RyZWFtcyB3aWxsIGJlIHJlc3RyaWN0ZWRcbiAgLy8gdG8gdGhlIGZpcnN0IGxldmVsXG4gIG9uQnVmZmVyQ29kZWNzKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgaWYgKGhscy5jb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemUgJiYgZGF0YS52aWRlbykge1xuICAgICAgLy8gSWYgdGhlIG1hbmlmZXN0IGRpZCBub3Qgc2lnbmFsIGEgdmlkZW8gY29kZWMgY2FwcGluZyBoYXMgYmVlbiBkZWZlcnJlZCB1bnRpbCB3ZSdyZSBjZXJ0YWluIHZpZGVvIGlzIHByZXNlbnRcbiAgICAgIHRoaXMuc3RhcnRDYXBwaW5nKCk7XG4gICAgfVxuICB9XG4gIG9uTWVkaWFEZXRhY2hpbmcoKSB7XG4gICAgdGhpcy5zdG9wQ2FwcGluZygpO1xuICB9XG4gIGRldGVjdFBsYXllclNpemUoKSB7XG4gICAgaWYgKHRoaXMubWVkaWEpIHtcbiAgICAgIGlmICh0aGlzLm1lZGlhSGVpZ2h0IDw9IDAgfHwgdGhpcy5tZWRpYVdpZHRoIDw9IDApIHtcbiAgICAgICAgdGhpcy5jbGllbnRSZWN0ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbGV2ZWxzID0gdGhpcy5obHMubGV2ZWxzO1xuICAgICAgaWYgKGxldmVscy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgICAgIGNvbnN0IG1heExldmVsID0gdGhpcy5nZXRNYXhMZXZlbChsZXZlbHMubGVuZ3RoIC0gMSk7XG4gICAgICAgIGlmIChtYXhMZXZlbCAhPT0gdGhpcy5hdXRvTGV2ZWxDYXBwaW5nKSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgU2V0dGluZyBhdXRvTGV2ZWxDYXBwaW5nIHRvICR7bWF4TGV2ZWx9OiAke2xldmVsc1ttYXhMZXZlbF0uaGVpZ2h0fXBAJHtsZXZlbHNbbWF4TGV2ZWxdLmJpdHJhdGV9IGZvciBtZWRpYSAke3RoaXMubWVkaWFXaWR0aH14JHt0aGlzLm1lZGlhSGVpZ2h0fWApO1xuICAgICAgICB9XG4gICAgICAgIGhscy5hdXRvTGV2ZWxDYXBwaW5nID0gbWF4TGV2ZWw7XG4gICAgICAgIGlmIChobHMuYXV0b0xldmVsQ2FwcGluZyA+IHRoaXMuYXV0b0xldmVsQ2FwcGluZyAmJiB0aGlzLnN0cmVhbUNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAvLyBpZiBhdXRvIGxldmVsIGNhcHBpbmcgaGFzIGEgaGlnaGVyIHZhbHVlIGZvciB0aGUgcHJldmlvdXMgb25lLCBmbHVzaCB0aGUgYnVmZmVyIHVzaW5nIG5leHRMZXZlbFN3aXRjaFxuICAgICAgICAgIC8vIHVzdWFsbHkgaGFwcGVuIHdoZW4gdGhlIHVzZXIgZ28gdG8gdGhlIGZ1bGxzY3JlZW4gbW9kZS5cbiAgICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsU3dpdGNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hdXRvTGV2ZWxDYXBwaW5nID0gaGxzLmF1dG9MZXZlbENhcHBpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLypcbiAgICogcmV0dXJucyBsZXZlbCBzaG91bGQgYmUgdGhlIG9uZSB3aXRoIHRoZSBkaW1lbnNpb25zIGVxdWFsIG9yIGdyZWF0ZXIgdGhhbiB0aGUgbWVkaWEgKHBsYXllcikgZGltZW5zaW9ucyAoc28gdGhlIHZpZGVvIHdpbGwgYmUgZG93bnNjYWxlZClcbiAgICovXG4gIGdldE1heExldmVsKGNhcExldmVsSW5kZXgpIHtcbiAgICBjb25zdCBsZXZlbHMgPSB0aGlzLmhscy5sZXZlbHM7XG4gICAgaWYgKCFsZXZlbHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGNvbnN0IHZhbGlkTGV2ZWxzID0gbGV2ZWxzLmZpbHRlcigobGV2ZWwsIGluZGV4KSA9PiB0aGlzLmlzTGV2ZWxBbGxvd2VkKGxldmVsKSAmJiBpbmRleCA8PSBjYXBMZXZlbEluZGV4KTtcbiAgICB0aGlzLmNsaWVudFJlY3QgPSBudWxsO1xuICAgIHJldHVybiBDYXBMZXZlbENvbnRyb2xsZXIuZ2V0TWF4TGV2ZWxCeU1lZGlhU2l6ZSh2YWxpZExldmVscywgdGhpcy5tZWRpYVdpZHRoLCB0aGlzLm1lZGlhSGVpZ2h0KTtcbiAgfVxuICBzdGFydENhcHBpbmcoKSB7XG4gICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgIC8vIERvbid0IHJlc2V0IGNhcHBpbmcgaWYgc3RhcnRlZCB0d2ljZTsgdGhpcyBjYW4gaGFwcGVuIGlmIHRoZSBtYW5pZmVzdCBzaWduYWxzIGEgdmlkZW8gY29kZWNcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5hdXRvTGV2ZWxDYXBwaW5nID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICB0aGlzLnRpbWVyID0gc2VsZi5zZXRJbnRlcnZhbCh0aGlzLmRldGVjdFBsYXllclNpemUuYmluZCh0aGlzKSwgMTAwMCk7XG4gICAgdGhpcy5kZXRlY3RQbGF5ZXJTaXplKCk7XG4gIH1cbiAgc3RvcENhcHBpbmcoKSB7XG4gICAgdGhpcy5yZXN0cmljdGVkTGV2ZWxzID0gW107XG4gICAgdGhpcy5maXJzdExldmVsID0gLTE7XG4gICAgdGhpcy5hdXRvTGV2ZWxDYXBwaW5nID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICBzZWxmLmNsZWFySW50ZXJ2YWwodGhpcy50aW1lcik7XG4gICAgICB0aGlzLnRpbWVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICBnZXREaW1lbnNpb25zKCkge1xuICAgIGlmICh0aGlzLmNsaWVudFJlY3QpIHtcbiAgICAgIHJldHVybiB0aGlzLmNsaWVudFJlY3Q7XG4gICAgfVxuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBjb25zdCBib3VuZHNSZWN0ID0ge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9O1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgY29uc3QgY2xpZW50UmVjdCA9IG1lZGlhLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgYm91bmRzUmVjdC53aWR0aCA9IGNsaWVudFJlY3Qud2lkdGg7XG4gICAgICBib3VuZHNSZWN0LmhlaWdodCA9IGNsaWVudFJlY3QuaGVpZ2h0O1xuICAgICAgaWYgKCFib3VuZHNSZWN0LndpZHRoICYmICFib3VuZHNSZWN0LmhlaWdodCkge1xuICAgICAgICAvLyBXaGVuIHRoZSBtZWRpYSBlbGVtZW50IGhhcyBubyB3aWR0aCBvciBoZWlnaHQgKGVxdWl2YWxlbnQgdG8gbm90IGJlaW5nIGluIHRoZSBET00pLFxuICAgICAgICAvLyB0aGVuIHVzZSBpdHMgd2lkdGggYW5kIGhlaWdodCBhdHRyaWJ1dGVzIChtZWRpYS53aWR0aCwgbWVkaWEuaGVpZ2h0KVxuICAgICAgICBib3VuZHNSZWN0LndpZHRoID0gY2xpZW50UmVjdC5yaWdodCAtIGNsaWVudFJlY3QubGVmdCB8fCBtZWRpYS53aWR0aCB8fCAwO1xuICAgICAgICBib3VuZHNSZWN0LmhlaWdodCA9IGNsaWVudFJlY3QuYm90dG9tIC0gY2xpZW50UmVjdC50b3AgfHwgbWVkaWEuaGVpZ2h0IHx8IDA7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY2xpZW50UmVjdCA9IGJvdW5kc1JlY3Q7XG4gICAgcmV0dXJuIGJvdW5kc1JlY3Q7XG4gIH1cbiAgZ2V0IG1lZGlhV2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RGltZW5zaW9ucygpLndpZHRoICogdGhpcy5jb250ZW50U2NhbGVGYWN0b3I7XG4gIH1cbiAgZ2V0IG1lZGlhSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmdldERpbWVuc2lvbnMoKS5oZWlnaHQgKiB0aGlzLmNvbnRlbnRTY2FsZUZhY3RvcjtcbiAgfVxuICBnZXQgY29udGVudFNjYWxlRmFjdG9yKCkge1xuICAgIGxldCBwaXhlbFJhdGlvID0gMTtcbiAgICBpZiAoIXRoaXMuaGxzLmNvbmZpZy5pZ25vcmVEZXZpY2VQaXhlbFJhdGlvKSB7XG4gICAgICB0cnkge1xuICAgICAgICBwaXhlbFJhdGlvID0gc2VsZi5kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvKiBuby1vcCAqL1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGl4ZWxSYXRpbztcbiAgfVxuICBpc0xldmVsQWxsb3dlZChsZXZlbCkge1xuICAgIGNvbnN0IHJlc3RyaWN0ZWRMZXZlbHMgPSB0aGlzLnJlc3RyaWN0ZWRMZXZlbHM7XG4gICAgcmV0dXJuICFyZXN0cmljdGVkTGV2ZWxzLnNvbWUocmVzdHJpY3RlZExldmVsID0+IHtcbiAgICAgIHJldHVybiBsZXZlbC5iaXRyYXRlID09PSByZXN0cmljdGVkTGV2ZWwuYml0cmF0ZSAmJiBsZXZlbC53aWR0aCA9PT0gcmVzdHJpY3RlZExldmVsLndpZHRoICYmIGxldmVsLmhlaWdodCA9PT0gcmVzdHJpY3RlZExldmVsLmhlaWdodDtcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0TWF4TGV2ZWxCeU1lZGlhU2l6ZShsZXZlbHMsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAoIShsZXZlbHMgIT0gbnVsbCAmJiBsZXZlbHMubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8vIExldmVscyBjYW4gaGF2ZSB0aGUgc2FtZSBkaW1lbnNpb25zIGJ1dCBkaWZmZXJpbmcgYmFuZHdpZHRocyAtIHNpbmNlIGxldmVscyBhcmUgb3JkZXJlZCwgd2UgY2FuIGxvb2sgdG8gdGhlIG5leHRcbiAgICAvLyB0byBkZXRlcm1pbmUgd2hldGhlciB3ZSd2ZSBjaG9zZW4gdGhlIGdyZWF0ZXN0IGJhbmR3aWR0aCBmb3IgdGhlIG1lZGlhJ3MgZGltZW5zaW9uc1xuICAgIGNvbnN0IGF0R3JlYXRlc3RCYW5kd2lkdGggPSAoY3VyTGV2ZWwsIG5leHRMZXZlbCkgPT4ge1xuICAgICAgaWYgKCFuZXh0TGV2ZWwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3VyTGV2ZWwud2lkdGggIT09IG5leHRMZXZlbC53aWR0aCB8fCBjdXJMZXZlbC5oZWlnaHQgIT09IG5leHRMZXZlbC5oZWlnaHQ7XG4gICAgfTtcblxuICAgIC8vIElmIHdlIHJ1biB0aHJvdWdoIHRoZSBsb29wIHdpdGhvdXQgYnJlYWtpbmcsIHRoZSBtZWRpYSdzIGRpbWVuc2lvbnMgYXJlIGdyZWF0ZXIgdGhhbiBldmVyeSBsZXZlbCwgc28gZGVmYXVsdCB0b1xuICAgIC8vIHRoZSBtYXggbGV2ZWxcbiAgICBsZXQgbWF4TGV2ZWxJbmRleCA9IGxldmVscy5sZW5ndGggLSAxO1xuICAgIC8vIFByZXZlbnQgY2hhbmdlcyBpbiBhc3BlY3QtcmF0aW8gZnJvbSBjYXVzaW5nIGNhcHBpbmcgdG8gdG9nZ2xlIGJhY2sgYW5kIGZvcnRoXG4gICAgY29uc3Qgc3F1YXJlU2l6ZSA9IE1hdGgubWF4KHdpZHRoLCBoZWlnaHQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGV2ZWxzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBjb25zdCBsZXZlbCA9IGxldmVsc1tpXTtcbiAgICAgIGlmICgobGV2ZWwud2lkdGggPj0gc3F1YXJlU2l6ZSB8fCBsZXZlbC5oZWlnaHQgPj0gc3F1YXJlU2l6ZSkgJiYgYXRHcmVhdGVzdEJhbmR3aWR0aChsZXZlbCwgbGV2ZWxzW2kgKyAxXSkpIHtcbiAgICAgICAgbWF4TGV2ZWxJbmRleCA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF4TGV2ZWxJbmRleDtcbiAgfVxufVxuXG5jbGFzcyBGUFNDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoaGxzKSB7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5pc1ZpZGVvUGxheWJhY2tRdWFsaXR5QXZhaWxhYmxlID0gZmFsc2U7XG4gICAgdGhpcy50aW1lciA9IHZvaWQgMDtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICB0aGlzLmxhc3RUaW1lID0gdm9pZCAwO1xuICAgIHRoaXMubGFzdERyb3BwZWRGcmFtZXMgPSAwO1xuICAgIHRoaXMubGFzdERlY29kZWRGcmFtZXMgPSAwO1xuICAgIC8vIHN0cmVhbSBjb250cm9sbGVyIG11c3QgYmUgcHJvdmlkZWQgYXMgYSBkZXBlbmRlbmN5IVxuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlciA9IHZvaWQgMDtcbiAgICB0aGlzLmhscyA9IGhscztcbiAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cbiAgc2V0U3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyKSB7XG4gICAgdGhpcy5zdHJlYW1Db250cm9sbGVyID0gc3RyZWFtQ29udHJvbGxlcjtcbiAgfVxuICByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB0aGlzLmhscy5vbihFdmVudHMuTUVESUFfQVRUQUNISU5HLCB0aGlzLm9uTWVkaWFBdHRhY2hpbmcsIHRoaXMpO1xuICB9XG4gIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5obHMub2ZmKEV2ZW50cy5NRURJQV9BVFRBQ0hJTkcsIHRoaXMub25NZWRpYUF0dGFjaGluZywgdGhpcyk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICB9XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5pc1ZpZGVvUGxheWJhY2tRdWFsaXR5QXZhaWxhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gIH1cbiAgb25NZWRpYUF0dGFjaGluZyhldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuaGxzLmNvbmZpZztcbiAgICBpZiAoY29uZmlnLmNhcExldmVsT25GUFNEcm9wKSB7XG4gICAgICBjb25zdCBtZWRpYSA9IGRhdGEubWVkaWEgaW5zdGFuY2VvZiBzZWxmLkhUTUxWaWRlb0VsZW1lbnQgPyBkYXRhLm1lZGlhIDogbnVsbDtcbiAgICAgIHRoaXMubWVkaWEgPSBtZWRpYTtcbiAgICAgIGlmIChtZWRpYSAmJiB0eXBlb2YgbWVkaWEuZ2V0VmlkZW9QbGF5YmFja1F1YWxpdHkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5pc1ZpZGVvUGxheWJhY2tRdWFsaXR5QXZhaWxhYmxlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICAgIHRoaXMudGltZXIgPSBzZWxmLnNldEludGVydmFsKHRoaXMuY2hlY2tGUFNJbnRlcnZhbC5iaW5kKHRoaXMpLCBjb25maWcuZnBzRHJvcHBlZE1vbml0b3JpbmdQZXJpb2QpO1xuICAgIH1cbiAgfVxuICBjaGVja0ZQUyh2aWRlbywgZGVjb2RlZEZyYW1lcywgZHJvcHBlZEZyYW1lcykge1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgaWYgKGRlY29kZWRGcmFtZXMpIHtcbiAgICAgIGlmICh0aGlzLmxhc3RUaW1lKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRQZXJpb2QgPSBjdXJyZW50VGltZSAtIHRoaXMubGFzdFRpbWU7XG4gICAgICAgIGNvbnN0IGN1cnJlbnREcm9wcGVkID0gZHJvcHBlZEZyYW1lcyAtIHRoaXMubGFzdERyb3BwZWRGcmFtZXM7XG4gICAgICAgIGNvbnN0IGN1cnJlbnREZWNvZGVkID0gZGVjb2RlZEZyYW1lcyAtIHRoaXMubGFzdERlY29kZWRGcmFtZXM7XG4gICAgICAgIGNvbnN0IGRyb3BwZWRGUFMgPSAxMDAwICogY3VycmVudERyb3BwZWQgLyBjdXJyZW50UGVyaW9kO1xuICAgICAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkZQU19EUk9QLCB7XG4gICAgICAgICAgY3VycmVudERyb3BwZWQ6IGN1cnJlbnREcm9wcGVkLFxuICAgICAgICAgIGN1cnJlbnREZWNvZGVkOiBjdXJyZW50RGVjb2RlZCxcbiAgICAgICAgICB0b3RhbERyb3BwZWRGcmFtZXM6IGRyb3BwZWRGcmFtZXNcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChkcm9wcGVkRlBTID4gMCkge1xuICAgICAgICAgIC8vIGxvZ2dlci5sb2coJ2NoZWNrRlBTIDogZHJvcHBlZEZQUy9kZWNvZGVkRlBTOicgKyBkcm9wcGVkRlBTLygxMDAwICogY3VycmVudERlY29kZWQgLyBjdXJyZW50UGVyaW9kKSk7XG4gICAgICAgICAgaWYgKGN1cnJlbnREcm9wcGVkID4gaGxzLmNvbmZpZy5mcHNEcm9wcGVkTW9uaXRvcmluZ1RocmVzaG9sZCAqIGN1cnJlbnREZWNvZGVkKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudExldmVsID0gaGxzLmN1cnJlbnRMZXZlbDtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKCdkcm9wIEZQUyByYXRpbyBncmVhdGVyIHRoYW4gbWF4IGFsbG93ZWQgdmFsdWUgZm9yIGN1cnJlbnRMZXZlbDogJyArIGN1cnJlbnRMZXZlbCk7XG4gICAgICAgICAgICBpZiAoY3VycmVudExldmVsID4gMCAmJiAoaGxzLmF1dG9MZXZlbENhcHBpbmcgPT09IC0xIHx8IGhscy5hdXRvTGV2ZWxDYXBwaW5nID49IGN1cnJlbnRMZXZlbCkpIHtcbiAgICAgICAgICAgICAgY3VycmVudExldmVsID0gY3VycmVudExldmVsIC0gMTtcbiAgICAgICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkZQU19EUk9QX0xFVkVMX0NBUFBJTkcsIHtcbiAgICAgICAgICAgICAgICBsZXZlbDogY3VycmVudExldmVsLFxuICAgICAgICAgICAgICAgIGRyb3BwZWRMZXZlbDogaGxzLmN1cnJlbnRMZXZlbFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaGxzLmF1dG9MZXZlbENhcHBpbmcgPSBjdXJyZW50TGV2ZWw7XG4gICAgICAgICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWxTd2l0Y2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubGFzdFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICAgIHRoaXMubGFzdERyb3BwZWRGcmFtZXMgPSBkcm9wcGVkRnJhbWVzO1xuICAgICAgdGhpcy5sYXN0RGVjb2RlZEZyYW1lcyA9IGRlY29kZWRGcmFtZXM7XG4gICAgfVxuICB9XG4gIGNoZWNrRlBTSW50ZXJ2YWwoKSB7XG4gICAgY29uc3QgdmlkZW8gPSB0aGlzLm1lZGlhO1xuICAgIGlmICh2aWRlbykge1xuICAgICAgaWYgKHRoaXMuaXNWaWRlb1BsYXliYWNrUXVhbGl0eUF2YWlsYWJsZSkge1xuICAgICAgICBjb25zdCB2aWRlb1BsYXliYWNrUXVhbGl0eSA9IHZpZGVvLmdldFZpZGVvUGxheWJhY2tRdWFsaXR5KCk7XG4gICAgICAgIHRoaXMuY2hlY2tGUFModmlkZW8sIHZpZGVvUGxheWJhY2tRdWFsaXR5LnRvdGFsVmlkZW9GcmFtZXMsIHZpZGVvUGxheWJhY2tRdWFsaXR5LmRyb3BwZWRWaWRlb0ZyYW1lcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBIVE1MVmlkZW9FbGVtZW50IGRvZXNuJ3QgaW5jbHVkZSB0aGUgd2Via2l0IHR5cGVzXG4gICAgICAgIHRoaXMuY2hlY2tGUFModmlkZW8sIHZpZGVvLndlYmtpdERlY29kZWRGcmFtZUNvdW50LCB2aWRlby53ZWJraXREcm9wcGVkRnJhbWVDb3VudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IExPR0dFUl9QUkVGSVggPSAnW2VtZV0nO1xuLyoqXG4gKiBDb250cm9sbGVyIHRvIGRlYWwgd2l0aCBlbmNyeXB0ZWQgbWVkaWEgZXh0ZW5zaW9ucyAoRU1FKVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRW5jcnlwdGVkX01lZGlhX0V4dGVuc2lvbnNfQVBJXG4gKlxuICogQGNsYXNzXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgRU1FQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICAgIHRoaXMua2V5Rm9ybWF0UHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy5rZXlTeXN0ZW1BY2Nlc3NQcm9taXNlcyA9IHt9O1xuICAgIHRoaXMuX3JlcXVlc3RMaWNlbnNlRmFpbHVyZUNvdW50ID0gMDtcbiAgICB0aGlzLm1lZGlhS2V5U2Vzc2lvbnMgPSBbXTtcbiAgICB0aGlzLmtleUlkVG9LZXlTZXNzaW9uUHJvbWlzZSA9IHt9O1xuICAgIHRoaXMuc2V0TWVkaWFLZXlzUXVldWUgPSBFTUVDb250cm9sbGVyLkNETUNsZWFudXBQcm9taXNlID8gW0VNRUNvbnRyb2xsZXIuQ0RNQ2xlYW51cFByb21pc2VdIDogW107XG4gICAgdGhpcy5vbk1lZGlhRW5jcnlwdGVkID0gdGhpcy5fb25NZWRpYUVuY3J5cHRlZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25XYWl0aW5nRm9yS2V5ID0gdGhpcy5fb25XYWl0aW5nRm9yS2V5LmJpbmQodGhpcyk7XG4gICAgdGhpcy5kZWJ1ZyA9IGxvZ2dlci5kZWJ1Zy5iaW5kKGxvZ2dlciwgTE9HR0VSX1BSRUZJWCk7XG4gICAgdGhpcy5sb2cgPSBsb2dnZXIubG9nLmJpbmQobG9nZ2VyLCBMT0dHRVJfUFJFRklYKTtcbiAgICB0aGlzLndhcm4gPSBsb2dnZXIud2Fybi5iaW5kKGxvZ2dlciwgTE9HR0VSX1BSRUZJWCk7XG4gICAgdGhpcy5lcnJvciA9IGxvZ2dlci5lcnJvci5iaW5kKGxvZ2dlciwgTE9HR0VSX1BSRUZJWCk7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgdGhpcy5jb25maWcgPSBobHMuY29uZmlnO1xuICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIHRoaXMub25NZWRpYURldGFjaGVkKCk7XG4gICAgLy8gUmVtb3ZlIGFueSByZWZlcmVuY2VzIHRoYXQgY291bGQgYmUgaGVsZCBpbiBjb25maWcgb3B0aW9ucyBvciBjYWxsYmFja3NcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBjb25maWcucmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzRnVuYyA9IG51bGw7XG4gICAgY29uZmlnLmxpY2Vuc2VYaHJTZXR1cCA9IGNvbmZpZy5saWNlbnNlUmVzcG9uc2VDYWxsYmFjayA9IHVuZGVmaW5lZDtcbiAgICBjb25maWcuZHJtU3lzdGVtcyA9IGNvbmZpZy5kcm1TeXN0ZW1PcHRpb25zID0ge307XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuaGxzID0gdGhpcy5vbk1lZGlhRW5jcnlwdGVkID0gdGhpcy5vbldhaXRpbmdGb3JLZXkgPSB0aGlzLmtleUlkVG9LZXlTZXNzaW9uUHJvbWlzZSA9IG51bGw7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuY29uZmlnID0gbnVsbDtcbiAgfVxuICByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB0aGlzLmhscy5vbihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICB0aGlzLmhscy5vbihFdmVudHMuTUVESUFfREVUQUNIRUQsIHRoaXMub25NZWRpYURldGFjaGVkLCB0aGlzKTtcbiAgICB0aGlzLmhscy5vbihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgdGhpcy5obHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURFRCwgdGhpcy5vbk1hbmlmZXN0TG9hZGVkLCB0aGlzKTtcbiAgfVxuICB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHRoaXMuaGxzLm9mZihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICB0aGlzLmhscy5vZmYoRXZlbnRzLk1FRElBX0RFVEFDSEVELCB0aGlzLm9uTWVkaWFEZXRhY2hlZCwgdGhpcyk7XG4gICAgdGhpcy5obHMub2ZmKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICB0aGlzLmhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURFRCwgdGhpcy5vbk1hbmlmZXN0TG9hZGVkLCB0aGlzKTtcbiAgfVxuICBnZXRMaWNlbnNlU2VydmVyVXJsKGtleVN5c3RlbSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRybVN5c3RlbXMsXG4gICAgICB3aWRldmluZUxpY2Vuc2VVcmxcbiAgICB9ID0gdGhpcy5jb25maWc7XG4gICAgY29uc3Qga2V5U3lzdGVtQ29uZmlndXJhdGlvbiA9IGRybVN5c3RlbXNba2V5U3lzdGVtXTtcbiAgICBpZiAoa2V5U3lzdGVtQ29uZmlndXJhdGlvbikge1xuICAgICAgcmV0dXJuIGtleVN5c3RlbUNvbmZpZ3VyYXRpb24ubGljZW5zZVVybDtcbiAgICB9XG5cbiAgICAvLyBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgIGlmIChrZXlTeXN0ZW0gPT09IEtleVN5c3RlbXMuV0lERVZJTkUgJiYgd2lkZXZpbmVMaWNlbnNlVXJsKSB7XG4gICAgICByZXR1cm4gd2lkZXZpbmVMaWNlbnNlVXJsO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYG5vIGxpY2Vuc2Ugc2VydmVyIFVSTCBjb25maWd1cmVkIGZvciBrZXktc3lzdGVtIFwiJHtrZXlTeXN0ZW19XCJgKTtcbiAgfVxuICBnZXRTZXJ2ZXJDZXJ0aWZpY2F0ZVVybChrZXlTeXN0ZW0pIHtcbiAgICBjb25zdCB7XG4gICAgICBkcm1TeXN0ZW1zXG4gICAgfSA9IHRoaXMuY29uZmlnO1xuICAgIGNvbnN0IGtleVN5c3RlbUNvbmZpZ3VyYXRpb24gPSBkcm1TeXN0ZW1zW2tleVN5c3RlbV07XG4gICAgaWYgKGtleVN5c3RlbUNvbmZpZ3VyYXRpb24pIHtcbiAgICAgIHJldHVybiBrZXlTeXN0ZW1Db25maWd1cmF0aW9uLnNlcnZlckNlcnRpZmljYXRlVXJsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvZyhgTm8gU2VydmVyIENlcnRpZmljYXRlIGluIGNvbmZpZy5kcm1TeXN0ZW1zW1wiJHtrZXlTeXN0ZW19XCJdYCk7XG4gICAgfVxuICB9XG4gIGF0dGVtcHRLZXlTeXN0ZW1BY2Nlc3Moa2V5U3lzdGVtc1RvQXR0ZW1wdCkge1xuICAgIGNvbnN0IGxldmVscyA9IHRoaXMuaGxzLmxldmVscztcbiAgICBjb25zdCB1bmlxdWVDb2RlYyA9ICh2YWx1ZSwgaSwgYSkgPT4gISF2YWx1ZSAmJiBhLmluZGV4T2YodmFsdWUpID09PSBpO1xuICAgIGNvbnN0IGF1ZGlvQ29kZWNzID0gbGV2ZWxzLm1hcChsZXZlbCA9PiBsZXZlbC5hdWRpb0NvZGVjKS5maWx0ZXIodW5pcXVlQ29kZWMpO1xuICAgIGNvbnN0IHZpZGVvQ29kZWNzID0gbGV2ZWxzLm1hcChsZXZlbCA9PiBsZXZlbC52aWRlb0NvZGVjKS5maWx0ZXIodW5pcXVlQ29kZWMpO1xuICAgIGlmIChhdWRpb0NvZGVjcy5sZW5ndGggKyB2aWRlb0NvZGVjcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHZpZGVvQ29kZWNzLnB1c2goJ2F2YzEuNDJlMDFlJyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBhdHRlbXB0ID0ga2V5U3lzdGVtcyA9PiB7XG4gICAgICAgIGNvbnN0IGtleVN5c3RlbSA9IGtleVN5c3RlbXMuc2hpZnQoKTtcbiAgICAgICAgdGhpcy5nZXRNZWRpYUtleXNQcm9taXNlKGtleVN5c3RlbSwgYXVkaW9Db2RlY3MsIHZpZGVvQ29kZWNzKS50aGVuKG1lZGlhS2V5cyA9PiByZXNvbHZlKHtcbiAgICAgICAgICBrZXlTeXN0ZW0sXG4gICAgICAgICAgbWVkaWFLZXlzXG4gICAgICAgIH0pKS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgaWYgKGtleVN5c3RlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBhdHRlbXB0KGtleVN5c3RlbXMpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFTUVLZXlFcnJvcikge1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFTUVLZXlFcnJvcih7XG4gICAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fTk9fQUNDRVNTLFxuICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgICAgICAgIH0sIGVycm9yLm1lc3NhZ2UpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGF0dGVtcHQoa2V5U3lzdGVtc1RvQXR0ZW1wdCk7XG4gICAgfSk7XG4gIH1cbiAgcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzKGtleVN5c3RlbSwgc3VwcG9ydGVkQ29uZmlndXJhdGlvbnMpIHtcbiAgICBjb25zdCB7XG4gICAgICByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NGdW5jXG4gICAgfSA9IHRoaXMuY29uZmlnO1xuICAgIGlmICghKHR5cGVvZiByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NGdW5jID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgbGV0IGVyck1lc3NhZ2UgPSBgQ29uZmlndXJlZCByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MgaXMgbm90IGEgZnVuY3Rpb24gJHtyZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NGdW5jfWA7XG4gICAgICBpZiAocmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzID09PSBudWxsICYmIHNlbGYubG9jYXRpb24ucHJvdG9jb2wgPT09ICdodHRwOicpIHtcbiAgICAgICAgZXJyTWVzc2FnZSA9IGBuYXZpZ2F0b3IucmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzIGlzIG5vdCBhdmFpbGFibGUgb3ZlciBpbnNlY3VyZSBwcm90b2NvbCAke2xvY2F0aW9uLnByb3RvY29sfWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGVyck1lc3NhZ2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc0Z1bmMoa2V5U3lzdGVtLCBzdXBwb3J0ZWRDb25maWd1cmF0aW9ucyk7XG4gIH1cbiAgZ2V0TWVkaWFLZXlzUHJvbWlzZShrZXlTeXN0ZW0sIGF1ZGlvQ29kZWNzLCB2aWRlb0NvZGVjcykge1xuICAgIC8vIFRoaXMgY2FuIHRocm93LCBidXQgaXMgY2F1Z2h0IGluIGV2ZW50IGhhbmRsZXIgY2FsbHBhdGhcbiAgICBjb25zdCBtZWRpYUtleVN5c3RlbUNvbmZpZ3MgPSBnZXRTdXBwb3J0ZWRNZWRpYUtleVN5c3RlbUNvbmZpZ3VyYXRpb25zKGtleVN5c3RlbSwgYXVkaW9Db2RlY3MsIHZpZGVvQ29kZWNzLCB0aGlzLmNvbmZpZy5kcm1TeXN0ZW1PcHRpb25zKTtcbiAgICBjb25zdCBrZXlTeXN0ZW1BY2Nlc3NQcm9taXNlcyA9IHRoaXMua2V5U3lzdGVtQWNjZXNzUHJvbWlzZXNba2V5U3lzdGVtXTtcbiAgICBsZXQga2V5U3lzdGVtQWNjZXNzID0ga2V5U3lzdGVtQWNjZXNzUHJvbWlzZXMgPT0gbnVsbCA/IHZvaWQgMCA6IGtleVN5c3RlbUFjY2Vzc1Byb21pc2VzLmtleVN5c3RlbUFjY2VzcztcbiAgICBpZiAoIWtleVN5c3RlbUFjY2Vzcykge1xuICAgICAgdGhpcy5sb2coYFJlcXVlc3RpbmcgZW5jcnlwdGVkIG1lZGlhIFwiJHtrZXlTeXN0ZW19XCIga2V5LXN5c3RlbSBhY2Nlc3Mgd2l0aCBjb25maWc6ICR7SlNPTi5zdHJpbmdpZnkobWVkaWFLZXlTeXN0ZW1Db25maWdzKX1gKTtcbiAgICAgIGtleVN5c3RlbUFjY2VzcyA9IHRoaXMucmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzKGtleVN5c3RlbSwgbWVkaWFLZXlTeXN0ZW1Db25maWdzKTtcbiAgICAgIGNvbnN0IF9rZXlTeXN0ZW1BY2Nlc3NQcm9taXNlcyA9IHRoaXMua2V5U3lzdGVtQWNjZXNzUHJvbWlzZXNba2V5U3lzdGVtXSA9IHtcbiAgICAgICAga2V5U3lzdGVtQWNjZXNzXG4gICAgICB9O1xuICAgICAga2V5U3lzdGVtQWNjZXNzLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgdGhpcy5sb2coYEZhaWxlZCB0byBvYnRhaW4gYWNjZXNzIHRvIGtleS1zeXN0ZW0gXCIke2tleVN5c3RlbX1cIjogJHtlcnJvcn1gKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGtleVN5c3RlbUFjY2Vzcy50aGVuKG1lZGlhS2V5U3lzdGVtQWNjZXNzID0+IHtcbiAgICAgICAgdGhpcy5sb2coYEFjY2VzcyBmb3Iga2V5LXN5c3RlbSBcIiR7bWVkaWFLZXlTeXN0ZW1BY2Nlc3Mua2V5U3lzdGVtfVwiIG9idGFpbmVkYCk7XG4gICAgICAgIGNvbnN0IGNlcnRpZmljYXRlUmVxdWVzdCA9IHRoaXMuZmV0Y2hTZXJ2ZXJDZXJ0aWZpY2F0ZShrZXlTeXN0ZW0pO1xuICAgICAgICB0aGlzLmxvZyhgQ3JlYXRlIG1lZGlhLWtleXMgZm9yIFwiJHtrZXlTeXN0ZW19XCJgKTtcbiAgICAgICAgX2tleVN5c3RlbUFjY2Vzc1Byb21pc2VzLm1lZGlhS2V5cyA9IG1lZGlhS2V5U3lzdGVtQWNjZXNzLmNyZWF0ZU1lZGlhS2V5cygpLnRoZW4obWVkaWFLZXlzID0+IHtcbiAgICAgICAgICB0aGlzLmxvZyhgTWVkaWEta2V5cyBjcmVhdGVkIGZvciBcIiR7a2V5U3lzdGVtfVwiYCk7XG4gICAgICAgICAgcmV0dXJuIGNlcnRpZmljYXRlUmVxdWVzdC50aGVuKGNlcnRpZmljYXRlID0+IHtcbiAgICAgICAgICAgIGlmIChjZXJ0aWZpY2F0ZSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRNZWRpYUtleXNTZXJ2ZXJDZXJ0aWZpY2F0ZShtZWRpYUtleXMsIGtleVN5c3RlbSwgY2VydGlmaWNhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lZGlhS2V5cztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIF9rZXlTeXN0ZW1BY2Nlc3NQcm9taXNlcy5tZWRpYUtleXMuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgIHRoaXMuZXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgbWVkaWEta2V5cyBmb3IgXCIke2tleVN5c3RlbX1cIn06ICR7ZXJyb3J9YCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX2tleVN5c3RlbUFjY2Vzc1Byb21pc2VzLm1lZGlhS2V5cztcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ga2V5U3lzdGVtQWNjZXNzLnRoZW4oKCkgPT4ga2V5U3lzdGVtQWNjZXNzUHJvbWlzZXMubWVkaWFLZXlzKTtcbiAgfVxuICBjcmVhdGVNZWRpYUtleVNlc3Npb25Db250ZXh0KHtcbiAgICBkZWNyeXB0ZGF0YSxcbiAgICBrZXlTeXN0ZW0sXG4gICAgbWVkaWFLZXlzXG4gIH0pIHtcbiAgICB0aGlzLmxvZyhgQ3JlYXRpbmcga2V5LXN5c3RlbSBzZXNzaW9uIFwiJHtrZXlTeXN0ZW19XCIga2V5SWQ6ICR7SGV4LmhleER1bXAoZGVjcnlwdGRhdGEua2V5SWQgfHwgW10pfWApO1xuICAgIGNvbnN0IG1lZGlhS2V5c1Nlc3Npb24gPSBtZWRpYUtleXMuY3JlYXRlU2Vzc2lvbigpO1xuICAgIGNvbnN0IG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQgPSB7XG4gICAgICBkZWNyeXB0ZGF0YSxcbiAgICAgIGtleVN5c3RlbSxcbiAgICAgIG1lZGlhS2V5cyxcbiAgICAgIG1lZGlhS2V5c1Nlc3Npb24sXG4gICAgICBrZXlTdGF0dXM6ICdzdGF0dXMtcGVuZGluZydcbiAgICB9O1xuICAgIHRoaXMubWVkaWFLZXlTZXNzaW9ucy5wdXNoKG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQpO1xuICAgIHJldHVybiBtZWRpYUtleVNlc3Npb25Db250ZXh0O1xuICB9XG4gIHJlbmV3S2V5U2Vzc2lvbihtZWRpYUtleVNlc3Npb25Db250ZXh0KSB7XG4gICAgY29uc3QgZGVjcnlwdGRhdGEgPSBtZWRpYUtleVNlc3Npb25Db250ZXh0LmRlY3J5cHRkYXRhO1xuICAgIGlmIChkZWNyeXB0ZGF0YS5wc3NoKSB7XG4gICAgICBjb25zdCBrZXlTZXNzaW9uQ29udGV4dCA9IHRoaXMuY3JlYXRlTWVkaWFLZXlTZXNzaW9uQ29udGV4dChtZWRpYUtleVNlc3Npb25Db250ZXh0KTtcbiAgICAgIGNvbnN0IGtleUlkID0gdGhpcy5nZXRLZXlJZFN0cmluZyhkZWNyeXB0ZGF0YSk7XG4gICAgICBjb25zdCBzY2hlbWUgPSAnY2VuYyc7XG4gICAgICB0aGlzLmtleUlkVG9LZXlTZXNzaW9uUHJvbWlzZVtrZXlJZF0gPSB0aGlzLmdlbmVyYXRlUmVxdWVzdFdpdGhQcmVmZXJyZWRLZXlTZXNzaW9uKGtleVNlc3Npb25Db250ZXh0LCBzY2hlbWUsIGRlY3J5cHRkYXRhLnBzc2gsICdleHBpcmVkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud2FybihgQ291bGQgbm90IHJlbmV3IGV4cGlyZWQgc2Vzc2lvbi4gTWlzc2luZyBwc3NoIGluaXREYXRhLmApO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZVNlc3Npb24obWVkaWFLZXlTZXNzaW9uQ29udGV4dCk7XG4gIH1cbiAgZ2V0S2V5SWRTdHJpbmcoZGVjcnlwdGRhdGEpIHtcbiAgICBpZiAoIWRlY3J5cHRkYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCByZWFkIGtleUlkIG9mIHVuZGVmaW5lZCBkZWNyeXB0ZGF0YScpO1xuICAgIH1cbiAgICBpZiAoZGVjcnlwdGRhdGEua2V5SWQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigna2V5SWQgaXMgbnVsbCcpO1xuICAgIH1cbiAgICByZXR1cm4gSGV4LmhleER1bXAoZGVjcnlwdGRhdGEua2V5SWQpO1xuICB9XG4gIHVwZGF0ZUtleVNlc3Npb24obWVkaWFLZXlTZXNzaW9uQ29udGV4dCwgZGF0YSkge1xuICAgIHZhciBfbWVkaWFLZXlTZXNzaW9uQ29udGU7XG4gICAgY29uc3Qga2V5U2Vzc2lvbiA9IG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQubWVkaWFLZXlzU2Vzc2lvbjtcbiAgICB0aGlzLmxvZyhgVXBkYXRpbmcga2V5LXNlc3Npb24gXCIke2tleVNlc3Npb24uc2Vzc2lvbklkfVwiIGZvciBrZXlJRCAke0hleC5oZXhEdW1wKCgoX21lZGlhS2V5U2Vzc2lvbkNvbnRlID0gbWVkaWFLZXlTZXNzaW9uQ29udGV4dC5kZWNyeXB0ZGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9tZWRpYUtleVNlc3Npb25Db250ZS5rZXlJZCkgfHwgW10pfVxuICAgICAgfSAoZGF0YSBsZW5ndGg6ICR7ZGF0YSA/IGRhdGEuYnl0ZUxlbmd0aCA6IGRhdGF9KWApO1xuICAgIHJldHVybiBrZXlTZXNzaW9uLnVwZGF0ZShkYXRhKTtcbiAgfVxuICBzZWxlY3RLZXlTeXN0ZW1Gb3JtYXQoZnJhZykge1xuICAgIGNvbnN0IGtleUZvcm1hdHMgPSBPYmplY3Qua2V5cyhmcmFnLmxldmVsa2V5cyB8fCB7fSk7XG4gICAgaWYgKCF0aGlzLmtleUZvcm1hdFByb21pc2UpIHtcbiAgICAgIHRoaXMubG9nKGBTZWxlY3Rpbmcga2V5LXN5c3RlbSBmcm9tIGZyYWdtZW50IChzbjogJHtmcmFnLnNufSAke2ZyYWcudHlwZX06ICR7ZnJhZy5sZXZlbH0pIGtleSBmb3JtYXRzICR7a2V5Rm9ybWF0cy5qb2luKCcsICcpfWApO1xuICAgICAgdGhpcy5rZXlGb3JtYXRQcm9taXNlID0gdGhpcy5nZXRLZXlGb3JtYXRQcm9taXNlKGtleUZvcm1hdHMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5rZXlGb3JtYXRQcm9taXNlO1xuICB9XG4gIGdldEtleUZvcm1hdFByb21pc2Uoa2V5Rm9ybWF0cykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBrZXlTeXN0ZW1zSW5Db25maWcgPSBnZXRLZXlTeXN0ZW1zRm9yQ29uZmlnKHRoaXMuY29uZmlnKTtcbiAgICAgIGNvbnN0IGtleVN5c3RlbXNUb0F0dGVtcHQgPSBrZXlGb3JtYXRzLm1hcChrZXlTeXN0ZW1Gb3JtYXRUb0tleVN5c3RlbURvbWFpbikuZmlsdGVyKHZhbHVlID0+ICEhdmFsdWUgJiYga2V5U3lzdGVtc0luQ29uZmlnLmluZGV4T2YodmFsdWUpICE9PSAtMSk7XG4gICAgICByZXR1cm4gdGhpcy5nZXRLZXlTeXN0ZW1TZWxlY3Rpb25Qcm9taXNlKGtleVN5c3RlbXNUb0F0dGVtcHQpLnRoZW4oKHtcbiAgICAgICAga2V5U3lzdGVtXG4gICAgICB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGtleVN5c3RlbUZvcm1hdCA9IGtleVN5c3RlbURvbWFpblRvS2V5U3lzdGVtRm9ybWF0KGtleVN5c3RlbSk7XG4gICAgICAgIGlmIChrZXlTeXN0ZW1Gb3JtYXQpIHtcbiAgICAgICAgICByZXNvbHZlKGtleVN5c3RlbUZvcm1hdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgVW5hYmxlIHRvIGZpbmQgZm9ybWF0IGZvciBrZXktc3lzdGVtIFwiJHtrZXlTeXN0ZW19XCJgKSk7XG4gICAgICAgIH1cbiAgICAgIH0pLmNhdGNoKHJlamVjdCk7XG4gICAgfSk7XG4gIH1cbiAgbG9hZEtleShkYXRhKSB7XG4gICAgY29uc3QgZGVjcnlwdGRhdGEgPSBkYXRhLmtleUluZm8uZGVjcnlwdGRhdGE7XG4gICAgY29uc3Qga2V5SWQgPSB0aGlzLmdldEtleUlkU3RyaW5nKGRlY3J5cHRkYXRhKTtcbiAgICBjb25zdCBrZXlEZXRhaWxzID0gYChrZXlJZDogJHtrZXlJZH0gZm9ybWF0OiBcIiR7ZGVjcnlwdGRhdGEua2V5Rm9ybWF0fVwiIG1ldGhvZDogJHtkZWNyeXB0ZGF0YS5tZXRob2R9IHVyaTogJHtkZWNyeXB0ZGF0YS51cml9KWA7XG4gICAgdGhpcy5sb2coYFN0YXJ0aW5nIHNlc3Npb24gZm9yIGtleSAke2tleURldGFpbHN9YCk7XG4gICAgbGV0IGtleVNlc3Npb25Db250ZXh0UHJvbWlzZSA9IHRoaXMua2V5SWRUb0tleVNlc3Npb25Qcm9taXNlW2tleUlkXTtcbiAgICBpZiAoIWtleVNlc3Npb25Db250ZXh0UHJvbWlzZSkge1xuICAgICAga2V5U2Vzc2lvbkNvbnRleHRQcm9taXNlID0gdGhpcy5rZXlJZFRvS2V5U2Vzc2lvblByb21pc2Vba2V5SWRdID0gdGhpcy5nZXRLZXlTeXN0ZW1Gb3JLZXlQcm9taXNlKGRlY3J5cHRkYXRhKS50aGVuKCh7XG4gICAgICAgIGtleVN5c3RlbSxcbiAgICAgICAgbWVkaWFLZXlzXG4gICAgICB9KSA9PiB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICB0aGlzLmxvZyhgSGFuZGxlIGVuY3J5cHRlZCBtZWRpYSBzbjogJHtkYXRhLmZyYWcuc259ICR7ZGF0YS5mcmFnLnR5cGV9OiAke2RhdGEuZnJhZy5sZXZlbH0gdXNpbmcga2V5ICR7a2V5RGV0YWlsc31gKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0ZW1wdFNldE1lZGlhS2V5cyhrZXlTeXN0ZW0sIG1lZGlhS2V5cykudGhlbigoKSA9PiB7XG4gICAgICAgICAgdGhpcy50aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgICAgY29uc3Qga2V5U2Vzc2lvbkNvbnRleHQgPSB0aGlzLmNyZWF0ZU1lZGlhS2V5U2Vzc2lvbkNvbnRleHQoe1xuICAgICAgICAgICAga2V5U3lzdGVtLFxuICAgICAgICAgICAgbWVkaWFLZXlzLFxuICAgICAgICAgICAgZGVjcnlwdGRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCBzY2hlbWUgPSAnY2VuYyc7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVSZXF1ZXN0V2l0aFByZWZlcnJlZEtleVNlc3Npb24oa2V5U2Vzc2lvbkNvbnRleHQsIHNjaGVtZSwgZGVjcnlwdGRhdGEucHNzaCwgJ3BsYXlsaXN0LWtleScpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAga2V5U2Vzc2lvbkNvbnRleHRQcm9taXNlLmNhdGNoKGVycm9yID0+IHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IpKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleVNlc3Npb25Db250ZXh0UHJvbWlzZTtcbiAgfVxuICB0aHJvd0lmRGVzdHJveWVkKG1lc3NhZ2UgPSAnSW52YWxpZCBzdGF0ZScpIHtcbiAgICBpZiAoIXRoaXMuaGxzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc3RhdGUnKTtcbiAgICB9XG4gIH1cbiAgaGFuZGxlRXJyb3IoZXJyb3IpIHtcbiAgICBpZiAoIXRoaXMuaGxzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRU1FS2V5RXJyb3IpIHtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCBlcnJvci5kYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuS0VZX1NZU1RFTV9OT19LRVlTLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBnZXRLZXlTeXN0ZW1Gb3JLZXlQcm9taXNlKGRlY3J5cHRkYXRhKSB7XG4gICAgY29uc3Qga2V5SWQgPSB0aGlzLmdldEtleUlkU3RyaW5nKGRlY3J5cHRkYXRhKTtcbiAgICBjb25zdCBtZWRpYUtleVNlc3Npb25Db250ZXh0ID0gdGhpcy5rZXlJZFRvS2V5U2Vzc2lvblByb21pc2Vba2V5SWRdO1xuICAgIGlmICghbWVkaWFLZXlTZXNzaW9uQ29udGV4dCkge1xuICAgICAgY29uc3Qga2V5U3lzdGVtID0ga2V5U3lzdGVtRm9ybWF0VG9LZXlTeXN0ZW1Eb21haW4oZGVjcnlwdGRhdGEua2V5Rm9ybWF0KTtcbiAgICAgIGNvbnN0IGtleVN5c3RlbXNUb0F0dGVtcHQgPSBrZXlTeXN0ZW0gPyBba2V5U3lzdGVtXSA6IGdldEtleVN5c3RlbXNGb3JDb25maWcodGhpcy5jb25maWcpO1xuICAgICAgcmV0dXJuIHRoaXMuYXR0ZW1wdEtleVN5c3RlbUFjY2VzcyhrZXlTeXN0ZW1zVG9BdHRlbXB0KTtcbiAgICB9XG4gICAgcmV0dXJuIG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQ7XG4gIH1cbiAgZ2V0S2V5U3lzdGVtU2VsZWN0aW9uUHJvbWlzZShrZXlTeXN0ZW1zVG9BdHRlbXB0KSB7XG4gICAgaWYgKCFrZXlTeXN0ZW1zVG9BdHRlbXB0Lmxlbmd0aCkge1xuICAgICAga2V5U3lzdGVtc1RvQXR0ZW1wdCA9IGdldEtleVN5c3RlbXNGb3JDb25maWcodGhpcy5jb25maWcpO1xuICAgIH1cbiAgICBpZiAoa2V5U3lzdGVtc1RvQXR0ZW1wdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFTUVLZXlFcnJvcih7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fTk9fQ09ORklHVVJFRF9MSUNFTlNFLFxuICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgfSwgYE1pc3Npbmcga2V5LXN5c3RlbSBsaWNlbnNlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyAke0pTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgZHJtU3lzdGVtczogdGhpcy5jb25maWcuZHJtU3lzdGVtc1xuICAgICAgfSl9YCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmF0dGVtcHRLZXlTeXN0ZW1BY2Nlc3Moa2V5U3lzdGVtc1RvQXR0ZW1wdCk7XG4gIH1cbiAgX29uTWVkaWFFbmNyeXB0ZWQoZXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBpbml0RGF0YVR5cGUsXG4gICAgICBpbml0RGF0YVxuICAgIH0gPSBldmVudDtcbiAgICB0aGlzLmRlYnVnKGBcIiR7ZXZlbnQudHlwZX1cIiBldmVudDogaW5pdCBkYXRhIHR5cGU6IFwiJHtpbml0RGF0YVR5cGV9XCJgKTtcblxuICAgIC8vIElnbm9yZSBldmVudCB3aGVuIGluaXREYXRhIGlzIG51bGxcbiAgICBpZiAoaW5pdERhdGEgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGtleUlkO1xuICAgIGxldCBrZXlTeXN0ZW1Eb21haW47XG4gICAgaWYgKGluaXREYXRhVHlwZSA9PT0gJ3NpbmYnICYmIHRoaXMuY29uZmlnLmRybVN5c3RlbXNbS2V5U3lzdGVtcy5GQUlSUExBWV0pIHtcbiAgICAgIC8vIE1hdGNoIHNpbmYga2V5SWQgdG8gcGxheWxpc3Qgc2tkOi8va2V5SWQ9XG4gICAgICBjb25zdCBqc29uID0gYmluMnN0cihuZXcgVWludDhBcnJheShpbml0RGF0YSkpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc2luZiA9IGJhc2U2NERlY29kZShKU09OLnBhcnNlKGpzb24pLnNpbmYpO1xuICAgICAgICBjb25zdCB0ZW5jID0gcGFyc2VTaW5mKG5ldyBVaW50OEFycmF5KHNpbmYpKTtcbiAgICAgICAgaWYgKCF0ZW5jKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGtleUlkID0gdGVuYy5zdWJhcnJheSg4LCAyNCk7XG4gICAgICAgIGtleVN5c3RlbURvbWFpbiA9IEtleVN5c3RlbXMuRkFJUlBMQVk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aGlzLndhcm4oJ0ZhaWxlZCB0byBwYXJzZSBzaW5mIFwiZW5jcnlwdGVkXCIgZXZlbnQgbWVzc2FnZSBpbml0RGF0YScpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN1cHBvcnQgY2xlYXItbGVhZCBrZXktc2Vzc2lvbiBjcmVhdGlvbiAob3RoZXJ3aXNlIGRlcGVuZCBvbiBwbGF5bGlzdCBrZXlzKVxuICAgICAgY29uc3QgcHNzaEluZm8gPSBwYXJzZVBzc2goaW5pdERhdGEpO1xuICAgICAgaWYgKHBzc2hJbmZvID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChwc3NoSW5mby52ZXJzaW9uID09PSAwICYmIHBzc2hJbmZvLnN5c3RlbUlkID09PSBLZXlTeXN0ZW1JZHMuV0lERVZJTkUgJiYgcHNzaEluZm8uZGF0YSkge1xuICAgICAgICBrZXlJZCA9IHBzc2hJbmZvLmRhdGEuc3ViYXJyYXkoOCwgMjQpO1xuICAgICAgfVxuICAgICAga2V5U3lzdGVtRG9tYWluID0ga2V5U3lzdGVtSWRUb0tleVN5c3RlbURvbWFpbihwc3NoSW5mby5zeXN0ZW1JZCk7XG4gICAgfVxuICAgIGlmICgha2V5U3lzdGVtRG9tYWluIHx8ICFrZXlJZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBrZXlJZEhleCA9IEhleC5oZXhEdW1wKGtleUlkKTtcbiAgICBjb25zdCB7XG4gICAgICBrZXlJZFRvS2V5U2Vzc2lvblByb21pc2UsXG4gICAgICBtZWRpYUtleVNlc3Npb25zXG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IGtleVNlc3Npb25Db250ZXh0UHJvbWlzZSA9IGtleUlkVG9LZXlTZXNzaW9uUHJvbWlzZVtrZXlJZEhleF07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZWRpYUtleVNlc3Npb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBNYXRjaCBwbGF5bGlzdCBrZXlcbiAgICAgIGNvbnN0IGtleUNvbnRleHQgPSBtZWRpYUtleVNlc3Npb25zW2ldO1xuICAgICAgY29uc3QgZGVjcnlwdGRhdGEgPSBrZXlDb250ZXh0LmRlY3J5cHRkYXRhO1xuICAgICAgaWYgKGRlY3J5cHRkYXRhLnBzc2ggfHwgIWRlY3J5cHRkYXRhLmtleUlkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qgb2xkS2V5SWRIZXggPSBIZXguaGV4RHVtcChkZWNyeXB0ZGF0YS5rZXlJZCk7XG4gICAgICBpZiAoa2V5SWRIZXggPT09IG9sZEtleUlkSGV4IHx8IGRlY3J5cHRkYXRhLnVyaS5yZXBsYWNlKC8tL2csICcnKS5pbmRleE9mKGtleUlkSGV4KSAhPT0gLTEpIHtcbiAgICAgICAga2V5U2Vzc2lvbkNvbnRleHRQcm9taXNlID0ga2V5SWRUb0tleVNlc3Npb25Qcm9taXNlW29sZEtleUlkSGV4XTtcbiAgICAgICAgZGVsZXRlIGtleUlkVG9LZXlTZXNzaW9uUHJvbWlzZVtvbGRLZXlJZEhleF07XG4gICAgICAgIGRlY3J5cHRkYXRhLnBzc2ggPSBuZXcgVWludDhBcnJheShpbml0RGF0YSk7XG4gICAgICAgIGRlY3J5cHRkYXRhLmtleUlkID0ga2V5SWQ7XG4gICAgICAgIGtleVNlc3Npb25Db250ZXh0UHJvbWlzZSA9IGtleUlkVG9LZXlTZXNzaW9uUHJvbWlzZVtrZXlJZEhleF0gPSBrZXlTZXNzaW9uQ29udGV4dFByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVSZXF1ZXN0V2l0aFByZWZlcnJlZEtleVNlc3Npb24oa2V5Q29udGV4dCwgaW5pdERhdGFUeXBlLCBpbml0RGF0YSwgJ2VuY3J5cHRlZC1ldmVudC1rZXktbWF0Y2gnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWtleVNlc3Npb25Db250ZXh0UHJvbWlzZSkge1xuICAgICAgLy8gQ2xlYXItbGVhZCBrZXkgKG5vdCBlbmNvdW50ZXJlZCBpbiBwbGF5bGlzdClcbiAgICAgIGtleVNlc3Npb25Db250ZXh0UHJvbWlzZSA9IGtleUlkVG9LZXlTZXNzaW9uUHJvbWlzZVtrZXlJZEhleF0gPSB0aGlzLmdldEtleVN5c3RlbVNlbGVjdGlvblByb21pc2UoW2tleVN5c3RlbURvbWFpbl0pLnRoZW4oKHtcbiAgICAgICAga2V5U3lzdGVtLFxuICAgICAgICBtZWRpYUtleXNcbiAgICAgIH0pID0+IHtcbiAgICAgICAgdmFyIF9rZXlTeXN0ZW1Ub0tleVN5c3RlbTtcbiAgICAgICAgdGhpcy50aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgIGNvbnN0IGRlY3J5cHRkYXRhID0gbmV3IExldmVsS2V5KCdJU08tMjMwMDEtNycsIGtleUlkSGV4LCAoX2tleVN5c3RlbVRvS2V5U3lzdGVtID0ga2V5U3lzdGVtRG9tYWluVG9LZXlTeXN0ZW1Gb3JtYXQoa2V5U3lzdGVtKSkgIT0gbnVsbCA/IF9rZXlTeXN0ZW1Ub0tleVN5c3RlbSA6ICcnKTtcbiAgICAgICAgZGVjcnlwdGRhdGEucHNzaCA9IG5ldyBVaW50OEFycmF5KGluaXREYXRhKTtcbiAgICAgICAgZGVjcnlwdGRhdGEua2V5SWQgPSBrZXlJZDtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0ZW1wdFNldE1lZGlhS2V5cyhrZXlTeXN0ZW0sIG1lZGlhS2V5cykudGhlbigoKSA9PiB7XG4gICAgICAgICAgdGhpcy50aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgICAgY29uc3Qga2V5U2Vzc2lvbkNvbnRleHQgPSB0aGlzLmNyZWF0ZU1lZGlhS2V5U2Vzc2lvbkNvbnRleHQoe1xuICAgICAgICAgICAgZGVjcnlwdGRhdGEsXG4gICAgICAgICAgICBrZXlTeXN0ZW0sXG4gICAgICAgICAgICBtZWRpYUtleXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZVJlcXVlc3RXaXRoUHJlZmVycmVkS2V5U2Vzc2lvbihrZXlTZXNzaW9uQ29udGV4dCwgaW5pdERhdGFUeXBlLCBpbml0RGF0YSwgJ2VuY3J5cHRlZC1ldmVudC1uby1tYXRjaCcpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBrZXlTZXNzaW9uQ29udGV4dFByb21pc2UuY2F0Y2goZXJyb3IgPT4gdGhpcy5oYW5kbGVFcnJvcihlcnJvcikpO1xuICB9XG4gIF9vbldhaXRpbmdGb3JLZXkoZXZlbnQpIHtcbiAgICB0aGlzLmxvZyhgXCIke2V2ZW50LnR5cGV9XCIgZXZlbnRgKTtcbiAgfVxuICBhdHRlbXB0U2V0TWVkaWFLZXlzKGtleVN5c3RlbSwgbWVkaWFLZXlzKSB7XG4gICAgY29uc3QgcXVldWUgPSB0aGlzLnNldE1lZGlhS2V5c1F1ZXVlLnNsaWNlKCk7XG4gICAgdGhpcy5sb2coYFNldHRpbmcgbWVkaWEta2V5cyBmb3IgXCIke2tleVN5c3RlbX1cImApO1xuICAgIC8vIE9ubHkgb25lIHNldE1lZGlhS2V5cygpIGNhbiBydW4gYXQgb25lIHRpbWUsIGFuZCBtdWx0aXBsZSBzZXRNZWRpYUtleXMoKSBvcGVyYXRpb25zXG4gICAgLy8gY2FuIGJlIHF1ZXVlZCBmb3IgZXhlY3V0aW9uIGZvciBtdWx0aXBsZSBrZXkgc2Vzc2lvbnMuXG4gICAgY29uc3Qgc2V0TWVkaWFLZXlzUHJvbWlzZSA9IFByb21pc2UuYWxsKHF1ZXVlKS50aGVuKCgpID0+IHtcbiAgICAgIGlmICghdGhpcy5tZWRpYSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRlZCB0byBzZXQgbWVkaWFLZXlzIHdpdGhvdXQgbWVkaWEgZWxlbWVudCBhdHRhY2hlZCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMubWVkaWEuc2V0TWVkaWFLZXlzKG1lZGlhS2V5cyk7XG4gICAgfSk7XG4gICAgdGhpcy5zZXRNZWRpYUtleXNRdWV1ZS5wdXNoKHNldE1lZGlhS2V5c1Byb21pc2UpO1xuICAgIHJldHVybiBzZXRNZWRpYUtleXNQcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy5sb2coYE1lZGlhLWtleXMgc2V0IGZvciBcIiR7a2V5U3lzdGVtfVwiYCk7XG4gICAgICBxdWV1ZS5wdXNoKHNldE1lZGlhS2V5c1Byb21pc2UpO1xuICAgICAgdGhpcy5zZXRNZWRpYUtleXNRdWV1ZSA9IHRoaXMuc2V0TWVkaWFLZXlzUXVldWUuZmlsdGVyKHAgPT4gcXVldWUuaW5kZXhPZihwKSA9PT0gLTEpO1xuICAgIH0pO1xuICB9XG4gIGdlbmVyYXRlUmVxdWVzdFdpdGhQcmVmZXJyZWRLZXlTZXNzaW9uKGNvbnRleHQsIGluaXREYXRhVHlwZSwgaW5pdERhdGEsIHJlYXNvbikge1xuICAgIHZhciBfdGhpcyRjb25maWckZHJtU3lzdGUsIF90aGlzJGNvbmZpZyRkcm1TeXN0ZTI7XG4gICAgY29uc3QgZ2VuZXJhdGVSZXF1ZXN0RmlsdGVyID0gKF90aGlzJGNvbmZpZyRkcm1TeXN0ZSA9IHRoaXMuY29uZmlnLmRybVN5c3RlbXMpID09IG51bGwgPyB2b2lkIDAgOiAoX3RoaXMkY29uZmlnJGRybVN5c3RlMiA9IF90aGlzJGNvbmZpZyRkcm1TeXN0ZVtjb250ZXh0LmtleVN5c3RlbV0pID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRjb25maWckZHJtU3lzdGUyLmdlbmVyYXRlUmVxdWVzdDtcbiAgICBpZiAoZ2VuZXJhdGVSZXF1ZXN0RmlsdGVyKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBtYXBwZWRJbml0RGF0YSA9IGdlbmVyYXRlUmVxdWVzdEZpbHRlci5jYWxsKHRoaXMuaGxzLCBpbml0RGF0YVR5cGUsIGluaXREYXRhLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKCFtYXBwZWRJbml0RGF0YSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZXNwb25zZSBmcm9tIGNvbmZpZ3VyZWQgZ2VuZXJhdGVSZXF1ZXN0IGZpbHRlcicpO1xuICAgICAgICB9XG4gICAgICAgIGluaXREYXRhVHlwZSA9IG1hcHBlZEluaXREYXRhLmluaXREYXRhVHlwZTtcbiAgICAgICAgaW5pdERhdGEgPSBjb250ZXh0LmRlY3J5cHRkYXRhLnBzc2ggPSBtYXBwZWRJbml0RGF0YS5pbml0RGF0YSA/IG5ldyBVaW50OEFycmF5KG1hcHBlZEluaXREYXRhLmluaXREYXRhKSA6IG51bGw7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB2YXIgX3RoaXMkaGxzO1xuICAgICAgICB0aGlzLndhcm4oZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIGlmICgoX3RoaXMkaGxzID0gdGhpcy5obHMpICE9IG51bGwgJiYgX3RoaXMkaGxzLmNvbmZpZy5kZWJ1Zykge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpbml0RGF0YSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5sb2coYFNraXBwaW5nIGtleS1zZXNzaW9uIHJlcXVlc3QgZm9yIFwiJHtyZWFzb259XCIgKG5vIGluaXREYXRhKWApO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjb250ZXh0KTtcbiAgICB9XG4gICAgY29uc3Qga2V5SWQgPSB0aGlzLmdldEtleUlkU3RyaW5nKGNvbnRleHQuZGVjcnlwdGRhdGEpO1xuICAgIHRoaXMubG9nKGBHZW5lcmF0aW5nIGtleS1zZXNzaW9uIHJlcXVlc3QgZm9yIFwiJHtyZWFzb259XCI6ICR7a2V5SWR9IChpbml0IGRhdGEgdHlwZTogJHtpbml0RGF0YVR5cGV9IGxlbmd0aDogJHtpbml0RGF0YSA/IGluaXREYXRhLmJ5dGVMZW5ndGggOiBudWxsfSlgKTtcbiAgICBjb25zdCBsaWNlbnNlU3RhdHVzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIGNvbnN0IG9ubWVzc2FnZSA9IGNvbnRleHQuX29ubWVzc2FnZSA9IGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IGtleVNlc3Npb24gPSBjb250ZXh0Lm1lZGlhS2V5c1Nlc3Npb247XG4gICAgICBpZiAoIWtleVNlc3Npb24pIHtcbiAgICAgICAgbGljZW5zZVN0YXR1cy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignaW52YWxpZCBzdGF0ZScpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICBtZXNzYWdlVHlwZSxcbiAgICAgICAgbWVzc2FnZVxuICAgICAgfSA9IGV2ZW50O1xuICAgICAgdGhpcy5sb2coYFwiJHttZXNzYWdlVHlwZX1cIiBtZXNzYWdlIGV2ZW50IGZvciBzZXNzaW9uIFwiJHtrZXlTZXNzaW9uLnNlc3Npb25JZH1cIiBtZXNzYWdlIHNpemU6ICR7bWVzc2FnZS5ieXRlTGVuZ3RofWApO1xuICAgICAgaWYgKG1lc3NhZ2VUeXBlID09PSAnbGljZW5zZS1yZXF1ZXN0JyB8fCBtZXNzYWdlVHlwZSA9PT0gJ2xpY2Vuc2UtcmVuZXdhbCcpIHtcbiAgICAgICAgdGhpcy5yZW5ld0xpY2Vuc2UoY29udGV4dCwgbWVzc2FnZSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgIHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgICAgICAgIGxpY2Vuc2VTdGF0dXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChtZXNzYWdlVHlwZSA9PT0gJ2xpY2Vuc2UtcmVsZWFzZScpIHtcbiAgICAgICAgaWYgKGNvbnRleHQua2V5U3lzdGVtID09PSBLZXlTeXN0ZW1zLkZBSVJQTEFZKSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVLZXlTZXNzaW9uKGNvbnRleHQsIHN0clRvVXRmOGFycmF5KCdhY2tub3dsZWRnZWQnKSk7XG4gICAgICAgICAgdGhpcy5yZW1vdmVTZXNzaW9uKGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLndhcm4oYHVuaGFuZGxlZCBtZWRpYSBrZXkgbWVzc2FnZSB0eXBlIFwiJHttZXNzYWdlVHlwZX1cImApO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgb25rZXlzdGF0dXNlc2NoYW5nZSA9IGNvbnRleHQuX29ua2V5c3RhdHVzZXNjaGFuZ2UgPSBldmVudCA9PiB7XG4gICAgICBjb25zdCBrZXlTZXNzaW9uID0gY29udGV4dC5tZWRpYUtleXNTZXNzaW9uO1xuICAgICAgaWYgKCFrZXlTZXNzaW9uKSB7XG4gICAgICAgIGxpY2Vuc2VTdGF0dXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ2ludmFsaWQgc3RhdGUnKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMub25LZXlTdGF0dXNDaGFuZ2UoY29udGV4dCk7XG4gICAgICBjb25zdCBrZXlTdGF0dXMgPSBjb250ZXh0LmtleVN0YXR1cztcbiAgICAgIGxpY2Vuc2VTdGF0dXMuZW1pdCgna2V5U3RhdHVzJywga2V5U3RhdHVzKTtcbiAgICAgIGlmIChrZXlTdGF0dXMgPT09ICdleHBpcmVkJykge1xuICAgICAgICB0aGlzLndhcm4oYCR7Y29udGV4dC5rZXlTeXN0ZW19IGV4cGlyZWQgZm9yIGtleSAke2tleUlkfWApO1xuICAgICAgICB0aGlzLnJlbmV3S2V5U2Vzc2lvbihjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnRleHQubWVkaWFLZXlzU2Vzc2lvbi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgb25tZXNzYWdlKTtcbiAgICBjb250ZXh0Lm1lZGlhS2V5c1Nlc3Npb24uYWRkRXZlbnRMaXN0ZW5lcigna2V5c3RhdHVzZXNjaGFuZ2UnLCBvbmtleXN0YXR1c2VzY2hhbmdlKTtcbiAgICBjb25zdCBrZXlVc2FibGVQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbGljZW5zZVN0YXR1cy5vbignZXJyb3InLCByZWplY3QpO1xuICAgICAgbGljZW5zZVN0YXR1cy5vbigna2V5U3RhdHVzJywga2V5U3RhdHVzID0+IHtcbiAgICAgICAgaWYgKGtleVN0YXR1cy5zdGFydHNXaXRoKCd1c2FibGUnKSkge1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXlTdGF0dXMgPT09ICdvdXRwdXQtcmVzdHJpY3RlZCcpIHtcbiAgICAgICAgICByZWplY3QobmV3IEVNRUtleUVycm9yKHtcbiAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfU1lTVEVNX1NUQVRVU19PVVRQVVRfUkVTVFJJQ1RFRCxcbiAgICAgICAgICAgIGZhdGFsOiBmYWxzZVxuICAgICAgICAgIH0sICdIRENQIGxldmVsIG91dHB1dCByZXN0cmljdGVkJykpO1xuICAgICAgICB9IGVsc2UgaWYgKGtleVN0YXR1cyA9PT0gJ2ludGVybmFsLWVycm9yJykge1xuICAgICAgICAgIHJlamVjdChuZXcgRU1FS2V5RXJyb3Ioe1xuICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fU1RBVFVTX0lOVEVSTkFMX0VSUk9SLFxuICAgICAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgICAgICB9LCBga2V5IHN0YXR1cyBjaGFuZ2VkIHRvIFwiJHtrZXlTdGF0dXN9XCJgKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5U3RhdHVzID09PSAnZXhwaXJlZCcpIHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdrZXkgZXhwaXJlZCB3aGlsZSBnZW5lcmF0aW5nIHJlcXVlc3QnKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy53YXJuKGB1bmhhbmRsZWQga2V5IHN0YXR1cyBjaGFuZ2UgXCIke2tleVN0YXR1c31cImApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gY29udGV4dC5tZWRpYUtleXNTZXNzaW9uLmdlbmVyYXRlUmVxdWVzdChpbml0RGF0YVR5cGUsIGluaXREYXRhKS50aGVuKCgpID0+IHtcbiAgICAgIHZhciBfY29udGV4dCRtZWRpYUtleXNTZXM7XG4gICAgICB0aGlzLmxvZyhgUmVxdWVzdCBnZW5lcmF0ZWQgZm9yIGtleS1zZXNzaW9uIFwiJHsoX2NvbnRleHQkbWVkaWFLZXlzU2VzID0gY29udGV4dC5tZWRpYUtleXNTZXNzaW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2NvbnRleHQkbWVkaWFLZXlzU2VzLnNlc3Npb25JZH1cIiBrZXlJZDogJHtrZXlJZH1gKTtcbiAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICB0aHJvdyBuZXcgRU1FS2V5RXJyb3Ioe1xuICAgICAgICB0eXBlOiBFcnJvclR5cGVzLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfU1lTVEVNX05PX1NFU1NJT04sXG4gICAgICAgIGVycm9yLFxuICAgICAgICBmYXRhbDogZmFsc2VcbiAgICAgIH0sIGBFcnJvciBnZW5lcmF0aW5nIGtleS1zZXNzaW9uIHJlcXVlc3Q6ICR7ZXJyb3J9YCk7XG4gICAgfSkudGhlbigoKSA9PiBrZXlVc2FibGVQcm9taXNlKS5jYXRjaChlcnJvciA9PiB7XG4gICAgICBsaWNlbnNlU3RhdHVzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgdGhpcy5yZW1vdmVTZXNzaW9uKGNvbnRleHQpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSkudGhlbigoKSA9PiB7XG4gICAgICBsaWNlbnNlU3RhdHVzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfSk7XG4gIH1cbiAgb25LZXlTdGF0dXNDaGFuZ2UobWVkaWFLZXlTZXNzaW9uQ29udGV4dCkge1xuICAgIG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQubWVkaWFLZXlzU2Vzc2lvbi5rZXlTdGF0dXNlcy5mb3JFYWNoKChzdGF0dXMsIGtleUlkKSA9PiB7XG4gICAgICB0aGlzLmxvZyhga2V5IHN0YXR1cyBjaGFuZ2UgXCIke3N0YXR1c31cIiBmb3Iga2V5U3RhdHVzZXMga2V5SWQ6ICR7SGV4LmhleER1bXAoJ2J1ZmZlcicgaW4ga2V5SWQgPyBuZXcgVWludDhBcnJheShrZXlJZC5idWZmZXIsIGtleUlkLmJ5dGVPZmZzZXQsIGtleUlkLmJ5dGVMZW5ndGgpIDogbmV3IFVpbnQ4QXJyYXkoa2V5SWQpKX0gc2Vzc2lvbiBrZXlJZDogJHtIZXguaGV4RHVtcChuZXcgVWludDhBcnJheShtZWRpYUtleVNlc3Npb25Db250ZXh0LmRlY3J5cHRkYXRhLmtleUlkIHx8IFtdKSl9IHVyaTogJHttZWRpYUtleVNlc3Npb25Db250ZXh0LmRlY3J5cHRkYXRhLnVyaX1gKTtcbiAgICAgIG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQua2V5U3RhdHVzID0gc3RhdHVzO1xuICAgIH0pO1xuICB9XG4gIGZldGNoU2VydmVyQ2VydGlmaWNhdGUoa2V5U3lzdGVtKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgY29uc3QgTG9hZGVyID0gY29uZmlnLmxvYWRlcjtcbiAgICBjb25zdCBjZXJ0TG9hZGVyID0gbmV3IExvYWRlcihjb25maWcpO1xuICAgIGNvbnN0IHVybCA9IHRoaXMuZ2V0U2VydmVyQ2VydGlmaWNhdGVVcmwoa2V5U3lzdGVtKTtcbiAgICBpZiAoIXVybCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICB0aGlzLmxvZyhgRmV0Y2hpbmcgc2VydmVyIGNlcnRpZmljYXRlIGZvciBcIiR7a2V5U3lzdGVtfVwiYCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGxvYWRlckNvbnRleHQgPSB7XG4gICAgICAgIHJlc3BvbnNlVHlwZTogJ2FycmF5YnVmZmVyJyxcbiAgICAgICAgdXJsXG4gICAgICB9O1xuICAgICAgY29uc3QgbG9hZFBvbGljeSA9IGNvbmZpZy5jZXJ0TG9hZFBvbGljeS5kZWZhdWx0O1xuICAgICAgY29uc3QgbG9hZGVyQ29uZmlnID0ge1xuICAgICAgICBsb2FkUG9saWN5LFxuICAgICAgICB0aW1lb3V0OiBsb2FkUG9saWN5Lm1heExvYWRUaW1lTXMsXG4gICAgICAgIG1heFJldHJ5OiAwLFxuICAgICAgICByZXRyeURlbGF5OiAwLFxuICAgICAgICBtYXhSZXRyeURlbGF5OiAwXG4gICAgICB9O1xuICAgICAgY29uc3QgbG9hZGVyQ2FsbGJhY2tzID0ge1xuICAgICAgICBvblN1Y2Nlc3M6IChyZXNwb25zZSwgc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZShyZXNwb25zZS5kYXRhKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25FcnJvcjogKHJlc3BvbnNlLCBjb250ZXgsIG5ldHdvcmtEZXRhaWxzLCBzdGF0cykgPT4ge1xuICAgICAgICAgIHJlamVjdChuZXcgRU1FS2V5RXJyb3Ioe1xuICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fU0VSVkVSX0NFUlRJRklDQVRFX1JFUVVFU1RfRkFJTEVELFxuICAgICAgICAgICAgZmF0YWw6IHRydWUsXG4gICAgICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICAgIHJlc3BvbnNlOiBfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAgICAgIHVybDogbG9hZGVyQ29udGV4dC51cmwsXG4gICAgICAgICAgICAgIGRhdGE6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfSwgcmVzcG9uc2UpXG4gICAgICAgICAgfSwgYFwiJHtrZXlTeXN0ZW19XCIgY2VydGlmaWNhdGUgcmVxdWVzdCBmYWlsZWQgKCR7dXJsfSkuIFN0YXR1czogJHtyZXNwb25zZS5jb2RlfSAoJHtyZXNwb25zZS50ZXh0fSlgKSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uVGltZW91dDogKHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykgPT4ge1xuICAgICAgICAgIHJlamVjdChuZXcgRU1FS2V5RXJyb3Ioe1xuICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLktFWV9TWVNURU1fU0VSVkVSX0NFUlRJRklDQVRFX1JFUVVFU1RfRkFJTEVELFxuICAgICAgICAgICAgZmF0YWw6IHRydWUsXG4gICAgICAgICAgICBuZXR3b3JrRGV0YWlscyxcbiAgICAgICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgICAgIHVybDogbG9hZGVyQ29udGV4dC51cmwsXG4gICAgICAgICAgICAgIGRhdGE6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIGBcIiR7a2V5U3lzdGVtfVwiIGNlcnRpZmljYXRlIHJlcXVlc3QgdGltZWQgb3V0ICgke3VybH0pYCkpO1xuICAgICAgICB9LFxuICAgICAgICBvbkFib3J0OiAoc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSA9PiB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignYWJvcnRlZCcpKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNlcnRMb2FkZXIubG9hZChsb2FkZXJDb250ZXh0LCBsb2FkZXJDb25maWcsIGxvYWRlckNhbGxiYWNrcyk7XG4gICAgfSk7XG4gIH1cbiAgc2V0TWVkaWFLZXlzU2VydmVyQ2VydGlmaWNhdGUobWVkaWFLZXlzLCBrZXlTeXN0ZW0sIGNlcnQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbWVkaWFLZXlzLnNldFNlcnZlckNlcnRpZmljYXRlKGNlcnQpLnRoZW4oc3VjY2VzcyA9PiB7XG4gICAgICAgIHRoaXMubG9nKGBzZXRTZXJ2ZXJDZXJ0aWZpY2F0ZSAke3N1Y2Nlc3MgPyAnc3VjY2VzcycgOiAnbm90IHN1cHBvcnRlZCBieSBDRE0nfSAoJHtjZXJ0ID09IG51bGwgPyB2b2lkIDAgOiBjZXJ0LmJ5dGVMZW5ndGh9KSBvbiBcIiR7a2V5U3lzdGVtfVwiYCk7XG4gICAgICAgIHJlc29sdmUobWVkaWFLZXlzKTtcbiAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgcmVqZWN0KG5ldyBFTUVLZXlFcnJvcih7XG4gICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfU1lTVEVNX1NFUlZFUl9DRVJUSUZJQ0FURV9VUERBVEVfRkFJTEVELFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICAgIH0sIGVycm9yLm1lc3NhZ2UpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHJlbmV3TGljZW5zZShjb250ZXh0LCBrZXlNZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdExpY2Vuc2UoY29udGV4dCwgbmV3IFVpbnQ4QXJyYXkoa2V5TWVzc2FnZSkpLnRoZW4oZGF0YSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy51cGRhdGVLZXlTZXNzaW9uKGNvbnRleHQsIG5ldyBVaW50OEFycmF5KGRhdGEpKS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFTUVLZXlFcnJvcih7XG4gICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfU1lTVEVNX1NFU1NJT05fVVBEQVRFX0ZBSUxFRCxcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgICB9LCBlcnJvci5tZXNzYWdlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHVucGFja1BsYXlSZWFkeUtleU1lc3NhZ2UoeGhyLCBsaWNlbnNlQ2hhbGxlbmdlKSB7XG4gICAgLy8gT24gRWRnZSwgdGhlIHJhdyBsaWNlbnNlIG1lc3NhZ2UgaXMgVVRGLTE2LWVuY29kZWQgWE1MLiAgV2UgbmVlZFxuICAgIC8vIHRvIHVucGFjayB0aGUgQ2hhbGxlbmdlIGVsZW1lbnQgKGJhc2U2NC1lbmNvZGVkIHN0cmluZyBjb250YWluaW5nIHRoZVxuICAgIC8vIGFjdHVhbCBsaWNlbnNlIHJlcXVlc3QpIGFuZCBhbnkgSHR0cEhlYWRlciBlbGVtZW50cyAoc2VudCBhcyByZXF1ZXN0XG4gICAgLy8gaGVhZGVycykuXG4gICAgLy8gRm9yIFBsYXlSZWFkeSBDRE1zLCB3ZSBuZWVkIHRvIGRpZyB0aGUgQ2hhbGxlbmdlIG91dCBvZiB0aGUgWE1MLlxuICAgIGNvbnN0IHhtbFN0cmluZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQxNkFycmF5KGxpY2Vuc2VDaGFsbGVuZ2UuYnVmZmVyKSk7XG4gICAgaWYgKCF4bWxTdHJpbmcuaW5jbHVkZXMoJ1BsYXlSZWFkeUtleU1lc3NhZ2UnKSkge1xuICAgICAgLy8gVGhpcyBkb2VzIG5vdCBhcHBlYXIgdG8gYmUgYSB3cmFwcGVkIG1lc3NhZ2UgYXMgb24gRWRnZS4gIFNvbWVcbiAgICAgIC8vIGNsaWVudHMgZG8gbm90IG5lZWQgdGhpcyB1bndyYXBwaW5nLCBzbyB3ZSB3aWxsIGFzc3VtZSB0aGlzIGlzIG9uZSBvZlxuICAgICAgLy8gdGhlbS4gIE5vdGUgdGhhdCBcInhtbFwiIGF0IHRoaXMgcG9pbnQgcHJvYmFibHkgbG9va3MgbGlrZSByYW5kb21cbiAgICAgIC8vIGdhcmJhZ2UsIHNpbmNlIHdlIGludGVycHJldGVkIFVURi04IGFzIFVURi0xNi5cbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAndGV4dC94bWw7IGNoYXJzZXQ9dXRmLTgnKTtcbiAgICAgIHJldHVybiBsaWNlbnNlQ2hhbGxlbmdlO1xuICAgIH1cbiAgICBjb25zdCBrZXlNZXNzYWdlWG1sID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyh4bWxTdHJpbmcsICdhcHBsaWNhdGlvbi94bWwnKTtcbiAgICAvLyBTZXQgcmVxdWVzdCBoZWFkZXJzLlxuICAgIGNvbnN0IGhlYWRlcnMgPSBrZXlNZXNzYWdlWG1sLnF1ZXJ5U2VsZWN0b3JBbGwoJ0h0dHBIZWFkZXInKTtcbiAgICBpZiAoaGVhZGVycy5sZW5ndGggPiAwKSB7XG4gICAgICBsZXQgaGVhZGVyO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGhlYWRlcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIF9oZWFkZXIkcXVlcnlTZWxlY3RvciwgX2hlYWRlciRxdWVyeVNlbGVjdG9yMjtcbiAgICAgICAgaGVhZGVyID0gaGVhZGVyc1tpXTtcbiAgICAgICAgY29uc3QgbmFtZSA9IChfaGVhZGVyJHF1ZXJ5U2VsZWN0b3IgPSBoZWFkZXIucXVlcnlTZWxlY3RvcignbmFtZScpKSA9PSBudWxsID8gdm9pZCAwIDogX2hlYWRlciRxdWVyeVNlbGVjdG9yLnRleHRDb250ZW50O1xuICAgICAgICBjb25zdCB2YWx1ZSA9IChfaGVhZGVyJHF1ZXJ5U2VsZWN0b3IyID0gaGVhZGVyLnF1ZXJ5U2VsZWN0b3IoJ3ZhbHVlJykpID09IG51bGwgPyB2b2lkIDAgOiBfaGVhZGVyJHF1ZXJ5U2VsZWN0b3IyLnRleHRDb250ZW50O1xuICAgICAgICBpZiAobmFtZSAmJiB2YWx1ZSkge1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjaGFsbGVuZ2VFbGVtZW50ID0ga2V5TWVzc2FnZVhtbC5xdWVyeVNlbGVjdG9yKCdDaGFsbGVuZ2UnKTtcbiAgICBjb25zdCBjaGFsbGVuZ2VUZXh0ID0gY2hhbGxlbmdlRWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogY2hhbGxlbmdlRWxlbWVudC50ZXh0Q29udGVudDtcbiAgICBpZiAoIWNoYWxsZW5nZVRleHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGZpbmQgPENoYWxsZW5nZT4gaW4ga2V5IG1lc3NhZ2VgKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0clRvVXRmOGFycmF5KGF0b2IoY2hhbGxlbmdlVGV4dCkpO1xuICB9XG4gIHNldHVwTGljZW5zZVhIUih4aHIsIHVybCwga2V5c0xpc3RJdGVtLCBsaWNlbnNlQ2hhbGxlbmdlKSB7XG4gICAgY29uc3QgbGljZW5zZVhoclNldHVwID0gdGhpcy5jb25maWcubGljZW5zZVhoclNldHVwO1xuICAgIGlmICghbGljZW5zZVhoclNldHVwKSB7XG4gICAgICB4aHIub3BlbignUE9TVCcsIHVybCwgdHJ1ZSk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgeGhyLFxuICAgICAgICBsaWNlbnNlQ2hhbGxlbmdlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgaWYgKCFrZXlzTGlzdEl0ZW0uZGVjcnlwdGRhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdLZXkgcmVtb3ZlZCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxpY2Vuc2VYaHJTZXR1cC5jYWxsKHRoaXMuaGxzLCB4aHIsIHVybCwga2V5c0xpc3RJdGVtLCBsaWNlbnNlQ2hhbGxlbmdlKTtcbiAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICBpZiAoIWtleXNMaXN0SXRlbS5kZWNyeXB0ZGF0YSkge1xuICAgICAgICAvLyBLZXkgc2Vzc2lvbiByZW1vdmVkLiBDYW5jZWwgbGljZW5zZSByZXF1ZXN0LlxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIC8vIGxldCdzIHRyeSB0byBvcGVuIGJlZm9yZSBydW5uaW5nIHNldHVwXG4gICAgICB4aHIub3BlbignUE9TVCcsIHVybCwgdHJ1ZSk7XG4gICAgICByZXR1cm4gbGljZW5zZVhoclNldHVwLmNhbGwodGhpcy5obHMsIHhociwgdXJsLCBrZXlzTGlzdEl0ZW0sIGxpY2Vuc2VDaGFsbGVuZ2UpO1xuICAgIH0pLnRoZW4obGljZW5zZVhoclNldHVwUmVzdWx0ID0+IHtcbiAgICAgIC8vIGlmIGxpY2Vuc2VYaHJTZXR1cCBkaWQgbm90IHlldCBjYWxsIG9wZW4sIGxldCdzIGRvIGl0IG5vd1xuICAgICAgaWYgKCF4aHIucmVhZHlTdGF0ZSkge1xuICAgICAgICB4aHIub3BlbignUE9TVCcsIHVybCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBmaW5hbExpY2Vuc2VDaGFsbGVuZ2UgPSBsaWNlbnNlWGhyU2V0dXBSZXN1bHQgPyBsaWNlbnNlWGhyU2V0dXBSZXN1bHQgOiBsaWNlbnNlQ2hhbGxlbmdlO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeGhyLFxuICAgICAgICBsaWNlbnNlQ2hhbGxlbmdlOiBmaW5hbExpY2Vuc2VDaGFsbGVuZ2VcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgcmVxdWVzdExpY2Vuc2Uoa2V5U2Vzc2lvbkNvbnRleHQsIGxpY2Vuc2VDaGFsbGVuZ2UpIHtcbiAgICBjb25zdCBrZXlMb2FkUG9saWN5ID0gdGhpcy5jb25maWcua2V5TG9hZFBvbGljeS5kZWZhdWx0O1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCB1cmwgPSB0aGlzLmdldExpY2Vuc2VTZXJ2ZXJVcmwoa2V5U2Vzc2lvbkNvbnRleHQua2V5U3lzdGVtKTtcbiAgICAgIHRoaXMubG9nKGBTZW5kaW5nIGxpY2Vuc2UgcmVxdWVzdCB0byBVUkw6ICR7dXJsfWApO1xuICAgICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5obHMgfHwgIWtleVNlc3Npb25Db250ZXh0Lm1lZGlhS2V5c1Nlc3Npb24pIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignaW52YWxpZCBzdGF0ZScpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0TGljZW5zZUZhaWx1cmVDb3VudCA9IDA7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IHhoci5yZXNwb25zZTtcbiAgICAgICAgICAgIHRoaXMubG9nKGBMaWNlbnNlIHJlY2VpdmVkICR7ZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyID8gZGF0YS5ieXRlTGVuZ3RoIDogZGF0YX1gKTtcbiAgICAgICAgICAgIGNvbnN0IGxpY2Vuc2VSZXNwb25zZUNhbGxiYWNrID0gdGhpcy5jb25maWcubGljZW5zZVJlc3BvbnNlQ2FsbGJhY2s7XG4gICAgICAgICAgICBpZiAobGljZW5zZVJlc3BvbnNlQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBkYXRhID0gbGljZW5zZVJlc3BvbnNlQ2FsbGJhY2suY2FsbCh0aGlzLmhscywgeGhyLCB1cmwsIGtleVNlc3Npb25Db250ZXh0KTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcmV0cnlDb25maWcgPSBrZXlMb2FkUG9saWN5LmVycm9yUmV0cnk7XG4gICAgICAgICAgICBjb25zdCBtYXhOdW1SZXRyeSA9IHJldHJ5Q29uZmlnID8gcmV0cnlDb25maWcubWF4TnVtUmV0cnkgOiAwO1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdExpY2Vuc2VGYWlsdXJlQ291bnQrKztcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZXF1ZXN0TGljZW5zZUZhaWx1cmVDb3VudCA+IG1heE51bVJldHJ5IHx8IHhoci5zdGF0dXMgPj0gNDAwICYmIHhoci5zdGF0dXMgPCA1MDApIHtcbiAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFTUVLZXlFcnJvcih7XG4gICAgICAgICAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5LRVlfU1lTVEVNX0xJQ0VOU0VfUkVRVUVTVF9GQUlMRUQsXG4gICAgICAgICAgICAgICAgZmF0YWw6IHRydWUsXG4gICAgICAgICAgICAgICAgbmV0d29ya0RldGFpbHM6IHhocixcbiAgICAgICAgICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgICAgZGF0YTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgY29kZTogeGhyLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgIHRleHQ6IHhoci5zdGF0dXNUZXh0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LCBgTGljZW5zZSBSZXF1ZXN0IFhIUiBmYWlsZWQgKCR7dXJsfSkuIFN0YXR1czogJHt4aHIuc3RhdHVzfSAoJHt4aHIuc3RhdHVzVGV4dH0pYCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc3QgYXR0ZW1wdHNMZWZ0ID0gbWF4TnVtUmV0cnkgLSB0aGlzLl9yZXF1ZXN0TGljZW5zZUZhaWx1cmVDb3VudCArIDE7XG4gICAgICAgICAgICAgIHRoaXMud2FybihgUmV0cnlpbmcgbGljZW5zZSByZXF1ZXN0LCAke2F0dGVtcHRzTGVmdH0gYXR0ZW1wdHMgbGVmdGApO1xuICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RMaWNlbnNlKGtleVNlc3Npb25Db250ZXh0LCBsaWNlbnNlQ2hhbGxlbmdlKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKGtleVNlc3Npb25Db250ZXh0LmxpY2Vuc2VYaHIgJiYga2V5U2Vzc2lvbkNvbnRleHQubGljZW5zZVhoci5yZWFkeVN0YXRlICE9PSBYTUxIdHRwUmVxdWVzdC5ET05FKSB7XG4gICAgICAgIGtleVNlc3Npb25Db250ZXh0LmxpY2Vuc2VYaHIuYWJvcnQoKTtcbiAgICAgIH1cbiAgICAgIGtleVNlc3Npb25Db250ZXh0LmxpY2Vuc2VYaHIgPSB4aHI7XG4gICAgICB0aGlzLnNldHVwTGljZW5zZVhIUih4aHIsIHVybCwga2V5U2Vzc2lvbkNvbnRleHQsIGxpY2Vuc2VDaGFsbGVuZ2UpLnRoZW4oKHtcbiAgICAgICAgeGhyLFxuICAgICAgICBsaWNlbnNlQ2hhbGxlbmdlXG4gICAgICB9KSA9PiB7XG4gICAgICAgIGlmIChrZXlTZXNzaW9uQ29udGV4dC5rZXlTeXN0ZW0gPT0gS2V5U3lzdGVtcy5QTEFZUkVBRFkpIHtcbiAgICAgICAgICBsaWNlbnNlQ2hhbGxlbmdlID0gdGhpcy51bnBhY2tQbGF5UmVhZHlLZXlNZXNzYWdlKHhociwgbGljZW5zZUNoYWxsZW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgeGhyLnNlbmQobGljZW5zZUNoYWxsZW5nZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBvbk1lZGlhQXR0YWNoZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuY29uZmlnLmVtZUVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWVkaWEgPSBkYXRhLm1lZGlhO1xuXG4gICAgLy8ga2VlcCByZWZlcmVuY2Ugb2YgbWVkaWFcbiAgICB0aGlzLm1lZGlhID0gbWVkaWE7XG4gICAgbWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignZW5jcnlwdGVkJywgdGhpcy5vbk1lZGlhRW5jcnlwdGVkKTtcbiAgICBtZWRpYS5hZGRFdmVudExpc3RlbmVyKCd3YWl0aW5nZm9ya2V5JywgdGhpcy5vbldhaXRpbmdGb3JLZXkpO1xuICB9XG4gIG9uTWVkaWFEZXRhY2hlZCgpIHtcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgY29uc3QgbWVkaWFLZXlzTGlzdCA9IHRoaXMubWVkaWFLZXlTZXNzaW9ucztcbiAgICBpZiAobWVkaWEpIHtcbiAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuY3J5cHRlZCcsIHRoaXMub25NZWRpYUVuY3J5cHRlZCk7XG4gICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCd3YWl0aW5nZm9ya2V5JywgdGhpcy5vbldhaXRpbmdGb3JLZXkpO1xuICAgICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RMaWNlbnNlRmFpbHVyZUNvdW50ID0gMDtcbiAgICB0aGlzLnNldE1lZGlhS2V5c1F1ZXVlID0gW107XG4gICAgdGhpcy5tZWRpYUtleVNlc3Npb25zID0gW107XG4gICAgdGhpcy5rZXlJZFRvS2V5U2Vzc2lvblByb21pc2UgPSB7fTtcbiAgICBMZXZlbEtleS5jbGVhcktleVVyaVRvS2V5SWRNYXAoKTtcblxuICAgIC8vIENsb3NlIGFsbCBzZXNzaW9ucyBhbmQgcmVtb3ZlIG1lZGlhIGtleXMgZnJvbSB0aGUgdmlkZW8gZWxlbWVudC5cbiAgICBjb25zdCBrZXlTZXNzaW9uQ291bnQgPSBtZWRpYUtleXNMaXN0Lmxlbmd0aDtcbiAgICBFTUVDb250cm9sbGVyLkNETUNsZWFudXBQcm9taXNlID0gUHJvbWlzZS5hbGwobWVkaWFLZXlzTGlzdC5tYXAobWVkaWFLZXlTZXNzaW9uQ29udGV4dCA9PiB0aGlzLnJlbW92ZVNlc3Npb24obWVkaWFLZXlTZXNzaW9uQ29udGV4dCkpLmNvbmNhdChtZWRpYSA9PSBudWxsID8gdm9pZCAwIDogbWVkaWEuc2V0TWVkaWFLZXlzKG51bGwpLmNhdGNoKGVycm9yID0+IHtcbiAgICAgIHRoaXMubG9nKGBDb3VsZCBub3QgY2xlYXIgbWVkaWEga2V5czogJHtlcnJvcn1gKTtcbiAgICB9KSkpLnRoZW4oKCkgPT4ge1xuICAgICAgaWYgKGtleVNlc3Npb25Db3VudCkge1xuICAgICAgICB0aGlzLmxvZygnZmluaXNoZWQgY2xvc2luZyBrZXkgc2Vzc2lvbnMgYW5kIGNsZWFyaW5nIG1lZGlhIGtleXMnKTtcbiAgICAgICAgbWVkaWFLZXlzTGlzdC5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgIHRoaXMubG9nKGBDb3VsZCBub3QgY2xvc2Ugc2Vzc2lvbnMgYW5kIGNsZWFyIG1lZGlhIGtleXM6ICR7ZXJyb3J9YCk7XG4gICAgfSk7XG4gIH1cbiAgb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgdGhpcy5rZXlGb3JtYXRQcm9taXNlID0gbnVsbDtcbiAgfVxuICBvbk1hbmlmZXN0TG9hZGVkKGV2ZW50LCB7XG4gICAgc2Vzc2lvbktleXNcbiAgfSkge1xuICAgIGlmICghc2Vzc2lvbktleXMgfHwgIXRoaXMuY29uZmlnLmVtZUVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmtleUZvcm1hdFByb21pc2UpIHtcbiAgICAgIGNvbnN0IGtleUZvcm1hdHMgPSBzZXNzaW9uS2V5cy5yZWR1Y2UoKGZvcm1hdHMsIHNlc3Npb25LZXkpID0+IHtcbiAgICAgICAgaWYgKGZvcm1hdHMuaW5kZXhPZihzZXNzaW9uS2V5LmtleUZvcm1hdCkgPT09IC0xKSB7XG4gICAgICAgICAgZm9ybWF0cy5wdXNoKHNlc3Npb25LZXkua2V5Rm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0cztcbiAgICAgIH0sIFtdKTtcbiAgICAgIHRoaXMubG9nKGBTZWxlY3Rpbmcga2V5LXN5c3RlbSBmcm9tIHNlc3Npb24ta2V5cyAke2tleUZvcm1hdHMuam9pbignLCAnKX1gKTtcbiAgICAgIHRoaXMua2V5Rm9ybWF0UHJvbWlzZSA9IHRoaXMuZ2V0S2V5Rm9ybWF0UHJvbWlzZShrZXlGb3JtYXRzKTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlU2Vzc2lvbihtZWRpYUtleVNlc3Npb25Db250ZXh0KSB7XG4gICAgY29uc3Qge1xuICAgICAgbWVkaWFLZXlzU2Vzc2lvbixcbiAgICAgIGxpY2Vuc2VYaHJcbiAgICB9ID0gbWVkaWFLZXlTZXNzaW9uQ29udGV4dDtcbiAgICBpZiAobWVkaWFLZXlzU2Vzc2lvbikge1xuICAgICAgdGhpcy5sb2coYFJlbW92ZSBsaWNlbnNlcyBhbmQga2V5cyBhbmQgY2xvc2Ugc2Vzc2lvbiAke21lZGlhS2V5c1Nlc3Npb24uc2Vzc2lvbklkfWApO1xuICAgICAgaWYgKG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQuX29ubWVzc2FnZSkge1xuICAgICAgICBtZWRpYUtleXNTZXNzaW9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBtZWRpYUtleVNlc3Npb25Db250ZXh0Ll9vbm1lc3NhZ2UpO1xuICAgICAgICBtZWRpYUtleVNlc3Npb25Db250ZXh0Ll9vbm1lc3NhZ2UgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAobWVkaWFLZXlTZXNzaW9uQ29udGV4dC5fb25rZXlzdGF0dXNlc2NoYW5nZSkge1xuICAgICAgICBtZWRpYUtleXNTZXNzaW9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXN0YXR1c2VzY2hhbmdlJywgbWVkaWFLZXlTZXNzaW9uQ29udGV4dC5fb25rZXlzdGF0dXNlc2NoYW5nZSk7XG4gICAgICAgIG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQuX29ua2V5c3RhdHVzZXNjaGFuZ2UgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAobGljZW5zZVhociAmJiBsaWNlbnNlWGhyLnJlYWR5U3RhdGUgIT09IFhNTEh0dHBSZXF1ZXN0LkRPTkUpIHtcbiAgICAgICAgbGljZW5zZVhoci5hYm9ydCgpO1xuICAgICAgfVxuICAgICAgbWVkaWFLZXlTZXNzaW9uQ29udGV4dC5tZWRpYUtleXNTZXNzaW9uID0gbWVkaWFLZXlTZXNzaW9uQ29udGV4dC5kZWNyeXB0ZGF0YSA9IG1lZGlhS2V5U2Vzc2lvbkNvbnRleHQubGljZW5zZVhociA9IHVuZGVmaW5lZDtcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5tZWRpYUtleVNlc3Npb25zLmluZGV4T2YobWVkaWFLZXlTZXNzaW9uQ29udGV4dCk7XG4gICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICB0aGlzLm1lZGlhS2V5U2Vzc2lvbnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZWRpYUtleXNTZXNzaW9uLnJlbW92ZSgpLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgdGhpcy5sb2coYENvdWxkIG5vdCByZW1vdmUgc2Vzc2lvbjogJHtlcnJvcn1gKTtcbiAgICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICByZXR1cm4gbWVkaWFLZXlzU2Vzc2lvbi5jbG9zZSgpO1xuICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICB0aGlzLmxvZyhgQ291bGQgbm90IGNsb3NlIHNlc3Npb246ICR7ZXJyb3J9YCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbkVNRUNvbnRyb2xsZXIuQ0RNQ2xlYW51cFByb21pc2UgPSB2b2lkIDA7XG5jbGFzcyBFTUVLZXlFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoZGF0YSwgbWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuZGF0YSA9IHZvaWQgMDtcbiAgICBkYXRhLmVycm9yIHx8IChkYXRhLmVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpKTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIGRhdGEuZXJyID0gZGF0YS5lcnJvcjtcbiAgfVxufVxuXG4vKipcbiAqIENvbW1vbiBNZWRpYSBPYmplY3QgVHlwZVxuICpcbiAqIEBncm91cCBDTUNEXG4gKiBAZ3JvdXAgQ01TRFxuICpcbiAqIEBiZXRhXG4gKi9cbnZhciBDbU9iamVjdFR5cGU7XG4oZnVuY3Rpb24gKENtT2JqZWN0VHlwZSkge1xuICAvKipcbiAgICogdGV4dCBmaWxlLCBzdWNoIGFzIGEgbWFuaWZlc3Qgb3IgcGxheWxpc3RcbiAgICovXG4gIENtT2JqZWN0VHlwZVtcIk1BTklGRVNUXCJdID0gXCJtXCI7XG4gIC8qKlxuICAgKiBhdWRpbyBvbmx5XG4gICAqL1xuICBDbU9iamVjdFR5cGVbXCJBVURJT1wiXSA9IFwiYVwiO1xuICAvKipcbiAgICogdmlkZW8gb25seVxuICAgKi9cbiAgQ21PYmplY3RUeXBlW1wiVklERU9cIl0gPSBcInZcIjtcbiAgLyoqXG4gICAqIG11eGVkIGF1ZGlvIGFuZCB2aWRlb1xuICAgKi9cbiAgQ21PYmplY3RUeXBlW1wiTVVYRURcIl0gPSBcImF2XCI7XG4gIC8qKlxuICAgKiBpbml0IHNlZ21lbnRcbiAgICovXG4gIENtT2JqZWN0VHlwZVtcIklOSVRcIl0gPSBcImlcIjtcbiAgLyoqXG4gICAqIGNhcHRpb24gb3Igc3VidGl0bGVcbiAgICovXG4gIENtT2JqZWN0VHlwZVtcIkNBUFRJT05cIl0gPSBcImNcIjtcbiAgLyoqXG4gICAqIElTT0JNRkYgdGltZWQgdGV4dCB0cmFja1xuICAgKi9cbiAgQ21PYmplY3RUeXBlW1wiVElNRURfVEVYVFwiXSA9IFwidHRcIjtcbiAgLyoqXG4gICAqIGNyeXB0b2dyYXBoaWMga2V5LCBsaWNlbnNlIG9yIGNlcnRpZmljYXRlLlxuICAgKi9cbiAgQ21PYmplY3RUeXBlW1wiS0VZXCJdID0gXCJrXCI7XG4gIC8qKlxuICAgKiBvdGhlclxuICAgKi9cbiAgQ21PYmplY3RUeXBlW1wiT1RIRVJcIl0gPSBcIm9cIjtcbn0pKENtT2JqZWN0VHlwZSB8fCAoQ21PYmplY3RUeXBlID0ge30pKTtcblxuLyoqXG4gKiBDb21tb24gTWVkaWEgU3RyZWFtaW5nIEZvcm1hdFxuICpcbiAqIEBncm91cCBDTUNEXG4gKiBAZ3JvdXAgQ01TRFxuICpcbiAqIEBiZXRhXG4gKi9cbnZhciBDbVN0cmVhbWluZ0Zvcm1hdDtcbihmdW5jdGlvbiAoQ21TdHJlYW1pbmdGb3JtYXQpIHtcbiAgLyoqXG4gICAqIE1QRUcgREFTSFxuICAgKi9cbiAgQ21TdHJlYW1pbmdGb3JtYXRbXCJEQVNIXCJdID0gXCJkXCI7XG4gIC8qKlxuICAgKiBIVFRQIExpdmUgU3RyZWFtaW5nIChITFMpXG4gICAqL1xuICBDbVN0cmVhbWluZ0Zvcm1hdFtcIkhMU1wiXSA9IFwiaFwiO1xuICAvKipcbiAgICogU21vb3RoIFN0cmVhbWluZ1xuICAgKi9cbiAgQ21TdHJlYW1pbmdGb3JtYXRbXCJTTU9PVEhcIl0gPSBcInNcIjtcbiAgLyoqXG4gICAqIE90aGVyXG4gICAqL1xuICBDbVN0cmVhbWluZ0Zvcm1hdFtcIk9USEVSXCJdID0gXCJvXCI7XG59KShDbVN0cmVhbWluZ0Zvcm1hdCB8fCAoQ21TdHJlYW1pbmdGb3JtYXQgPSB7fSkpO1xuXG4vKipcbiAqIENNQ0QgaGVhZGVyIGZpZWxkcy5cbiAqXG4gKiBAZ3JvdXAgQ01DRFxuICpcbiAqIEBiZXRhXG4gKi9cbnZhciBDbWNkSGVhZGVyRmllbGQ7XG4oZnVuY3Rpb24gKENtY2RIZWFkZXJGaWVsZCkge1xuICAvKipcbiAgICoga2V5cyB3aG9zZSB2YWx1ZXMgdmFyeSB3aXRoIHRoZSBvYmplY3QgYmVpbmcgcmVxdWVzdGVkLlxuICAgKi9cbiAgQ21jZEhlYWRlckZpZWxkW1wiT0JKRUNUXCJdID0gXCJDTUNELU9iamVjdFwiO1xuICAvKipcbiAgICoga2V5cyB3aG9zZSB2YWx1ZXMgdmFyeSB3aXRoIGVhY2ggcmVxdWVzdC5cbiAgICovXG4gIENtY2RIZWFkZXJGaWVsZFtcIlJFUVVFU1RcIl0gPSBcIkNNQ0QtUmVxdWVzdFwiO1xuICAvKipcbiAgICoga2V5cyB3aG9zZSB2YWx1ZXMgYXJlIGV4cGVjdGVkIHRvIGJlIGludmFyaWFudCBvdmVyIHRoZSBsaWZlIG9mIHRoZSBzZXNzaW9uLlxuICAgKi9cbiAgQ21jZEhlYWRlckZpZWxkW1wiU0VTU0lPTlwiXSA9IFwiQ01DRC1TZXNzaW9uXCI7XG4gIC8qKlxuICAgKiBrZXlzIHdob3NlIHZhbHVlcyBkbyBub3QgdmFyeSB3aXRoIGV2ZXJ5IHJlcXVlc3Qgb3Igb2JqZWN0LlxuICAgKi9cbiAgQ21jZEhlYWRlckZpZWxkW1wiU1RBVFVTXCJdID0gXCJDTUNELVN0YXR1c1wiO1xufSkoQ21jZEhlYWRlckZpZWxkIHx8IChDbWNkSGVhZGVyRmllbGQgPSB7fSkpO1xuXG4vKipcbiAqIFRoZSBtYXAgb2YgQ01DRCBoZWFkZXIgZmllbGRzIHRvIG9mZmljaWFsIENNQ0Qga2V5cy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqXG4gKiBAZ3JvdXAgQ01DRFxuICovXG5jb25zdCBDbWNkSGVhZGVyTWFwID0ge1xuICBbQ21jZEhlYWRlckZpZWxkLk9CSkVDVF06IFsnYnInLCAnZCcsICdvdCcsICd0YiddLFxuICBbQ21jZEhlYWRlckZpZWxkLlJFUVVFU1RdOiBbJ2JsJywgJ2RsJywgJ210cCcsICdub3InLCAnbnJyJywgJ3N1J10sXG4gIFtDbWNkSGVhZGVyRmllbGQuU0VTU0lPTl06IFsnY2lkJywgJ3ByJywgJ3NmJywgJ3NpZCcsICdzdCcsICd2J10sXG4gIFtDbWNkSGVhZGVyRmllbGQuU1RBVFVTXTogWydicycsICdydHAnXVxufTtcblxuLyoqXG4gKiBTdHJ1Y3R1cmVkIEZpZWxkIEl0ZW1cbiAqXG4gKiBAZ3JvdXAgU3RydWN0dXJlZCBGaWVsZFxuICpcbiAqIEBiZXRhXG4gKi9cbmNsYXNzIFNmSXRlbSB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBwYXJhbXMpIHtcbiAgICB0aGlzLnZhbHVlID0gdm9pZCAwO1xuICAgIHRoaXMucGFyYW1zID0gdm9pZCAwO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5tYXAodiA9PiB2IGluc3RhbmNlb2YgU2ZJdGVtID8gdiA6IG5ldyBTZkl0ZW0odikpO1xuICAgIH1cbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gIH1cbn1cblxuLyoqXG4gKiBBIGNsYXNzIHRvIHJlcHJlc2VudCBzdHJ1Y3R1cmVkIGZpZWxkIHRva2VucyB3aGVuIGBTeW1ib2xgIGlzIG5vdCBhdmFpbGFibGUuXG4gKlxuICogQGdyb3VwIFN0cnVjdHVyZWQgRmllbGRcbiAqXG4gKiBAYmV0YVxuICovXG5jbGFzcyBTZlRva2VuIHtcbiAgY29uc3RydWN0b3IoZGVzY3JpcHRpb24pIHtcbiAgICB0aGlzLmRlc2NyaXB0aW9uID0gdm9pZCAwO1xuICAgIHRoaXMuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgfVxufVxuXG5jb25zdCBESUNUID0gJ0RpY3QnO1xuXG5mdW5jdGlvbiBmb3JtYXQodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgfVxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXApIHtcbiAgICByZXR1cm4gJ01hcHt9JztcbiAgfVxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICByZXR1cm4gJ1NldHt9JztcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG59XG5mdW5jdGlvbiB0aHJvd0Vycm9yKGFjdGlvbiwgc3JjLCB0eXBlLCBjYXVzZSkge1xuICByZXR1cm4gbmV3IEVycm9yKGBmYWlsZWQgdG8gJHthY3Rpb259IFwiJHtmb3JtYXQoc3JjKX1cIiBhcyAke3R5cGV9YCwge1xuICAgIGNhdXNlXG4gIH0pO1xufVxuXG5jb25zdCBCQVJFX0lURU0gPSAnQmFyZSBJdGVtJztcblxuY29uc3QgQk9PTEVBTiA9ICdCb29sZWFuJztcblxuY29uc3QgQllURVMgPSAnQnl0ZSBTZXF1ZW5jZSc7XG5cbmNvbnN0IERFQ0lNQUwgPSAnRGVjaW1hbCc7XG5cbmNvbnN0IElOVEVHRVIgPSAnSW50ZWdlcic7XG5cbmZ1bmN0aW9uIGlzSW52YWxpZEludCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPCAtOTk5OTk5OTk5OTk5OTk5IHx8IDk5OTk5OTk5OTk5OTk5OSA8IHZhbHVlO1xufVxuXG5jb25zdCBTVFJJTkdfUkVHRVggPSAvW1xceDAwLVxceDFmXFx4N2ZdKy87IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29udHJvbC1yZWdleFxuXG5jb25zdCBUT0tFTiA9ICdUb2tlbic7XG5cbmNvbnN0IEtFWSA9ICdLZXknO1xuXG5mdW5jdGlvbiBzZXJpYWxpemVFcnJvcihzcmMsIHR5cGUsIGNhdXNlKSB7XG4gIHJldHVybiB0aHJvd0Vycm9yKCdzZXJpYWxpemUnLCBzcmMsIHR5cGUsIGNhdXNlKTtcbn1cblxuLy8gNC4xLjkuICBTZXJpYWxpemluZyBhIEJvb2xlYW5cbi8vXG4vLyBHaXZlbiBhIEJvb2xlYW4gYXMgaW5wdXRfYm9vbGVhbiwgcmV0dXJuIGFuIEFTQ0lJIHN0cmluZyBzdWl0YWJsZSBmb3Jcbi8vIHVzZSBpbiBhIEhUVFAgZmllbGQgdmFsdWUuXG4vL1xuLy8gMS4gIElmIGlucHV0X2Jvb2xlYW4gaXMgbm90IGEgYm9vbGVhbiwgZmFpbCBzZXJpYWxpemF0aW9uLlxuLy9cbi8vIDIuICBMZXQgb3V0cHV0IGJlIGFuIGVtcHR5IHN0cmluZy5cbi8vXG4vLyAzLiAgQXBwZW5kIFwiP1wiIHRvIG91dHB1dC5cbi8vXG4vLyA0LiAgSWYgaW5wdXRfYm9vbGVhbiBpcyB0cnVlLCBhcHBlbmQgXCIxXCIgdG8gb3V0cHV0LlxuLy9cbi8vIDUuICBJZiBpbnB1dF9ib29sZWFuIGlzIGZhbHNlLCBhcHBlbmQgXCIwXCIgdG8gb3V0cHV0LlxuLy9cbi8vIDYuICBSZXR1cm4gb3V0cHV0LlxuZnVuY3Rpb24gc2VyaWFsaXplQm9vbGVhbih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicpIHtcbiAgICB0aHJvdyBzZXJpYWxpemVFcnJvcih2YWx1ZSwgQk9PTEVBTik7XG4gIH1cbiAgcmV0dXJuIHZhbHVlID8gJz8xJyA6ICc/MCc7XG59XG5cbi8qKlxuICogRW5jb2RlcyBiaW5hcnkgZGF0YSB0byBiYXNlNjRcbiAqXG4gKiBAcGFyYW0gYmluYXJ5IC0gVGhlIGJpbmFyeSBkYXRhIHRvIGVuY29kZVxuICogQHJldHVybnMgVGhlIGJhc2U2NCBlbmNvZGVkIHN0cmluZ1xuICpcbiAqIEBncm91cCBVdGlsc1xuICpcbiAqIEBiZXRhXG4gKi9cbmZ1bmN0aW9uIGJhc2U2NGVuY29kZShiaW5hcnkpIHtcbiAgcmV0dXJuIGJ0b2EoU3RyaW5nLmZyb21DaGFyQ29kZSguLi5iaW5hcnkpKTtcbn1cblxuLy8gNC4xLjguICBTZXJpYWxpemluZyBhIEJ5dGUgU2VxdWVuY2Vcbi8vXG4vLyBHaXZlbiBhIEJ5dGUgU2VxdWVuY2UgYXMgaW5wdXRfYnl0ZXMsIHJldHVybiBhbiBBU0NJSSBzdHJpbmcgc3VpdGFibGVcbi8vIGZvciB1c2UgaW4gYSBIVFRQIGZpZWxkIHZhbHVlLlxuLy9cbi8vIDEuICBJZiBpbnB1dF9ieXRlcyBpcyBub3QgYSBzZXF1ZW5jZSBvZiBieXRlcywgZmFpbCBzZXJpYWxpemF0aW9uLlxuLy9cbi8vIDIuICBMZXQgb3V0cHV0IGJlIGFuIGVtcHR5IHN0cmluZy5cbi8vXG4vLyAzLiAgQXBwZW5kIFwiOlwiIHRvIG91dHB1dC5cbi8vXG4vLyA0LiAgQXBwZW5kIHRoZSByZXN1bHQgb2YgYmFzZTY0LWVuY29kaW5nIGlucHV0X2J5dGVzIGFzIHBlclxuLy8gICAgIFtSRkM0NjQ4XSwgU2VjdGlvbiA0LCB0YWtpbmcgYWNjb3VudCBvZiB0aGUgcmVxdWlyZW1lbnRzIGJlbG93LlxuLy9cbi8vIDUuICBBcHBlbmQgXCI6XCIgdG8gb3V0cHV0LlxuLy9cbi8vIDYuICBSZXR1cm4gb3V0cHV0LlxuLy9cbi8vIFRoZSBlbmNvZGVkIGRhdGEgaXMgcmVxdWlyZWQgdG8gYmUgcGFkZGVkIHdpdGggXCI9XCIsIGFzIHBlciBbUkZDNDY0OF0sXG4vLyBTZWN0aW9uIDMuMi5cbi8vXG4vLyBMaWtld2lzZSwgZW5jb2RlZCBkYXRhIFNIT1VMRCBoYXZlIHBhZCBiaXRzIHNldCB0byB6ZXJvLCBhcyBwZXJcbi8vIFtSRkM0NjQ4XSwgU2VjdGlvbiAzLjUsIHVubGVzcyBpdCBpcyBub3QgcG9zc2libGUgdG8gZG8gc28gZHVlIHRvXG4vLyBpbXBsZW1lbnRhdGlvbiBjb25zdHJhaW50cy5cbmZ1bmN0aW9uIHNlcmlhbGl6ZUJ5dGVTZXF1ZW5jZSh2YWx1ZSkge1xuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBzZXJpYWxpemVFcnJvcih2YWx1ZSwgQllURVMpO1xuICB9XG4gIHJldHVybiBgOiR7YmFzZTY0ZW5jb2RlKHZhbHVlKX06YDtcbn1cblxuLy8gNC4xLjQuICBTZXJpYWxpemluZyBhbiBJbnRlZ2VyXG4vL1xuLy8gR2l2ZW4gYW4gSW50ZWdlciBhcyBpbnB1dF9pbnRlZ2VyLCByZXR1cm4gYW4gQVNDSUkgc3RyaW5nIHN1aXRhYmxlXG4vLyBmb3IgdXNlIGluIGEgSFRUUCBmaWVsZCB2YWx1ZS5cbi8vXG4vLyAxLiAgSWYgaW5wdXRfaW50ZWdlciBpcyBub3QgYW4gaW50ZWdlciBpbiB0aGUgcmFuZ2Ugb2Zcbi8vICAgICAtOTk5LDk5OSw5OTksOTk5LDk5OSB0byA5OTksOTk5LDk5OSw5OTksOTk5IGluY2x1c2l2ZSwgZmFpbFxuLy8gICAgIHNlcmlhbGl6YXRpb24uXG4vL1xuLy8gMi4gIExldCBvdXRwdXQgYmUgYW4gZW1wdHkgc3RyaW5nLlxuLy9cbi8vIDMuICBJZiBpbnB1dF9pbnRlZ2VyIGlzIGxlc3MgdGhhbiAoYnV0IG5vdCBlcXVhbCB0bykgMCwgYXBwZW5kIFwiLVwiIHRvXG4vLyAgICAgb3V0cHV0LlxuLy9cbi8vIDQuICBBcHBlbmQgaW5wdXRfaW50ZWdlcidzIG51bWVyaWMgdmFsdWUgcmVwcmVzZW50ZWQgaW4gYmFzZSAxMCB1c2luZ1xuLy8gICAgIG9ubHkgZGVjaW1hbCBkaWdpdHMgdG8gb3V0cHV0LlxuLy9cbi8vIDUuICBSZXR1cm4gb3V0cHV0LlxuZnVuY3Rpb24gc2VyaWFsaXplSW50ZWdlcih2YWx1ZSkge1xuICBpZiAoaXNJbnZhbGlkSW50KHZhbHVlKSkge1xuICAgIHRocm93IHNlcmlhbGl6ZUVycm9yKHZhbHVlLCBJTlRFR0VSKTtcbiAgfVxuICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbn1cblxuLy8gNC4xLjEwLiAgU2VyaWFsaXppbmcgYSBEYXRlXG4vL1xuLy8gR2l2ZW4gYSBEYXRlIGFzIGlucHV0X2ludGVnZXIsIHJldHVybiBhbiBBU0NJSSBzdHJpbmcgc3VpdGFibGUgZm9yXG4vLyB1c2UgaW4gYW4gSFRUUCBmaWVsZCB2YWx1ZS5cbi8vIDEuICBMZXQgb3V0cHV0IGJlIFwiQFwiLlxuLy8gMi4gIEFwcGVuZCB0byBvdXRwdXQgdGhlIHJlc3VsdCBvZiBydW5uaW5nIFNlcmlhbGl6aW5nIGFuIEludGVnZXJcbi8vICAgICB3aXRoIGlucHV0X2RhdGUgKFNlY3Rpb24gNC4xLjQpLlxuLy8gMy4gIFJldHVybiBvdXRwdXQuXG5mdW5jdGlvbiBzZXJpYWxpemVEYXRlKHZhbHVlKSB7XG4gIHJldHVybiBgQCR7c2VyaWFsaXplSW50ZWdlcih2YWx1ZS5nZXRUaW1lKCkgLyAxMDAwKX1gO1xufVxuXG4vKipcbiAqIFRoaXMgaW1wbGVtZW50cyB0aGUgcm91bmRpbmcgcHJvY2VkdXJlIGRlc2NyaWJlZCBpbiBzdGVwIDIgb2YgdGhlIFwiU2VyaWFsaXppbmcgYSBEZWNpbWFsXCIgc3BlY2lmaWNhdGlvbi5cbiAqIFRoaXMgcm91bmRpbmcgc3R5bGUgaXMga25vd24gYXMgXCJldmVuIHJvdW5kaW5nXCIsIFwiYmFua2VyJ3Mgcm91bmRpbmdcIiwgb3IgXCJjb21tZXJjaWFsIHJvdW5kaW5nXCIuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHJvdW5kXG4gKiBAcGFyYW0gcHJlY2lzaW9uIC0gVGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0byByb3VuZCB0b1xuICogQHJldHVybnMgVGhlIHJvdW5kZWQgdmFsdWVcbiAqXG4gKiBAZ3JvdXAgVXRpbHNcbiAqXG4gKiBAYmV0YVxuICovXG5mdW5jdGlvbiByb3VuZFRvRXZlbih2YWx1ZSwgcHJlY2lzaW9uKSB7XG4gIGlmICh2YWx1ZSA8IDApIHtcbiAgICByZXR1cm4gLXJvdW5kVG9FdmVuKC12YWx1ZSwgcHJlY2lzaW9uKTtcbiAgfVxuICBjb25zdCBkZWNpbWFsU2hpZnQgPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uKTtcbiAgY29uc3QgaXNFcXVpZGlzdGFudCA9IE1hdGguYWJzKHZhbHVlICogZGVjaW1hbFNoaWZ0ICUgMSAtIDAuNSkgPCBOdW1iZXIuRVBTSUxPTjtcbiAgaWYgKGlzRXF1aWRpc3RhbnQpIHtcbiAgICAvLyBJZiB0aGUgdGFpbCBvZiB0aGUgZGVjaW1hbCBwbGFjZSBpcyAnZXF1aWRpc3RhbnQnIHdlIHJvdW5kIHRvIHRoZSBuZWFyZXN0IGV2ZW4gdmFsdWVcbiAgICBjb25zdCBmbG9vcmVkVmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlICogZGVjaW1hbFNoaWZ0KTtcbiAgICByZXR1cm4gKGZsb29yZWRWYWx1ZSAlIDIgPT09IDAgPyBmbG9vcmVkVmFsdWUgOiBmbG9vcmVkVmFsdWUgKyAxKSAvIGRlY2ltYWxTaGlmdDtcbiAgfSBlbHNlIHtcbiAgICAvLyBPdGhlcndpc2UsIHByb2NlZWQgYXMgbm9ybWFsXG4gICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiBkZWNpbWFsU2hpZnQpIC8gZGVjaW1hbFNoaWZ0O1xuICB9XG59XG5cbi8vIDQuMS41LiAgU2VyaWFsaXppbmcgYSBEZWNpbWFsXG4vL1xuLy8gR2l2ZW4gYSBkZWNpbWFsIG51bWJlciBhcyBpbnB1dF9kZWNpbWFsLCByZXR1cm4gYW4gQVNDSUkgc3RyaW5nXG4vLyBzdWl0YWJsZSBmb3IgdXNlIGluIGEgSFRUUCBmaWVsZCB2YWx1ZS5cbi8vXG4vLyAxLiAgIElmIGlucHV0X2RlY2ltYWwgaXMgbm90IGEgZGVjaW1hbCBudW1iZXIsIGZhaWwgc2VyaWFsaXphdGlvbi5cbi8vXG4vLyAyLiAgIElmIGlucHV0X2RlY2ltYWwgaGFzIG1vcmUgdGhhbiB0aHJlZSBzaWduaWZpY2FudCBkaWdpdHMgdG8gdGhlXG4vLyAgICAgIHJpZ2h0IG9mIHRoZSBkZWNpbWFsIHBvaW50LCByb3VuZCBpdCB0byB0aHJlZSBkZWNpbWFsIHBsYWNlcyxcbi8vICAgICAgcm91bmRpbmcgdGhlIGZpbmFsIGRpZ2l0IHRvIHRoZSBuZWFyZXN0IHZhbHVlLCBvciB0byB0aGUgZXZlblxuLy8gICAgICB2YWx1ZSBpZiBpdCBpcyBlcXVpZGlzdGFudC5cbi8vXG4vLyAzLiAgIElmIGlucHV0X2RlY2ltYWwgaGFzIG1vcmUgdGhhbiAxMiBzaWduaWZpY2FudCBkaWdpdHMgdG8gdGhlIGxlZnRcbi8vICAgICAgb2YgdGhlIGRlY2ltYWwgcG9pbnQgYWZ0ZXIgcm91bmRpbmcsIGZhaWwgc2VyaWFsaXphdGlvbi5cbi8vXG4vLyA0LiAgIExldCBvdXRwdXQgYmUgYW4gZW1wdHkgc3RyaW5nLlxuLy9cbi8vIDUuICAgSWYgaW5wdXRfZGVjaW1hbCBpcyBsZXNzIHRoYW4gKGJ1dCBub3QgZXF1YWwgdG8pIDAsIGFwcGVuZCBcIi1cIlxuLy8gICAgICB0byBvdXRwdXQuXG4vL1xuLy8gNi4gICBBcHBlbmQgaW5wdXRfZGVjaW1hbCdzIGludGVnZXIgY29tcG9uZW50IHJlcHJlc2VudGVkIGluIGJhc2UgMTBcbi8vICAgICAgKHVzaW5nIG9ubHkgZGVjaW1hbCBkaWdpdHMpIHRvIG91dHB1dDsgaWYgaXQgaXMgemVybywgYXBwZW5kXG4vLyAgICAgIFwiMFwiLlxuLy9cbi8vIDcuICAgQXBwZW5kIFwiLlwiIHRvIG91dHB1dC5cbi8vXG4vLyA4LiAgIElmIGlucHV0X2RlY2ltYWwncyBmcmFjdGlvbmFsIGNvbXBvbmVudCBpcyB6ZXJvLCBhcHBlbmQgXCIwXCIgdG9cbi8vICAgICAgb3V0cHV0LlxuLy9cbi8vIDkuICAgT3RoZXJ3aXNlLCBhcHBlbmQgdGhlIHNpZ25pZmljYW50IGRpZ2l0cyBvZiBpbnB1dF9kZWNpbWFsJ3Ncbi8vICAgICAgZnJhY3Rpb25hbCBjb21wb25lbnQgcmVwcmVzZW50ZWQgaW4gYmFzZSAxMCAodXNpbmcgb25seSBkZWNpbWFsXG4vLyAgICAgIGRpZ2l0cykgdG8gb3V0cHV0LlxuLy9cbi8vIDEwLiAgUmV0dXJuIG91dHB1dC5cbmZ1bmN0aW9uIHNlcmlhbGl6ZURlY2ltYWwodmFsdWUpIHtcbiAgY29uc3Qgcm91bmRlZFZhbHVlID0gcm91bmRUb0V2ZW4odmFsdWUsIDMpOyAvLyByb3VuZCB0byAzIGRlY2ltYWwgcGxhY2VzXG4gIGlmIChNYXRoLmZsb29yKE1hdGguYWJzKHJvdW5kZWRWYWx1ZSkpLnRvU3RyaW5nKCkubGVuZ3RoID4gMTIpIHtcbiAgICB0aHJvdyBzZXJpYWxpemVFcnJvcih2YWx1ZSwgREVDSU1BTCk7XG4gIH1cbiAgY29uc3Qgc3RyaW5nVmFsdWUgPSByb3VuZGVkVmFsdWUudG9TdHJpbmcoKTtcbiAgcmV0dXJuIHN0cmluZ1ZhbHVlLmluY2x1ZGVzKCcuJykgPyBzdHJpbmdWYWx1ZSA6IGAke3N0cmluZ1ZhbHVlfS4wYDtcbn1cblxuY29uc3QgU1RSSU5HID0gJ1N0cmluZyc7XG5cbi8vIDQuMS42LiAgU2VyaWFsaXppbmcgYSBTdHJpbmdcbi8vXG4vLyBHaXZlbiBhIFN0cmluZyBhcyBpbnB1dF9zdHJpbmcsIHJldHVybiBhbiBBU0NJSSBzdHJpbmcgc3VpdGFibGUgZm9yXG4vLyB1c2UgaW4gYSBIVFRQIGZpZWxkIHZhbHVlLlxuLy9cbi8vIDEuICBDb252ZXJ0IGlucHV0X3N0cmluZyBpbnRvIGEgc2VxdWVuY2Ugb2YgQVNDSUkgY2hhcmFjdGVyczsgaWZcbi8vICAgICBjb252ZXJzaW9uIGZhaWxzLCBmYWlsIHNlcmlhbGl6YXRpb24uXG4vL1xuLy8gMi4gIElmIGlucHV0X3N0cmluZyBjb250YWlucyBjaGFyYWN0ZXJzIGluIHRoZSByYW5nZSAleDAwLTFmIG9yICV4N2Zcbi8vICAgICAoaS5lLiwgbm90IGluIFZDSEFSIG9yIFNQKSwgZmFpbCBzZXJpYWxpemF0aW9uLlxuLy9cbi8vIDMuICBMZXQgb3V0cHV0IGJlIHRoZSBzdHJpbmcgRFFVT1RFLlxuLy9cbi8vIDQuICBGb3IgZWFjaCBjaGFyYWN0ZXIgY2hhciBpbiBpbnB1dF9zdHJpbmc6XG4vL1xuLy8gICAgIDEuICBJZiBjaGFyIGlzIFwiXFxcIiBvciBEUVVPVEU6XG4vL1xuLy8gICAgICAgICAxLiAgQXBwZW5kIFwiXFxcIiB0byBvdXRwdXQuXG4vL1xuLy8gICAgIDIuICBBcHBlbmQgY2hhciB0byBvdXRwdXQuXG4vL1xuLy8gNS4gIEFwcGVuZCBEUVVPVEUgdG8gb3V0cHV0LlxuLy9cbi8vIDYuICBSZXR1cm4gb3V0cHV0LlxuZnVuY3Rpb24gc2VyaWFsaXplU3RyaW5nKHZhbHVlKSB7XG4gIGlmIChTVFJJTkdfUkVHRVgudGVzdCh2YWx1ZSkpIHtcbiAgICB0aHJvdyBzZXJpYWxpemVFcnJvcih2YWx1ZSwgU1RSSU5HKTtcbiAgfVxuICByZXR1cm4gYFwiJHt2YWx1ZS5yZXBsYWNlKC9cXFxcL2csIGBcXFxcXFxcXGApLnJlcGxhY2UoL1wiL2csIGBcXFxcXCJgKX1cImA7XG59XG5cbmZ1bmN0aW9uIHN5bWJvbFRvU3RyKHN5bWJvbCkge1xuICByZXR1cm4gc3ltYm9sLmRlc2NyaXB0aW9uIHx8IHN5bWJvbC50b1N0cmluZygpLnNsaWNlKDcsIC0xKTtcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplVG9rZW4odG9rZW4pIHtcbiAgY29uc3QgdmFsdWUgPSBzeW1ib2xUb1N0cih0b2tlbik7XG4gIGlmICgvXihbYS16QS1aKl0pKFshIyQlJicqK1xcLS5eX2B8flxcdzovXSopJC8udGVzdCh2YWx1ZSkgPT09IGZhbHNlKSB7XG4gICAgdGhyb3cgc2VyaWFsaXplRXJyb3IodmFsdWUsIFRPS0VOKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8vIDQuMS4zLjEuICBTZXJpYWxpemluZyBhIEJhcmUgSXRlbVxuLy9cbi8vIEdpdmVuIGFuIEl0ZW0gYXMgaW5wdXRfaXRlbSwgcmV0dXJuIGFuIEFTQ0lJIHN0cmluZyBzdWl0YWJsZSBmb3IgdXNlXG4vLyBpbiBhIEhUVFAgZmllbGQgdmFsdWUuXG4vL1xuLy8gMS4gIElmIGlucHV0X2l0ZW0gaXMgYW4gSW50ZWdlciwgcmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZ1xuLy8gICAgIFNlcmlhbGl6aW5nIGFuIEludGVnZXIgKFNlY3Rpb24gNC4xLjQpIHdpdGggaW5wdXRfaXRlbS5cbi8vXG4vLyAyLiAgSWYgaW5wdXRfaXRlbSBpcyBhIERlY2ltYWwsIHJldHVybiB0aGUgcmVzdWx0IG9mIHJ1bm5pbmdcbi8vICAgICBTZXJpYWxpemluZyBhIERlY2ltYWwgKFNlY3Rpb24gNC4xLjUpIHdpdGggaW5wdXRfaXRlbS5cbi8vXG4vLyAzLiAgSWYgaW5wdXRfaXRlbSBpcyBhIFN0cmluZywgcmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZ1xuLy8gICAgIFNlcmlhbGl6aW5nIGEgU3RyaW5nIChTZWN0aW9uIDQuMS42KSB3aXRoIGlucHV0X2l0ZW0uXG4vL1xuLy8gNC4gIElmIGlucHV0X2l0ZW0gaXMgYSBUb2tlbiwgcmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZ1xuLy8gICAgIFNlcmlhbGl6aW5nIGEgVG9rZW4gKFNlY3Rpb24gNC4xLjcpIHdpdGggaW5wdXRfaXRlbS5cbi8vXG4vLyA1LiAgSWYgaW5wdXRfaXRlbSBpcyBhIEJvb2xlYW4sIHJldHVybiB0aGUgcmVzdWx0IG9mIHJ1bm5pbmdcbi8vICAgICBTZXJpYWxpemluZyBhIEJvb2xlYW4gKFNlY3Rpb24gNC4xLjkpIHdpdGggaW5wdXRfaXRlbS5cbi8vXG4vLyA2LiAgSWYgaW5wdXRfaXRlbSBpcyBhIEJ5dGUgU2VxdWVuY2UsIHJldHVybiB0aGUgcmVzdWx0IG9mIHJ1bm5pbmdcbi8vICAgICBTZXJpYWxpemluZyBhIEJ5dGUgU2VxdWVuY2UgKFNlY3Rpb24gNC4xLjgpIHdpdGggaW5wdXRfaXRlbS5cbi8vXG4vLyA3LiAgSWYgaW5wdXRfaXRlbSBpcyBhIERhdGUsIHJldHVybiB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgU2VyaWFsaXppbmdcbi8vICAgICBhIERhdGUgKFNlY3Rpb24gNC4xLjEwKSB3aXRoIGlucHV0X2l0ZW0uXG4vL1xuLy8gOC4gIE90aGVyd2lzZSwgZmFpbCBzZXJpYWxpemF0aW9uLlxuZnVuY3Rpb24gc2VyaWFsaXplQmFyZUl0ZW0odmFsdWUpIHtcbiAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgaWYgKCFpc0Zpbml0ZU51bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgc2VyaWFsaXplRXJyb3IodmFsdWUsIEJBUkVfSVRFTSk7XG4gICAgICB9XG4gICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZUludGVnZXIodmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlcmlhbGl6ZURlY2ltYWwodmFsdWUpO1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gc2VyaWFsaXplU3RyaW5nKHZhbHVlKTtcbiAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgcmV0dXJuIHNlcmlhbGl6ZVRva2VuKHZhbHVlKTtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiBzZXJpYWxpemVCb29sZWFuKHZhbHVlKTtcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplRGF0ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVCeXRlU2VxdWVuY2UodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU2ZUb2tlbikge1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplVG9rZW4odmFsdWUpO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBmYWlsXG4gICAgICB0aHJvdyBzZXJpYWxpemVFcnJvcih2YWx1ZSwgQkFSRV9JVEVNKTtcbiAgfVxufVxuXG4vLyA0LjEuMS4zLiAgU2VyaWFsaXppbmcgYSBLZXlcbi8vXG4vLyBHaXZlbiBhIGtleSBhcyBpbnB1dF9rZXksIHJldHVybiBhbiBBU0NJSSBzdHJpbmcgc3VpdGFibGUgZm9yIHVzZSBpblxuLy8gYSBIVFRQIGZpZWxkIHZhbHVlLlxuLy9cbi8vIDEuICBDb252ZXJ0IGlucHV0X2tleSBpbnRvIGEgc2VxdWVuY2Ugb2YgQVNDSUkgY2hhcmFjdGVyczsgaWZcbi8vICAgICBjb252ZXJzaW9uIGZhaWxzLCBmYWlsIHNlcmlhbGl6YXRpb24uXG4vL1xuLy8gMi4gIElmIGlucHV0X2tleSBjb250YWlucyBjaGFyYWN0ZXJzIG5vdCBpbiBsY2FscGhhLCBESUdJVCwgXCJfXCIsIFwiLVwiLFxuLy8gICAgIFwiLlwiLCBvciBcIipcIiBmYWlsIHNlcmlhbGl6YXRpb24uXG4vL1xuLy8gMy4gIElmIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgaW5wdXRfa2V5IGlzIG5vdCBsY2FscGhhIG9yIFwiKlwiLCBmYWlsXG4vLyAgICAgc2VyaWFsaXphdGlvbi5cbi8vXG4vLyA0LiAgTGV0IG91dHB1dCBiZSBhbiBlbXB0eSBzdHJpbmcuXG4vL1xuLy8gNS4gIEFwcGVuZCBpbnB1dF9rZXkgdG8gb3V0cHV0LlxuLy9cbi8vIDYuICBSZXR1cm4gb3V0cHV0LlxuZnVuY3Rpb24gc2VyaWFsaXplS2V5KHZhbHVlKSB7XG4gIGlmICgvXlthLXoqXVthLXowLTlcXC1fLipdKiQvLnRlc3QodmFsdWUpID09PSBmYWxzZSkge1xuICAgIHRocm93IHNlcmlhbGl6ZUVycm9yKHZhbHVlLCBLRVkpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLy8gNC4xLjEuMi4gIFNlcmlhbGl6aW5nIFBhcmFtZXRlcnNcbi8vXG4vLyBHaXZlbiBhbiBvcmRlcmVkIERpY3Rpb25hcnkgYXMgaW5wdXRfcGFyYW1ldGVycyAoZWFjaCBtZW1iZXIgaGF2aW5nIGFcbi8vIHBhcmFtX25hbWUgYW5kIGEgcGFyYW1fdmFsdWUpLCByZXR1cm4gYW4gQVNDSUkgc3RyaW5nIHN1aXRhYmxlIGZvclxuLy8gdXNlIGluIGEgSFRUUCBmaWVsZCB2YWx1ZS5cbi8vXG4vLyAxLiAgTGV0IG91dHB1dCBiZSBhbiBlbXB0eSBzdHJpbmcuXG4vL1xuLy8gMi4gIEZvciBlYWNoIHBhcmFtX25hbWUgd2l0aCBhIHZhbHVlIG9mIHBhcmFtX3ZhbHVlIGluXG4vLyAgICAgaW5wdXRfcGFyYW1ldGVyczpcbi8vXG4vLyAgICAgMS4gIEFwcGVuZCBcIjtcIiB0byBvdXRwdXQuXG4vL1xuLy8gICAgIDIuICBBcHBlbmQgdGhlIHJlc3VsdCBvZiBydW5uaW5nIFNlcmlhbGl6aW5nIGEgS2V5XG4vLyAgICAgICAgIChTZWN0aW9uIDQuMS4xLjMpIHdpdGggcGFyYW1fbmFtZSB0byBvdXRwdXQuXG4vL1xuLy8gICAgIDMuICBJZiBwYXJhbV92YWx1ZSBpcyBub3QgQm9vbGVhbiB0cnVlOlxuLy9cbi8vICAgICAgICAgMS4gIEFwcGVuZCBcIj1cIiB0byBvdXRwdXQuXG4vL1xuLy8gICAgICAgICAyLiAgQXBwZW5kIHRoZSByZXN1bHQgb2YgcnVubmluZyBTZXJpYWxpemluZyBhIGJhcmUgSXRlbVxuLy8gICAgICAgICAgICAgKFNlY3Rpb24gNC4xLjMuMSkgd2l0aCBwYXJhbV92YWx1ZSB0byBvdXRwdXQuXG4vL1xuLy8gMy4gIFJldHVybiBvdXRwdXQuXG5mdW5jdGlvbiBzZXJpYWxpemVQYXJhbXMocGFyYW1zKSB7XG4gIGlmIChwYXJhbXMgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICByZXR1cm4gT2JqZWN0LmVudHJpZXMocGFyYW1zKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIGA7JHtzZXJpYWxpemVLZXkoa2V5KX1gOyAvLyBvbWl0IHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGA7JHtzZXJpYWxpemVLZXkoa2V5KX09JHtzZXJpYWxpemVCYXJlSXRlbSh2YWx1ZSl9YDtcbiAgfSkuam9pbignJyk7XG59XG5cbi8vIDQuMS4zLiAgU2VyaWFsaXppbmcgYW4gSXRlbVxuLy9cbi8vIEdpdmVuIGFuIEl0ZW0gYXMgYmFyZV9pdGVtIGFuZCBQYXJhbWV0ZXJzIGFzIGl0ZW1fcGFyYW1ldGVycywgcmV0dXJuXG4vLyBhbiBBU0NJSSBzdHJpbmcgc3VpdGFibGUgZm9yIHVzZSBpbiBhIEhUVFAgZmllbGQgdmFsdWUuXG4vL1xuLy8gMS4gIExldCBvdXRwdXQgYmUgYW4gZW1wdHkgc3RyaW5nLlxuLy9cbi8vIDIuICBBcHBlbmQgdGhlIHJlc3VsdCBvZiBydW5uaW5nIFNlcmlhbGl6aW5nIGEgQmFyZSBJdGVtXG4vLyAgICAgU2VjdGlvbiA0LjEuMy4xIHdpdGggYmFyZV9pdGVtIHRvIG91dHB1dC5cbi8vXG4vLyAzLiAgQXBwZW5kIHRoZSByZXN1bHQgb2YgcnVubmluZyBTZXJpYWxpemluZyBQYXJhbWV0ZXJzXG4vLyAgICAgU2VjdGlvbiA0LjEuMS4yIHdpdGggaXRlbV9wYXJhbWV0ZXJzIHRvIG91dHB1dC5cbi8vXG4vLyA0LiAgUmV0dXJuIG91dHB1dC5cbmZ1bmN0aW9uIHNlcmlhbGl6ZUl0ZW0odmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU2ZJdGVtKSB7XG4gICAgcmV0dXJuIGAke3NlcmlhbGl6ZUJhcmVJdGVtKHZhbHVlLnZhbHVlKX0ke3NlcmlhbGl6ZVBhcmFtcyh2YWx1ZS5wYXJhbXMpfWA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZUJhcmVJdGVtKHZhbHVlKTtcbiAgfVxufVxuXG4vLyA0LjEuMS4xLiAgU2VyaWFsaXppbmcgYW4gSW5uZXIgTGlzdFxuLy9cbi8vIEdpdmVuIGFuIGFycmF5IG9mIChtZW1iZXJfdmFsdWUsIHBhcmFtZXRlcnMpIHR1cGxlcyBhcyBpbm5lcl9saXN0LFxuLy8gYW5kIHBhcmFtZXRlcnMgYXMgbGlzdF9wYXJhbWV0ZXJzLCByZXR1cm4gYW4gQVNDSUkgc3RyaW5nIHN1aXRhYmxlXG4vLyBmb3IgdXNlIGluIGEgSFRUUCBmaWVsZCB2YWx1ZS5cbi8vXG4vLyAxLiAgTGV0IG91dHB1dCBiZSB0aGUgc3RyaW5nIFwiKFwiLlxuLy9cbi8vIDIuICBGb3IgZWFjaCAobWVtYmVyX3ZhbHVlLCBwYXJhbWV0ZXJzKSBvZiBpbm5lcl9saXN0OlxuLy9cbi8vICAgICAxLiAgQXBwZW5kIHRoZSByZXN1bHQgb2YgcnVubmluZyBTZXJpYWxpemluZyBhbiBJdGVtXG4vLyAgICAgICAgIChTZWN0aW9uIDQuMS4zKSB3aXRoIChtZW1iZXJfdmFsdWUsIHBhcmFtZXRlcnMpIHRvIG91dHB1dC5cbi8vXG4vLyAgICAgMi4gIElmIG1vcmUgdmFsdWVzIHJlbWFpbiBpbiBpbm5lcl9saXN0LCBhcHBlbmQgYSBzaW5nbGUgU1AgdG9cbi8vICAgICAgICAgb3V0cHV0LlxuLy9cbi8vIDMuICBBcHBlbmQgXCIpXCIgdG8gb3V0cHV0LlxuLy9cbi8vIDQuICBBcHBlbmQgdGhlIHJlc3VsdCBvZiBydW5uaW5nIFNlcmlhbGl6aW5nIFBhcmFtZXRlcnNcbi8vICAgICAoU2VjdGlvbiA0LjEuMS4yKSB3aXRoIGxpc3RfcGFyYW1ldGVycyB0byBvdXRwdXQuXG4vL1xuLy8gNS4gIFJldHVybiBvdXRwdXQuXG5mdW5jdGlvbiBzZXJpYWxpemVJbm5lckxpc3QodmFsdWUpIHtcbiAgcmV0dXJuIGAoJHt2YWx1ZS52YWx1ZS5tYXAoc2VyaWFsaXplSXRlbSkuam9pbignICcpfSkke3NlcmlhbGl6ZVBhcmFtcyh2YWx1ZS5wYXJhbXMpfWA7XG59XG5cbi8vIDQuMS4yLiAgU2VyaWFsaXppbmcgYSBEaWN0aW9uYXJ5XG4vL1xuLy8gR2l2ZW4gYW4gb3JkZXJlZCBEaWN0aW9uYXJ5IGFzIGlucHV0X2RpY3Rpb25hcnkgKGVhY2ggbWVtYmVyIGhhdmluZyBhXG4vLyBtZW1iZXJfbmFtZSBhbmQgYSB0dXBsZSB2YWx1ZSBvZiAobWVtYmVyX3ZhbHVlLCBwYXJhbWV0ZXJzKSksIHJldHVyblxuLy8gYW4gQVNDSUkgc3RyaW5nIHN1aXRhYmxlIGZvciB1c2UgaW4gYSBIVFRQIGZpZWxkIHZhbHVlLlxuLy9cbi8vIDEuICBMZXQgb3V0cHV0IGJlIGFuIGVtcHR5IHN0cmluZy5cbi8vXG4vLyAyLiAgRm9yIGVhY2ggbWVtYmVyX25hbWUgd2l0aCBhIHZhbHVlIG9mIChtZW1iZXJfdmFsdWUsIHBhcmFtZXRlcnMpXG4vLyAgICAgaW4gaW5wdXRfZGljdGlvbmFyeTpcbi8vXG4vLyAgICAgMS4gIEFwcGVuZCB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgU2VyaWFsaXppbmcgYSBLZXlcbi8vICAgICAgICAgKFNlY3Rpb24gNC4xLjEuMykgd2l0aCBtZW1iZXIncyBtZW1iZXJfbmFtZSB0byBvdXRwdXQuXG4vL1xuLy8gICAgIDIuICBJZiBtZW1iZXJfdmFsdWUgaXMgQm9vbGVhbiB0cnVlOlxuLy9cbi8vICAgICAgICAgMS4gIEFwcGVuZCB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgU2VyaWFsaXppbmcgUGFyYW1ldGVyc1xuLy8gICAgICAgICAgICAgKFNlY3Rpb24gNC4xLjEuMikgd2l0aCBwYXJhbWV0ZXJzIHRvIG91dHB1dC5cbi8vXG4vLyAgICAgMy4gIE90aGVyd2lzZTpcbi8vXG4vLyAgICAgICAgIDEuICBBcHBlbmQgXCI9XCIgdG8gb3V0cHV0LlxuLy9cbi8vICAgICAgICAgMi4gIElmIG1lbWJlcl92YWx1ZSBpcyBhbiBhcnJheSwgYXBwZW5kIHRoZSByZXN1bHQgb2YgcnVubmluZ1xuLy8gICAgICAgICAgICAgU2VyaWFsaXppbmcgYW4gSW5uZXIgTGlzdCAoU2VjdGlvbiA0LjEuMS4xKSB3aXRoXG4vLyAgICAgICAgICAgICAobWVtYmVyX3ZhbHVlLCBwYXJhbWV0ZXJzKSB0byBvdXRwdXQuXG4vL1xuLy8gICAgICAgICAzLiAgT3RoZXJ3aXNlLCBhcHBlbmQgdGhlIHJlc3VsdCBvZiBydW5uaW5nIFNlcmlhbGl6aW5nIGFuXG4vLyAgICAgICAgICAgICBJdGVtIChTZWN0aW9uIDQuMS4zKSB3aXRoIChtZW1iZXJfdmFsdWUsIHBhcmFtZXRlcnMpIHRvXG4vLyAgICAgICAgICAgICBvdXRwdXQuXG4vL1xuLy8gICAgIDQuICBJZiBtb3JlIG1lbWJlcnMgcmVtYWluIGluIGlucHV0X2RpY3Rpb25hcnk6XG4vL1xuLy8gICAgICAgICAxLiAgQXBwZW5kIFwiLFwiIHRvIG91dHB1dC5cbi8vXG4vLyAgICAgICAgIDIuICBBcHBlbmQgYSBzaW5nbGUgU1AgdG8gb3V0cHV0LlxuLy9cbi8vIDMuICBSZXR1cm4gb3V0cHV0LlxuZnVuY3Rpb24gc2VyaWFsaXplRGljdChkaWN0LCBvcHRpb25zID0ge1xuICB3aGl0ZXNwYWNlOiB0cnVlXG59KSB7XG4gIGlmICh0eXBlb2YgZGljdCAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBzZXJpYWxpemVFcnJvcihkaWN0LCBESUNUKTtcbiAgfVxuICBjb25zdCBlbnRyaWVzID0gZGljdCBpbnN0YW5jZW9mIE1hcCA/IGRpY3QuZW50cmllcygpIDogT2JqZWN0LmVudHJpZXMoZGljdCk7XG4gIGNvbnN0IG9wdGlvbmFsV2hpdGVTcGFjZSA9IG9wdGlvbnMgIT0gbnVsbCAmJiBvcHRpb25zLndoaXRlc3BhY2UgPyAnICcgOiAnJztcbiAgcmV0dXJuIEFycmF5LmZyb20oZW50cmllcykubWFwKChba2V5LCBpdGVtXSkgPT4ge1xuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgU2ZJdGVtID09PSBmYWxzZSkge1xuICAgICAgaXRlbSA9IG5ldyBTZkl0ZW0oaXRlbSk7XG4gICAgfVxuICAgIGxldCBvdXRwdXQgPSBzZXJpYWxpemVLZXkoa2V5KTtcbiAgICBpZiAoaXRlbS52YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgb3V0cHV0ICs9IHNlcmlhbGl6ZVBhcmFtcyhpdGVtLnBhcmFtcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dCArPSAnPSc7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtLnZhbHVlKSkge1xuICAgICAgICBvdXRwdXQgKz0gc2VyaWFsaXplSW5uZXJMaXN0KGl0ZW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0ICs9IHNlcmlhbGl6ZUl0ZW0oaXRlbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH0pLmpvaW4oYCwke29wdGlvbmFsV2hpdGVTcGFjZX1gKTtcbn1cblxuLyoqXG4gKiBFbmNvZGUgYW4gb2JqZWN0IGludG8gYSBzdHJ1Y3R1cmVkIGZpZWxkIGRpY3Rpb25hcnlcbiAqXG4gKiBAcGFyYW0gaW5wdXQgLSBUaGUgc3RydWN0dXJlZCBmaWVsZCBkaWN0aW9uYXJ5IHRvIGVuY29kZVxuICogQHJldHVybnMgVGhlIHN0cnVjdHVyZWQgZmllbGQgc3RyaW5nXG4gKlxuICogQGdyb3VwIFN0cnVjdHVyZWQgRmllbGRcbiAqXG4gKiBAYmV0YVxuICovXG5mdW5jdGlvbiBlbmNvZGVTZkRpY3QodmFsdWUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHNlcmlhbGl6ZURpY3QodmFsdWUsIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4ga2V5IGlzIGEgdG9rZW4gZmllbGQuXG4gKlxuICogQHBhcmFtIGtleSAtIFRoZSBrZXkgdG8gY2hlY2suXG4gKlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBrZXkgaXMgYSB0b2tlbiBmaWVsZC5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqXG4gKiBAZ3JvdXAgQ01DRFxuICovXG5jb25zdCBpc1Rva2VuRmllbGQgPSBrZXkgPT4ga2V5ID09PSAnb3QnIHx8IGtleSA9PT0gJ3NmJyB8fCBrZXkgPT09ICdzdCc7XG5cbmNvbnN0IGlzVmFsaWQgPSB2YWx1ZSA9PiB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGlzRmluaXRlTnVtYmVyKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSAhPT0gJycgJiYgdmFsdWUgIT09IGZhbHNlO1xufTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgcmVsYXRpdmUgcGF0aCBmcm9tIGEgVVJMLlxuICpcbiAqIEBwYXJhbSB1cmwgLSBUaGUgZGVzdGluYXRpb24gVVJMXG4gKiBAcGFyYW0gYmFzZSAtIFRoZSBiYXNlIFVSTFxuICogQHJldHVybnMgVGhlIHJlbGF0aXZlIHBhdGhcbiAqXG4gKiBAZ3JvdXAgVXRpbHNcbiAqXG4gKiBAYmV0YVxuICovXG5mdW5jdGlvbiB1cmxUb1JlbGF0aXZlUGF0aCh1cmwsIGJhc2UpIHtcbiAgY29uc3QgdG8gPSBuZXcgVVJMKHVybCk7XG4gIGNvbnN0IGZyb20gPSBuZXcgVVJMKGJhc2UpO1xuICBpZiAodG8ub3JpZ2luICE9PSBmcm9tLm9yaWdpbikge1xuICAgIHJldHVybiB1cmw7XG4gIH1cbiAgY29uc3QgdG9QYXRoID0gdG8ucGF0aG5hbWUuc3BsaXQoJy8nKS5zbGljZSgxKTtcbiAgY29uc3QgZnJvbVBhdGggPSBmcm9tLnBhdGhuYW1lLnNwbGl0KCcvJykuc2xpY2UoMSwgLTEpO1xuICAvLyByZW1vdmUgY29tbW9uIHBhcmVudHNcbiAgd2hpbGUgKHRvUGF0aFswXSA9PT0gZnJvbVBhdGhbMF0pIHtcbiAgICB0b1BhdGguc2hpZnQoKTtcbiAgICBmcm9tUGF0aC5zaGlmdCgpO1xuICB9XG4gIC8vIGFkZCBiYWNrIHBhdGhzXG4gIHdoaWxlIChmcm9tUGF0aC5sZW5ndGgpIHtcbiAgICBmcm9tUGF0aC5zaGlmdCgpO1xuICAgIHRvUGF0aC51bnNoaWZ0KCcuLicpO1xuICB9XG4gIHJldHVybiB0b1BhdGguam9pbignLycpO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgcmFuZG9tIHY0IFVVSURcbiAqXG4gKiBAcmV0dXJucyBBIHJhbmRvbSB2NCBVVUlEXG4gKlxuICogQGdyb3VwIFV0aWxzXG4gKlxuICogQGJldGFcbiAqL1xuZnVuY3Rpb24gdXVpZCgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gY3J5cHRvLnJhbmRvbVVVSUQoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYigpKTtcbiAgICAgIGNvbnN0IHV1aWQgPSB1cmwudG9TdHJpbmcoKTtcbiAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodXJsKTtcbiAgICAgIHJldHVybiB1dWlkLnNsaWNlKHV1aWQubGFzdEluZGV4T2YoJy8nKSArIDEpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsZXQgZHQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgIGNvbnN0IHV1aWQgPSAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGMgPT4ge1xuICAgICAgICBjb25zdCByID0gKGR0ICsgTWF0aC5yYW5kb20oKSAqIDE2KSAlIDE2IHwgMDtcbiAgICAgICAgZHQgPSBNYXRoLmZsb29yKGR0IC8gMTYpO1xuICAgICAgICByZXR1cm4gKGMgPT0gJ3gnID8gciA6IHIgJiAweDMgfCAweDgpLnRvU3RyaW5nKDE2KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHV1aWQ7XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IHRvUm91bmRlZCA9IHZhbHVlID0+IE1hdGgucm91bmQodmFsdWUpO1xuY29uc3QgdG9VcmxTYWZlID0gKHZhbHVlLCBvcHRpb25zKSA9PiB7XG4gIGlmIChvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5iYXNlVXJsKSB7XG4gICAgdmFsdWUgPSB1cmxUb1JlbGF0aXZlUGF0aCh2YWx1ZSwgb3B0aW9ucy5iYXNlVXJsKTtcbiAgfVxuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbn07XG5jb25zdCB0b0h1bmRyZWQgPSB2YWx1ZSA9PiB0b1JvdW5kZWQodmFsdWUgLyAxMDApICogMTAwO1xuLyoqXG4gKiBUaGUgZGVmYXVsdCBmb3JtYXR0ZXJzIGZvciBDTUNEIHZhbHVlcy5cbiAqXG4gKiBAZ3JvdXAgQ01DRFxuICpcbiAqIEBiZXRhXG4gKi9cbmNvbnN0IENtY2RGb3JtYXR0ZXJzID0ge1xuICAvKipcbiAgICogQml0cmF0ZSAoa2Jwcykgcm91bmRlZCBpbnRlZ2VyXG4gICAqL1xuICBicjogdG9Sb3VuZGVkLFxuICAvKipcbiAgICogRHVyYXRpb24gKG1pbGxpc2Vjb25kcykgcm91bmRlZCBpbnRlZ2VyXG4gICAqL1xuICBkOiB0b1JvdW5kZWQsXG4gIC8qKlxuICAgKiBCdWZmZXIgTGVuZ3RoIChtaWxsaXNlY29uZHMpIHJvdW5kZWQgbmVhcmVzdCAxMDBtc1xuICAgKi9cbiAgYmw6IHRvSHVuZHJlZCxcbiAgLyoqXG4gICAqIERlYWRsaW5lIChtaWxsaXNlY29uZHMpIHJvdW5kZWQgbmVhcmVzdCAxMDBtc1xuICAgKi9cbiAgZGw6IHRvSHVuZHJlZCxcbiAgLyoqXG4gICAqIE1lYXN1cmVkIFRocm91Z2hwdXQgKGticHMpIHJvdW5kZWQgbmVhcmVzdCAxMDBrYnBzXG4gICAqL1xuICBtdHA6IHRvSHVuZHJlZCxcbiAgLyoqXG4gICAqIE5leHQgT2JqZWN0IFJlcXVlc3QgVVJMIGVuY29kZWRcbiAgICovXG4gIG5vcjogdG9VcmxTYWZlLFxuICAvKipcbiAgICogUmVxdWVzdGVkIG1heGltdW0gdGhyb3VnaHB1dCAoa2Jwcykgcm91bmRlZCBuZWFyZXN0IDEwMGticHNcbiAgICovXG4gIHJ0cDogdG9IdW5kcmVkLFxuICAvKipcbiAgICogVG9wIEJpdHJhdGUgKGticHMpIHJvdW5kZWQgaW50ZWdlclxuICAgKi9cbiAgdGI6IHRvUm91bmRlZFxufTtcblxuLyoqXG4gKiBJbnRlcm5hbCBDTUNEIHByb2Nlc3NpbmcgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIG9iaiAtIFRoZSBDTUNEIG9iamVjdCB0byBwcm9jZXNzLlxuICogQHBhcmFtIG1hcCAtIFRoZSBtYXBwaW5nIGZ1bmN0aW9uIHRvIHVzZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgZW5jb2RpbmcuXG4gKlxuICogQGludGVybmFsXG4gKlxuICogQGdyb3VwIENNQ0RcbiAqL1xuZnVuY3Rpb24gcHJvY2Vzc0NtY2Qob2JqLCBvcHRpb25zKSB7XG4gIGNvbnN0IHJlc3VsdHMgPSB7fTtcbiAgaWYgKG9iaiA9PSBudWxsIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaikuc29ydCgpO1xuICBjb25zdCBmb3JtYXR0ZXJzID0gX2V4dGVuZHMoe30sIENtY2RGb3JtYXR0ZXJzLCBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmZvcm1hdHRlcnMpO1xuICBjb25zdCBmaWx0ZXIgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmZpbHRlcjtcbiAga2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgaWYgKGZpbHRlciAhPSBudWxsICYmIGZpbHRlcihrZXkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCB2YWx1ZSA9IG9ialtrZXldO1xuICAgIGNvbnN0IGZvcm1hdHRlciA9IGZvcm1hdHRlcnNba2V5XTtcbiAgICBpZiAoZm9ybWF0dGVyKSB7XG4gICAgICB2YWx1ZSA9IGZvcm1hdHRlcih2YWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8vIFZlcnNpb24gc2hvdWxkIG9ubHkgYmUgcmVwb3J0ZWQgaWYgbm90IGVxdWFsIHRvIDEuXG4gICAgaWYgKGtleSA9PT0gJ3YnICYmIHZhbHVlID09PSAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFBsYXliYWNrIHJhdGUgc2hvdWxkIG9ubHkgYmUgc2VudCBpZiBub3QgZXF1YWwgdG8gMS5cbiAgICBpZiAoa2V5ID09ICdwcicgJiYgdmFsdWUgPT09IDEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gaWdub3JlIGludmFsaWQgdmFsdWVzXG4gICAgaWYgKCFpc1ZhbGlkKHZhbHVlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNUb2tlbkZpZWxkKGtleSkgJiYgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgdmFsdWUgPSBuZXcgU2ZUb2tlbih2YWx1ZSk7XG4gICAgfVxuICAgIHJlc3VsdHNba2V5XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5cbi8qKlxuICogRW5jb2RlIGEgQ01DRCBvYmplY3QgdG8gYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGNtY2QgLSBUaGUgQ01DRCBvYmplY3QgdG8gZW5jb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciBlbmNvZGluZy5cbiAqXG4gKiBAcmV0dXJucyBUaGUgZW5jb2RlZCBDTUNEIHN0cmluZy5cbiAqXG4gKiBAZ3JvdXAgQ01DRFxuICpcbiAqIEBiZXRhXG4gKi9cbmZ1bmN0aW9uIGVuY29kZUNtY2QoY21jZCwgb3B0aW9ucyA9IHt9KSB7XG4gIGlmICghY21jZCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICByZXR1cm4gZW5jb2RlU2ZEaWN0KHByb2Nlc3NDbWNkKGNtY2QsIG9wdGlvbnMpLCBfZXh0ZW5kcyh7XG4gICAgd2hpdGVzcGFjZTogZmFsc2VcbiAgfSwgb3B0aW9ucykpO1xufVxuXG4vKipcbiAqIENvbnZlcnQgYSBDTUNEIGRhdGEgb2JqZWN0IHRvIHJlcXVlc3QgaGVhZGVyc1xuICpcbiAqIEBwYXJhbSBjbWNkIC0gVGhlIENNQ0QgZGF0YSBvYmplY3QgdG8gY29udmVydC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgZW5jb2RpbmcgdGhlIENNQ0Qgb2JqZWN0LlxuICpcbiAqIEByZXR1cm5zIFRoZSBDTUNEIGhlYWRlciBzaGFyZHMuXG4gKlxuICogQGdyb3VwIENNQ0RcbiAqXG4gKiBAYmV0YVxuICovXG5mdW5jdGlvbiB0b0NtY2RIZWFkZXJzKGNtY2QsIG9wdGlvbnMgPSB7fSkge1xuICBpZiAoIWNtY2QpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgY29uc3QgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKGNtY2QpO1xuICBjb25zdCBoZWFkZXJNYXAgPSBPYmplY3QuZW50cmllcyhDbWNkSGVhZGVyTWFwKS5jb25jYXQoT2JqZWN0LmVudHJpZXMoKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuY3VzdG9tSGVhZGVyTWFwKSB8fCB7fSkpO1xuICBjb25zdCBzaGFyZHMgPSBlbnRyaWVzLnJlZHVjZSgoYWNjLCBlbnRyeSkgPT4ge1xuICAgIHZhciBfaGVhZGVyTWFwJGZpbmQsIF9hY2MkZmllbGQ7XG4gICAgY29uc3QgW2tleSwgdmFsdWVdID0gZW50cnk7XG4gICAgY29uc3QgZmllbGQgPSAoKF9oZWFkZXJNYXAkZmluZCA9IGhlYWRlck1hcC5maW5kKGVudHJ5ID0+IGVudHJ5WzFdLmluY2x1ZGVzKGtleSkpKSA9PSBudWxsID8gdm9pZCAwIDogX2hlYWRlck1hcCRmaW5kWzBdKSB8fCBDbWNkSGVhZGVyRmllbGQuUkVRVUVTVDtcbiAgICAoX2FjYyRmaWVsZCA9IGFjY1tmaWVsZF0pICE9IG51bGwgPyBfYWNjJGZpZWxkIDogYWNjW2ZpZWxkXSA9IHt9O1xuICAgIGFjY1tmaWVsZF1ba2V5XSA9IHZhbHVlO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHNoYXJkcykucmVkdWNlKChhY2MsIFtmaWVsZCwgdmFsdWVdKSA9PiB7XG4gICAgYWNjW2ZpZWxkXSA9IGVuY29kZUNtY2QodmFsdWUsIG9wdGlvbnMpO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbn1cblxuLyoqXG4gKiBBcHBlbmQgQ01DRCBxdWVyeSBhcmdzIHRvIGEgaGVhZGVyIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gaGVhZGVycyAtIFRoZSBoZWFkZXJzIHRvIGFwcGVuZCB0by5cbiAqIEBwYXJhbSBjbWNkIC0gVGhlIENNQ0Qgb2JqZWN0IHRvIGFwcGVuZC5cbiAqIEBwYXJhbSBjdXN0b21IZWFkZXJNYXAgLSBBIG1hcCBvZiBjdXN0b20gQ01DRCBrZXlzIHRvIGhlYWRlciBmaWVsZHMuXG4gKlxuICogQHJldHVybnMgVGhlIGhlYWRlcnMgd2l0aCB0aGUgQ01DRCBoZWFkZXIgc2hhcmRzIGFwcGVuZGVkLlxuICpcbiAqIEBncm91cCBDTUNEXG4gKlxuICogQGJldGFcbiAqL1xuZnVuY3Rpb24gYXBwZW5kQ21jZEhlYWRlcnMoaGVhZGVycywgY21jZCwgb3B0aW9ucykge1xuICByZXR1cm4gX2V4dGVuZHMoaGVhZGVycywgdG9DbWNkSGVhZGVycyhjbWNkLCBvcHRpb25zKSk7XG59XG5cbi8qKlxuICogQ01DRCBwYXJhbWV0ZXIgbmFtZS5cbiAqXG4gKiBAZ3JvdXAgQ01DRFxuICpcbiAqIEBiZXRhXG4gKi9cbmNvbnN0IENNQ0RfUEFSQU0gPSAnQ01DRCc7XG5cbi8qKlxuICogQ29udmVydCBhIENNQ0QgZGF0YSBvYmplY3QgdG8gYSBxdWVyeSBhcmcuXG4gKlxuICogQHBhcmFtIGNtY2QgLSBUaGUgQ01DRCBvYmplY3QgdG8gY29udmVydC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgZW5jb2RpbmcgdGhlIENNQ0Qgb2JqZWN0LlxuICpcbiAqIEByZXR1cm5zIFRoZSBDTUNEIHF1ZXJ5IGFyZy5cbiAqXG4gKiBAZ3JvdXAgQ01DRFxuICpcbiAqIEBiZXRhXG4gKi9cbmZ1bmN0aW9uIHRvQ21jZFF1ZXJ5KGNtY2QsIG9wdGlvbnMgPSB7fSkge1xuICBpZiAoIWNtY2QpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgY29uc3QgcGFyYW1zID0gZW5jb2RlQ21jZChjbWNkLCBvcHRpb25zKTtcbiAgcmV0dXJuIGAke0NNQ0RfUEFSQU19PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcyl9YDtcbn1cblxuY29uc3QgUkVHRVggPSAvQ01DRD1bXiYjXSsvO1xuLyoqXG4gKiBBcHBlbmQgQ01DRCBxdWVyeSBhcmdzIHRvIGEgVVJMLlxuICpcbiAqIEBwYXJhbSB1cmwgLSBUaGUgVVJMIHRvIGFwcGVuZCB0by5cbiAqIEBwYXJhbSBjbWNkIC0gVGhlIENNQ0Qgb2JqZWN0IHRvIGFwcGVuZC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgZW5jb2RpbmcgdGhlIENNQ0Qgb2JqZWN0LlxuICpcbiAqIEByZXR1cm5zIFRoZSBVUkwgd2l0aCB0aGUgQ01DRCBxdWVyeSBhcmdzIGFwcGVuZGVkLlxuICpcbiAqIEBncm91cCBDTUNEXG4gKlxuICogQGJldGFcbiAqL1xuZnVuY3Rpb24gYXBwZW5kQ21jZFF1ZXJ5KHVybCwgY21jZCwgb3B0aW9ucykge1xuICAvLyBUT0RPOiBSZXBsYWNlIHdpdGggVVJMU2VhcmNoUGFyYW1zIG9uY2Ugd2UgZHJvcCBTYWZhcmkgPCAxMC4xICYgQ2hyb21lIDwgNDkgc3VwcG9ydC5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1VSTFNlYXJjaFBhcmFtc1xuICBjb25zdCBxdWVyeSA9IHRvQ21jZFF1ZXJ5KGNtY2QsIG9wdGlvbnMpO1xuICBpZiAoIXF1ZXJ5KSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICBpZiAoUkVHRVgudGVzdCh1cmwpKSB7XG4gICAgcmV0dXJuIHVybC5yZXBsYWNlKFJFR0VYLCBxdWVyeSk7XG4gIH1cbiAgY29uc3Qgc2VwYXJhdG9yID0gdXJsLmluY2x1ZGVzKCc/JykgPyAnJicgOiAnPyc7XG4gIHJldHVybiBgJHt1cmx9JHtzZXBhcmF0b3J9JHtxdWVyeX1gO1xufVxuXG4vKipcbiAqIENvbnRyb2xsZXIgdG8gZGVhbCB3aXRoIENvbW1vbiBNZWRpYSBDbGllbnQgRGF0YSAoQ01DRClcbiAqIEBzZWUgaHR0cHM6Ly9jZG4uY3RhLnRlY2gvY3RhL21lZGlhL21lZGlhL3Jlc291cmNlcy9zdGFuZGFyZHMvcGRmcy9jdGEtNTAwNC1maW5hbC5wZGZcbiAqL1xuY2xhc3MgQ01DRENvbnRyb2xsZXIge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFsc1xuXG4gIGNvbnN0cnVjdG9yKGhscykge1xuICAgIHRoaXMuaGxzID0gdm9pZCAwO1xuICAgIHRoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgIHRoaXMubWVkaWEgPSB2b2lkIDA7XG4gICAgdGhpcy5zaWQgPSB2b2lkIDA7XG4gICAgdGhpcy5jaWQgPSB2b2lkIDA7XG4gICAgdGhpcy51c2VIZWFkZXJzID0gZmFsc2U7XG4gICAgdGhpcy5pbmNsdWRlS2V5cyA9IHZvaWQgMDtcbiAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5zdGFydmVkID0gZmFsc2U7XG4gICAgdGhpcy5idWZmZXJpbmcgPSB0cnVlO1xuICAgIHRoaXMuYXVkaW9CdWZmZXIgPSB2b2lkIDA7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcbiAgICB0aGlzLnZpZGVvQnVmZmVyID0gdm9pZCAwO1xuICAgIHRoaXMub25XYWl0aW5nID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgdGhpcy5zdGFydmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYnVmZmVyaW5nID0gdHJ1ZTtcbiAgICB9O1xuICAgIHRoaXMub25QbGF5aW5nID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5idWZmZXJpbmcgPSBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFwcGx5IENNQ0QgZGF0YSB0byBhIG1hbmlmZXN0IHJlcXVlc3QuXG4gICAgICovXG4gICAgdGhpcy5hcHBseVBsYXlsaXN0RGF0YSA9IGNvbnRleHQgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5hcHBseShjb250ZXh0LCB7XG4gICAgICAgICAgb3Q6IENtT2JqZWN0VHlwZS5NQU5JRkVTVCxcbiAgICAgICAgICBzdTogIXRoaXMuaW5pdGlhbGl6ZWRcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dnZXIud2FybignQ291bGQgbm90IGdlbmVyYXRlIG1hbmlmZXN0IENNQ0QgZGF0YS4nLCBlcnJvcik7XG4gICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBcHBseSBDTUNEIGRhdGEgdG8gYSBzZWdtZW50IHJlcXVlc3RcbiAgICAgKi9cbiAgICB0aGlzLmFwcGx5RnJhZ21lbnREYXRhID0gY29udGV4dCA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IGNvbnRleHQuZnJhZztcbiAgICAgICAgY29uc3QgbGV2ZWwgPSB0aGlzLmhscy5sZXZlbHNbZnJhZ21lbnQubGV2ZWxdO1xuICAgICAgICBjb25zdCBvdCA9IHRoaXMuZ2V0T2JqZWN0VHlwZShmcmFnbWVudCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgZDogZnJhZ21lbnQuZHVyYXRpb24gKiAxMDAwLFxuICAgICAgICAgIG90XG4gICAgICAgIH07XG4gICAgICAgIGlmIChvdCA9PT0gQ21PYmplY3RUeXBlLlZJREVPIHx8IG90ID09PSBDbU9iamVjdFR5cGUuQVVESU8gfHwgb3QgPT0gQ21PYmplY3RUeXBlLk1VWEVEKSB7XG4gICAgICAgICAgZGF0YS5iciA9IGxldmVsLmJpdHJhdGUgLyAxMDAwO1xuICAgICAgICAgIGRhdGEudGIgPSB0aGlzLmdldFRvcEJhbmR3aWR0aChvdCkgLyAxMDAwO1xuICAgICAgICAgIGRhdGEuYmwgPSB0aGlzLmdldEJ1ZmZlckxlbmd0aChvdCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hcHBseShjb250ZXh0LCBkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKCdDb3VsZCBub3QgZ2VuZXJhdGUgc2VnbWVudCBDTUNEIGRhdGEuJywgZXJyb3IpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5obHMgPSBobHM7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWcgPSBobHMuY29uZmlnO1xuICAgIGNvbnN0IHtcbiAgICAgIGNtY2RcbiAgICB9ID0gY29uZmlnO1xuICAgIGlmIChjbWNkICE9IG51bGwpIHtcbiAgICAgIGNvbmZpZy5wTG9hZGVyID0gdGhpcy5jcmVhdGVQbGF5bGlzdExvYWRlcigpO1xuICAgICAgY29uZmlnLmZMb2FkZXIgPSB0aGlzLmNyZWF0ZUZyYWdtZW50TG9hZGVyKCk7XG4gICAgICB0aGlzLnNpZCA9IGNtY2Quc2Vzc2lvbklkIHx8IHV1aWQoKTtcbiAgICAgIHRoaXMuY2lkID0gY21jZC5jb250ZW50SWQ7XG4gICAgICB0aGlzLnVzZUhlYWRlcnMgPSBjbWNkLnVzZUhlYWRlcnMgPT09IHRydWU7XG4gICAgICB0aGlzLmluY2x1ZGVLZXlzID0gY21jZC5pbmNsdWRlS2V5cztcbiAgICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB9XG4gIH1cbiAgcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgaGxzLm9uKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUVESUFfREVUQUNIRUQsIHRoaXMub25NZWRpYURldGFjaGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkJVRkZFUl9DUkVBVEVELCB0aGlzLm9uQnVmZmVyQ3JlYXRlZCwgdGhpcyk7XG4gIH1cbiAgdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICBobHMub2ZmKEV2ZW50cy5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0RFVEFDSEVELCB0aGlzLm9uTWVkaWFEZXRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0NSRUFURUQsIHRoaXMub25CdWZmZXJDcmVhdGVkLCB0aGlzKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIHRoaXMub25NZWRpYURldGFjaGVkKCk7XG5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5obHMgPSB0aGlzLmNvbmZpZyA9IHRoaXMuYXVkaW9CdWZmZXIgPSB0aGlzLnZpZGVvQnVmZmVyID0gbnVsbDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5vbldhaXRpbmcgPSB0aGlzLm9uUGxheWluZyA9IG51bGw7XG4gIH1cbiAgb25NZWRpYUF0dGFjaGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5tZWRpYSA9IGRhdGEubWVkaWE7XG4gICAgdGhpcy5tZWRpYS5hZGRFdmVudExpc3RlbmVyKCd3YWl0aW5nJywgdGhpcy5vbldhaXRpbmcpO1xuICAgIHRoaXMubWVkaWEuYWRkRXZlbnRMaXN0ZW5lcigncGxheWluZycsIHRoaXMub25QbGF5aW5nKTtcbiAgfVxuICBvbk1lZGlhRGV0YWNoZWQoKSB7XG4gICAgaWYgKCF0aGlzLm1lZGlhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2FpdGluZycsIHRoaXMub25XYWl0aW5nKTtcbiAgICB0aGlzLm1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BsYXlpbmcnLCB0aGlzLm9uUGxheWluZyk7XG5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gIH1cbiAgb25CdWZmZXJDcmVhdGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIF9kYXRhJHRyYWNrcyRhdWRpbywgX2RhdGEkdHJhY2tzJHZpZGVvO1xuICAgIHRoaXMuYXVkaW9CdWZmZXIgPSAoX2RhdGEkdHJhY2tzJGF1ZGlvID0gZGF0YS50cmFja3MuYXVkaW8pID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YSR0cmFja3MkYXVkaW8uYnVmZmVyO1xuICAgIHRoaXMudmlkZW9CdWZmZXIgPSAoX2RhdGEkdHJhY2tzJHZpZGVvID0gZGF0YS50cmFja3MudmlkZW8pID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YSR0cmFja3MkdmlkZW8uYnVmZmVyO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYmFzZWxpbmUgQ01DRCBkYXRhXG4gICAqL1xuICBjcmVhdGVEYXRhKCkge1xuICAgIHZhciBfdGhpcyRtZWRpYTtcbiAgICByZXR1cm4ge1xuICAgICAgdjogMSxcbiAgICAgIHNmOiBDbVN0cmVhbWluZ0Zvcm1hdC5ITFMsXG4gICAgICBzaWQ6IHRoaXMuc2lkLFxuICAgICAgY2lkOiB0aGlzLmNpZCxcbiAgICAgIHByOiAoX3RoaXMkbWVkaWEgPSB0aGlzLm1lZGlhKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkbWVkaWEucGxheWJhY2tSYXRlLFxuICAgICAgbXRwOiB0aGlzLmhscy5iYW5kd2lkdGhFc3RpbWF0ZSAvIDEwMDBcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGx5IENNQ0QgZGF0YSB0byBhIHJlcXVlc3QuXG4gICAqL1xuICBhcHBseShjb250ZXh0LCBkYXRhID0ge30pIHtcbiAgICAvLyBhcHBseSBiYXNlbGluZSBkYXRhXG4gICAgX2V4dGVuZHMoZGF0YSwgdGhpcy5jcmVhdGVEYXRhKCkpO1xuICAgIGNvbnN0IGlzVmlkZW8gPSBkYXRhLm90ID09PSBDbU9iamVjdFR5cGUuSU5JVCB8fCBkYXRhLm90ID09PSBDbU9iamVjdFR5cGUuVklERU8gfHwgZGF0YS5vdCA9PT0gQ21PYmplY3RUeXBlLk1VWEVEO1xuICAgIGlmICh0aGlzLnN0YXJ2ZWQgJiYgaXNWaWRlbykge1xuICAgICAgZGF0YS5icyA9IHRydWU7XG4gICAgICBkYXRhLnN1ID0gdHJ1ZTtcbiAgICAgIHRoaXMuc3RhcnZlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZGF0YS5zdSA9PSBudWxsKSB7XG4gICAgICBkYXRhLnN1ID0gdGhpcy5idWZmZXJpbmc7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogSW1wbGVtZW50IHJ0cCwgbnJyLCBub3IsIGRsXG5cbiAgICBjb25zdCB7XG4gICAgICBpbmNsdWRlS2V5c1xuICAgIH0gPSB0aGlzO1xuICAgIGlmIChpbmNsdWRlS2V5cykge1xuICAgICAgZGF0YSA9IE9iamVjdC5rZXlzKGRhdGEpLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICAgICAgaW5jbHVkZUtleXMuaW5jbHVkZXMoa2V5KSAmJiAoYWNjW2tleV0gPSBkYXRhW2tleV0pO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSwge30pO1xuICAgIH1cbiAgICBpZiAodGhpcy51c2VIZWFkZXJzKSB7XG4gICAgICBpZiAoIWNvbnRleHQuaGVhZGVycykge1xuICAgICAgICBjb250ZXh0LmhlYWRlcnMgPSB7fTtcbiAgICAgIH1cbiAgICAgIGFwcGVuZENtY2RIZWFkZXJzKGNvbnRleHQuaGVhZGVycywgZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQudXJsID0gYXBwZW5kQ21jZFF1ZXJ5KGNvbnRleHQudXJsLCBkYXRhKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBDTUNEIG9iamVjdCB0eXBlLlxuICAgKi9cbiAgZ2V0T2JqZWN0VHlwZShmcmFnbWVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGVcbiAgICB9ID0gZnJhZ21lbnQ7XG4gICAgaWYgKHR5cGUgPT09ICdzdWJ0aXRsZScpIHtcbiAgICAgIHJldHVybiBDbU9iamVjdFR5cGUuVElNRURfVEVYVDtcbiAgICB9XG4gICAgaWYgKGZyYWdtZW50LnNuID09PSAnaW5pdFNlZ21lbnQnKSB7XG4gICAgICByZXR1cm4gQ21PYmplY3RUeXBlLklOSVQ7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICByZXR1cm4gQ21PYmplY3RUeXBlLkFVRElPO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ21haW4nKSB7XG4gICAgICBpZiAoIXRoaXMuaGxzLmF1ZGlvVHJhY2tzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gQ21PYmplY3RUeXBlLk1VWEVEO1xuICAgICAgfVxuICAgICAgcmV0dXJuIENtT2JqZWN0VHlwZS5WSURFTztcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGhpZ2hlc3QgYml0cmF0ZS5cbiAgICovXG4gIGdldFRvcEJhbmR3aWR0aCh0eXBlKSB7XG4gICAgbGV0IGJpdHJhdGUgPSAwO1xuICAgIGxldCBsZXZlbHM7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgaWYgKHR5cGUgPT09IENtT2JqZWN0VHlwZS5BVURJTykge1xuICAgICAgbGV2ZWxzID0gaGxzLmF1ZGlvVHJhY2tzO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtYXggPSBobHMubWF4QXV0b0xldmVsO1xuICAgICAgY29uc3QgbGVuID0gbWF4ID4gLTEgPyBtYXggKyAxIDogaGxzLmxldmVscy5sZW5ndGg7XG4gICAgICBsZXZlbHMgPSBobHMubGV2ZWxzLnNsaWNlKDAsIGxlbik7XG4gICAgfVxuICAgIGZvciAoY29uc3QgbGV2ZWwgb2YgbGV2ZWxzKSB7XG4gICAgICBpZiAobGV2ZWwuYml0cmF0ZSA+IGJpdHJhdGUpIHtcbiAgICAgICAgYml0cmF0ZSA9IGxldmVsLmJpdHJhdGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBiaXRyYXRlID4gMCA/IGJpdHJhdGUgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBidWZmZXIgbGVuZ3RoIGZvciBhIG1lZGlhIHR5cGUgaW4gbWlsbGlzZWNvbmRzXG4gICAqL1xuICBnZXRCdWZmZXJMZW5ndGgodHlwZSkge1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5obHMubWVkaWE7XG4gICAgY29uc3QgYnVmZmVyID0gdHlwZSA9PT0gQ21PYmplY3RUeXBlLkFVRElPID8gdGhpcy5hdWRpb0J1ZmZlciA6IHRoaXMudmlkZW9CdWZmZXI7XG4gICAgaWYgKCFidWZmZXIgfHwgIW1lZGlhKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICBjb25zdCBpbmZvID0gQnVmZmVySGVscGVyLmJ1ZmZlckluZm8oYnVmZmVyLCBtZWRpYS5jdXJyZW50VGltZSwgdGhpcy5jb25maWcubWF4QnVmZmVySG9sZSk7XG4gICAgcmV0dXJuIGluZm8ubGVuICogMTAwMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBwbGF5bGlzdCBsb2FkZXJcbiAgICovXG4gIGNyZWF0ZVBsYXlsaXN0TG9hZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBMb2FkZXJcbiAgICB9ID0gdGhpcy5jb25maWc7XG4gICAgY29uc3QgYXBwbHkgPSB0aGlzLmFwcGx5UGxheWxpc3REYXRhO1xuICAgIGNvbnN0IEN0b3IgPSBwTG9hZGVyIHx8IHRoaXMuY29uZmlnLmxvYWRlcjtcbiAgICByZXR1cm4gY2xhc3MgQ21jZFBsYXlsaXN0TG9hZGVyIHtcbiAgICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICB0aGlzLmxvYWRlciA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgQ3Rvcihjb25maWcpO1xuICAgICAgfVxuICAgICAgZ2V0IHN0YXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2FkZXIuc3RhdHM7XG4gICAgICB9XG4gICAgICBnZXQgY29udGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZGVyLmNvbnRleHQ7XG4gICAgICB9XG4gICAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmxvYWRlci5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgICBhYm9ydCgpIHtcbiAgICAgICAgdGhpcy5sb2FkZXIuYWJvcnQoKTtcbiAgICAgIH1cbiAgICAgIGxvYWQoY29udGV4dCwgY29uZmlnLCBjYWxsYmFja3MpIHtcbiAgICAgICAgYXBwbHkoY29udGV4dCk7XG4gICAgICAgIHRoaXMubG9hZGVyLmxvYWQoY29udGV4dCwgY29uZmlnLCBjYWxsYmFja3MpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgcGxheWxpc3QgbG9hZGVyXG4gICAqL1xuICBjcmVhdGVGcmFnbWVudExvYWRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBmTG9hZGVyXG4gICAgfSA9IHRoaXMuY29uZmlnO1xuICAgIGNvbnN0IGFwcGx5ID0gdGhpcy5hcHBseUZyYWdtZW50RGF0YTtcbiAgICBjb25zdCBDdG9yID0gZkxvYWRlciB8fCB0aGlzLmNvbmZpZy5sb2FkZXI7XG4gICAgcmV0dXJuIGNsYXNzIENtY2RGcmFnbWVudExvYWRlciB7XG4gICAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgdGhpcy5sb2FkZXIgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMubG9hZGVyID0gbmV3IEN0b3IoY29uZmlnKTtcbiAgICAgIH1cbiAgICAgIGdldCBzdGF0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZGVyLnN0YXRzO1xuICAgICAgfVxuICAgICAgZ2V0IGNvbnRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRlci5jb250ZXh0O1xuICAgICAgfVxuICAgICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5sb2FkZXIuZGVzdHJveSgpO1xuICAgICAgfVxuICAgICAgYWJvcnQoKSB7XG4gICAgICAgIHRoaXMubG9hZGVyLmFib3J0KCk7XG4gICAgICB9XG4gICAgICBsb2FkKGNvbnRleHQsIGNvbmZpZywgY2FsbGJhY2tzKSB7XG4gICAgICAgIGFwcGx5KGNvbnRleHQpO1xuICAgICAgICB0aGlzLmxvYWRlci5sb2FkKGNvbnRleHQsIGNvbmZpZywgY2FsbGJhY2tzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5cbmNvbnN0IFBBVEhXQVlfUEVOQUxUWV9EVVJBVElPTl9NUyA9IDMwMDAwMDtcbmNsYXNzIENvbnRlbnRTdGVlcmluZ0NvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihobHMpIHtcbiAgICB0aGlzLmhscyA9IHZvaWQgMDtcbiAgICB0aGlzLmxvZyA9IHZvaWQgMDtcbiAgICB0aGlzLmxvYWRlciA9IG51bGw7XG4gICAgdGhpcy51cmkgPSBudWxsO1xuICAgIHRoaXMucGF0aHdheUlkID0gJy4nO1xuICAgIHRoaXMucGF0aHdheVByaW9yaXR5ID0gbnVsbDtcbiAgICB0aGlzLnRpbWVUb0xvYWQgPSAzMDA7XG4gICAgdGhpcy5yZWxvYWRUaW1lciA9IC0xO1xuICAgIHRoaXMudXBkYXRlZCA9IDA7XG4gICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLmxldmVscyA9IG51bGw7XG4gICAgdGhpcy5hdWRpb1RyYWNrcyA9IG51bGw7XG4gICAgdGhpcy5zdWJ0aXRsZVRyYWNrcyA9IG51bGw7XG4gICAgdGhpcy5wZW5hbGl6ZWRQYXRod2F5cyA9IHt9O1xuICAgIHRoaXMuaGxzID0gaGxzO1xuICAgIHRoaXMubG9nID0gbG9nZ2VyLmxvZy5iaW5kKGxvZ2dlciwgYFtjb250ZW50LXN0ZWVyaW5nXTpgKTtcbiAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cbiAgcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURFRCwgdGhpcy5vbk1hbmlmZXN0TG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICB9XG4gIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgaGxzID0gdGhpcy5obHM7XG4gICAgaWYgKCFobHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUFOSUZFU1RfTE9BREVELCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfVxuICBzdGFydExvYWQoKSB7XG4gICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICAgIGlmICh0aGlzLmVuYWJsZWQgJiYgdGhpcy51cmkpIHtcbiAgICAgIGlmICh0aGlzLnVwZGF0ZWQpIHtcbiAgICAgICAgY29uc3QgdHRsID0gdGhpcy50aW1lVG9Mb2FkICogMTAwMCAtIChwZXJmb3JtYW5jZS5ub3coKSAtIHRoaXMudXBkYXRlZCk7XG4gICAgICAgIGlmICh0dGwgPiAwKSB7XG4gICAgICAgICAgdGhpcy5zY2hlZHVsZVJlZnJlc2godGhpcy51cmksIHR0bCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmxvYWRTdGVlcmluZ01hbmlmZXN0KHRoaXMudXJpKTtcbiAgICB9XG4gIH1cbiAgc3RvcExvYWQoKSB7XG4gICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgaWYgKHRoaXMubG9hZGVyKSB7XG4gICAgICB0aGlzLmxvYWRlci5kZXN0cm95KCk7XG4gICAgICB0aGlzLmxvYWRlciA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuY2xlYXJUaW1lb3V0KCk7XG4gIH1cbiAgY2xlYXJUaW1lb3V0KCkge1xuICAgIGlmICh0aGlzLnJlbG9hZFRpbWVyICE9PSAtMSkge1xuICAgICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZWxvYWRUaW1lcik7XG4gICAgICB0aGlzLnJlbG9hZFRpbWVyID0gLTE7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmhscyA9IG51bGw7XG4gICAgdGhpcy5sZXZlbHMgPSB0aGlzLmF1ZGlvVHJhY2tzID0gdGhpcy5zdWJ0aXRsZVRyYWNrcyA9IG51bGw7XG4gIH1cbiAgcmVtb3ZlTGV2ZWwobGV2ZWxUb1JlbW92ZSkge1xuICAgIGNvbnN0IGxldmVscyA9IHRoaXMubGV2ZWxzO1xuICAgIGlmIChsZXZlbHMpIHtcbiAgICAgIHRoaXMubGV2ZWxzID0gbGV2ZWxzLmZpbHRlcihsZXZlbCA9PiBsZXZlbCAhPT0gbGV2ZWxUb1JlbW92ZSk7XG4gICAgfVxuICB9XG4gIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMudGltZVRvTG9hZCA9IDMwMDtcbiAgICB0aGlzLnVwZGF0ZWQgPSAwO1xuICAgIHRoaXMudXJpID0gbnVsbDtcbiAgICB0aGlzLnBhdGh3YXlJZCA9ICcuJztcbiAgICB0aGlzLmxldmVscyA9IHRoaXMuYXVkaW9UcmFja3MgPSB0aGlzLnN1YnRpdGxlVHJhY2tzID0gbnVsbDtcbiAgfVxuICBvbk1hbmlmZXN0TG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29udGVudFN0ZWVyaW5nXG4gICAgfSA9IGRhdGE7XG4gICAgaWYgKGNvbnRlbnRTdGVlcmluZyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBhdGh3YXlJZCA9IGNvbnRlbnRTdGVlcmluZy5wYXRod2F5SWQ7XG4gICAgdGhpcy51cmkgPSBjb250ZW50U3RlZXJpbmcudXJpO1xuICAgIGlmICh0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgIHRoaXMuc3RhcnRMb2FkKCk7XG4gICAgfVxuICB9XG4gIG9uTWFuaWZlc3RQYXJzZWQoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLmF1ZGlvVHJhY2tzID0gZGF0YS5hdWRpb1RyYWNrcztcbiAgICB0aGlzLnN1YnRpdGxlVHJhY2tzID0gZGF0YS5zdWJ0aXRsZVRyYWNrcztcbiAgfVxuICBvbkVycm9yKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgZXJyb3JBY3Rpb25cbiAgICB9ID0gZGF0YTtcbiAgICBpZiAoKGVycm9yQWN0aW9uID09IG51bGwgPyB2b2lkIDAgOiBlcnJvckFjdGlvbi5hY3Rpb24pID09PSBOZXR3b3JrRXJyb3JBY3Rpb24uU2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveCAmJiBlcnJvckFjdGlvbi5mbGFncyA9PT0gRXJyb3JBY3Rpb25GbGFncy5Nb3ZlQWxsQWx0ZXJuYXRlc01hdGNoaW5nSG9zdCkge1xuICAgICAgY29uc3QgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG4gICAgICBsZXQgcGF0aHdheVByaW9yaXR5ID0gdGhpcy5wYXRod2F5UHJpb3JpdHk7XG4gICAgICBsZXQgZXJyb3JQYXRod2F5ID0gdGhpcy5wYXRod2F5SWQ7XG4gICAgICBpZiAoZGF0YS5jb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBncm91cElkLFxuICAgICAgICAgIHBhdGh3YXlJZCxcbiAgICAgICAgICB0eXBlXG4gICAgICAgIH0gPSBkYXRhLmNvbnRleHQ7XG4gICAgICAgIGlmIChncm91cElkICYmIGxldmVscykge1xuICAgICAgICAgIGVycm9yUGF0aHdheSA9IHRoaXMuZ2V0UGF0aHdheUZvckdyb3VwSWQoZ3JvdXBJZCwgdHlwZSwgZXJyb3JQYXRod2F5KTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXRod2F5SWQpIHtcbiAgICAgICAgICBlcnJvclBhdGh3YXkgPSBwYXRod2F5SWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghKGVycm9yUGF0aHdheSBpbiB0aGlzLnBlbmFsaXplZFBhdGh3YXlzKSkge1xuICAgICAgICB0aGlzLnBlbmFsaXplZFBhdGh3YXlzW2Vycm9yUGF0aHdheV0gPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIH1cbiAgICAgIGlmICghcGF0aHdheVByaW9yaXR5ICYmIGxldmVscykge1xuICAgICAgICAvLyBJZiBQQVRIV0FZLVBSSU9SSVRZIHdhcyBub3QgcHJvdmlkZWQsIGxpc3QgcGF0aHdheXMgZm9yIGVycm9yIGhhbmRsaW5nXG4gICAgICAgIHBhdGh3YXlQcmlvcml0eSA9IGxldmVscy5yZWR1Y2UoKHBhdGh3YXlzLCBsZXZlbCkgPT4ge1xuICAgICAgICAgIGlmIChwYXRod2F5cy5pbmRleE9mKGxldmVsLnBhdGh3YXlJZCkgPT09IC0xKSB7XG4gICAgICAgICAgICBwYXRod2F5cy5wdXNoKGxldmVsLnBhdGh3YXlJZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwYXRod2F5cztcbiAgICAgICAgfSwgW10pO1xuICAgICAgfVxuICAgICAgaWYgKHBhdGh3YXlQcmlvcml0eSAmJiBwYXRod2F5UHJpb3JpdHkubGVuZ3RoID4gMSkge1xuICAgICAgICB0aGlzLnVwZGF0ZVBhdGh3YXlQcmlvcml0eShwYXRod2F5UHJpb3JpdHkpO1xuICAgICAgICBlcnJvckFjdGlvbi5yZXNvbHZlZCA9IHRoaXMucGF0aHdheUlkICE9PSBlcnJvclBhdGh3YXk7XG4gICAgICB9XG4gICAgICBpZiAoIWVycm9yQWN0aW9uLnJlc29sdmVkKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKGBDb3VsZCBub3QgcmVzb2x2ZSAke2RhdGEuZGV0YWlsc30gKFwiJHtkYXRhLmVycm9yLm1lc3NhZ2V9XCIpIHdpdGggY29udGVudC1zdGVlcmluZyBmb3IgUGF0aHdheTogJHtlcnJvclBhdGh3YXl9IGxldmVsczogJHtsZXZlbHMgPyBsZXZlbHMubGVuZ3RoIDogbGV2ZWxzfSBwcmlvcml0aWVzOiAke0pTT04uc3RyaW5naWZ5KHBhdGh3YXlQcmlvcml0eSl9IHBlbmFsaXplZDogJHtKU09OLnN0cmluZ2lmeSh0aGlzLnBlbmFsaXplZFBhdGh3YXlzKX1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZmlsdGVyUGFyc2VkTGV2ZWxzKGxldmVscykge1xuICAgIC8vIEZpbHRlciBsZXZlbHMgdG8gb25seSBpbmNsdWRlIHRob3NlIHRoYXQgYXJlIGluIHRoZSBpbml0aWFsIHBhdGh3YXlcbiAgICB0aGlzLmxldmVscyA9IGxldmVscztcbiAgICBsZXQgcGF0aHdheUxldmVscyA9IHRoaXMuZ2V0TGV2ZWxzRm9yUGF0aHdheSh0aGlzLnBhdGh3YXlJZCk7XG4gICAgaWYgKHBhdGh3YXlMZXZlbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb25zdCBwYXRod2F5SWQgPSBsZXZlbHNbMF0ucGF0aHdheUlkO1xuICAgICAgdGhpcy5sb2coYE5vIGxldmVscyBmb3VuZCBpbiBQYXRod2F5ICR7dGhpcy5wYXRod2F5SWR9LiBTZXR0aW5nIGluaXRpYWwgUGF0aHdheSB0byBcIiR7cGF0aHdheUlkfVwiYCk7XG4gICAgICBwYXRod2F5TGV2ZWxzID0gdGhpcy5nZXRMZXZlbHNGb3JQYXRod2F5KHBhdGh3YXlJZCk7XG4gICAgICB0aGlzLnBhdGh3YXlJZCA9IHBhdGh3YXlJZDtcbiAgICB9XG4gICAgaWYgKHBhdGh3YXlMZXZlbHMubGVuZ3RoICE9PSBsZXZlbHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmxvZyhgRm91bmQgJHtwYXRod2F5TGV2ZWxzLmxlbmd0aH0vJHtsZXZlbHMubGVuZ3RofSBsZXZlbHMgaW4gUGF0aHdheSBcIiR7dGhpcy5wYXRod2F5SWR9XCJgKTtcbiAgICAgIHJldHVybiBwYXRod2F5TGV2ZWxzO1xuICAgIH1cbiAgICByZXR1cm4gbGV2ZWxzO1xuICB9XG4gIGdldExldmVsc0ZvclBhdGh3YXkocGF0aHdheUlkKSB7XG4gICAgaWYgKHRoaXMubGV2ZWxzID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxldmVscy5maWx0ZXIobGV2ZWwgPT4gcGF0aHdheUlkID09PSBsZXZlbC5wYXRod2F5SWQpO1xuICB9XG4gIHVwZGF0ZVBhdGh3YXlQcmlvcml0eShwYXRod2F5UHJpb3JpdHkpIHtcbiAgICB0aGlzLnBhdGh3YXlQcmlvcml0eSA9IHBhdGh3YXlQcmlvcml0eTtcbiAgICBsZXQgbGV2ZWxzO1xuXG4gICAgLy8gRXZhbHVhdGUgaWYgd2Ugc2hvdWxkIHJlbW92ZSB0aGUgcGF0aHdheSBmcm9tIHRoZSBwZW5hbGl6ZWQgbGlzdFxuICAgIGNvbnN0IHBlbmFsaXplZFBhdGh3YXlzID0gdGhpcy5wZW5hbGl6ZWRQYXRod2F5cztcbiAgICBjb25zdCBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBPYmplY3Qua2V5cyhwZW5hbGl6ZWRQYXRod2F5cykuZm9yRWFjaChwYXRod2F5SWQgPT4ge1xuICAgICAgaWYgKG5vdyAtIHBlbmFsaXplZFBhdGh3YXlzW3BhdGh3YXlJZF0gPiBQQVRIV0FZX1BFTkFMVFlfRFVSQVRJT05fTVMpIHtcbiAgICAgICAgZGVsZXRlIHBlbmFsaXplZFBhdGh3YXlzW3BhdGh3YXlJZF07XG4gICAgICB9XG4gICAgfSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRod2F5UHJpb3JpdHkubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBhdGh3YXlJZCA9IHBhdGh3YXlQcmlvcml0eVtpXTtcbiAgICAgIGlmIChwYXRod2F5SWQgaW4gcGVuYWxpemVkUGF0aHdheXMpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocGF0aHdheUlkID09PSB0aGlzLnBhdGh3YXlJZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzZWxlY3RlZEluZGV4ID0gdGhpcy5obHMubmV4dExvYWRMZXZlbDtcbiAgICAgIGNvbnN0IHNlbGVjdGVkTGV2ZWwgPSB0aGlzLmhscy5sZXZlbHNbc2VsZWN0ZWRJbmRleF07XG4gICAgICBsZXZlbHMgPSB0aGlzLmdldExldmVsc0ZvclBhdGh3YXkocGF0aHdheUlkKTtcbiAgICAgIGlmIChsZXZlbHMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmxvZyhgU2V0dGluZyBQYXRod2F5IHRvIFwiJHtwYXRod2F5SWR9XCJgKTtcbiAgICAgICAgdGhpcy5wYXRod2F5SWQgPSBwYXRod2F5SWQ7XG4gICAgICAgIHJlYXNzaWduRnJhZ21lbnRMZXZlbEluZGV4ZXMobGV2ZWxzKTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTEVWRUxTX1VQREFURUQsIHtcbiAgICAgICAgICBsZXZlbHNcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFNldCBMZXZlbENvbnRyb2xsZXIncyBsZXZlbCB0byB0cmlnZ2VyIExFVkVMX1NXSVRDSElORyB3aGljaCBsb2FkcyBwbGF5bGlzdCBpZiBuZWVkZWRcbiAgICAgICAgY29uc3QgbGV2ZWxBZnRlckNoYW5nZSA9IHRoaXMuaGxzLmxldmVsc1tzZWxlY3RlZEluZGV4XTtcbiAgICAgICAgaWYgKHNlbGVjdGVkTGV2ZWwgJiYgbGV2ZWxBZnRlckNoYW5nZSAmJiB0aGlzLmxldmVscykge1xuICAgICAgICAgIGlmIChsZXZlbEFmdGVyQ2hhbmdlLmF0dHJzWydTVEFCTEUtVkFSSUFOVC1JRCddICE9PSBzZWxlY3RlZExldmVsLmF0dHJzWydTVEFCTEUtVkFSSUFOVC1JRCddICYmIGxldmVsQWZ0ZXJDaGFuZ2UuYml0cmF0ZSAhPT0gc2VsZWN0ZWRMZXZlbC5iaXRyYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmxvZyhgVW5zdGFibGUgUGF0aHdheXMgY2hhbmdlIGZyb20gYml0cmF0ZSAke3NlbGVjdGVkTGV2ZWwuYml0cmF0ZX0gdG8gJHtsZXZlbEFmdGVyQ2hhbmdlLmJpdHJhdGV9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuaGxzLm5leHRMb2FkTGV2ZWwgPSBzZWxlY3RlZEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXRQYXRod2F5Rm9yR3JvdXBJZChncm91cElkLCB0eXBlLCBkZWZhdWx0UGF0aHdheSkge1xuICAgIGNvbnN0IGxldmVscyA9IHRoaXMuZ2V0TGV2ZWxzRm9yUGF0aHdheShkZWZhdWx0UGF0aHdheSkuY29uY2F0KHRoaXMubGV2ZWxzIHx8IFtdKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxldmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuQVVESU9fVFJBQ0sgJiYgbGV2ZWxzW2ldLmhhc0F1ZGlvR3JvdXAoZ3JvdXBJZCkgfHwgdHlwZSA9PT0gUGxheWxpc3RDb250ZXh0VHlwZS5TVUJUSVRMRV9UUkFDSyAmJiBsZXZlbHNbaV0uaGFzU3VidGl0bGVHcm91cChncm91cElkKSkge1xuICAgICAgICByZXR1cm4gbGV2ZWxzW2ldLnBhdGh3YXlJZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRQYXRod2F5O1xuICB9XG4gIGNsb25lUGF0aHdheXMocGF0aHdheUNsb25lcykge1xuICAgIGNvbnN0IGxldmVscyA9IHRoaXMubGV2ZWxzO1xuICAgIGlmICghbGV2ZWxzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGF1ZGlvR3JvdXBDbG9uZU1hcCA9IHt9O1xuICAgIGNvbnN0IHN1YnRpdGxlR3JvdXBDbG9uZU1hcCA9IHt9O1xuICAgIHBhdGh3YXlDbG9uZXMuZm9yRWFjaChwYXRod2F5Q2xvbmUgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBJRDogY2xvbmVJZCxcbiAgICAgICAgJ0JBU0UtSUQnOiBiYXNlSWQsXG4gICAgICAgICdVUkktUkVQTEFDRU1FTlQnOiB1cmlSZXBsYWNlbWVudFxuICAgICAgfSA9IHBhdGh3YXlDbG9uZTtcbiAgICAgIGlmIChsZXZlbHMuc29tZShsZXZlbCA9PiBsZXZlbC5wYXRod2F5SWQgPT09IGNsb25lSWQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNsb25lZFZhcmlhbnRzID0gdGhpcy5nZXRMZXZlbHNGb3JQYXRod2F5KGJhc2VJZCkubWFwKGJhc2VMZXZlbCA9PiB7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBuZXcgQXR0ckxpc3QoYmFzZUxldmVsLmF0dHJzKTtcbiAgICAgICAgYXR0cmlidXRlc1snUEFUSFdBWS1JRCddID0gY2xvbmVJZDtcbiAgICAgICAgY29uc3QgY2xvbmVkQXVkaW9Hcm91cElkID0gYXR0cmlidXRlcy5BVURJTyAmJiBgJHthdHRyaWJ1dGVzLkFVRElPfV9jbG9uZV8ke2Nsb25lSWR9YDtcbiAgICAgICAgY29uc3QgY2xvbmVkU3VidGl0bGVHcm91cElkID0gYXR0cmlidXRlcy5TVUJUSVRMRVMgJiYgYCR7YXR0cmlidXRlcy5TVUJUSVRMRVN9X2Nsb25lXyR7Y2xvbmVJZH1gO1xuICAgICAgICBpZiAoY2xvbmVkQXVkaW9Hcm91cElkKSB7XG4gICAgICAgICAgYXVkaW9Hcm91cENsb25lTWFwW2F0dHJpYnV0ZXMuQVVESU9dID0gY2xvbmVkQXVkaW9Hcm91cElkO1xuICAgICAgICAgIGF0dHJpYnV0ZXMuQVVESU8gPSBjbG9uZWRBdWRpb0dyb3VwSWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsb25lZFN1YnRpdGxlR3JvdXBJZCkge1xuICAgICAgICAgIHN1YnRpdGxlR3JvdXBDbG9uZU1hcFthdHRyaWJ1dGVzLlNVQlRJVExFU10gPSBjbG9uZWRTdWJ0aXRsZUdyb3VwSWQ7XG4gICAgICAgICAgYXR0cmlidXRlcy5TVUJUSVRMRVMgPSBjbG9uZWRTdWJ0aXRsZUdyb3VwSWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJsID0gcGVyZm9ybVVyaVJlcGxhY2VtZW50KGJhc2VMZXZlbC51cmksIGF0dHJpYnV0ZXNbJ1NUQUJMRS1WQVJJQU5ULUlEJ10sICdQRVItVkFSSUFOVC1VUklTJywgdXJpUmVwbGFjZW1lbnQpO1xuICAgICAgICBjb25zdCBjbG9uZWRMZXZlbCA9IG5ldyBMZXZlbCh7XG4gICAgICAgICAgYXR0cnM6IGF0dHJpYnV0ZXMsXG4gICAgICAgICAgYXVkaW9Db2RlYzogYmFzZUxldmVsLmF1ZGlvQ29kZWMsXG4gICAgICAgICAgYml0cmF0ZTogYmFzZUxldmVsLmJpdHJhdGUsXG4gICAgICAgICAgaGVpZ2h0OiBiYXNlTGV2ZWwuaGVpZ2h0LFxuICAgICAgICAgIG5hbWU6IGJhc2VMZXZlbC5uYW1lLFxuICAgICAgICAgIHVybCxcbiAgICAgICAgICB2aWRlb0NvZGVjOiBiYXNlTGV2ZWwudmlkZW9Db2RlYyxcbiAgICAgICAgICB3aWR0aDogYmFzZUxldmVsLndpZHRoXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoYmFzZUxldmVsLmF1ZGlvR3JvdXBzKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBiYXNlTGV2ZWwuYXVkaW9Hcm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNsb25lZExldmVsLmFkZEdyb3VwSWQoJ2F1ZGlvJywgYCR7YmFzZUxldmVsLmF1ZGlvR3JvdXBzW2ldfV9jbG9uZV8ke2Nsb25lSWR9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChiYXNlTGV2ZWwuc3VidGl0bGVHcm91cHMpIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGJhc2VMZXZlbC5zdWJ0aXRsZUdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2xvbmVkTGV2ZWwuYWRkR3JvdXBJZCgndGV4dCcsIGAke2Jhc2VMZXZlbC5zdWJ0aXRsZUdyb3Vwc1tpXX1fY2xvbmVfJHtjbG9uZUlkfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xvbmVkTGV2ZWw7XG4gICAgICB9KTtcbiAgICAgIGxldmVscy5wdXNoKC4uLmNsb25lZFZhcmlhbnRzKTtcbiAgICAgIGNsb25lUmVuZGl0aW9uR3JvdXBzKHRoaXMuYXVkaW9UcmFja3MsIGF1ZGlvR3JvdXBDbG9uZU1hcCwgdXJpUmVwbGFjZW1lbnQsIGNsb25lSWQpO1xuICAgICAgY2xvbmVSZW5kaXRpb25Hcm91cHModGhpcy5zdWJ0aXRsZVRyYWNrcywgc3VidGl0bGVHcm91cENsb25lTWFwLCB1cmlSZXBsYWNlbWVudCwgY2xvbmVJZCk7XG4gICAgfSk7XG4gIH1cbiAgbG9hZFN0ZWVyaW5nTWFuaWZlc3QodXJpKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5obHMuY29uZmlnO1xuICAgIGNvbnN0IExvYWRlciA9IGNvbmZpZy5sb2FkZXI7XG4gICAgaWYgKHRoaXMubG9hZGVyKSB7XG4gICAgICB0aGlzLmxvYWRlci5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMubG9hZGVyID0gbmV3IExvYWRlcihjb25maWcpO1xuICAgIGxldCB1cmw7XG4gICAgdHJ5IHtcbiAgICAgIHVybCA9IG5ldyBzZWxmLlVSTCh1cmkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMubG9nKGBGYWlsZWQgdG8gcGFyc2UgU3RlZXJpbmcgTWFuaWZlc3QgVVJJOiAke3VyaX1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHVybC5wcm90b2NvbCAhPT0gJ2RhdGE6Jykge1xuICAgICAgY29uc3QgdGhyb3VnaHB1dCA9ICh0aGlzLmhscy5iYW5kd2lkdGhFc3RpbWF0ZSB8fCBjb25maWcuYWJyRXdtYURlZmF1bHRFc3RpbWF0ZSkgfCAwO1xuICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ19ITFNfcGF0aHdheScsIHRoaXMucGF0aHdheUlkKTtcbiAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdfSExTX3Rocm91Z2hwdXQnLCAnJyArIHRocm91Z2hwdXQpO1xuICAgIH1cbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgcmVzcG9uc2VUeXBlOiAnanNvbicsXG4gICAgICB1cmw6IHVybC5ocmVmXG4gICAgfTtcbiAgICBjb25zdCBsb2FkUG9saWN5ID0gY29uZmlnLnN0ZWVyaW5nTWFuaWZlc3RMb2FkUG9saWN5LmRlZmF1bHQ7XG4gICAgY29uc3QgbGVnYWN5UmV0cnlDb21wYXRpYmlsaXR5ID0gbG9hZFBvbGljeS5lcnJvclJldHJ5IHx8IGxvYWRQb2xpY3kudGltZW91dFJldHJ5IHx8IHt9O1xuICAgIGNvbnN0IGxvYWRlckNvbmZpZyA9IHtcbiAgICAgIGxvYWRQb2xpY3ksXG4gICAgICB0aW1lb3V0OiBsb2FkUG9saWN5Lm1heExvYWRUaW1lTXMsXG4gICAgICBtYXhSZXRyeTogbGVnYWN5UmV0cnlDb21wYXRpYmlsaXR5Lm1heE51bVJldHJ5IHx8IDAsXG4gICAgICByZXRyeURlbGF5OiBsZWdhY3lSZXRyeUNvbXBhdGliaWxpdHkucmV0cnlEZWxheU1zIHx8IDAsXG4gICAgICBtYXhSZXRyeURlbGF5OiBsZWdhY3lSZXRyeUNvbXBhdGliaWxpdHkubWF4UmV0cnlEZWxheU1zIHx8IDBcbiAgICB9O1xuICAgIGNvbnN0IGNhbGxiYWNrcyA9IHtcbiAgICAgIG9uU3VjY2VzczogKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpID0+IHtcbiAgICAgICAgdGhpcy5sb2coYExvYWRlZCBzdGVlcmluZyBtYW5pZmVzdDogXCIke3VybH1cImApO1xuICAgICAgICBjb25zdCBzdGVlcmluZ0RhdGEgPSByZXNwb25zZS5kYXRhO1xuICAgICAgICBpZiAoc3RlZXJpbmdEYXRhLlZFUlNJT04gIT09IDEpIHtcbiAgICAgICAgICB0aGlzLmxvZyhgU3RlZXJpbmcgVkVSU0lPTiAke3N0ZWVyaW5nRGF0YS5WRVJTSU9OfSBub3Qgc3VwcG9ydGVkIWApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZWQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgdGhpcy50aW1lVG9Mb2FkID0gc3RlZXJpbmdEYXRhLlRUTDtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICdSRUxPQUQtVVJJJzogcmVsb2FkVXJpLFxuICAgICAgICAgICdQQVRIV0FZLUNMT05FUyc6IHBhdGh3YXlDbG9uZXMsXG4gICAgICAgICAgJ1BBVEhXQVktUFJJT1JJVFknOiBwYXRod2F5UHJpb3JpdHlcbiAgICAgICAgfSA9IHN0ZWVyaW5nRGF0YTtcbiAgICAgICAgaWYgKHJlbG9hZFVyaSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnVyaSA9IG5ldyBzZWxmLlVSTChyZWxvYWRVcmksIHVybCkuaHJlZjtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmxvZyhgRmFpbGVkIHRvIHBhcnNlIFN0ZWVyaW5nIE1hbmlmZXN0IFJFTE9BRC1VUkk6ICR7cmVsb2FkVXJpfWApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjaGVkdWxlUmVmcmVzaCh0aGlzLnVyaSB8fCBjb250ZXh0LnVybCk7XG4gICAgICAgIGlmIChwYXRod2F5Q2xvbmVzKSB7XG4gICAgICAgICAgdGhpcy5jbG9uZVBhdGh3YXlzKHBhdGh3YXlDbG9uZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxvYWRlZFN0ZWVyaW5nRGF0YSA9IHtcbiAgICAgICAgICBzdGVlcmluZ01hbmlmZXN0OiBzdGVlcmluZ0RhdGEsXG4gICAgICAgICAgdXJsOiB1cmwudG9TdHJpbmcoKVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5TVEVFUklOR19NQU5JRkVTVF9MT0FERUQsIGxvYWRlZFN0ZWVyaW5nRGF0YSk7XG4gICAgICAgIGlmIChwYXRod2F5UHJpb3JpdHkpIHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZVBhdGh3YXlQcmlvcml0eShwYXRod2F5UHJpb3JpdHkpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25FcnJvcjogKGVycm9yLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscywgc3RhdHMpID0+IHtcbiAgICAgICAgdGhpcy5sb2coYEVycm9yIGxvYWRpbmcgc3RlZXJpbmcgbWFuaWZlc3Q6ICR7ZXJyb3IuY29kZX0gJHtlcnJvci50ZXh0fSAoJHtjb250ZXh0LnVybH0pYCk7XG4gICAgICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IDQxMCkge1xuICAgICAgICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMubG9nKGBTdGVlcmluZyBtYW5pZmVzdCAke2NvbnRleHQudXJsfSBubyBsb25nZXIgYXZhaWxhYmxlYCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0dGwgPSB0aGlzLnRpbWVUb0xvYWQgKiAxMDAwO1xuICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gNDI5KSB7XG4gICAgICAgICAgY29uc3QgbG9hZGVyID0gdGhpcy5sb2FkZXI7XG4gICAgICAgICAgaWYgKHR5cGVvZiAobG9hZGVyID09IG51bGwgPyB2b2lkIDAgOiBsb2FkZXIuZ2V0UmVzcG9uc2VIZWFkZXIpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zdCByZXRyeUFmdGVyID0gbG9hZGVyLmdldFJlc3BvbnNlSGVhZGVyKCdSZXRyeS1BZnRlcicpO1xuICAgICAgICAgICAgaWYgKHJldHJ5QWZ0ZXIpIHtcbiAgICAgICAgICAgICAgdHRsID0gcGFyc2VGbG9hdChyZXRyeUFmdGVyKSAqIDEwMDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubG9nKGBTdGVlcmluZyBtYW5pZmVzdCAke2NvbnRleHQudXJsfSByYXRlIGxpbWl0ZWRgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zY2hlZHVsZVJlZnJlc2godGhpcy51cmkgfHwgY29udGV4dC51cmwsIHR0bCk7XG4gICAgICB9LFxuICAgICAgb25UaW1lb3V0OiAoc3RhdHMsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzKSA9PiB7XG4gICAgICAgIHRoaXMubG9nKGBUaW1lb3V0IGxvYWRpbmcgc3RlZXJpbmcgbWFuaWZlc3QgKCR7Y29udGV4dC51cmx9KWApO1xuICAgICAgICB0aGlzLnNjaGVkdWxlUmVmcmVzaCh0aGlzLnVyaSB8fCBjb250ZXh0LnVybCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmxvZyhgUmVxdWVzdGluZyBzdGVlcmluZyBtYW5pZmVzdDogJHt1cmx9YCk7XG4gICAgdGhpcy5sb2FkZXIubG9hZChjb250ZXh0LCBsb2FkZXJDb25maWcsIGNhbGxiYWNrcyk7XG4gIH1cbiAgc2NoZWR1bGVSZWZyZXNoKHVyaSwgdHRsTXMgPSB0aGlzLnRpbWVUb0xvYWQgKiAxMDAwKSB7XG4gICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgICB0aGlzLnJlbG9hZFRpbWVyID0gc2VsZi5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHZhciBfdGhpcyRobHM7XG4gICAgICBjb25zdCBtZWRpYSA9IChfdGhpcyRobHMgPSB0aGlzLmhscykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGhscy5tZWRpYTtcbiAgICAgIGlmIChtZWRpYSAmJiAhbWVkaWEuZW5kZWQpIHtcbiAgICAgICAgdGhpcy5sb2FkU3RlZXJpbmdNYW5pZmVzdCh1cmkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnNjaGVkdWxlUmVmcmVzaCh1cmksIHRoaXMudGltZVRvTG9hZCAqIDEwMDApO1xuICAgIH0sIHR0bE1zKTtcbiAgfVxufVxuZnVuY3Rpb24gY2xvbmVSZW5kaXRpb25Hcm91cHModHJhY2tzLCBncm91cENsb25lTWFwLCB1cmlSZXBsYWNlbWVudCwgY2xvbmVJZCkge1xuICBpZiAoIXRyYWNrcykge1xuICAgIHJldHVybjtcbiAgfVxuICBPYmplY3Qua2V5cyhncm91cENsb25lTWFwKS5mb3JFYWNoKGF1ZGlvR3JvdXBJZCA9PiB7XG4gICAgY29uc3QgY2xvbmVkVHJhY2tzID0gdHJhY2tzLmZpbHRlcih0cmFjayA9PiB0cmFjay5ncm91cElkID09PSBhdWRpb0dyb3VwSWQpLm1hcCh0cmFjayA9PiB7XG4gICAgICBjb25zdCBjbG9uZWRUcmFjayA9IF9leHRlbmRzKHt9LCB0cmFjayk7XG4gICAgICBjbG9uZWRUcmFjay5kZXRhaWxzID0gdW5kZWZpbmVkO1xuICAgICAgY2xvbmVkVHJhY2suYXR0cnMgPSBuZXcgQXR0ckxpc3QoY2xvbmVkVHJhY2suYXR0cnMpO1xuICAgICAgY2xvbmVkVHJhY2sudXJsID0gY2xvbmVkVHJhY2suYXR0cnMuVVJJID0gcGVyZm9ybVVyaVJlcGxhY2VtZW50KHRyYWNrLnVybCwgdHJhY2suYXR0cnNbJ1NUQUJMRS1SRU5ESVRJT04tSUQnXSwgJ1BFUi1SRU5ESVRJT04tVVJJUycsIHVyaVJlcGxhY2VtZW50KTtcbiAgICAgIGNsb25lZFRyYWNrLmdyb3VwSWQgPSBjbG9uZWRUcmFjay5hdHRyc1snR1JPVVAtSUQnXSA9IGdyb3VwQ2xvbmVNYXBbYXVkaW9Hcm91cElkXTtcbiAgICAgIGNsb25lZFRyYWNrLmF0dHJzWydQQVRIV0FZLUlEJ10gPSBjbG9uZUlkO1xuICAgICAgcmV0dXJuIGNsb25lZFRyYWNrO1xuICAgIH0pO1xuICAgIHRyYWNrcy5wdXNoKC4uLmNsb25lZFRyYWNrcyk7XG4gIH0pO1xufVxuZnVuY3Rpb24gcGVyZm9ybVVyaVJlcGxhY2VtZW50KHVyaSwgc3RhYmxlSWQsIHBlck9wdGlvbktleSwgdXJpUmVwbGFjZW1lbnQpIHtcbiAgY29uc3Qge1xuICAgIEhPU1Q6IGhvc3QsXG4gICAgUEFSQU1TOiBwYXJhbXMsXG4gICAgW3Blck9wdGlvbktleV06IHBlck9wdGlvblVyaXNcbiAgfSA9IHVyaVJlcGxhY2VtZW50O1xuICBsZXQgcGVyVmFyaWFudFVyaTtcbiAgaWYgKHN0YWJsZUlkKSB7XG4gICAgcGVyVmFyaWFudFVyaSA9IHBlck9wdGlvblVyaXMgPT0gbnVsbCA/IHZvaWQgMCA6IHBlck9wdGlvblVyaXNbc3RhYmxlSWRdO1xuICAgIGlmIChwZXJWYXJpYW50VXJpKSB7XG4gICAgICB1cmkgPSBwZXJWYXJpYW50VXJpO1xuICAgIH1cbiAgfVxuICBjb25zdCB1cmwgPSBuZXcgc2VsZi5VUkwodXJpKTtcbiAgaWYgKGhvc3QgJiYgIXBlclZhcmlhbnRVcmkpIHtcbiAgICB1cmwuaG9zdCA9IGhvc3Q7XG4gIH1cbiAgaWYgKHBhcmFtcykge1xuICAgIE9iamVjdC5rZXlzKHBhcmFtcykuc29ydCgpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoa2V5LCBwYXJhbXNba2V5XSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHVybC5ocmVmO1xufVxuXG5jb25zdCBBR0VfSEVBREVSX0xJTkVfUkVHRVggPSAvXmFnZTpcXHMqW1xcZC5dK1xccyokL2ltO1xuY2xhc3MgWGhyTG9hZGVyIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdGhpcy54aHJTZXR1cCA9IHZvaWQgMDtcbiAgICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gdm9pZCAwO1xuICAgIHRoaXMucmV0cnlUaW1lb3V0ID0gdm9pZCAwO1xuICAgIHRoaXMucmV0cnlEZWxheSA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbmZpZyA9IG51bGw7XG4gICAgdGhpcy5jYWxsYmFja3MgPSBudWxsO1xuICAgIHRoaXMuY29udGV4dCA9IG51bGw7XG4gICAgdGhpcy5sb2FkZXIgPSBudWxsO1xuICAgIHRoaXMuc3RhdHMgPSB2b2lkIDA7XG4gICAgdGhpcy54aHJTZXR1cCA9IGNvbmZpZyA/IGNvbmZpZy54aHJTZXR1cCB8fCBudWxsIDogbnVsbDtcbiAgICB0aGlzLnN0YXRzID0gbmV3IExvYWRTdGF0cygpO1xuICAgIHRoaXMucmV0cnlEZWxheSA9IDA7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmNhbGxiYWNrcyA9IG51bGw7XG4gICAgdGhpcy5hYm9ydEludGVybmFsKCk7XG4gICAgdGhpcy5sb2FkZXIgPSBudWxsO1xuICAgIHRoaXMuY29uZmlnID0gbnVsbDtcbiAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICAgIHRoaXMueGhyU2V0dXAgPSBudWxsO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLnN0YXRzID0gbnVsbDtcbiAgfVxuICBhYm9ydEludGVybmFsKCkge1xuICAgIGNvbnN0IGxvYWRlciA9IHRoaXMubG9hZGVyO1xuICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmVxdWVzdFRpbWVvdXQpO1xuICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmV0cnlUaW1lb3V0KTtcbiAgICBpZiAobG9hZGVyKSB7XG4gICAgICBsb2FkZXIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgIGxvYWRlci5vbnByb2dyZXNzID0gbnVsbDtcbiAgICAgIGlmIChsb2FkZXIucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgICB0aGlzLnN0YXRzLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgICBsb2FkZXIuYWJvcnQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYWJvcnQoKSB7XG4gICAgdmFyIF90aGlzJGNhbGxiYWNrcztcbiAgICB0aGlzLmFib3J0SW50ZXJuYWwoKTtcbiAgICBpZiAoKF90aGlzJGNhbGxiYWNrcyA9IHRoaXMuY2FsbGJhY2tzKSAhPSBudWxsICYmIF90aGlzJGNhbGxiYWNrcy5vbkFib3J0KSB7XG4gICAgICB0aGlzLmNhbGxiYWNrcy5vbkFib3J0KHRoaXMuc3RhdHMsIHRoaXMuY29udGV4dCwgdGhpcy5sb2FkZXIpO1xuICAgIH1cbiAgfVxuICBsb2FkKGNvbnRleHQsIGNvbmZpZywgY2FsbGJhY2tzKSB7XG4gICAgaWYgKHRoaXMuc3RhdHMubG9hZGluZy5zdGFydCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdMb2FkZXIgY2FuIG9ubHkgYmUgdXNlZCBvbmNlLicpO1xuICAgIH1cbiAgICB0aGlzLnN0YXRzLmxvYWRpbmcuc3RhcnQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5jYWxsYmFja3MgPSBjYWxsYmFja3M7XG4gICAgdGhpcy5sb2FkSW50ZXJuYWwoKTtcbiAgfVxuICBsb2FkSW50ZXJuYWwoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29uZmlnLFxuICAgICAgY29udGV4dFxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghY29uZmlnIHx8ICFjb250ZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHhociA9IHRoaXMubG9hZGVyID0gbmV3IHNlbGYuWE1MSHR0cFJlcXVlc3QoKTtcbiAgICBjb25zdCBzdGF0cyA9IHRoaXMuc3RhdHM7XG4gICAgc3RhdHMubG9hZGluZy5maXJzdCA9IDA7XG4gICAgc3RhdHMubG9hZGVkID0gMDtcbiAgICBzdGF0cy5hYm9ydGVkID0gZmFsc2U7XG4gICAgY29uc3QgeGhyU2V0dXAgPSB0aGlzLnhoclNldHVwO1xuICAgIGlmICh4aHJTZXR1cCkge1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRzLmFib3J0ZWQpIHJldHVybjtcbiAgICAgICAgcmV0dXJuIHhoclNldHVwKHhociwgY29udGV4dC51cmwpO1xuICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICB4aHIub3BlbignR0VUJywgY29udGV4dC51cmwsIHRydWUpO1xuICAgICAgICByZXR1cm4geGhyU2V0dXAoeGhyLCBjb250ZXh0LnVybCk7XG4gICAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHMuYWJvcnRlZCkgcmV0dXJuO1xuICAgICAgICB0aGlzLm9wZW5BbmRTZW5kWGhyKHhociwgY29udGV4dCwgY29uZmlnKTtcbiAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgLy8gSUUxMSB0aHJvd3MgYW4gZXhjZXB0aW9uIG9uIHhoci5vcGVuIGlmIGF0dGVtcHRpbmcgdG8gYWNjZXNzIGFuIEhUVFAgcmVzb3VyY2Ugb3ZlciBIVFRQU1xuICAgICAgICB0aGlzLmNhbGxiYWNrcy5vbkVycm9yKHtcbiAgICAgICAgICBjb2RlOiB4aHIuc3RhdHVzLFxuICAgICAgICAgIHRleHQ6IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgfSwgY29udGV4dCwgeGhyLCBzdGF0cyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9wZW5BbmRTZW5kWGhyKHhociwgY29udGV4dCwgY29uZmlnKTtcbiAgICB9XG4gIH1cbiAgb3BlbkFuZFNlbmRYaHIoeGhyLCBjb250ZXh0LCBjb25maWcpIHtcbiAgICBpZiAoIXhoci5yZWFkeVN0YXRlKSB7XG4gICAgICB4aHIub3BlbignR0VUJywgY29udGV4dC51cmwsIHRydWUpO1xuICAgIH1cbiAgICBjb25zdCBoZWFkZXJzID0gY29udGV4dC5oZWFkZXJzO1xuICAgIGNvbnN0IHtcbiAgICAgIG1heFRpbWVUb0ZpcnN0Qnl0ZU1zLFxuICAgICAgbWF4TG9hZFRpbWVNc1xuICAgIH0gPSBjb25maWcubG9hZFBvbGljeTtcbiAgICBpZiAoaGVhZGVycykge1xuICAgICAgZm9yIChjb25zdCBoZWFkZXIgaW4gaGVhZGVycykge1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihoZWFkZXIsIGhlYWRlcnNbaGVhZGVyXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb250ZXh0LnJhbmdlRW5kKSB7XG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignUmFuZ2UnLCAnYnl0ZXM9JyArIGNvbnRleHQucmFuZ2VTdGFydCArICctJyArIChjb250ZXh0LnJhbmdlRW5kIC0gMSkpO1xuICAgIH1cbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gdGhpcy5yZWFkeXN0YXRlY2hhbmdlLmJpbmQodGhpcyk7XG4gICAgeGhyLm9ucHJvZ3Jlc3MgPSB0aGlzLmxvYWRwcm9ncmVzcy5iaW5kKHRoaXMpO1xuICAgIHhoci5yZXNwb25zZVR5cGUgPSBjb250ZXh0LnJlc3BvbnNlVHlwZTtcbiAgICAvLyBzZXR1cCB0aW1lb3V0IGJlZm9yZSB3ZSBwZXJmb3JtIHJlcXVlc3RcbiAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KTtcbiAgICBjb25maWcudGltZW91dCA9IG1heFRpbWVUb0ZpcnN0Qnl0ZU1zICYmIGlzRmluaXRlTnVtYmVyKG1heFRpbWVUb0ZpcnN0Qnl0ZU1zKSA/IG1heFRpbWVUb0ZpcnN0Qnl0ZU1zIDogbWF4TG9hZFRpbWVNcztcbiAgICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gc2VsZi5zZXRUaW1lb3V0KHRoaXMubG9hZHRpbWVvdXQuYmluZCh0aGlzKSwgY29uZmlnLnRpbWVvdXQpO1xuICAgIHhoci5zZW5kKCk7XG4gIH1cbiAgcmVhZHlzdGF0ZWNoYW5nZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb250ZXh0LFxuICAgICAgbG9hZGVyOiB4aHIsXG4gICAgICBzdGF0c1xuICAgIH0gPSB0aGlzO1xuICAgIGlmICghY29udGV4dCB8fCAheGhyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlYWR5U3RhdGUgPSB4aHIucmVhZHlTdGF0ZTtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcblxuICAgIC8vIGRvbid0IHByb2NlZWQgaWYgeGhyIGhhcyBiZWVuIGFib3J0ZWRcbiAgICBpZiAoc3RhdHMuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vID49IEhFQURFUlNfUkVDRUlWRURcbiAgICBpZiAocmVhZHlTdGF0ZSA+PSAyKSB7XG4gICAgICBpZiAoc3RhdHMubG9hZGluZy5maXJzdCA9PT0gMCkge1xuICAgICAgICBzdGF0cy5sb2FkaW5nLmZpcnN0ID0gTWF0aC5tYXgoc2VsZi5wZXJmb3JtYW5jZS5ub3coKSwgc3RhdHMubG9hZGluZy5zdGFydCk7XG4gICAgICAgIC8vIHJlYWR5U3RhdGUgPj0gMiBBTkQgcmVhZHlTdGF0ZSAhPT00IChyZWFkeVN0YXRlID0gSEVBREVSU19SRUNFSVZFRCB8fCBMT0FESU5HKSByZWFybSB0aW1lb3V0IGFzIHhociBub3QgZmluaXNoZWQgeWV0XG4gICAgICAgIGlmIChjb25maWcudGltZW91dCAhPT0gY29uZmlnLmxvYWRQb2xpY3kubWF4TG9hZFRpbWVNcykge1xuICAgICAgICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmVxdWVzdFRpbWVvdXQpO1xuICAgICAgICAgIGNvbmZpZy50aW1lb3V0ID0gY29uZmlnLmxvYWRQb2xpY3kubWF4TG9hZFRpbWVNcztcbiAgICAgICAgICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gc2VsZi5zZXRUaW1lb3V0KHRoaXMubG9hZHRpbWVvdXQuYmluZCh0aGlzKSwgY29uZmlnLmxvYWRQb2xpY3kubWF4TG9hZFRpbWVNcyAtIChzdGF0cy5sb2FkaW5nLmZpcnN0IC0gc3RhdHMubG9hZGluZy5zdGFydCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KTtcbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgIHhoci5vbnByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0geGhyLnN0YXR1cztcbiAgICAgICAgLy8gaHR0cCBzdGF0dXMgYmV0d2VlbiAyMDAgdG8gMjk5IGFyZSBhbGwgc3VjY2Vzc2Z1bFxuICAgICAgICBjb25zdCB1c2VSZXNwb25zZSA9IHhoci5yZXNwb25zZVR5cGUgIT09ICd0ZXh0JztcbiAgICAgICAgaWYgKHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwICYmICh1c2VSZXNwb25zZSAmJiB4aHIucmVzcG9uc2UgfHwgeGhyLnJlc3BvbnNlVGV4dCAhPT0gbnVsbCkpIHtcbiAgICAgICAgICBzdGF0cy5sb2FkaW5nLmVuZCA9IE1hdGgubWF4KHNlbGYucGVyZm9ybWFuY2Uubm93KCksIHN0YXRzLmxvYWRpbmcuZmlyc3QpO1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSB1c2VSZXNwb25zZSA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgY29uc3QgbGVuID0geGhyLnJlc3BvbnNlVHlwZSA9PT0gJ2FycmF5YnVmZmVyJyA/IGRhdGEuYnl0ZUxlbmd0aCA6IGRhdGEubGVuZ3RoO1xuICAgICAgICAgIHN0YXRzLmxvYWRlZCA9IHN0YXRzLnRvdGFsID0gbGVuO1xuICAgICAgICAgIHN0YXRzLmJ3RXN0aW1hdGUgPSBzdGF0cy50b3RhbCAqIDgwMDAgLyAoc3RhdHMubG9hZGluZy5lbmQgLSBzdGF0cy5sb2FkaW5nLmZpcnN0KTtcbiAgICAgICAgICBpZiAoIXRoaXMuY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG9uUHJvZ3Jlc3MgPSB0aGlzLmNhbGxiYWNrcy5vblByb2dyZXNzO1xuICAgICAgICAgIGlmIChvblByb2dyZXNzKSB7XG4gICAgICAgICAgICBvblByb2dyZXNzKHN0YXRzLCBjb250ZXh0LCBkYXRhLCB4aHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMuY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgdXJsOiB4aHIucmVzcG9uc2VVUkwsXG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgY29kZTogc3RhdHVzXG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5vblN1Y2Nlc3MocmVzcG9uc2UsIHN0YXRzLCBjb250ZXh0LCB4aHIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHJldHJ5Q29uZmlnID0gY29uZmlnLmxvYWRQb2xpY3kuZXJyb3JSZXRyeTtcbiAgICAgICAgICBjb25zdCByZXRyeUNvdW50ID0gc3RhdHMucmV0cnk7XG4gICAgICAgICAgLy8gaWYgbWF4IG5iIG9mIHJldHJpZXMgcmVhY2hlZCBvciBpZiBodHRwIHN0YXR1cyBiZXR3ZWVuIDQwMCBhbmQgNDk5IChzdWNoIGVycm9yIGNhbm5vdCBiZSByZWNvdmVyZWQsIHJldHJ5aW5nIGlzIHVzZWxlc3MpLCByZXR1cm4gZXJyb3JcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHtcbiAgICAgICAgICAgIHVybDogY29udGV4dC51cmwsXG4gICAgICAgICAgICBkYXRhOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjb2RlOiBzdGF0dXNcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChzaG91bGRSZXRyeShyZXRyeUNvbmZpZywgcmV0cnlDb3VudCwgZmFsc2UsIHJlc3BvbnNlKSkge1xuICAgICAgICAgICAgdGhpcy5yZXRyeShyZXRyeUNvbmZpZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgJHtzdGF0dXN9IHdoaWxlIGxvYWRpbmcgJHtjb250ZXh0LnVybH1gKTtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLm9uRXJyb3Ioe1xuICAgICAgICAgICAgICBjb2RlOiBzdGF0dXMsXG4gICAgICAgICAgICAgIHRleHQ6IHhoci5zdGF0dXNUZXh0XG4gICAgICAgICAgICB9LCBjb250ZXh0LCB4aHIsIHN0YXRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbG9hZHRpbWVvdXQoKSB7XG4gICAgdmFyIF90aGlzJGNvbmZpZztcbiAgICBjb25zdCByZXRyeUNvbmZpZyA9IChfdGhpcyRjb25maWcgPSB0aGlzLmNvbmZpZykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGNvbmZpZy5sb2FkUG9saWN5LnRpbWVvdXRSZXRyeTtcbiAgICBjb25zdCByZXRyeUNvdW50ID0gdGhpcy5zdGF0cy5yZXRyeTtcbiAgICBpZiAoc2hvdWxkUmV0cnkocmV0cnlDb25maWcsIHJldHJ5Q291bnQsIHRydWUpKSB7XG4gICAgICB0aGlzLnJldHJ5KHJldHJ5Q29uZmlnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF90aGlzJGNvbnRleHQ7XG4gICAgICBsb2dnZXIud2FybihgdGltZW91dCB3aGlsZSBsb2FkaW5nICR7KF90aGlzJGNvbnRleHQgPSB0aGlzLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRjb250ZXh0LnVybH1gKTtcbiAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXMuY2FsbGJhY2tzO1xuICAgICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgICB0aGlzLmFib3J0SW50ZXJuYWwoKTtcbiAgICAgICAgY2FsbGJhY2tzLm9uVGltZW91dCh0aGlzLnN0YXRzLCB0aGlzLmNvbnRleHQsIHRoaXMubG9hZGVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0cnkocmV0cnlDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb250ZXh0LFxuICAgICAgc3RhdHNcbiAgICB9ID0gdGhpcztcbiAgICB0aGlzLnJldHJ5RGVsYXkgPSBnZXRSZXRyeURlbGF5KHJldHJ5Q29uZmlnLCBzdGF0cy5yZXRyeSk7XG4gICAgc3RhdHMucmV0cnkrKztcbiAgICBsb2dnZXIud2FybihgJHtzdGF0dXMgPyAnSFRUUCBTdGF0dXMgJyArIHN0YXR1cyA6ICdUaW1lb3V0J30gd2hpbGUgbG9hZGluZyAke2NvbnRleHQgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRleHQudXJsfSwgcmV0cnlpbmcgJHtzdGF0cy5yZXRyeX0vJHtyZXRyeUNvbmZpZy5tYXhOdW1SZXRyeX0gaW4gJHt0aGlzLnJldHJ5RGVsYXl9bXNgKTtcbiAgICAvLyBhYm9ydCBhbmQgcmVzZXQgaW50ZXJuYWwgc3RhdGVcbiAgICB0aGlzLmFib3J0SW50ZXJuYWwoKTtcbiAgICB0aGlzLmxvYWRlciA9IG51bGw7XG4gICAgLy8gc2NoZWR1bGUgcmV0cnlcbiAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJldHJ5VGltZW91dCk7XG4gICAgdGhpcy5yZXRyeVRpbWVvdXQgPSBzZWxmLnNldFRpbWVvdXQodGhpcy5sb2FkSW50ZXJuYWwuYmluZCh0aGlzKSwgdGhpcy5yZXRyeURlbGF5KTtcbiAgfVxuICBsb2FkcHJvZ3Jlc3MoZXZlbnQpIHtcbiAgICBjb25zdCBzdGF0cyA9IHRoaXMuc3RhdHM7XG4gICAgc3RhdHMubG9hZGVkID0gZXZlbnQubG9hZGVkO1xuICAgIGlmIChldmVudC5sZW5ndGhDb21wdXRhYmxlKSB7XG4gICAgICBzdGF0cy50b3RhbCA9IGV2ZW50LnRvdGFsO1xuICAgIH1cbiAgfVxuICBnZXRDYWNoZUFnZSgpIHtcbiAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICBpZiAodGhpcy5sb2FkZXIgJiYgQUdFX0hFQURFUl9MSU5FX1JFR0VYLnRlc3QodGhpcy5sb2FkZXIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpKSB7XG4gICAgICBjb25zdCBhZ2VIZWFkZXIgPSB0aGlzLmxvYWRlci5nZXRSZXNwb25zZUhlYWRlcignYWdlJyk7XG4gICAgICByZXN1bHQgPSBhZ2VIZWFkZXIgPyBwYXJzZUZsb2F0KGFnZUhlYWRlcikgOiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGdldFJlc3BvbnNlSGVhZGVyKG5hbWUpIHtcbiAgICBpZiAodGhpcy5sb2FkZXIgJiYgbmV3IFJlZ0V4cChgXiR7bmFtZX06XFxcXHMqW1xcXFxkLl0rXFxcXHMqJGAsICdpbScpLnRlc3QodGhpcy5sb2FkZXIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpKSB7XG4gICAgICByZXR1cm4gdGhpcy5sb2FkZXIuZ2V0UmVzcG9uc2VIZWFkZXIobmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZldGNoU3VwcG9ydGVkKCkge1xuICBpZiAoXG4gIC8vIEB0cy1pZ25vcmVcbiAgc2VsZi5mZXRjaCAmJiBzZWxmLkFib3J0Q29udHJvbGxlciAmJiBzZWxmLlJlYWRhYmxlU3RyZWFtICYmIHNlbGYuUmVxdWVzdCkge1xuICAgIHRyeSB7XG4gICAgICBuZXcgc2VsZi5SZWFkYWJsZVN0cmVhbSh7fSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvKiBub29wICovXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmNvbnN0IEJZVEVSQU5HRSA9IC8oXFxkKyktKFxcZCspXFwvKFxcZCspLztcbmNsYXNzIEZldGNoTG9hZGVyIHtcbiAgY29uc3RydWN0b3IoY29uZmlnIC8qIEhsc0NvbmZpZyAqLykge1xuICAgIHRoaXMuZmV0Y2hTZXR1cCA9IHZvaWQgMDtcbiAgICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gdm9pZCAwO1xuICAgIHRoaXMucmVxdWVzdCA9IG51bGw7XG4gICAgdGhpcy5yZXNwb25zZSA9IG51bGw7XG4gICAgdGhpcy5jb250cm9sbGVyID0gdm9pZCAwO1xuICAgIHRoaXMuY29udGV4dCA9IG51bGw7XG4gICAgdGhpcy5jb25maWcgPSBudWxsO1xuICAgIHRoaXMuY2FsbGJhY2tzID0gbnVsbDtcbiAgICB0aGlzLnN0YXRzID0gdm9pZCAwO1xuICAgIHRoaXMubG9hZGVyID0gbnVsbDtcbiAgICB0aGlzLmZldGNoU2V0dXAgPSBjb25maWcuZmV0Y2hTZXR1cCB8fCBnZXRSZXF1ZXN0O1xuICAgIHRoaXMuY29udHJvbGxlciA9IG5ldyBzZWxmLkFib3J0Q29udHJvbGxlcigpO1xuICAgIHRoaXMuc3RhdHMgPSBuZXcgTG9hZFN0YXRzKCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmxvYWRlciA9IHRoaXMuY2FsbGJhY2tzID0gdGhpcy5jb250ZXh0ID0gdGhpcy5jb25maWcgPSB0aGlzLnJlcXVlc3QgPSBudWxsO1xuICAgIHRoaXMuYWJvcnRJbnRlcm5hbCgpO1xuICAgIHRoaXMucmVzcG9uc2UgPSBudWxsO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmZldGNoU2V0dXAgPSB0aGlzLmNvbnRyb2xsZXIgPSB0aGlzLnN0YXRzID0gbnVsbDtcbiAgfVxuICBhYm9ydEludGVybmFsKCkge1xuICAgIGlmICh0aGlzLmNvbnRyb2xsZXIgJiYgIXRoaXMuc3RhdHMubG9hZGluZy5lbmQpIHtcbiAgICAgIHRoaXMuc3RhdHMuYWJvcnRlZCA9IHRydWU7XG4gICAgICB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICB9XG4gIH1cbiAgYWJvcnQoKSB7XG4gICAgdmFyIF90aGlzJGNhbGxiYWNrcztcbiAgICB0aGlzLmFib3J0SW50ZXJuYWwoKTtcbiAgICBpZiAoKF90aGlzJGNhbGxiYWNrcyA9IHRoaXMuY2FsbGJhY2tzKSAhPSBudWxsICYmIF90aGlzJGNhbGxiYWNrcy5vbkFib3J0KSB7XG4gICAgICB0aGlzLmNhbGxiYWNrcy5vbkFib3J0KHRoaXMuc3RhdHMsIHRoaXMuY29udGV4dCwgdGhpcy5yZXNwb25zZSk7XG4gICAgfVxuICB9XG4gIGxvYWQoY29udGV4dCwgY29uZmlnLCBjYWxsYmFja3MpIHtcbiAgICBjb25zdCBzdGF0cyA9IHRoaXMuc3RhdHM7XG4gICAgaWYgKHN0YXRzLmxvYWRpbmcuc3RhcnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTG9hZGVyIGNhbiBvbmx5IGJlIHVzZWQgb25jZS4nKTtcbiAgICB9XG4gICAgc3RhdHMubG9hZGluZy5zdGFydCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY29uc3QgaW5pdFBhcmFtcyA9IGdldFJlcXVlc3RQYXJhbWV0ZXJzKGNvbnRleHQsIHRoaXMuY29udHJvbGxlci5zaWduYWwpO1xuICAgIGNvbnN0IG9uUHJvZ3Jlc3MgPSBjYWxsYmFja3Mub25Qcm9ncmVzcztcbiAgICBjb25zdCBpc0FycmF5QnVmZmVyID0gY29udGV4dC5yZXNwb25zZVR5cGUgPT09ICdhcnJheWJ1ZmZlcic7XG4gICAgY29uc3QgTEVOR1RIID0gaXNBcnJheUJ1ZmZlciA/ICdieXRlTGVuZ3RoJyA6ICdsZW5ndGgnO1xuICAgIGNvbnN0IHtcbiAgICAgIG1heFRpbWVUb0ZpcnN0Qnl0ZU1zLFxuICAgICAgbWF4TG9hZFRpbWVNc1xuICAgIH0gPSBjb25maWcubG9hZFBvbGljeTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMuY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xuICAgIHRoaXMucmVxdWVzdCA9IHRoaXMuZmV0Y2hTZXR1cChjb250ZXh0LCBpbml0UGFyYW1zKTtcbiAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KTtcbiAgICBjb25maWcudGltZW91dCA9IG1heFRpbWVUb0ZpcnN0Qnl0ZU1zICYmIGlzRmluaXRlTnVtYmVyKG1heFRpbWVUb0ZpcnN0Qnl0ZU1zKSA/IG1heFRpbWVUb0ZpcnN0Qnl0ZU1zIDogbWF4TG9hZFRpbWVNcztcbiAgICB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gc2VsZi5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuYWJvcnRJbnRlcm5hbCgpO1xuICAgICAgY2FsbGJhY2tzLm9uVGltZW91dChzdGF0cywgY29udGV4dCwgdGhpcy5yZXNwb25zZSk7XG4gICAgfSwgY29uZmlnLnRpbWVvdXQpO1xuICAgIHNlbGYuZmV0Y2godGhpcy5yZXF1ZXN0KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgIHRoaXMucmVzcG9uc2UgPSB0aGlzLmxvYWRlciA9IHJlc3BvbnNlO1xuICAgICAgY29uc3QgZmlyc3QgPSBNYXRoLm1heChzZWxmLnBlcmZvcm1hbmNlLm5vdygpLCBzdGF0cy5sb2FkaW5nLnN0YXJ0KTtcbiAgICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmVxdWVzdFRpbWVvdXQpO1xuICAgICAgY29uZmlnLnRpbWVvdXQgPSBtYXhMb2FkVGltZU1zO1xuICAgICAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IHNlbGYuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuYWJvcnRJbnRlcm5hbCgpO1xuICAgICAgICBjYWxsYmFja3Mub25UaW1lb3V0KHN0YXRzLCBjb250ZXh0LCB0aGlzLnJlc3BvbnNlKTtcbiAgICAgIH0sIG1heExvYWRUaW1lTXMgLSAoZmlyc3QgLSBzdGF0cy5sb2FkaW5nLnN0YXJ0KSk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgc3RhdHVzVGV4dFxuICAgICAgICB9ID0gcmVzcG9uc2U7XG4gICAgICAgIHRocm93IG5ldyBGZXRjaEVycm9yKHN0YXR1c1RleHQgfHwgJ2ZldGNoLCBiYWQgbmV0d29yayByZXNwb25zZScsIHN0YXR1cywgcmVzcG9uc2UpO1xuICAgICAgfVxuICAgICAgc3RhdHMubG9hZGluZy5maXJzdCA9IGZpcnN0O1xuICAgICAgc3RhdHMudG90YWwgPSBnZXRDb250ZW50TGVuZ3RoKHJlc3BvbnNlLmhlYWRlcnMpIHx8IHN0YXRzLnRvdGFsO1xuICAgICAgaWYgKG9uUHJvZ3Jlc3MgJiYgaXNGaW5pdGVOdW1iZXIoY29uZmlnLmhpZ2hXYXRlck1hcmspKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRQcm9ncmVzc2l2ZWx5KHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgY29uZmlnLmhpZ2hXYXRlck1hcmssIG9uUHJvZ3Jlc3MpO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG4gICAgICB9XG4gICAgICBpZiAoY29udGV4dC5yZXNwb25zZVR5cGUgPT09ICdqc29uJykge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgICB9KS50aGVuKHJlc3BvbnNlRGF0YSA9PiB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IHRoaXMucmVzcG9uc2U7XG4gICAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbG9hZGVyIGRlc3Ryb3llZCcpO1xuICAgICAgfVxuICAgICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCk7XG4gICAgICBzdGF0cy5sb2FkaW5nLmVuZCA9IE1hdGgubWF4KHNlbGYucGVyZm9ybWFuY2Uubm93KCksIHN0YXRzLmxvYWRpbmcuZmlyc3QpO1xuICAgICAgY29uc3QgdG90YWwgPSByZXNwb25zZURhdGFbTEVOR1RIXTtcbiAgICAgIGlmICh0b3RhbCkge1xuICAgICAgICBzdGF0cy5sb2FkZWQgPSBzdGF0cy50b3RhbCA9IHRvdGFsO1xuICAgICAgfVxuICAgICAgY29uc3QgbG9hZGVyUmVzcG9uc2UgPSB7XG4gICAgICAgIHVybDogcmVzcG9uc2UudXJsLFxuICAgICAgICBkYXRhOiByZXNwb25zZURhdGEsXG4gICAgICAgIGNvZGU6IHJlc3BvbnNlLnN0YXR1c1xuICAgICAgfTtcbiAgICAgIGlmIChvblByb2dyZXNzICYmICFpc0Zpbml0ZU51bWJlcihjb25maWcuaGlnaFdhdGVyTWFyaykpIHtcbiAgICAgICAgb25Qcm9ncmVzcyhzdGF0cywgY29udGV4dCwgcmVzcG9uc2VEYXRhLCByZXNwb25zZSk7XG4gICAgICB9XG4gICAgICBjYWxsYmFja3Mub25TdWNjZXNzKGxvYWRlclJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgcmVzcG9uc2UpO1xuICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmVxdWVzdFRpbWVvdXQpO1xuICAgICAgaWYgKHN0YXRzLmFib3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gQ09SUyBlcnJvcnMgcmVzdWx0IGluIGFuIHVuZGVmaW5lZCBjb2RlLiBTZXQgaXQgdG8gMCBoZXJlIHRvIGFsaWduIHdpdGggWEhSJ3MgYmVoYXZpb3JcbiAgICAgIC8vIHdoZW4gZGVzdHJveWluZywgJ2Vycm9yJyBpdHNlbGYgY2FuIGJlIHVuZGVmaW5lZFxuICAgICAgY29uc3QgY29kZSA9ICFlcnJvciA/IDAgOiBlcnJvci5jb2RlIHx8IDA7XG4gICAgICBjb25zdCB0ZXh0ID0gIWVycm9yID8gbnVsbCA6IGVycm9yLm1lc3NhZ2U7XG4gICAgICBjYWxsYmFja3Mub25FcnJvcih7XG4gICAgICAgIGNvZGUsXG4gICAgICAgIHRleHRcbiAgICAgIH0sIGNvbnRleHQsIGVycm9yID8gZXJyb3IuZGV0YWlscyA6IG51bGwsIHN0YXRzKTtcbiAgICB9KTtcbiAgfVxuICBnZXRDYWNoZUFnZSgpIHtcbiAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICBpZiAodGhpcy5yZXNwb25zZSkge1xuICAgICAgY29uc3QgYWdlSGVhZGVyID0gdGhpcy5yZXNwb25zZS5oZWFkZXJzLmdldCgnYWdlJyk7XG4gICAgICByZXN1bHQgPSBhZ2VIZWFkZXIgPyBwYXJzZUZsb2F0KGFnZUhlYWRlcikgOiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGdldFJlc3BvbnNlSGVhZGVyKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNwb25zZSA/IHRoaXMucmVzcG9uc2UuaGVhZGVycy5nZXQobmFtZSkgOiBudWxsO1xuICB9XG4gIGxvYWRQcm9ncmVzc2l2ZWx5KHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgaGlnaFdhdGVyTWFyayA9IDAsIG9uUHJvZ3Jlc3MpIHtcbiAgICBjb25zdCBjaHVua0NhY2hlID0gbmV3IENodW5rQ2FjaGUoKTtcbiAgICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuICAgIGNvbnN0IHB1bXAgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gcmVhZGVyLnJlYWQoKS50aGVuKGRhdGEgPT4ge1xuICAgICAgICBpZiAoZGF0YS5kb25lKSB7XG4gICAgICAgICAgaWYgKGNodW5rQ2FjaGUuZGF0YUxlbmd0aCkge1xuICAgICAgICAgICAgb25Qcm9ncmVzcyhzdGF0cywgY29udGV4dCwgY2h1bmtDYWNoZS5mbHVzaCgpLCByZXNwb25zZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEFycmF5QnVmZmVyKDApKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaHVuayA9IGRhdGEudmFsdWU7XG4gICAgICAgIGNvbnN0IGxlbiA9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgc3RhdHMubG9hZGVkICs9IGxlbjtcbiAgICAgICAgaWYgKGxlbiA8IGhpZ2hXYXRlck1hcmsgfHwgY2h1bmtDYWNoZS5kYXRhTGVuZ3RoKSB7XG4gICAgICAgICAgLy8gVGhlIGN1cnJlbnQgY2h1bmsgaXMgdG9vIHNtYWxsIHRvIHRvIGJlIGVtaXR0ZWQgb3IgdGhlIGNhY2hlIGFscmVhZHkgaGFzIGRhdGFcbiAgICAgICAgICAvLyBQdXNoIGl0IHRvIHRoZSBjYWNoZVxuICAgICAgICAgIGNodW5rQ2FjaGUucHVzaChjaHVuayk7XG4gICAgICAgICAgaWYgKGNodW5rQ2FjaGUuZGF0YUxlbmd0aCA+PSBoaWdoV2F0ZXJNYXJrKSB7XG4gICAgICAgICAgICAvLyBmbHVzaCBpbiBvcmRlciB0byBqb2luIHRoZSB0eXBlZCBhcnJheXNcbiAgICAgICAgICAgIG9uUHJvZ3Jlc3Moc3RhdHMsIGNvbnRleHQsIGNodW5rQ2FjaGUuZmx1c2goKSwgcmVzcG9uc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJZiB0aGVyZSdzIG5vdGhpbmcgY2FjaGVkIGFscmVhZHksIGFuZCB0aGUgY2hhY2hlIGlzIGxhcmdlIGVub3VnaFxuICAgICAgICAgIC8vIGp1c3QgZW1pdCB0aGUgcHJvZ3Jlc3MgZXZlbnRcbiAgICAgICAgICBvblByb2dyZXNzKHN0YXRzLCBjb250ZXh0LCBjaHVuaywgcmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwdW1wKCk7XG4gICAgICB9KS5jYXRjaCgoKSA9PiB7XG4gICAgICAgIC8qIGFib3J0ZWQgKi9cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBwdW1wKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFJlcXVlc3RQYXJhbWV0ZXJzKGNvbnRleHQsIHNpZ25hbCkge1xuICBjb25zdCBpbml0UGFyYW1zID0ge1xuICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgbW9kZTogJ2NvcnMnLFxuICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nLFxuICAgIHNpZ25hbCxcbiAgICBoZWFkZXJzOiBuZXcgc2VsZi5IZWFkZXJzKF9leHRlbmRzKHt9LCBjb250ZXh0LmhlYWRlcnMpKVxuICB9O1xuICBpZiAoY29udGV4dC5yYW5nZUVuZCkge1xuICAgIGluaXRQYXJhbXMuaGVhZGVycy5zZXQoJ1JhbmdlJywgJ2J5dGVzPScgKyBjb250ZXh0LnJhbmdlU3RhcnQgKyAnLScgKyBTdHJpbmcoY29udGV4dC5yYW5nZUVuZCAtIDEpKTtcbiAgfVxuICByZXR1cm4gaW5pdFBhcmFtcztcbn1cbmZ1bmN0aW9uIGdldEJ5dGVSYW5nZUxlbmd0aChieXRlUmFuZ2VIZWFkZXIpIHtcbiAgY29uc3QgcmVzdWx0ID0gQllURVJBTkdFLmV4ZWMoYnl0ZVJhbmdlSGVhZGVyKTtcbiAgaWYgKHJlc3VsdCkge1xuICAgIHJldHVybiBwYXJzZUludChyZXN1bHRbMl0pIC0gcGFyc2VJbnQocmVzdWx0WzFdKSArIDE7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldENvbnRlbnRMZW5ndGgoaGVhZGVycykge1xuICBjb25zdCBjb250ZW50UmFuZ2UgPSBoZWFkZXJzLmdldCgnQ29udGVudC1SYW5nZScpO1xuICBpZiAoY29udGVudFJhbmdlKSB7XG4gICAgY29uc3QgYnl0ZVJhbmdlTGVuZ3RoID0gZ2V0Qnl0ZVJhbmdlTGVuZ3RoKGNvbnRlbnRSYW5nZSk7XG4gICAgaWYgKGlzRmluaXRlTnVtYmVyKGJ5dGVSYW5nZUxlbmd0aCkpIHtcbiAgICAgIHJldHVybiBieXRlUmFuZ2VMZW5ndGg7XG4gICAgfVxuICB9XG4gIGNvbnN0IGNvbnRlbnRMZW5ndGggPSBoZWFkZXJzLmdldCgnQ29udGVudC1MZW5ndGgnKTtcbiAgaWYgKGNvbnRlbnRMZW5ndGgpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQoY29udGVudExlbmd0aCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFJlcXVlc3QoY29udGV4dCwgaW5pdFBhcmFtcykge1xuICByZXR1cm4gbmV3IHNlbGYuUmVxdWVzdChjb250ZXh0LnVybCwgaW5pdFBhcmFtcyk7XG59XG5jbGFzcyBGZXRjaEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBjb2RlLCBkZXRhaWxzKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5jb2RlID0gdm9pZCAwO1xuICAgIHRoaXMuZGV0YWlscyA9IHZvaWQgMDtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gIH1cbn1cblxuY29uc3QgV0hJVEVTUEFDRV9DSEFSID0gL1xccy87XG5jb25zdCBDdWVzID0ge1xuICBuZXdDdWUodHJhY2ssIHN0YXJ0VGltZSwgZW5kVGltZSwgY2FwdGlvblNjcmVlbikge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCByb3c7XG4gICAgLy8gdGhlIHR5cGUgZGF0YSBzdGF0ZXMgdGhpcyBpcyBWVFRDdWUsIGJ1dCBpdCBjYW4gcG90ZW50aWFsbHkgYmUgYSBUZXh0VHJhY2tDdWUgb24gb2xkIGJyb3dzZXJzXG4gICAgbGV0IGN1ZTtcbiAgICBsZXQgaW5kZW50aW5nO1xuICAgIGxldCBpbmRlbnQ7XG4gICAgbGV0IHRleHQ7XG4gICAgY29uc3QgQ3VlID0gc2VsZi5WVFRDdWUgfHwgc2VsZi5UZXh0VHJhY2tDdWU7XG4gICAgZm9yIChsZXQgciA9IDA7IHIgPCBjYXB0aW9uU2NyZWVuLnJvd3MubGVuZ3RoOyByKyspIHtcbiAgICAgIHJvdyA9IGNhcHRpb25TY3JlZW4ucm93c1tyXTtcbiAgICAgIGluZGVudGluZyA9IHRydWU7XG4gICAgICBpbmRlbnQgPSAwO1xuICAgICAgdGV4dCA9ICcnO1xuICAgICAgaWYgKCFyb3cuaXNFbXB0eSgpKSB7XG4gICAgICAgIHZhciBfdHJhY2skY3VlcztcbiAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCByb3cuY2hhcnMubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICBpZiAoV0hJVEVTUEFDRV9DSEFSLnRlc3Qocm93LmNoYXJzW2NdLnVjaGFyKSAmJiBpbmRlbnRpbmcpIHtcbiAgICAgICAgICAgIGluZGVudCsrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXh0ICs9IHJvdy5jaGFyc1tjXS51Y2hhcjtcbiAgICAgICAgICAgIGluZGVudGluZyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUbyBiZSB1c2VkIGZvciBjbGVhbmluZy11cCBvcnBoYW5lZCByb2xsLXVwIGNhcHRpb25zXG4gICAgICAgIHJvdy5jdWVTdGFydFRpbWUgPSBzdGFydFRpbWU7XG5cbiAgICAgICAgLy8gR2l2ZSBhIHNsaWdodCBidW1wIHRvIHRoZSBlbmRUaW1lIGlmIGl0J3MgZXF1YWwgdG8gc3RhcnRUaW1lIHRvIGF2b2lkIGEgU3ludGF4RXJyb3IgaW4gSUVcbiAgICAgICAgaWYgKHN0YXJ0VGltZSA9PT0gZW5kVGltZSkge1xuICAgICAgICAgIGVuZFRpbWUgKz0gMC4wMDAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRlbnQgPj0gMTYpIHtcbiAgICAgICAgICBpbmRlbnQtLTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbmRlbnQrKztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdWVUZXh0ID0gZml4TGluZUJyZWFrcyh0ZXh0LnRyaW0oKSk7XG4gICAgICAgIGNvbnN0IGlkID0gZ2VuZXJhdGVDdWVJZChzdGFydFRpbWUsIGVuZFRpbWUsIGN1ZVRleHQpO1xuXG4gICAgICAgIC8vIElmIHRoaXMgY3VlIGFscmVhZHkgZXhpc3RzIGluIHRoZSB0cmFjayBkbyBub3QgcHVzaCBpdFxuICAgICAgICBpZiAoISh0cmFjayAhPSBudWxsICYmIChfdHJhY2skY3VlcyA9IHRyYWNrLmN1ZXMpICE9IG51bGwgJiYgX3RyYWNrJGN1ZXMuZ2V0Q3VlQnlJZChpZCkpKSB7XG4gICAgICAgICAgY3VlID0gbmV3IEN1ZShzdGFydFRpbWUsIGVuZFRpbWUsIGN1ZVRleHQpO1xuICAgICAgICAgIGN1ZS5pZCA9IGlkO1xuICAgICAgICAgIGN1ZS5saW5lID0gciArIDE7XG4gICAgICAgICAgY3VlLmFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgIC8vIENsYW1wIHRoZSBwb3NpdGlvbiBiZXR3ZWVuIDEwIGFuZCA4MCBwZXJjZW50IChDRUEtNjA4IFBBQyBpbmRlbnQgY29kZSlcbiAgICAgICAgICAvLyBodHRwczovL2R2Y3MudzMub3JnL2hnL3RleHQtdHJhY2tzL3Jhdy1maWxlL2RlZmF1bHQvNjA4dG9WVFQvNjA4dG9WVFQuaHRtbCNwb3NpdGlvbmluZy1pbi1jZWEtNjA4XG4gICAgICAgICAgLy8gRmlyZWZveCB0aHJvd3MgYW4gZXhjZXB0aW9uIGFuZCBjYXB0aW9ucyBicmVhayB3aXRoIG91dCBvZiBib3VuZHMgMC0xMDAgdmFsdWVzXG4gICAgICAgICAgY3VlLnBvc2l0aW9uID0gMTAgKyBNYXRoLm1pbig4MCwgTWF0aC5mbG9vcihpbmRlbnQgKiA4IC8gMzIpICogMTApO1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGN1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRyYWNrICYmIHJlc3VsdC5sZW5ndGgpIHtcbiAgICAgIC8vIFNvcnQgYm90dG9tIGN1ZXMgaW4gcmV2ZXJzZSBvcmRlciBzbyB0aGF0IHRoZXkgcmVuZGVyIGluIGxpbmUgb3JkZXIgd2hlbiBvdmVybGFwcGluZyBpbiBDaHJvbWVcbiAgICAgIHJlc3VsdC5zb3J0KChjdWVBLCBjdWVCKSA9PiB7XG4gICAgICAgIGlmIChjdWVBLmxpbmUgPT09ICdhdXRvJyB8fCBjdWVCLmxpbmUgPT09ICdhdXRvJykge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdWVBLmxpbmUgPiA4ICYmIGN1ZUIubGluZSA+IDgpIHtcbiAgICAgICAgICByZXR1cm4gY3VlQi5saW5lIC0gY3VlQS5saW5lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdWVBLmxpbmUgLSBjdWVCLmxpbmU7XG4gICAgICB9KTtcbiAgICAgIHJlc3VsdC5mb3JFYWNoKGN1ZSA9PiBhZGRDdWVUb1RyYWNrKHRyYWNrLCBjdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZCB1c2UgZnJhZ0xvYWRQb2xpY3kuZGVmYXVsdFxuICovXG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgdXNlIG1hbmlmZXN0TG9hZFBvbGljeS5kZWZhdWx0IGFuZCBwbGF5bGlzdExvYWRQb2xpY3kuZGVmYXVsdFxuICovXG5cbmNvbnN0IGRlZmF1bHRMb2FkUG9saWN5ID0ge1xuICBtYXhUaW1lVG9GaXJzdEJ5dGVNczogODAwMCxcbiAgbWF4TG9hZFRpbWVNczogMjAwMDAsXG4gIHRpbWVvdXRSZXRyeTogbnVsbCxcbiAgZXJyb3JSZXRyeTogbnVsbFxufTtcblxuLyoqXG4gKiBAaWdub3JlXG4gKiBJZiBwb3NzaWJsZSwga2VlcCBobHNEZWZhdWx0Q29uZmlnIHNoYWxsb3dcbiAqIEl0IGlzIGNsb25lZCB3aGVuZXZlciBhIG5ldyBIbHMgaW5zdGFuY2UgaXMgY3JlYXRlZCwgYnkga2VlcGluZyB0aGUgY29uZmlnXG4gKiBzaGFsbG93IHRoZSBwcm9wZXJ0aWVzIGFyZSBjbG9uZWQsIGFuZCB3ZSBkb24ndCBlbmQgdXAgbWFuaXB1bGF0aW5nIHRoZSBkZWZhdWx0XG4gKi9cbmNvbnN0IGhsc0RlZmF1bHRDb25maWcgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7XG4gIGF1dG9TdGFydExvYWQ6IHRydWUsXG4gIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgc3RhcnRQb3NpdGlvbjogLTEsXG4gIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgZGVmYXVsdEF1ZGlvQ29kZWM6IHVuZGVmaW5lZCxcbiAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBkZWJ1ZzogZmFsc2UsXG4gIC8vIHVzZWQgYnkgbG9nZ2VyXG4gIGNhcExldmVsT25GUFNEcm9wOiBmYWxzZSxcbiAgLy8gdXNlZCBieSBmcHMtY29udHJvbGxlclxuICBjYXBMZXZlbFRvUGxheWVyU2l6ZTogZmFsc2UsXG4gIC8vIHVzZWQgYnkgY2FwLWxldmVsLWNvbnRyb2xsZXJcbiAgaWdub3JlRGV2aWNlUGl4ZWxSYXRpbzogZmFsc2UsXG4gIC8vIHVzZWQgYnkgY2FwLWxldmVsLWNvbnRyb2xsZXJcbiAgcHJlZmVyTWFuYWdlZE1lZGlhU291cmNlOiB0cnVlLFxuICBpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZTogMSxcbiAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBtYXhCdWZmZXJMZW5ndGg6IDMwLFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIGJhY2tCdWZmZXJMZW5ndGg6IEluZmluaXR5LFxuICAvLyB1c2VkIGJ5IGJ1ZmZlci1jb250cm9sbGVyXG4gIGZyb250QnVmZmVyRmx1c2hUaHJlc2hvbGQ6IEluZmluaXR5LFxuICBtYXhCdWZmZXJTaXplOiA2MCAqIDEwMDAgKiAxMDAwLFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIG1heEJ1ZmZlckhvbGU6IDAuMSxcbiAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBoaWdoQnVmZmVyV2F0Y2hkb2dQZXJpb2Q6IDIsXG4gIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgbnVkZ2VPZmZzZXQ6IDAuMSxcbiAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBudWRnZU1heFJldHJ5OiAzLFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIG1heEZyYWdMb29rVXBUb2xlcmFuY2U6IDAuMjUsXG4gIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgbGl2ZVN5bmNEdXJhdGlvbkNvdW50OiAzLFxuICAvLyB1c2VkIGJ5IGxhdGVuY3ktY29udHJvbGxlclxuICBsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQ6IEluZmluaXR5LFxuICAvLyB1c2VkIGJ5IGxhdGVuY3ktY29udHJvbGxlclxuICBsaXZlU3luY0R1cmF0aW9uOiB1bmRlZmluZWQsXG4gIC8vIHVzZWQgYnkgbGF0ZW5jeS1jb250cm9sbGVyXG4gIGxpdmVNYXhMYXRlbmN5RHVyYXRpb246IHVuZGVmaW5lZCxcbiAgLy8gdXNlZCBieSBsYXRlbmN5LWNvbnRyb2xsZXJcbiAgbWF4TGl2ZVN5bmNQbGF5YmFja1JhdGU6IDEsXG4gIC8vIHVzZWQgYnkgbGF0ZW5jeS1jb250cm9sbGVyXG4gIGxpdmVEdXJhdGlvbkluZmluaXR5OiBmYWxzZSxcbiAgLy8gdXNlZCBieSBidWZmZXItY29udHJvbGxlclxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGJhY2tCdWZmZXJMZW5ndGhcbiAgICovXG4gIGxpdmVCYWNrQnVmZmVyTGVuZ3RoOiBudWxsLFxuICAvLyB1c2VkIGJ5IGJ1ZmZlci1jb250cm9sbGVyXG4gIG1heE1heEJ1ZmZlckxlbmd0aDogNjAwLFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIGVuYWJsZVdvcmtlcjogdHJ1ZSxcbiAgLy8gdXNlZCBieSB0cmFuc211eGVyXG4gIHdvcmtlclBhdGg6IG51bGwsXG4gIC8vIHVzZWQgYnkgdHJhbnNtdXhlclxuICBlbmFibGVTb2Z0d2FyZUFFUzogdHJ1ZSxcbiAgLy8gdXNlZCBieSBkZWNyeXB0ZXJcbiAgc3RhcnRMZXZlbDogdW5kZWZpbmVkLFxuICAvLyB1c2VkIGJ5IGxldmVsLWNvbnRyb2xsZXJcbiAgc3RhcnRGcmFnUHJlZmV0Y2g6IGZhbHNlLFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIGZwc0Ryb3BwZWRNb25pdG9yaW5nUGVyaW9kOiA1MDAwLFxuICAvLyB1c2VkIGJ5IGZwcy1jb250cm9sbGVyXG4gIGZwc0Ryb3BwZWRNb25pdG9yaW5nVGhyZXNob2xkOiAwLjIsXG4gIC8vIHVzZWQgYnkgZnBzLWNvbnRyb2xsZXJcbiAgYXBwZW5kRXJyb3JNYXhSZXRyeTogMyxcbiAgLy8gdXNlZCBieSBidWZmZXItY29udHJvbGxlclxuICBsb2FkZXI6IFhockxvYWRlcixcbiAgLy8gbG9hZGVyOiBGZXRjaExvYWRlcixcbiAgZkxvYWRlcjogdW5kZWZpbmVkLFxuICAvLyB1c2VkIGJ5IGZyYWdtZW50LWxvYWRlclxuICBwTG9hZGVyOiB1bmRlZmluZWQsXG4gIC8vIHVzZWQgYnkgcGxheWxpc3QtbG9hZGVyXG4gIHhoclNldHVwOiB1bmRlZmluZWQsXG4gIC8vIHVzZWQgYnkgeGhyLWxvYWRlclxuICBsaWNlbnNlWGhyU2V0dXA6IHVuZGVmaW5lZCxcbiAgLy8gdXNlZCBieSBlbWUtY29udHJvbGxlclxuICBsaWNlbnNlUmVzcG9uc2VDYWxsYmFjazogdW5kZWZpbmVkLFxuICAvLyB1c2VkIGJ5IGVtZS1jb250cm9sbGVyXG4gIGFickNvbnRyb2xsZXI6IEFickNvbnRyb2xsZXIsXG4gIGJ1ZmZlckNvbnRyb2xsZXI6IEJ1ZmZlckNvbnRyb2xsZXIsXG4gIGNhcExldmVsQ29udHJvbGxlcjogQ2FwTGV2ZWxDb250cm9sbGVyLFxuICBlcnJvckNvbnRyb2xsZXI6IEVycm9yQ29udHJvbGxlcixcbiAgZnBzQ29udHJvbGxlcjogRlBTQ29udHJvbGxlcixcbiAgc3RyZXRjaFNob3J0VmlkZW9UcmFjazogZmFsc2UsXG4gIC8vIHVzZWQgYnkgbXA0LXJlbXV4ZXJcbiAgbWF4QXVkaW9GcmFtZXNEcmlmdDogMSxcbiAgLy8gdXNlZCBieSBtcDQtcmVtdXhlclxuICBmb3JjZUtleUZyYW1lT25EaXNjb250aW51aXR5OiB0cnVlLFxuICAvLyB1c2VkIGJ5IHRzLWRlbXV4ZXJcbiAgYWJyRXdtYUZhc3RMaXZlOiAzLFxuICAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIGFickV3bWFTbG93TGl2ZTogOSxcbiAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBhYnJFd21hRmFzdFZvRDogMyxcbiAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBhYnJFd21hU2xvd1ZvRDogOSxcbiAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBhYnJFd21hRGVmYXVsdEVzdGltYXRlOiA1ZTUsXG4gIC8vIDUwMCBrYnBzICAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIGFickV3bWFEZWZhdWx0RXN0aW1hdGVNYXg6IDVlNixcbiAgLy8gNSBtYnBzXG4gIGFickJhbmRXaWR0aEZhY3RvcjogMC45NSxcbiAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBhYnJCYW5kV2lkdGhVcEZhY3RvcjogMC43LFxuICAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIGFick1heFdpdGhSZWFsQml0cmF0ZTogZmFsc2UsXG4gIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgbWF4U3RhcnZhdGlvbkRlbGF5OiA0LFxuICAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIG1heExvYWRpbmdEZWxheTogNCxcbiAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBtaW5BdXRvQml0cmF0ZTogMCxcbiAgLy8gdXNlZCBieSBobHNcbiAgZW1lRW5hYmxlZDogZmFsc2UsXG4gIC8vIHVzZWQgYnkgZW1lLWNvbnRyb2xsZXJcbiAgd2lkZXZpbmVMaWNlbnNlVXJsOiB1bmRlZmluZWQsXG4gIC8vIHVzZWQgYnkgZW1lLWNvbnRyb2xsZXJcbiAgZHJtU3lzdGVtczoge30sXG4gIC8vIHVzZWQgYnkgZW1lLWNvbnRyb2xsZXJcbiAgZHJtU3lzdGVtT3B0aW9uczoge30sXG4gIC8vIHVzZWQgYnkgZW1lLWNvbnRyb2xsZXJcbiAgcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzRnVuYzogcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzICxcbiAgLy8gdXNlZCBieSBlbWUtY29udHJvbGxlclxuICB0ZXN0QmFuZHdpZHRoOiB0cnVlLFxuICBwcm9ncmVzc2l2ZTogZmFsc2UsXG4gIGxvd0xhdGVuY3lNb2RlOiB0cnVlLFxuICBjbWNkOiB1bmRlZmluZWQsXG4gIGVuYWJsZURhdGVSYW5nZU1ldGFkYXRhQ3VlczogdHJ1ZSxcbiAgZW5hYmxlRW1zZ01ldGFkYXRhQ3VlczogdHJ1ZSxcbiAgZW5hYmxlSUQzTWV0YWRhdGFDdWVzOiB0cnVlLFxuICB1c2VNZWRpYUNhcGFiaWxpdGllczogdHJ1ZSxcbiAgY2VydExvYWRQb2xpY3k6IHtcbiAgICBkZWZhdWx0OiBkZWZhdWx0TG9hZFBvbGljeVxuICB9LFxuICBrZXlMb2FkUG9saWN5OiB7XG4gICAgZGVmYXVsdDoge1xuICAgICAgbWF4VGltZVRvRmlyc3RCeXRlTXM6IDgwMDAsXG4gICAgICBtYXhMb2FkVGltZU1zOiAyMDAwMCxcbiAgICAgIHRpbWVvdXRSZXRyeToge1xuICAgICAgICBtYXhOdW1SZXRyeTogMSxcbiAgICAgICAgcmV0cnlEZWxheU1zOiAxMDAwLFxuICAgICAgICBtYXhSZXRyeURlbGF5TXM6IDIwMDAwLFxuICAgICAgICBiYWNrb2ZmOiAnbGluZWFyJ1xuICAgICAgfSxcbiAgICAgIGVycm9yUmV0cnk6IHtcbiAgICAgICAgbWF4TnVtUmV0cnk6IDgsXG4gICAgICAgIHJldHJ5RGVsYXlNczogMTAwMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheU1zOiAyMDAwMCxcbiAgICAgICAgYmFja29mZjogJ2xpbmVhcidcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG1hbmlmZXN0TG9hZFBvbGljeToge1xuICAgIGRlZmF1bHQ6IHtcbiAgICAgIG1heFRpbWVUb0ZpcnN0Qnl0ZU1zOiBJbmZpbml0eSxcbiAgICAgIG1heExvYWRUaW1lTXM6IDIwMDAwLFxuICAgICAgdGltZW91dFJldHJ5OiB7XG4gICAgICAgIG1heE51bVJldHJ5OiAyLFxuICAgICAgICByZXRyeURlbGF5TXM6IDAsXG4gICAgICAgIG1heFJldHJ5RGVsYXlNczogMFxuICAgICAgfSxcbiAgICAgIGVycm9yUmV0cnk6IHtcbiAgICAgICAgbWF4TnVtUmV0cnk6IDEsXG4gICAgICAgIHJldHJ5RGVsYXlNczogMTAwMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheU1zOiA4MDAwXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwbGF5bGlzdExvYWRQb2xpY3k6IHtcbiAgICBkZWZhdWx0OiB7XG4gICAgICBtYXhUaW1lVG9GaXJzdEJ5dGVNczogMTAwMDAsXG4gICAgICBtYXhMb2FkVGltZU1zOiAyMDAwMCxcbiAgICAgIHRpbWVvdXRSZXRyeToge1xuICAgICAgICBtYXhOdW1SZXRyeTogMixcbiAgICAgICAgcmV0cnlEZWxheU1zOiAwLFxuICAgICAgICBtYXhSZXRyeURlbGF5TXM6IDBcbiAgICAgIH0sXG4gICAgICBlcnJvclJldHJ5OiB7XG4gICAgICAgIG1heE51bVJldHJ5OiAyLFxuICAgICAgICByZXRyeURlbGF5TXM6IDEwMDAsXG4gICAgICAgIG1heFJldHJ5RGVsYXlNczogODAwMFxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgZnJhZ0xvYWRQb2xpY3k6IHtcbiAgICBkZWZhdWx0OiB7XG4gICAgICBtYXhUaW1lVG9GaXJzdEJ5dGVNczogMTAwMDAsXG4gICAgICBtYXhMb2FkVGltZU1zOiAxMjAwMDAsXG4gICAgICB0aW1lb3V0UmV0cnk6IHtcbiAgICAgICAgbWF4TnVtUmV0cnk6IDQsXG4gICAgICAgIHJldHJ5RGVsYXlNczogMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheU1zOiAwXG4gICAgICB9LFxuICAgICAgZXJyb3JSZXRyeToge1xuICAgICAgICBtYXhOdW1SZXRyeTogNixcbiAgICAgICAgcmV0cnlEZWxheU1zOiAxMDAwLFxuICAgICAgICBtYXhSZXRyeURlbGF5TXM6IDgwMDBcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHN0ZWVyaW5nTWFuaWZlc3RMb2FkUG9saWN5OiB7XG4gICAgZGVmYXVsdDoge1xuICAgICAgbWF4VGltZVRvRmlyc3RCeXRlTXM6IDEwMDAwLFxuICAgICAgbWF4TG9hZFRpbWVNczogMjAwMDAsXG4gICAgICB0aW1lb3V0UmV0cnk6IHtcbiAgICAgICAgbWF4TnVtUmV0cnk6IDIsXG4gICAgICAgIHJldHJ5RGVsYXlNczogMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheU1zOiAwXG4gICAgICB9LFxuICAgICAgZXJyb3JSZXRyeToge1xuICAgICAgICBtYXhOdW1SZXRyeTogMSxcbiAgICAgICAgcmV0cnlEZWxheU1zOiAxMDAwLFxuICAgICAgICBtYXhSZXRyeURlbGF5TXM6IDgwMDBcbiAgICAgIH1cbiAgICB9IFxuICB9LFxuICAvLyBUaGVzZSBkZWZhdWx0IHNldHRpbmdzIGFyZSBkZXByZWNhdGVkIGluIGZhdm9yIG9mIHRoZSBhYm92ZSBwb2xpY2llc1xuICAvLyBhbmQgYXJlIG1haW50YWluZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gIG1hbmlmZXN0TG9hZGluZ1RpbWVPdXQ6IDEwMDAwLFxuICBtYW5pZmVzdExvYWRpbmdNYXhSZXRyeTogMSxcbiAgbWFuaWZlc3RMb2FkaW5nUmV0cnlEZWxheTogMTAwMCxcbiAgbWFuaWZlc3RMb2FkaW5nTWF4UmV0cnlUaW1lb3V0OiA2NDAwMCxcbiAgbGV2ZWxMb2FkaW5nVGltZU91dDogMTAwMDAsXG4gIGxldmVsTG9hZGluZ01heFJldHJ5OiA0LFxuICBsZXZlbExvYWRpbmdSZXRyeURlbGF5OiAxMDAwLFxuICBsZXZlbExvYWRpbmdNYXhSZXRyeVRpbWVvdXQ6IDY0MDAwLFxuICBmcmFnTG9hZGluZ1RpbWVPdXQ6IDIwMDAwLFxuICBmcmFnTG9hZGluZ01heFJldHJ5OiA2LFxuICBmcmFnTG9hZGluZ1JldHJ5RGVsYXk6IDEwMDAsXG4gIGZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0OiA2NDAwMFxufSwgdGltZWxpbmVDb25maWcoKSksIHt9LCB7XG4gIHN1YnRpdGxlU3RyZWFtQ29udHJvbGxlcjogU3VidGl0bGVTdHJlYW1Db250cm9sbGVyICxcbiAgc3VidGl0bGVUcmFja0NvbnRyb2xsZXI6IFN1YnRpdGxlVHJhY2tDb250cm9sbGVyICxcbiAgdGltZWxpbmVDb250cm9sbGVyOiBUaW1lbGluZUNvbnRyb2xsZXIgLFxuICBhdWRpb1N0cmVhbUNvbnRyb2xsZXI6IEF1ZGlvU3RyZWFtQ29udHJvbGxlciAsXG4gIGF1ZGlvVHJhY2tDb250cm9sbGVyOiBBdWRpb1RyYWNrQ29udHJvbGxlciAsXG4gIGVtZUNvbnRyb2xsZXI6IEVNRUNvbnRyb2xsZXIgLFxuICBjbWNkQ29udHJvbGxlcjogQ01DRENvbnRyb2xsZXIgLFxuICBjb250ZW50U3RlZXJpbmdDb250cm9sbGVyOiBDb250ZW50U3RlZXJpbmdDb250cm9sbGVyIFxufSk7XG5mdW5jdGlvbiB0aW1lbGluZUNvbmZpZygpIHtcbiAgcmV0dXJuIHtcbiAgICBjdWVIYW5kbGVyOiBDdWVzLFxuICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGVuYWJsZVdlYlZUVDogdHJ1ZSxcbiAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBlbmFibGVJTVNDMTogdHJ1ZSxcbiAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBlbmFibGVDRUE3MDhDYXB0aW9uczogdHJ1ZSxcbiAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBjYXB0aW9uc1RleHRUcmFjazFMYWJlbDogJ0VuZ2xpc2gnLFxuICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGNhcHRpb25zVGV4dFRyYWNrMUxhbmd1YWdlQ29kZTogJ2VuJyxcbiAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBjYXB0aW9uc1RleHRUcmFjazJMYWJlbDogJ1NwYW5pc2gnLFxuICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGNhcHRpb25zVGV4dFRyYWNrMkxhbmd1YWdlQ29kZTogJ2VzJyxcbiAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBjYXB0aW9uc1RleHRUcmFjazNMYWJlbDogJ1Vua25vd24gQ0MnLFxuICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGNhcHRpb25zVGV4dFRyYWNrM0xhbmd1YWdlQ29kZTogJycsXG4gICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgY2FwdGlvbnNUZXh0VHJhY2s0TGFiZWw6ICdVbmtub3duIENDJyxcbiAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBjYXB0aW9uc1RleHRUcmFjazRMYW5ndWFnZUNvZGU6ICcnLFxuICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIHJlbmRlclRleHRUcmFja3NOYXRpdmVseTogdHJ1ZVxuICB9O1xufVxuXG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gbWVyZ2VDb25maWcoZGVmYXVsdENvbmZpZywgdXNlckNvbmZpZykge1xuICBpZiAoKHVzZXJDb25maWcubGl2ZVN5bmNEdXJhdGlvbkNvdW50IHx8IHVzZXJDb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50KSAmJiAodXNlckNvbmZpZy5saXZlU3luY0R1cmF0aW9uIHx8IHVzZXJDb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIGhscy5qcyBjb25maWc6IGRvbid0IG1peCB1cCBsaXZlU3luY0R1cmF0aW9uQ291bnQvbGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50IGFuZCBsaXZlU3luY0R1cmF0aW9uL2xpdmVNYXhMYXRlbmN5RHVyYXRpb25cIik7XG4gIH1cbiAgaWYgKHVzZXJDb25maWcubGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50ICE9PSB1bmRlZmluZWQgJiYgKHVzZXJDb25maWcubGl2ZVN5bmNEdXJhdGlvbkNvdW50ID09PSB1bmRlZmluZWQgfHwgdXNlckNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQgPD0gdXNlckNvbmZpZy5saXZlU3luY0R1cmF0aW9uQ291bnQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGhscy5qcyBjb25maWc6IFwibGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50XCIgbXVzdCBiZSBncmVhdGVyIHRoYW4gXCJsaXZlU3luY0R1cmF0aW9uQ291bnRcIicpO1xuICB9XG4gIGlmICh1c2VyQ29uZmlnLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24gIT09IHVuZGVmaW5lZCAmJiAodXNlckNvbmZpZy5saXZlU3luY0R1cmF0aW9uID09PSB1bmRlZmluZWQgfHwgdXNlckNvbmZpZy5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uIDw9IHVzZXJDb25maWcubGl2ZVN5bmNEdXJhdGlvbikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgaGxzLmpzIGNvbmZpZzogXCJsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uXCIgbXVzdCBiZSBncmVhdGVyIHRoYW4gXCJsaXZlU3luY0R1cmF0aW9uXCInKTtcbiAgfVxuICBjb25zdCBkZWZhdWx0c0NvcHkgPSBkZWVwQ3B5KGRlZmF1bHRDb25maWcpO1xuXG4gIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggZGVwcmVjYXRlZCBjb25maWcgdmFsdWVzXG4gIGNvbnN0IGRlcHJlY2F0ZWRTZXR0aW5nVHlwZXMgPSBbJ21hbmlmZXN0JywgJ2xldmVsJywgJ2ZyYWcnXTtcbiAgY29uc3QgZGVwcmVjYXRlZFNldHRpbmdzID0gWydUaW1lT3V0JywgJ01heFJldHJ5JywgJ1JldHJ5RGVsYXknLCAnTWF4UmV0cnlUaW1lb3V0J107XG4gIGRlcHJlY2F0ZWRTZXR0aW5nVHlwZXMuZm9yRWFjaCh0eXBlID0+IHtcbiAgICBjb25zdCBwb2xpY3lOYW1lID0gYCR7dHlwZSA9PT0gJ2xldmVsJyA/ICdwbGF5bGlzdCcgOiB0eXBlfUxvYWRQb2xpY3lgO1xuICAgIGNvbnN0IHBvbGljeU5vdFNldCA9IHVzZXJDb25maWdbcG9saWN5TmFtZV0gPT09IHVuZGVmaW5lZDtcbiAgICBjb25zdCByZXBvcnQgPSBbXTtcbiAgICBkZXByZWNhdGVkU2V0dGluZ3MuZm9yRWFjaChzZXR0aW5nID0+IHtcbiAgICAgIGNvbnN0IGRlcHJlY2F0ZWRTZXR0aW5nID0gYCR7dHlwZX1Mb2FkaW5nJHtzZXR0aW5nfWA7XG4gICAgICBjb25zdCB2YWx1ZSA9IHVzZXJDb25maWdbZGVwcmVjYXRlZFNldHRpbmddO1xuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgcG9saWN5Tm90U2V0KSB7XG4gICAgICAgIHJlcG9ydC5wdXNoKGRlcHJlY2F0ZWRTZXR0aW5nKTtcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBkZWZhdWx0c0NvcHlbcG9saWN5TmFtZV0uZGVmYXVsdDtcbiAgICAgICAgdXNlckNvbmZpZ1twb2xpY3lOYW1lXSA9IHtcbiAgICAgICAgICBkZWZhdWx0OiBzZXR0aW5nc1xuICAgICAgICB9O1xuICAgICAgICBzd2l0Y2ggKHNldHRpbmcpIHtcbiAgICAgICAgICBjYXNlICdUaW1lT3V0JzpcbiAgICAgICAgICAgIHNldHRpbmdzLm1heExvYWRUaW1lTXMgPSB2YWx1ZTtcbiAgICAgICAgICAgIHNldHRpbmdzLm1heFRpbWVUb0ZpcnN0Qnl0ZU1zID0gdmFsdWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdNYXhSZXRyeSc6XG4gICAgICAgICAgICBzZXR0aW5ncy5lcnJvclJldHJ5Lm1heE51bVJldHJ5ID0gdmFsdWU7XG4gICAgICAgICAgICBzZXR0aW5ncy50aW1lb3V0UmV0cnkubWF4TnVtUmV0cnkgPSB2YWx1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ1JldHJ5RGVsYXknOlxuICAgICAgICAgICAgc2V0dGluZ3MuZXJyb3JSZXRyeS5yZXRyeURlbGF5TXMgPSB2YWx1ZTtcbiAgICAgICAgICAgIHNldHRpbmdzLnRpbWVvdXRSZXRyeS5yZXRyeURlbGF5TXMgPSB2YWx1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ01heFJldHJ5VGltZW91dCc6XG4gICAgICAgICAgICBzZXR0aW5ncy5lcnJvclJldHJ5Lm1heFJldHJ5RGVsYXlNcyA9IHZhbHVlO1xuICAgICAgICAgICAgc2V0dGluZ3MudGltZW91dFJldHJ5Lm1heFJldHJ5RGVsYXlNcyA9IHZhbHVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAocmVwb3J0Lmxlbmd0aCkge1xuICAgICAgbG9nZ2VyLndhcm4oYGhscy5qcyBjb25maWc6IFwiJHtyZXBvcnQuam9pbignXCIsIFwiJyl9XCIgc2V0dGluZyhzKSBhcmUgZGVwcmVjYXRlZCwgdXNlIFwiJHtwb2xpY3lOYW1lfVwiOiAke0pTT04uc3RyaW5naWZ5KHVzZXJDb25maWdbcG9saWN5TmFtZV0pfWApO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZGVmYXVsdHNDb3B5KSwgdXNlckNvbmZpZyk7XG59XG5mdW5jdGlvbiBkZWVwQ3B5KG9iaikge1xuICBpZiAob2JqICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgcmV0dXJuIG9iai5tYXAoZGVlcENweSk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLnJlZHVjZSgocmVzdWx0LCBrZXkpID0+IHtcbiAgICAgIHJlc3VsdFtrZXldID0gZGVlcENweShvYmpba2V5XSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIHt9KTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gZW5hYmxlU3RyZWFtaW5nTW9kZShjb25maWcpIHtcbiAgY29uc3QgY3VycmVudExvYWRlciA9IGNvbmZpZy5sb2FkZXI7XG4gIGlmIChjdXJyZW50TG9hZGVyICE9PSBGZXRjaExvYWRlciAmJiBjdXJyZW50TG9hZGVyICE9PSBYaHJMb2FkZXIpIHtcbiAgICAvLyBJZiBhIGRldmVsb3BlciBoYXMgY29uZmlndXJlZCB0aGVpciBvd24gbG9hZGVyLCByZXNwZWN0IHRoYXQgY2hvaWNlXG4gICAgbG9nZ2VyLmxvZygnW2NvbmZpZ106IEN1c3RvbSBsb2FkZXIgZGV0ZWN0ZWQsIGNhbm5vdCBlbmFibGUgcHJvZ3Jlc3NpdmUgc3RyZWFtaW5nJyk7XG4gICAgY29uZmlnLnByb2dyZXNzaXZlID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgY2FuU3RyZWFtUHJvZ3Jlc3NpdmVseSA9IGZldGNoU3VwcG9ydGVkKCk7XG4gICAgaWYgKGNhblN0cmVhbVByb2dyZXNzaXZlbHkpIHtcbiAgICAgIGNvbmZpZy5sb2FkZXIgPSBGZXRjaExvYWRlcjtcbiAgICAgIGNvbmZpZy5wcm9ncmVzc2l2ZSA9IHRydWU7XG4gICAgICBjb25maWcuZW5hYmxlU29mdHdhcmVBRVMgPSB0cnVlO1xuICAgICAgbG9nZ2VyLmxvZygnW2NvbmZpZ106IFByb2dyZXNzaXZlIHN0cmVhbWluZyBlbmFibGVkLCB1c2luZyBGZXRjaExvYWRlcicpO1xuICAgIH1cbiAgfVxufVxuXG5sZXQgY2hyb21lT3JGaXJlZm94O1xuY2xhc3MgTGV2ZWxDb250cm9sbGVyIGV4dGVuZHMgQmFzZVBsYXlsaXN0Q29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGhscywgY29udGVudFN0ZWVyaW5nQ29udHJvbGxlcikge1xuICAgIHN1cGVyKGhscywgJ1tsZXZlbC1jb250cm9sbGVyXScpO1xuICAgIHRoaXMuX2xldmVscyA9IFtdO1xuICAgIHRoaXMuX2ZpcnN0TGV2ZWwgPSAtMTtcbiAgICB0aGlzLl9tYXhBdXRvTGV2ZWwgPSAtMTtcbiAgICB0aGlzLl9zdGFydExldmVsID0gdm9pZCAwO1xuICAgIHRoaXMuY3VycmVudExldmVsID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnRMZXZlbEluZGV4ID0gLTE7XG4gICAgdGhpcy5tYW51YWxMZXZlbEluZGV4ID0gLTE7XG4gICAgdGhpcy5zdGVlcmluZyA9IHZvaWQgMDtcbiAgICB0aGlzLm9uUGFyc2VkQ29tcGxldGUgPSB2b2lkIDA7XG4gICAgdGhpcy5zdGVlcmluZyA9IGNvbnRlbnRTdGVlcmluZ0NvbnRyb2xsZXI7XG4gICAgdGhpcy5fcmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICBfcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgaGxzLm9uKEV2ZW50cy5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURFRCwgdGhpcy5vbk1hbmlmZXN0TG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMX0xPQURFRCwgdGhpcy5vbkxldmVsTG9hZGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkxFVkVMU19VUERBVEVELCB0aGlzLm9uTGV2ZWxzVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5GUkFHX0JVRkZFUkVELCB0aGlzLm9uRnJhZ0J1ZmZlcmVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICB9XG4gIF91bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURFRCwgdGhpcy5vbk1hbmlmZXN0TG9hZGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTF9MT0FERUQsIHRoaXMub25MZXZlbExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTEVWRUxTX1VQREFURUQsIHRoaXMub25MZXZlbHNVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5GUkFHX0JVRkZFUkVELCB0aGlzLm9uRnJhZ0J1ZmZlcmVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLnN0ZWVyaW5nID0gbnVsbDtcbiAgICB0aGlzLnJlc2V0TGV2ZWxzKCk7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICB9XG4gIHN0b3BMb2FkKCkge1xuICAgIGNvbnN0IGxldmVscyA9IHRoaXMuX2xldmVscztcblxuICAgIC8vIGNsZWFuIHVwIGxpdmUgbGV2ZWwgZGV0YWlscyB0byBmb3JjZSByZWxvYWQgdGhlbSwgYW5kIHJlc2V0IGxvYWQgZXJyb3JzXG4gICAgbGV2ZWxzLmZvckVhY2gobGV2ZWwgPT4ge1xuICAgICAgbGV2ZWwubG9hZEVycm9yID0gMDtcbiAgICAgIGxldmVsLmZyYWdtZW50RXJyb3IgPSAwO1xuICAgIH0pO1xuICAgIHN1cGVyLnN0b3BMb2FkKCk7XG4gIH1cbiAgcmVzZXRMZXZlbHMoKSB7XG4gICAgdGhpcy5fc3RhcnRMZXZlbCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1hbnVhbExldmVsSW5kZXggPSAtMTtcbiAgICB0aGlzLmN1cnJlbnRMZXZlbEluZGV4ID0gLTE7XG4gICAgdGhpcy5jdXJyZW50TGV2ZWwgPSBudWxsO1xuICAgIHRoaXMuX2xldmVscyA9IFtdO1xuICAgIHRoaXMuX21heEF1dG9MZXZlbCA9IC0xO1xuICB9XG4gIG9uTWFuaWZlc3RMb2FkaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgdGhpcy5yZXNldExldmVscygpO1xuICB9XG4gIG9uTWFuaWZlc3RMb2FkZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCBwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UgPSB0aGlzLmhscy5jb25maWcucHJlZmVyTWFuYWdlZE1lZGlhU291cmNlO1xuICAgIGNvbnN0IGxldmVscyA9IFtdO1xuICAgIGNvbnN0IHJlZHVuZGFudFNldCA9IHt9O1xuICAgIGNvbnN0IGdlbmVyYXRlUGF0aHdheVNldCA9IHt9O1xuICAgIGxldCByZXNvbHV0aW9uRm91bmQgPSBmYWxzZTtcbiAgICBsZXQgdmlkZW9Db2RlY0ZvdW5kID0gZmFsc2U7XG4gICAgbGV0IGF1ZGlvQ29kZWNGb3VuZCA9IGZhbHNlO1xuICAgIGRhdGEubGV2ZWxzLmZvckVhY2gobGV2ZWxQYXJzZWQgPT4ge1xuICAgICAgdmFyIF9hdWRpb0NvZGVjLCBfdmlkZW9Db2RlYztcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBsZXZlbFBhcnNlZC5hdHRycztcblxuICAgICAgLy8gZXJhc2UgYXVkaW8gY29kZWMgaW5mbyBpZiBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgbXA0YS40MC4zNC5cbiAgICAgIC8vIGRlbXV4ZXIgd2lsbCBhdXRvZGV0ZWN0IGNvZGVjIGFuZCBmYWxsYmFjayB0byBtcGVnL2F1ZGlvXG4gICAgICBsZXQge1xuICAgICAgICBhdWRpb0NvZGVjLFxuICAgICAgICB2aWRlb0NvZGVjXG4gICAgICB9ID0gbGV2ZWxQYXJzZWQ7XG4gICAgICBpZiAoKChfYXVkaW9Db2RlYyA9IGF1ZGlvQ29kZWMpID09IG51bGwgPyB2b2lkIDAgOiBfYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjM0JykpICE9PSAtMSkge1xuICAgICAgICBjaHJvbWVPckZpcmVmb3ggfHwgKGNocm9tZU9yRmlyZWZveCA9IC9jaHJvbWV8ZmlyZWZveC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpO1xuICAgICAgICBpZiAoY2hyb21lT3JGaXJlZm94KSB7XG4gICAgICAgICAgbGV2ZWxQYXJzZWQuYXVkaW9Db2RlYyA9IGF1ZGlvQ29kZWMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhdWRpb0NvZGVjKSB7XG4gICAgICAgIGxldmVsUGFyc2VkLmF1ZGlvQ29kZWMgPSBhdWRpb0NvZGVjID0gZ2V0Q29kZWNDb21wYXRpYmxlTmFtZShhdWRpb0NvZGVjLCBwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UpO1xuICAgICAgfVxuICAgICAgaWYgKCgoX3ZpZGVvQ29kZWMgPSB2aWRlb0NvZGVjKSA9PSBudWxsID8gdm9pZCAwIDogX3ZpZGVvQ29kZWMuaW5kZXhPZignYXZjMScpKSA9PT0gMCkge1xuICAgICAgICB2aWRlb0NvZGVjID0gbGV2ZWxQYXJzZWQudmlkZW9Db2RlYyA9IGNvbnZlcnRBVkMxVG9BVkNPVEkodmlkZW9Db2RlYyk7XG4gICAgICB9XG5cbiAgICAgIC8vIG9ubHkga2VlcCBsZXZlbHMgd2l0aCBzdXBwb3J0ZWQgYXVkaW8vdmlkZW8gY29kZWNzXG4gICAgICBjb25zdCB7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIHVua25vd25Db2RlY3NcbiAgICAgIH0gPSBsZXZlbFBhcnNlZDtcbiAgICAgIHJlc29sdXRpb25Gb3VuZCB8fCAocmVzb2x1dGlvbkZvdW5kID0gISEod2lkdGggJiYgaGVpZ2h0KSk7XG4gICAgICB2aWRlb0NvZGVjRm91bmQgfHwgKHZpZGVvQ29kZWNGb3VuZCA9ICEhdmlkZW9Db2RlYyk7XG4gICAgICBhdWRpb0NvZGVjRm91bmQgfHwgKGF1ZGlvQ29kZWNGb3VuZCA9ICEhYXVkaW9Db2RlYyk7XG4gICAgICBpZiAodW5rbm93bkNvZGVjcyAhPSBudWxsICYmIHVua25vd25Db2RlY3MubGVuZ3RoIHx8IGF1ZGlvQ29kZWMgJiYgIWFyZUNvZGVjc01lZGlhU291cmNlU3VwcG9ydGVkKGF1ZGlvQ29kZWMsICdhdWRpbycsIHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSkgfHwgdmlkZW9Db2RlYyAmJiAhYXJlQ29kZWNzTWVkaWFTb3VyY2VTdXBwb3J0ZWQodmlkZW9Db2RlYywgJ3ZpZGVvJywgcHJlZmVyTWFuYWdlZE1lZGlhU291cmNlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIENPREVDUyxcbiAgICAgICAgJ0ZSQU1FLVJBVEUnOiBGUkFNRVJBVEUsXG4gICAgICAgICdIRENQLUxFVkVMJzogSERDUCxcbiAgICAgICAgJ1BBVEhXQVktSUQnOiBQQVRIV0FZLFxuICAgICAgICBSRVNPTFVUSU9OLFxuICAgICAgICAnVklERU8tUkFOR0UnOiBWSURFT19SQU5HRVxuICAgICAgfSA9IGF0dHJpYnV0ZXM7XG4gICAgICBjb25zdCBjb250ZW50U3RlZXJpbmdQcmVmaXggPSBgJHtQQVRIV0FZIHx8ICcuJ30tYDtcbiAgICAgIGNvbnN0IGxldmVsS2V5ID0gYCR7Y29udGVudFN0ZWVyaW5nUHJlZml4fSR7bGV2ZWxQYXJzZWQuYml0cmF0ZX0tJHtSRVNPTFVUSU9OfS0ke0ZSQU1FUkFURX0tJHtDT0RFQ1N9LSR7VklERU9fUkFOR0V9LSR7SERDUH1gO1xuICAgICAgaWYgKCFyZWR1bmRhbnRTZXRbbGV2ZWxLZXldKSB7XG4gICAgICAgIGNvbnN0IGxldmVsID0gbmV3IExldmVsKGxldmVsUGFyc2VkKTtcbiAgICAgICAgcmVkdW5kYW50U2V0W2xldmVsS2V5XSA9IGxldmVsO1xuICAgICAgICBnZW5lcmF0ZVBhdGh3YXlTZXRbbGV2ZWxLZXldID0gMTtcbiAgICAgICAgbGV2ZWxzLnB1c2gobGV2ZWwpO1xuICAgICAgfSBlbHNlIGlmIChyZWR1bmRhbnRTZXRbbGV2ZWxLZXldLnVyaSAhPT0gbGV2ZWxQYXJzZWQudXJsICYmICFsZXZlbFBhcnNlZC5hdHRyc1snUEFUSFdBWS1JRCddKSB7XG4gICAgICAgIC8vIEFzc2lnbiBQYXRod2F5IElEcyB0byBSZWR1bmRhbnQgU3RyZWFtcyAoZGVmYXVsdCBQYXRod2F5cyBpcyBcIi5cIi4gUmVkdW5kYW50IFN0cmVhbXMgXCIuLlwiLCBcIi4uLlwiLCBhbmQgc28gb24uKVxuICAgICAgICAvLyBDb250ZW50IFN0ZWVyaW5nIGNvbnRyb2xsZXIgdG8gaGFuZGxlcyBQYXRod2F5IGZhbGxiYWNrIG9uIGVycm9yXG4gICAgICAgIGNvbnN0IHBhdGh3YXlDb3VudCA9IGdlbmVyYXRlUGF0aHdheVNldFtsZXZlbEtleV0gKz0gMTtcbiAgICAgICAgbGV2ZWxQYXJzZWQuYXR0cnNbJ1BBVEhXQVktSUQnXSA9IG5ldyBBcnJheShwYXRod2F5Q291bnQgKyAxKS5qb2luKCcuJyk7XG4gICAgICAgIGNvbnN0IGxldmVsID0gbmV3IExldmVsKGxldmVsUGFyc2VkKTtcbiAgICAgICAgcmVkdW5kYW50U2V0W2xldmVsS2V5XSA9IGxldmVsO1xuICAgICAgICBsZXZlbHMucHVzaChsZXZlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWR1bmRhbnRTZXRbbGV2ZWxLZXldLmFkZEdyb3VwSWQoJ2F1ZGlvJywgYXR0cmlidXRlcy5BVURJTyk7XG4gICAgICAgIHJlZHVuZGFudFNldFtsZXZlbEtleV0uYWRkR3JvdXBJZCgndGV4dCcsIGF0dHJpYnV0ZXMuU1VCVElUTEVTKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmZpbHRlckFuZFNvcnRNZWRpYU9wdGlvbnMobGV2ZWxzLCBkYXRhLCByZXNvbHV0aW9uRm91bmQsIHZpZGVvQ29kZWNGb3VuZCwgYXVkaW9Db2RlY0ZvdW5kKTtcbiAgfVxuICBmaWx0ZXJBbmRTb3J0TWVkaWFPcHRpb25zKGZpbHRlcmVkTGV2ZWxzLCBkYXRhLCByZXNvbHV0aW9uRm91bmQsIHZpZGVvQ29kZWNGb3VuZCwgYXVkaW9Db2RlY0ZvdW5kKSB7XG4gICAgbGV0IGF1ZGlvVHJhY2tzID0gW107XG4gICAgbGV0IHN1YnRpdGxlVHJhY2tzID0gW107XG4gICAgbGV0IGxldmVscyA9IGZpbHRlcmVkTGV2ZWxzO1xuXG4gICAgLy8gcmVtb3ZlIGF1ZGlvLW9ubHkgYW5kIGludmFsaWQgdmlkZW8tcmFuZ2UgbGV2ZWxzIGlmIHdlIGFsc28gaGF2ZSBsZXZlbHMgd2l0aCB2aWRlbyBjb2RlY3Mgb3IgUkVTT0xVVElPTiBzaWduYWxsZWRcbiAgICBpZiAoKHJlc29sdXRpb25Gb3VuZCB8fCB2aWRlb0NvZGVjRm91bmQpICYmIGF1ZGlvQ29kZWNGb3VuZCkge1xuICAgICAgbGV2ZWxzID0gbGV2ZWxzLmZpbHRlcigoe1xuICAgICAgICB2aWRlb0NvZGVjLFxuICAgICAgICB2aWRlb1JhbmdlLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICB9KSA9PiAoISF2aWRlb0NvZGVjIHx8ICEhKHdpZHRoICYmIGhlaWdodCkpICYmIGlzVmlkZW9SYW5nZSh2aWRlb1JhbmdlKSk7XG4gICAgfVxuICAgIGlmIChsZXZlbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBEaXNwYXRjaCBlcnJvciBhZnRlciBNQU5JRkVTVF9MT0FERUQgaXMgZG9uZSBwcm9wYWdhdGluZ1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmhscykge1xuICAgICAgICAgIGlmIChkYXRhLmxldmVscy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMud2FybihgT25lIG9yIG1vcmUgQ09ERUNTIGluIHZhcmlhbnQgbm90IHN1cHBvcnRlZDogJHtKU09OLnN0cmluZ2lmeShkYXRhLmxldmVsc1swXS5hdHRycyl9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdubyBsZXZlbCB3aXRoIGNvbXBhdGlibGUgY29kZWNzIGZvdW5kIGluIG1hbmlmZXN0Jyk7XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuTUFOSUZFU1RfSU5DT01QQVRJQkxFX0NPREVDU19FUlJPUixcbiAgICAgICAgICAgIGZhdGFsOiB0cnVlLFxuICAgICAgICAgICAgdXJsOiBkYXRhLnVybCxcbiAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgcmVhc29uOiBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZGF0YS5hdWRpb1RyYWNrcykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2VcbiAgICAgIH0gPSB0aGlzLmhscy5jb25maWc7XG4gICAgICBhdWRpb1RyYWNrcyA9IGRhdGEuYXVkaW9UcmFja3MuZmlsdGVyKHRyYWNrID0+ICF0cmFjay5hdWRpb0NvZGVjIHx8IGFyZUNvZGVjc01lZGlhU291cmNlU3VwcG9ydGVkKHRyYWNrLmF1ZGlvQ29kZWMsICdhdWRpbycsIHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSkpO1xuICAgICAgLy8gQXNzaWduIGlkcyBhZnRlciBmaWx0ZXJpbmcgYXMgYXJyYXkgaW5kaWNlcyBieSBncm91cC1pZFxuICAgICAgYXNzaWduVHJhY2tJZHNCeUdyb3VwKGF1ZGlvVHJhY2tzKTtcbiAgICB9XG4gICAgaWYgKGRhdGEuc3VidGl0bGVzKSB7XG4gICAgICBzdWJ0aXRsZVRyYWNrcyA9IGRhdGEuc3VidGl0bGVzO1xuICAgICAgYXNzaWduVHJhY2tJZHNCeUdyb3VwKHN1YnRpdGxlVHJhY2tzKTtcbiAgICB9XG4gICAgLy8gc3RhcnQgYml0cmF0ZSBpcyB0aGUgZmlyc3QgYml0cmF0ZSBvZiB0aGUgbWFuaWZlc3RcbiAgICBjb25zdCB1bnNvcnRlZExldmVscyA9IGxldmVscy5zbGljZSgwKTtcbiAgICAvLyBzb3J0IGxldmVscyBmcm9tIGxvd2VzdCB0byBoaWdoZXN0XG4gICAgbGV2ZWxzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIGlmIChhLmF0dHJzWydIRENQLUxFVkVMJ10gIT09IGIuYXR0cnNbJ0hEQ1AtTEVWRUwnXSkge1xuICAgICAgICByZXR1cm4gKGEuYXR0cnNbJ0hEQ1AtTEVWRUwnXSB8fCAnJykgPiAoYi5hdHRyc1snSERDUC1MRVZFTCddIHx8ICcnKSA/IDEgOiAtMTtcbiAgICAgIH1cbiAgICAgIC8vIHNvcnQgb24gaGVpZ2h0IGJlZm9yZSBiaXRyYXRlIGZvciBjYXAtbGV2ZWwtY29udHJvbGxlclxuICAgICAgaWYgKHJlc29sdXRpb25Gb3VuZCAmJiBhLmhlaWdodCAhPT0gYi5oZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIGEuaGVpZ2h0IC0gYi5oZWlnaHQ7XG4gICAgICB9XG4gICAgICBpZiAoYS5mcmFtZVJhdGUgIT09IGIuZnJhbWVSYXRlKSB7XG4gICAgICAgIHJldHVybiBhLmZyYW1lUmF0ZSAtIGIuZnJhbWVSYXRlO1xuICAgICAgfVxuICAgICAgaWYgKGEudmlkZW9SYW5nZSAhPT0gYi52aWRlb1JhbmdlKSB7XG4gICAgICAgIHJldHVybiBWaWRlb1JhbmdlVmFsdWVzLmluZGV4T2YoYS52aWRlb1JhbmdlKSAtIFZpZGVvUmFuZ2VWYWx1ZXMuaW5kZXhPZihiLnZpZGVvUmFuZ2UpO1xuICAgICAgfVxuICAgICAgaWYgKGEudmlkZW9Db2RlYyAhPT0gYi52aWRlb0NvZGVjKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlQSA9IHZpZGVvQ29kZWNQcmVmZXJlbmNlVmFsdWUoYS52aWRlb0NvZGVjKTtcbiAgICAgICAgY29uc3QgdmFsdWVCID0gdmlkZW9Db2RlY1ByZWZlcmVuY2VWYWx1ZShiLnZpZGVvQ29kZWMpO1xuICAgICAgICBpZiAodmFsdWVBICE9PSB2YWx1ZUIpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWVCIC0gdmFsdWVBO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYS51cmkgPT09IGIudXJpICYmIGEuY29kZWNTZXQgIT09IGIuY29kZWNTZXQpIHtcbiAgICAgICAgY29uc3QgdmFsdWVBID0gY29kZWNzU2V0U2VsZWN0aW9uUHJlZmVyZW5jZVZhbHVlKGEuY29kZWNTZXQpO1xuICAgICAgICBjb25zdCB2YWx1ZUIgPSBjb2RlY3NTZXRTZWxlY3Rpb25QcmVmZXJlbmNlVmFsdWUoYi5jb2RlY1NldCk7XG4gICAgICAgIGlmICh2YWx1ZUEgIT09IHZhbHVlQikge1xuICAgICAgICAgIHJldHVybiB2YWx1ZUIgLSB2YWx1ZUE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhLmF2ZXJhZ2VCaXRyYXRlICE9PSBiLmF2ZXJhZ2VCaXRyYXRlKSB7XG4gICAgICAgIHJldHVybiBhLmF2ZXJhZ2VCaXRyYXRlIC0gYi5hdmVyYWdlQml0cmF0ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH0pO1xuICAgIGxldCBmaXJzdExldmVsSW5QbGF5bGlzdCA9IHVuc29ydGVkTGV2ZWxzWzBdO1xuICAgIGlmICh0aGlzLnN0ZWVyaW5nKSB7XG4gICAgICBsZXZlbHMgPSB0aGlzLnN0ZWVyaW5nLmZpbHRlclBhcnNlZExldmVscyhsZXZlbHMpO1xuICAgICAgaWYgKGxldmVscy5sZW5ndGggIT09IHVuc29ydGVkTGV2ZWxzLmxlbmd0aCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVuc29ydGVkTGV2ZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHVuc29ydGVkTGV2ZWxzW2ldLnBhdGh3YXlJZCA9PT0gbGV2ZWxzWzBdLnBhdGh3YXlJZCkge1xuICAgICAgICAgICAgZmlyc3RMZXZlbEluUGxheWxpc3QgPSB1bnNvcnRlZExldmVsc1tpXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9sZXZlbHMgPSBsZXZlbHM7XG5cbiAgICAvLyBmaW5kIGluZGV4IG9mIGZpcnN0IGxldmVsIGluIHNvcnRlZCBsZXZlbHNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxldmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxldmVsc1tpXSA9PT0gZmlyc3RMZXZlbEluUGxheWxpc3QpIHtcbiAgICAgICAgdmFyIF90aGlzJGhscyR1c2VyQ29uZmlnO1xuICAgICAgICB0aGlzLl9maXJzdExldmVsID0gaTtcbiAgICAgICAgY29uc3QgZmlyc3RMZXZlbEJpdHJhdGUgPSBmaXJzdExldmVsSW5QbGF5bGlzdC5iaXRyYXRlO1xuICAgICAgICBjb25zdCBiYW5kd2lkdGhFc3RpbWF0ZSA9IHRoaXMuaGxzLmJhbmR3aWR0aEVzdGltYXRlO1xuICAgICAgICB0aGlzLmxvZyhgbWFuaWZlc3QgbG9hZGVkLCAke2xldmVscy5sZW5ndGh9IGxldmVsKHMpIGZvdW5kLCBmaXJzdCBiaXRyYXRlOiAke2ZpcnN0TGV2ZWxCaXRyYXRlfWApO1xuICAgICAgICAvLyBVcGRhdGUgZGVmYXVsdCBid2UgdG8gZmlyc3QgdmFyaWFudCBiaXRyYXRlIGFzIGxvbmcgaXQgaGFzIG5vdCBiZWVuIGNvbmZpZ3VyZWQgb3Igc2V0XG4gICAgICAgIGlmICgoKF90aGlzJGhscyR1c2VyQ29uZmlnID0gdGhpcy5obHMudXNlckNvbmZpZykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGhscyR1c2VyQ29uZmlnLmFickV3bWFEZWZhdWx0RXN0aW1hdGUpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb25zdCBzdGFydGluZ0J3RXN0aW1hdGUgPSBNYXRoLm1pbihmaXJzdExldmVsQml0cmF0ZSwgdGhpcy5obHMuY29uZmlnLmFickV3bWFEZWZhdWx0RXN0aW1hdGVNYXgpO1xuICAgICAgICAgIGlmIChzdGFydGluZ0J3RXN0aW1hdGUgPiBiYW5kd2lkdGhFc3RpbWF0ZSAmJiBiYW5kd2lkdGhFc3RpbWF0ZSA9PT0gaGxzRGVmYXVsdENvbmZpZy5hYnJFd21hRGVmYXVsdEVzdGltYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmhscy5iYW5kd2lkdGhFc3RpbWF0ZSA9IHN0YXJ0aW5nQndFc3RpbWF0ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQXVkaW8gaXMgb25seSBhbHRlcm5hdGUgaWYgbWFuaWZlc3QgaW5jbHVkZSBhIFVSSSBhbG9uZyB3aXRoIHRoZSBhdWRpbyBncm91cCB0YWcsXG4gICAgLy8gYW5kIHRoaXMgaXMgbm90IGFuIGF1ZGlvLW9ubHkgc3RyZWFtIHdoZXJlIGxldmVscyBjb250YWluIGF1ZGlvLW9ubHlcbiAgICBjb25zdCBhdWRpb09ubHkgPSBhdWRpb0NvZGVjRm91bmQgJiYgIXZpZGVvQ29kZWNGb3VuZDtcbiAgICBjb25zdCBlZGF0YSA9IHtcbiAgICAgIGxldmVscyxcbiAgICAgIGF1ZGlvVHJhY2tzLFxuICAgICAgc3VidGl0bGVUcmFja3MsXG4gICAgICBzZXNzaW9uRGF0YTogZGF0YS5zZXNzaW9uRGF0YSxcbiAgICAgIHNlc3Npb25LZXlzOiBkYXRhLnNlc3Npb25LZXlzLFxuICAgICAgZmlyc3RMZXZlbDogdGhpcy5fZmlyc3RMZXZlbCxcbiAgICAgIHN0YXRzOiBkYXRhLnN0YXRzLFxuICAgICAgYXVkaW86IGF1ZGlvQ29kZWNGb3VuZCxcbiAgICAgIHZpZGVvOiB2aWRlb0NvZGVjRm91bmQsXG4gICAgICBhbHRBdWRpbzogIWF1ZGlvT25seSAmJiBhdWRpb1RyYWNrcy5zb21lKHQgPT4gISF0LnVybClcbiAgICB9O1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwgZWRhdGEpO1xuXG4gICAgLy8gSW5pdGlhdGUgbG9hZGluZyBhZnRlciBhbGwgY29udHJvbGxlcnMgaGF2ZSByZWNlaXZlZCBNQU5JRkVTVF9QQVJTRURcbiAgICBpZiAodGhpcy5obHMuY29uZmlnLmF1dG9TdGFydExvYWQgfHwgdGhpcy5obHMuZm9yY2VTdGFydExvYWQpIHtcbiAgICAgIHRoaXMuaGxzLnN0YXJ0TG9hZCh0aGlzLmhscy5jb25maWcuc3RhcnRQb3NpdGlvbik7XG4gICAgfVxuICB9XG4gIGdldCBsZXZlbHMoKSB7XG4gICAgaWYgKHRoaXMuX2xldmVscy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbGV2ZWxzO1xuICB9XG4gIGdldCBsZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50TGV2ZWxJbmRleDtcbiAgfVxuICBzZXQgbGV2ZWwobmV3TGV2ZWwpIHtcbiAgICBjb25zdCBsZXZlbHMgPSB0aGlzLl9sZXZlbHM7XG4gICAgaWYgKGxldmVscy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gY2hlY2sgaWYgbGV2ZWwgaWR4IGlzIHZhbGlkXG4gICAgaWYgKG5ld0xldmVsIDwgMCB8fCBuZXdMZXZlbCA+PSBsZXZlbHMubGVuZ3RoKSB7XG4gICAgICAvLyBpbnZhbGlkIGxldmVsIGlkIGdpdmVuLCB0cmlnZ2VyIGVycm9yXG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignaW52YWxpZCBsZXZlbCBpZHgnKTtcbiAgICAgIGNvbnN0IGZhdGFsID0gbmV3TGV2ZWwgPCAwO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5PVEhFUl9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkxFVkVMX1NXSVRDSF9FUlJPUixcbiAgICAgICAgbGV2ZWw6IG5ld0xldmVsLFxuICAgICAgICBmYXRhbCxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIHJlYXNvbjogZXJyb3IubWVzc2FnZVxuICAgICAgfSk7XG4gICAgICBpZiAoZmF0YWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbmV3TGV2ZWwgPSBNYXRoLm1pbihuZXdMZXZlbCwgbGV2ZWxzLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICBjb25zdCBsYXN0TGV2ZWxJbmRleCA9IHRoaXMuY3VycmVudExldmVsSW5kZXg7XG4gICAgY29uc3QgbGFzdExldmVsID0gdGhpcy5jdXJyZW50TGV2ZWw7XG4gICAgY29uc3QgbGFzdFBhdGh3YXlJZCA9IGxhc3RMZXZlbCA/IGxhc3RMZXZlbC5hdHRyc1snUEFUSFdBWS1JRCddIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IGxldmVsID0gbGV2ZWxzW25ld0xldmVsXTtcbiAgICBjb25zdCBwYXRod2F5SWQgPSBsZXZlbC5hdHRyc1snUEFUSFdBWS1JRCddO1xuICAgIHRoaXMuY3VycmVudExldmVsSW5kZXggPSBuZXdMZXZlbDtcbiAgICB0aGlzLmN1cnJlbnRMZXZlbCA9IGxldmVsO1xuICAgIGlmIChsYXN0TGV2ZWxJbmRleCA9PT0gbmV3TGV2ZWwgJiYgbGV2ZWwuZGV0YWlscyAmJiBsYXN0TGV2ZWwgJiYgbGFzdFBhdGh3YXlJZCA9PT0gcGF0aHdheUlkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubG9nKGBTd2l0Y2hpbmcgdG8gbGV2ZWwgJHtuZXdMZXZlbH0gKCR7bGV2ZWwuaGVpZ2h0ID8gbGV2ZWwuaGVpZ2h0ICsgJ3AgJyA6ICcnfSR7bGV2ZWwudmlkZW9SYW5nZSA/IGxldmVsLnZpZGVvUmFuZ2UgKyAnICcgOiAnJ30ke2xldmVsLmNvZGVjU2V0ID8gbGV2ZWwuY29kZWNTZXQgKyAnICcgOiAnJ31AJHtsZXZlbC5iaXRyYXRlfSkke3BhdGh3YXlJZCA/ICcgd2l0aCBQYXRod2F5ICcgKyBwYXRod2F5SWQgOiAnJ30gZnJvbSBsZXZlbCAke2xhc3RMZXZlbEluZGV4fSR7bGFzdFBhdGh3YXlJZCA/ICcgd2l0aCBQYXRod2F5ICcgKyBsYXN0UGF0aHdheUlkIDogJyd9YCk7XG4gICAgY29uc3QgbGV2ZWxTd2l0Y2hpbmdEYXRhID0ge1xuICAgICAgbGV2ZWw6IG5ld0xldmVsLFxuICAgICAgYXR0cnM6IGxldmVsLmF0dHJzLFxuICAgICAgZGV0YWlsczogbGV2ZWwuZGV0YWlscyxcbiAgICAgIGJpdHJhdGU6IGxldmVsLmJpdHJhdGUsXG4gICAgICBhdmVyYWdlQml0cmF0ZTogbGV2ZWwuYXZlcmFnZUJpdHJhdGUsXG4gICAgICBtYXhCaXRyYXRlOiBsZXZlbC5tYXhCaXRyYXRlLFxuICAgICAgcmVhbEJpdHJhdGU6IGxldmVsLnJlYWxCaXRyYXRlLFxuICAgICAgd2lkdGg6IGxldmVsLndpZHRoLFxuICAgICAgaGVpZ2h0OiBsZXZlbC5oZWlnaHQsXG4gICAgICBjb2RlY1NldDogbGV2ZWwuY29kZWNTZXQsXG4gICAgICBhdWRpb0NvZGVjOiBsZXZlbC5hdWRpb0NvZGVjLFxuICAgICAgdmlkZW9Db2RlYzogbGV2ZWwudmlkZW9Db2RlYyxcbiAgICAgIGF1ZGlvR3JvdXBzOiBsZXZlbC5hdWRpb0dyb3VwcyxcbiAgICAgIHN1YnRpdGxlR3JvdXBzOiBsZXZlbC5zdWJ0aXRsZUdyb3VwcyxcbiAgICAgIGxvYWRlZDogbGV2ZWwubG9hZGVkLFxuICAgICAgbG9hZEVycm9yOiBsZXZlbC5sb2FkRXJyb3IsXG4gICAgICBmcmFnbWVudEVycm9yOiBsZXZlbC5mcmFnbWVudEVycm9yLFxuICAgICAgbmFtZTogbGV2ZWwubmFtZSxcbiAgICAgIGlkOiBsZXZlbC5pZCxcbiAgICAgIHVyaTogbGV2ZWwudXJpLFxuICAgICAgdXJsOiBsZXZlbC51cmwsXG4gICAgICB1cmxJZDogMCxcbiAgICAgIGF1ZGlvR3JvdXBJZHM6IGxldmVsLmF1ZGlvR3JvdXBJZHMsXG4gICAgICB0ZXh0R3JvdXBJZHM6IGxldmVsLnRleHRHcm91cElkc1xuICAgIH07XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTEVWRUxfU1dJVENISU5HLCBsZXZlbFN3aXRjaGluZ0RhdGEpO1xuICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gbG9hZCBwbGF5bGlzdCBmb3IgdGhpcyBsZXZlbFxuICAgIGNvbnN0IGxldmVsRGV0YWlscyA9IGxldmVsLmRldGFpbHM7XG4gICAgaWYgKCFsZXZlbERldGFpbHMgfHwgbGV2ZWxEZXRhaWxzLmxpdmUpIHtcbiAgICAgIC8vIGxldmVsIG5vdCByZXRyaWV2ZWQgeWV0LCBvciBsaXZlIHBsYXlsaXN0IHdlIG5lZWQgdG8gKHJlKWxvYWQgaXRcbiAgICAgIGNvbnN0IGhsc1VybFBhcmFtZXRlcnMgPSB0aGlzLnN3aXRjaFBhcmFtcyhsZXZlbC51cmksIGxhc3RMZXZlbCA9PSBudWxsID8gdm9pZCAwIDogbGFzdExldmVsLmRldGFpbHMpO1xuICAgICAgdGhpcy5sb2FkUGxheWxpc3QoaGxzVXJsUGFyYW1ldGVycyk7XG4gICAgfVxuICB9XG4gIGdldCBtYW51YWxMZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5tYW51YWxMZXZlbEluZGV4O1xuICB9XG4gIHNldCBtYW51YWxMZXZlbChuZXdMZXZlbCkge1xuICAgIHRoaXMubWFudWFsTGV2ZWxJbmRleCA9IG5ld0xldmVsO1xuICAgIGlmICh0aGlzLl9zdGFydExldmVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3N0YXJ0TGV2ZWwgPSBuZXdMZXZlbDtcbiAgICB9XG4gICAgaWYgKG5ld0xldmVsICE9PSAtMSkge1xuICAgICAgdGhpcy5sZXZlbCA9IG5ld0xldmVsO1xuICAgIH1cbiAgfVxuICBnZXQgZmlyc3RMZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlyc3RMZXZlbDtcbiAgfVxuICBzZXQgZmlyc3RMZXZlbChuZXdMZXZlbCkge1xuICAgIHRoaXMuX2ZpcnN0TGV2ZWwgPSBuZXdMZXZlbDtcbiAgfVxuICBnZXQgc3RhcnRMZXZlbCgpIHtcbiAgICAvLyBTZXR0aW5nIGhscy5zdGFydExldmVsICh0aGlzLl9zdGFydExldmVsKSBvdmVycmlkZXMgY29uZmlnLnN0YXJ0TGV2ZWxcbiAgICBpZiAodGhpcy5fc3RhcnRMZXZlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBjb25maWdTdGFydExldmVsID0gdGhpcy5obHMuY29uZmlnLnN0YXJ0TGV2ZWw7XG4gICAgICBpZiAoY29uZmlnU3RhcnRMZXZlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBjb25maWdTdGFydExldmVsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuaGxzLmZpcnN0QXV0b0xldmVsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc3RhcnRMZXZlbDtcbiAgfVxuICBzZXQgc3RhcnRMZXZlbChuZXdMZXZlbCkge1xuICAgIHRoaXMuX3N0YXJ0TGV2ZWwgPSBuZXdMZXZlbDtcbiAgfVxuICBvbkVycm9yKGV2ZW50LCBkYXRhKSB7XG4gICAgaWYgKGRhdGEuZmF0YWwgfHwgIWRhdGEuY29udGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZGF0YS5jb250ZXh0LnR5cGUgPT09IFBsYXlsaXN0Q29udGV4dFR5cGUuTEVWRUwgJiYgZGF0YS5jb250ZXh0LmxldmVsID09PSB0aGlzLmxldmVsKSB7XG4gICAgICB0aGlzLmNoZWNrUmV0cnkoZGF0YSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcmVzZXQgZXJyb3JzIG9uIHRoZSBzdWNjZXNzZnVsIGxvYWQgb2YgYSBmcmFnbWVudFxuICBvbkZyYWdCdWZmZXJlZChldmVudCwge1xuICAgIGZyYWdcbiAgfSkge1xuICAgIGlmIChmcmFnICE9PSB1bmRlZmluZWQgJiYgZnJhZy50eXBlID09PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOKSB7XG4gICAgICBjb25zdCBlbCA9IGZyYWcuZWxlbWVudGFyeVN0cmVhbXM7XG4gICAgICBpZiAoIU9iamVjdC5rZXlzKGVsKS5zb21lKHR5cGUgPT4gISFlbFt0eXBlXSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbGV2ZWwgPSB0aGlzLl9sZXZlbHNbZnJhZy5sZXZlbF07XG4gICAgICBpZiAobGV2ZWwgIT0gbnVsbCAmJiBsZXZlbC5sb2FkRXJyb3IpIHtcbiAgICAgICAgdGhpcy5sb2coYFJlc2V0dGluZyBsZXZlbCBlcnJvciBjb3VudCBvZiAke2xldmVsLmxvYWRFcnJvcn0gb24gZnJhZyBidWZmZXJlZGApO1xuICAgICAgICBsZXZlbC5sb2FkRXJyb3IgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBvbkxldmVsTG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIF9kYXRhJGRlbGl2ZXJ5RGlyZWN0aTI7XG4gICAgY29uc3Qge1xuICAgICAgbGV2ZWwsXG4gICAgICBkZXRhaWxzXG4gICAgfSA9IGRhdGE7XG4gICAgY29uc3QgY3VyTGV2ZWwgPSB0aGlzLl9sZXZlbHNbbGV2ZWxdO1xuICAgIGlmICghY3VyTGV2ZWwpIHtcbiAgICAgIHZhciBfZGF0YSRkZWxpdmVyeURpcmVjdGk7XG4gICAgICB0aGlzLndhcm4oYEludmFsaWQgbGV2ZWwgaW5kZXggJHtsZXZlbH1gKTtcbiAgICAgIGlmICgoX2RhdGEkZGVsaXZlcnlEaXJlY3RpID0gZGF0YS5kZWxpdmVyeURpcmVjdGl2ZXMpICE9IG51bGwgJiYgX2RhdGEkZGVsaXZlcnlEaXJlY3RpLnNraXApIHtcbiAgICAgICAgZGV0YWlscy5kZWx0YVVwZGF0ZUZhaWxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gb25seSBwcm9jZXNzIGxldmVsIGxvYWRlZCBldmVudHMgbWF0Y2hpbmcgd2l0aCBleHBlY3RlZCBsZXZlbFxuICAgIGlmIChsZXZlbCA9PT0gdGhpcy5jdXJyZW50TGV2ZWxJbmRleCkge1xuICAgICAgLy8gcmVzZXQgbGV2ZWwgbG9hZCBlcnJvciBjb3VudGVyIG9uIHN1Y2Nlc3NmdWwgbGV2ZWwgbG9hZGVkIG9ubHkgaWYgdGhlcmUgaXMgbm8gaXNzdWVzIHdpdGggZnJhZ21lbnRzXG4gICAgICBpZiAoY3VyTGV2ZWwuZnJhZ21lbnRFcnJvciA9PT0gMCkge1xuICAgICAgICBjdXJMZXZlbC5sb2FkRXJyb3IgPSAwO1xuICAgICAgfVxuICAgICAgdGhpcy5wbGF5bGlzdExvYWRlZChsZXZlbCwgZGF0YSwgY3VyTGV2ZWwuZGV0YWlscyk7XG4gICAgfSBlbHNlIGlmICgoX2RhdGEkZGVsaXZlcnlEaXJlY3RpMiA9IGRhdGEuZGVsaXZlcnlEaXJlY3RpdmVzKSAhPSBudWxsICYmIF9kYXRhJGRlbGl2ZXJ5RGlyZWN0aTIuc2tpcCkge1xuICAgICAgLy8gcmVjZWl2ZWQgYSBkZWx0YSBwbGF5bGlzdCB1cGRhdGUgdGhhdCBjYW5ub3QgYmUgbWVyZ2VkXG4gICAgICBkZXRhaWxzLmRlbHRhVXBkYXRlRmFpbGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgbG9hZFBsYXlsaXN0KGhsc1VybFBhcmFtZXRlcnMpIHtcbiAgICBzdXBlci5sb2FkUGxheWxpc3QoKTtcbiAgICBjb25zdCBjdXJyZW50TGV2ZWxJbmRleCA9IHRoaXMuY3VycmVudExldmVsSW5kZXg7XG4gICAgY29uc3QgY3VycmVudExldmVsID0gdGhpcy5jdXJyZW50TGV2ZWw7XG4gICAgaWYgKGN1cnJlbnRMZXZlbCAmJiB0aGlzLnNob3VsZExvYWRQbGF5bGlzdChjdXJyZW50TGV2ZWwpKSB7XG4gICAgICBsZXQgdXJsID0gY3VycmVudExldmVsLnVyaTtcbiAgICAgIGlmIChobHNVcmxQYXJhbWV0ZXJzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdXJsID0gaGxzVXJsUGFyYW1ldGVycy5hZGREaXJlY3RpdmVzKHVybCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdGhpcy53YXJuKGBDb3VsZCBub3QgY29uc3RydWN0IG5ldyBVUkwgd2l0aCBITFMgRGVsaXZlcnkgRGlyZWN0aXZlczogJHtlcnJvcn1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgcGF0aHdheUlkID0gY3VycmVudExldmVsLmF0dHJzWydQQVRIV0FZLUlEJ107XG4gICAgICB0aGlzLmxvZyhgTG9hZGluZyBsZXZlbCBpbmRleCAke2N1cnJlbnRMZXZlbEluZGV4fSR7KGhsc1VybFBhcmFtZXRlcnMgPT0gbnVsbCA/IHZvaWQgMCA6IGhsc1VybFBhcmFtZXRlcnMubXNuKSAhPT0gdW5kZWZpbmVkID8gJyBhdCBzbiAnICsgaGxzVXJsUGFyYW1ldGVycy5tc24gKyAnIHBhcnQgJyArIGhsc1VybFBhcmFtZXRlcnMucGFydCA6ICcnfSB3aXRoJHtwYXRod2F5SWQgPyAnIFBhdGh3YXkgJyArIHBhdGh3YXlJZCA6ICcnfSAke3VybH1gKTtcblxuICAgICAgLy8gY29uc29sZS5sb2coJ0N1cnJlbnQgYXVkaW8gdHJhY2sgZ3JvdXAgSUQ6JywgdGhpcy5obHMuYXVkaW9UcmFja3NbdGhpcy5obHMuYXVkaW9UcmFja10uZ3JvdXBJZCk7XG4gICAgICAvLyBjb25zb2xlLmxvZygnTmV3IHZpZGVvIHF1YWxpdHkgbGV2ZWwgYXVkaW8gZ3JvdXAgaWQ6JywgbGV2ZWxPYmplY3QuYXR0cnMuQVVESU8sIGxldmVsKTtcbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTEVWRUxfTE9BRElORywge1xuICAgICAgICB1cmwsXG4gICAgICAgIGxldmVsOiBjdXJyZW50TGV2ZWxJbmRleCxcbiAgICAgICAgcGF0aHdheUlkOiBjdXJyZW50TGV2ZWwuYXR0cnNbJ1BBVEhXQVktSUQnXSxcbiAgICAgICAgaWQ6IDAsXG4gICAgICAgIC8vIERlcHJlY2F0ZWQgTGV2ZWwgdXJsSWRcbiAgICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzOiBobHNVcmxQYXJhbWV0ZXJzIHx8IG51bGxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBnZXQgbmV4dExvYWRMZXZlbCgpIHtcbiAgICBpZiAodGhpcy5tYW51YWxMZXZlbEluZGV4ICE9PSAtMSkge1xuICAgICAgcmV0dXJuIHRoaXMubWFudWFsTGV2ZWxJbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuaGxzLm5leHRBdXRvTGV2ZWw7XG4gICAgfVxuICB9XG4gIHNldCBuZXh0TG9hZExldmVsKG5leHRMZXZlbCkge1xuICAgIHRoaXMubGV2ZWwgPSBuZXh0TGV2ZWw7XG4gICAgaWYgKHRoaXMubWFudWFsTGV2ZWxJbmRleCA9PT0gLTEpIHtcbiAgICAgIHRoaXMuaGxzLm5leHRBdXRvTGV2ZWwgPSBuZXh0TGV2ZWw7XG4gICAgfVxuICB9XG4gIHJlbW92ZUxldmVsKGxldmVsSW5kZXgpIHtcbiAgICB2YXIgX3RoaXMkY3VycmVudExldmVsO1xuICAgIGNvbnN0IGxldmVscyA9IHRoaXMuX2xldmVscy5maWx0ZXIoKGxldmVsLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKGluZGV4ICE9PSBsZXZlbEluZGV4KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc3RlZXJpbmcpIHtcbiAgICAgICAgdGhpcy5zdGVlcmluZy5yZW1vdmVMZXZlbChsZXZlbCk7XG4gICAgICB9XG4gICAgICBpZiAobGV2ZWwgPT09IHRoaXMuY3VycmVudExldmVsKSB7XG4gICAgICAgIHRoaXMuY3VycmVudExldmVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdXJyZW50TGV2ZWxJbmRleCA9IC0xO1xuICAgICAgICBpZiAobGV2ZWwuZGV0YWlscykge1xuICAgICAgICAgIGxldmVsLmRldGFpbHMuZnJhZ21lbnRzLmZvckVhY2goZiA9PiBmLmxldmVsID0gLTEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gICAgcmVhc3NpZ25GcmFnbWVudExldmVsSW5kZXhlcyhsZXZlbHMpO1xuICAgIHRoaXMuX2xldmVscyA9IGxldmVscztcbiAgICBpZiAodGhpcy5jdXJyZW50TGV2ZWxJbmRleCA+IC0xICYmIChfdGhpcyRjdXJyZW50TGV2ZWwgPSB0aGlzLmN1cnJlbnRMZXZlbCkgIT0gbnVsbCAmJiBfdGhpcyRjdXJyZW50TGV2ZWwuZGV0YWlscykge1xuICAgICAgdGhpcy5jdXJyZW50TGV2ZWxJbmRleCA9IHRoaXMuY3VycmVudExldmVsLmRldGFpbHMuZnJhZ21lbnRzWzBdLmxldmVsO1xuICAgIH1cbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5MRVZFTFNfVVBEQVRFRCwge1xuICAgICAgbGV2ZWxzXG4gICAgfSk7XG4gIH1cbiAgb25MZXZlbHNVcGRhdGVkKGV2ZW50LCB7XG4gICAgbGV2ZWxzXG4gIH0pIHtcbiAgICB0aGlzLl9sZXZlbHMgPSBsZXZlbHM7XG4gIH1cbiAgY2hlY2tNYXhBdXRvVXBkYXRlZCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBhdXRvTGV2ZWxDYXBwaW5nLFxuICAgICAgbWF4QXV0b0xldmVsLFxuICAgICAgbWF4SGRjcExldmVsXG4gICAgfSA9IHRoaXMuaGxzO1xuICAgIGlmICh0aGlzLl9tYXhBdXRvTGV2ZWwgIT09IG1heEF1dG9MZXZlbCkge1xuICAgICAgdGhpcy5fbWF4QXV0b0xldmVsID0gbWF4QXV0b0xldmVsO1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuTUFYX0FVVE9fTEVWRUxfVVBEQVRFRCwge1xuICAgICAgICBhdXRvTGV2ZWxDYXBwaW5nLFxuICAgICAgICBsZXZlbHM6IHRoaXMubGV2ZWxzLFxuICAgICAgICBtYXhBdXRvTGV2ZWwsXG4gICAgICAgIG1pbkF1dG9MZXZlbDogdGhpcy5obHMubWluQXV0b0xldmVsLFxuICAgICAgICBtYXhIZGNwTGV2ZWxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYXNzaWduVHJhY2tJZHNCeUdyb3VwKHRyYWNrcykge1xuICBjb25zdCBncm91cHMgPSB7fTtcbiAgdHJhY2tzLmZvckVhY2godHJhY2sgPT4ge1xuICAgIGNvbnN0IGdyb3VwSWQgPSB0cmFjay5ncm91cElkIHx8ICcnO1xuICAgIHRyYWNrLmlkID0gZ3JvdXBzW2dyb3VwSWRdID0gZ3JvdXBzW2dyb3VwSWRdIHx8IDA7XG4gICAgZ3JvdXBzW2dyb3VwSWRdKys7XG4gIH0pO1xufVxuXG5jbGFzcyBLZXlMb2FkZXIge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICB0aGlzLmNvbmZpZyA9IHZvaWQgMDtcbiAgICB0aGlzLmtleVVyaVRvS2V5SW5mbyA9IHt9O1xuICAgIHRoaXMuZW1lQ29udHJvbGxlciA9IG51bGw7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gIH1cbiAgYWJvcnQodHlwZSkge1xuICAgIGZvciAoY29uc3QgdXJpIGluIHRoaXMua2V5VXJpVG9LZXlJbmZvKSB7XG4gICAgICBjb25zdCBsb2FkZXIgPSB0aGlzLmtleVVyaVRvS2V5SW5mb1t1cmldLmxvYWRlcjtcbiAgICAgIGlmIChsb2FkZXIpIHtcbiAgICAgICAgdmFyIF9sb2FkZXIkY29udGV4dDtcbiAgICAgICAgaWYgKHR5cGUgJiYgdHlwZSAhPT0gKChfbG9hZGVyJGNvbnRleHQgPSBsb2FkZXIuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9sb2FkZXIkY29udGV4dC5mcmFnLnR5cGUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxvYWRlci5hYm9ydCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBkZXRhY2goKSB7XG4gICAgZm9yIChjb25zdCB1cmkgaW4gdGhpcy5rZXlVcmlUb0tleUluZm8pIHtcbiAgICAgIGNvbnN0IGtleUluZm8gPSB0aGlzLmtleVVyaVRvS2V5SW5mb1t1cmldO1xuICAgICAgLy8gUmVtb3ZlIGNhY2hlZCBFTUUga2V5cyBvbiBkZXRhY2hcbiAgICAgIGlmIChrZXlJbmZvLm1lZGlhS2V5U2Vzc2lvbkNvbnRleHQgfHwga2V5SW5mby5kZWNyeXB0ZGF0YS5pc0NvbW1vbkVuY3J5cHRpb24pIHtcbiAgICAgICAgZGVsZXRlIHRoaXMua2V5VXJpVG9LZXlJbmZvW3VyaV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXRhY2goKTtcbiAgICBmb3IgKGNvbnN0IHVyaSBpbiB0aGlzLmtleVVyaVRvS2V5SW5mbykge1xuICAgICAgY29uc3QgbG9hZGVyID0gdGhpcy5rZXlVcmlUb0tleUluZm9bdXJpXS5sb2FkZXI7XG4gICAgICBpZiAobG9hZGVyKSB7XG4gICAgICAgIGxvYWRlci5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMua2V5VXJpVG9LZXlJbmZvID0ge307XG4gIH1cbiAgY3JlYXRlS2V5TG9hZEVycm9yKGZyYWcsIGRldGFpbHMgPSBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1IsIGVycm9yLCBuZXR3b3JrRGV0YWlscywgcmVzcG9uc2UpIHtcbiAgICByZXR1cm4gbmV3IExvYWRFcnJvcih7XG4gICAgICB0eXBlOiBFcnJvclR5cGVzLk5FVFdPUktfRVJST1IsXG4gICAgICBkZXRhaWxzLFxuICAgICAgZmF0YWw6IGZhbHNlLFxuICAgICAgZnJhZyxcbiAgICAgIHJlc3BvbnNlLFxuICAgICAgZXJyb3IsXG4gICAgICBuZXR3b3JrRGV0YWlsc1xuICAgIH0pO1xuICB9XG4gIGxvYWRDbGVhcihsb2FkaW5nRnJhZywgZW5jcnlwdGVkRnJhZ21lbnRzKSB7XG4gICAgaWYgKHRoaXMuZW1lQ29udHJvbGxlciAmJiB0aGlzLmNvbmZpZy5lbWVFbmFibGVkKSB7XG4gICAgICAvLyBhY2Nlc3Mga2V5LXN5c3RlbSB3aXRoIG5lYXJlc3Qga2V5IG9uIHN0YXJ0IChsb2FpZG5nIGZyYWcgaXMgdW5lbmNyeXB0ZWQpXG4gICAgICBjb25zdCB7XG4gICAgICAgIHNuLFxuICAgICAgICBjY1xuICAgICAgfSA9IGxvYWRpbmdGcmFnO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmNyeXB0ZWRGcmFnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZnJhZyA9IGVuY3J5cHRlZEZyYWdtZW50c1tpXTtcbiAgICAgICAgaWYgKGNjIDw9IGZyYWcuY2MgJiYgKHNuID09PSAnaW5pdFNlZ21lbnQnIHx8IGZyYWcuc24gPT09ICdpbml0U2VnbWVudCcgfHwgc24gPCBmcmFnLnNuKSkge1xuICAgICAgICAgIHRoaXMuZW1lQ29udHJvbGxlci5zZWxlY3RLZXlTeXN0ZW1Gb3JtYXQoZnJhZykudGhlbihrZXlTeXN0ZW1Gb3JtYXQgPT4ge1xuICAgICAgICAgICAgZnJhZy5zZXRLZXlGb3JtYXQoa2V5U3lzdGVtRm9ybWF0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBsb2FkKGZyYWcpIHtcbiAgICBpZiAoIWZyYWcuZGVjcnlwdGRhdGEgJiYgZnJhZy5lbmNyeXB0ZWQgJiYgdGhpcy5lbWVDb250cm9sbGVyKSB7XG4gICAgICAvLyBNdWx0aXBsZSBrZXlzLCBidXQgbm9uZSBzZWxlY3RlZCwgcmVzb2x2ZSBpbiBlbWUtY29udHJvbGxlclxuICAgICAgcmV0dXJuIHRoaXMuZW1lQ29udHJvbGxlci5zZWxlY3RLZXlTeXN0ZW1Gb3JtYXQoZnJhZykudGhlbihrZXlTeXN0ZW1Gb3JtYXQgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2FkSW50ZXJuYWwoZnJhZywga2V5U3lzdGVtRm9ybWF0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5sb2FkSW50ZXJuYWwoZnJhZyk7XG4gIH1cbiAgbG9hZEludGVybmFsKGZyYWcsIGtleVN5c3RlbUZvcm1hdCkge1xuICAgIHZhciBfa2V5SW5mbywgX2tleUluZm8yO1xuICAgIGlmIChrZXlTeXN0ZW1Gb3JtYXQpIHtcbiAgICAgIGZyYWcuc2V0S2V5Rm9ybWF0KGtleVN5c3RlbUZvcm1hdCk7XG4gICAgfVxuICAgIGNvbnN0IGRlY3J5cHRkYXRhID0gZnJhZy5kZWNyeXB0ZGF0YTtcbiAgICBpZiAoIWRlY3J5cHRkYXRhKSB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihrZXlTeXN0ZW1Gb3JtYXQgPyBgRXhwZWN0ZWQgZnJhZy5kZWNyeXB0ZGF0YSB0byBiZSBkZWZpbmVkIGFmdGVyIHNldHRpbmcgZm9ybWF0ICR7a2V5U3lzdGVtRm9ybWF0fWAgOiAnTWlzc2luZyBkZWNyeXB0aW9uIGRhdGEgb24gZnJhZ21lbnQgaW4gb25LZXlMb2FkaW5nJyk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QodGhpcy5jcmVhdGVLZXlMb2FkRXJyb3IoZnJhZywgRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SLCBlcnJvcikpO1xuICAgIH1cbiAgICBjb25zdCB1cmkgPSBkZWNyeXB0ZGF0YS51cmk7XG4gICAgaWYgKCF1cmkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh0aGlzLmNyZWF0ZUtleUxvYWRFcnJvcihmcmFnLCBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1IsIG5ldyBFcnJvcihgSW52YWxpZCBrZXkgVVJJOiBcIiR7dXJpfVwiYCkpKTtcbiAgICB9XG4gICAgbGV0IGtleUluZm8gPSB0aGlzLmtleVVyaVRvS2V5SW5mb1t1cmldO1xuICAgIGlmICgoX2tleUluZm8gPSBrZXlJbmZvKSAhPSBudWxsICYmIF9rZXlJbmZvLmRlY3J5cHRkYXRhLmtleSkge1xuICAgICAgZGVjcnlwdGRhdGEua2V5ID0ga2V5SW5mby5kZWNyeXB0ZGF0YS5rZXk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgZnJhZyxcbiAgICAgICAga2V5SW5mb1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFJldHVybiBrZXkgbG9hZCBwcm9taXNlIGFzIGxvbmcgYXMgaXQgZG9lcyBub3QgaGF2ZSBhIG1lZGlha2V5IHNlc3Npb24gd2l0aCBhbiB1bnVzYWJsZSBrZXkgc3RhdHVzXG4gICAgaWYgKChfa2V5SW5mbzIgPSBrZXlJbmZvKSAhPSBudWxsICYmIF9rZXlJbmZvMi5rZXlMb2FkUHJvbWlzZSkge1xuICAgICAgdmFyIF9rZXlJbmZvJG1lZGlhS2V5U2VzcztcbiAgICAgIHN3aXRjaCAoKF9rZXlJbmZvJG1lZGlhS2V5U2VzcyA9IGtleUluZm8ubWVkaWFLZXlTZXNzaW9uQ29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9rZXlJbmZvJG1lZGlhS2V5U2Vzcy5rZXlTdGF0dXMpIHtcbiAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIGNhc2UgJ3N0YXR1cy1wZW5kaW5nJzpcbiAgICAgICAgY2FzZSAndXNhYmxlJzpcbiAgICAgICAgY2FzZSAndXNhYmxlLWluLWZ1dHVyZSc6XG4gICAgICAgICAgcmV0dXJuIGtleUluZm8ua2V5TG9hZFByb21pc2UudGhlbihrZXlMb2FkZWREYXRhID0+IHtcbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgY29ycmVjdCBmcmFnbWVudCB3aXRoIHVwZGF0ZWQgZGVjcnlwdGRhdGEga2V5IGFuZCBsb2FkZWQga2V5SW5mb1xuICAgICAgICAgICAgZGVjcnlwdGRhdGEua2V5ID0ga2V5TG9hZGVkRGF0YS5rZXlJbmZvLmRlY3J5cHRkYXRhLmtleTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgICAgIGtleUluZm9cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvLyBJZiB3ZSBoYXZlIGEga2V5IHNlc3Npb24gYW5kIHN0YXR1cyBhbmQgaXQgaXMgbm90IHBlbmRpbmcgb3IgdXNhYmxlLCBjb250aW51ZVxuICAgICAgLy8gVGhpcyB3aWxsIGdvIGJhY2sgdG8gdGhlIGVtZS1jb250cm9sbGVyIGZvciBleHBpcmVkIGtleXMgdG8gZ2V0IGEgbmV3IGtleUxvYWRQcm9taXNlXG4gICAgfVxuXG4gICAgLy8gTG9hZCB0aGUga2V5IG9yIHJldHVybiB0aGUgbG9hZGluZyBwcm9taXNlXG4gICAga2V5SW5mbyA9IHRoaXMua2V5VXJpVG9LZXlJbmZvW3VyaV0gPSB7XG4gICAgICBkZWNyeXB0ZGF0YSxcbiAgICAgIGtleUxvYWRQcm9taXNlOiBudWxsLFxuICAgICAgbG9hZGVyOiBudWxsLFxuICAgICAgbWVkaWFLZXlTZXNzaW9uQ29udGV4dDogbnVsbFxuICAgIH07XG4gICAgc3dpdGNoIChkZWNyeXB0ZGF0YS5tZXRob2QpIHtcbiAgICAgIGNhc2UgJ0lTTy0yMzAwMS03JzpcbiAgICAgIGNhc2UgJ1NBTVBMRS1BRVMnOlxuICAgICAgY2FzZSAnU0FNUExFLUFFUy1DRU5DJzpcbiAgICAgIGNhc2UgJ1NBTVBMRS1BRVMtQ1RSJzpcbiAgICAgICAgaWYgKGRlY3J5cHRkYXRhLmtleUZvcm1hdCA9PT0gJ2lkZW50aXR5Jykge1xuICAgICAgICAgIC8vIGxvYWRLZXlIVFRQIGhhbmRsZXMgaHR0cChzKSBhbmQgZGF0YSBVUkxzXG4gICAgICAgICAgcmV0dXJuIHRoaXMubG9hZEtleUhUVFAoa2V5SW5mbywgZnJhZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZEtleUVNRShrZXlJbmZvLCBmcmFnKTtcbiAgICAgIGNhc2UgJ0FFUy0xMjgnOlxuICAgICAgICByZXR1cm4gdGhpcy5sb2FkS2V5SFRUUChrZXlJbmZvLCBmcmFnKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh0aGlzLmNyZWF0ZUtleUxvYWRFcnJvcihmcmFnLCBFcnJvckRldGFpbHMuS0VZX0xPQURfRVJST1IsIG5ldyBFcnJvcihgS2V5IHN1cHBsaWVkIHdpdGggdW5zdXBwb3J0ZWQgTUVUSE9EOiBcIiR7ZGVjcnlwdGRhdGEubWV0aG9kfVwiYCkpKTtcbiAgICB9XG4gIH1cbiAgbG9hZEtleUVNRShrZXlJbmZvLCBmcmFnKSB7XG4gICAgY29uc3Qga2V5TG9hZGVkRGF0YSA9IHtcbiAgICAgIGZyYWcsXG4gICAgICBrZXlJbmZvXG4gICAgfTtcbiAgICBpZiAodGhpcy5lbWVDb250cm9sbGVyICYmIHRoaXMuY29uZmlnLmVtZUVuYWJsZWQpIHtcbiAgICAgIGNvbnN0IGtleVNlc3Npb25Db250ZXh0UHJvbWlzZSA9IHRoaXMuZW1lQ29udHJvbGxlci5sb2FkS2V5KGtleUxvYWRlZERhdGEpO1xuICAgICAgaWYgKGtleVNlc3Npb25Db250ZXh0UHJvbWlzZSkge1xuICAgICAgICByZXR1cm4gKGtleUluZm8ua2V5TG9hZFByb21pc2UgPSBrZXlTZXNzaW9uQ29udGV4dFByb21pc2UudGhlbihrZXlTZXNzaW9uQ29udGV4dCA9PiB7XG4gICAgICAgICAga2V5SW5mby5tZWRpYUtleVNlc3Npb25Db250ZXh0ID0ga2V5U2Vzc2lvbkNvbnRleHQ7XG4gICAgICAgICAgcmV0dXJuIGtleUxvYWRlZERhdGE7XG4gICAgICAgIH0pKS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgLy8gUmVtb3ZlIHByb21pc2UgZm9yIGxpY2Vuc2UgcmVuZXdhbCBvciByZXRyeVxuICAgICAgICAgIGtleUluZm8ua2V5TG9hZFByb21pc2UgPSBudWxsO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShrZXlMb2FkZWREYXRhKTtcbiAgfVxuICBsb2FkS2V5SFRUUChrZXlJbmZvLCBmcmFnKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgY29uc3QgTG9hZGVyID0gY29uZmlnLmxvYWRlcjtcbiAgICBjb25zdCBrZXlMb2FkZXIgPSBuZXcgTG9hZGVyKGNvbmZpZyk7XG4gICAgZnJhZy5rZXlMb2FkZXIgPSBrZXlJbmZvLmxvYWRlciA9IGtleUxvYWRlcjtcbiAgICByZXR1cm4ga2V5SW5mby5rZXlMb2FkUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGxvYWRlckNvbnRleHQgPSB7XG4gICAgICAgIGtleUluZm8sXG4gICAgICAgIGZyYWcsXG4gICAgICAgIHJlc3BvbnNlVHlwZTogJ2FycmF5YnVmZmVyJyxcbiAgICAgICAgdXJsOiBrZXlJbmZvLmRlY3J5cHRkYXRhLnVyaVxuICAgICAgfTtcblxuICAgICAgLy8gbWF4UmV0cnkgaXMgMCBzbyB0aGF0IGluc3RlYWQgb2YgcmV0cnlpbmcgdGhlIHNhbWUga2V5IG9uIHRoZSBzYW1lIHZhcmlhbnQgbXVsdGlwbGUgdGltZXMsXG4gICAgICAvLyBrZXktbG9hZGVyIHdpbGwgdHJpZ2dlciBhbiBlcnJvciBhbmQgcmVseSBvbiBzdHJlYW0tY29udHJvbGxlciB0byBoYW5kbGUgcmV0cnkgbG9naWMuXG4gICAgICAvLyB0aGlzIHdpbGwgYWxzbyBhbGlnbiByZXRyeSBsb2dpYyB3aXRoIGZyYWdtZW50LWxvYWRlclxuICAgICAgY29uc3QgbG9hZFBvbGljeSA9IGNvbmZpZy5rZXlMb2FkUG9saWN5LmRlZmF1bHQ7XG4gICAgICBjb25zdCBsb2FkZXJDb25maWcgPSB7XG4gICAgICAgIGxvYWRQb2xpY3ksXG4gICAgICAgIHRpbWVvdXQ6IGxvYWRQb2xpY3kubWF4TG9hZFRpbWVNcyxcbiAgICAgICAgbWF4UmV0cnk6IDAsXG4gICAgICAgIHJldHJ5RGVsYXk6IDAsXG4gICAgICAgIG1heFJldHJ5RGVsYXk6IDBcbiAgICAgIH07XG4gICAgICBjb25zdCBsb2FkZXJDYWxsYmFja3MgPSB7XG4gICAgICAgIG9uU3VjY2VzczogKHJlc3BvbnNlLCBzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpID0+IHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAga2V5SW5mbyxcbiAgICAgICAgICAgIHVybDogdXJpXG4gICAgICAgICAgfSA9IGNvbnRleHQ7XG4gICAgICAgICAgaWYgKCFmcmFnLmRlY3J5cHRkYXRhIHx8IGtleUluZm8gIT09IHRoaXMua2V5VXJpVG9LZXlJbmZvW3VyaV0pIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QodGhpcy5jcmVhdGVLZXlMb2FkRXJyb3IoZnJhZywgRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SLCBuZXcgRXJyb3IoJ2FmdGVyIGtleSBsb2FkLCBkZWNyeXB0ZGF0YSB1bnNldCBvciBjaGFuZ2VkJyksIG5ldHdvcmtEZXRhaWxzKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGtleUluZm8uZGVjcnlwdGRhdGEua2V5ID0gZnJhZy5kZWNyeXB0ZGF0YS5rZXkgPSBuZXcgVWludDhBcnJheShyZXNwb25zZS5kYXRhKTtcblxuICAgICAgICAgIC8vIGRldGFjaCBmcmFnbWVudCBrZXkgbG9hZGVyIG9uIGxvYWQgc3VjY2Vzc1xuICAgICAgICAgIGZyYWcua2V5TG9hZGVyID0gbnVsbDtcbiAgICAgICAgICBrZXlJbmZvLmxvYWRlciA9IG51bGw7XG4gICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICBmcmFnLFxuICAgICAgICAgICAga2V5SW5mb1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvbkVycm9yOiAocmVzcG9uc2UsIGNvbnRleHQsIG5ldHdvcmtEZXRhaWxzLCBzdGF0cykgPT4ge1xuICAgICAgICAgIHRoaXMucmVzZXRMb2FkZXIoY29udGV4dCk7XG4gICAgICAgICAgcmVqZWN0KHRoaXMuY3JlYXRlS2V5TG9hZEVycm9yKGZyYWcsIEVycm9yRGV0YWlscy5LRVlfTE9BRF9FUlJPUiwgbmV3IEVycm9yKGBIVFRQIEVycm9yICR7cmVzcG9uc2UuY29kZX0gbG9hZGluZyBrZXkgJHtyZXNwb25zZS50ZXh0fWApLCBuZXR3b3JrRGV0YWlscywgX29iamVjdFNwcmVhZDIoe1xuICAgICAgICAgICAgdXJsOiBsb2FkZXJDb250ZXh0LnVybCxcbiAgICAgICAgICAgIGRhdGE6IHVuZGVmaW5lZFxuICAgICAgICAgIH0sIHJlc3BvbnNlKSkpO1xuICAgICAgICB9LFxuICAgICAgICBvblRpbWVvdXQ6IChzdGF0cywgY29udGV4dCwgbmV0d29ya0RldGFpbHMpID0+IHtcbiAgICAgICAgICB0aGlzLnJlc2V0TG9hZGVyKGNvbnRleHQpO1xuICAgICAgICAgIHJlamVjdCh0aGlzLmNyZWF0ZUtleUxvYWRFcnJvcihmcmFnLCBFcnJvckRldGFpbHMuS0VZX0xPQURfVElNRU9VVCwgbmV3IEVycm9yKCdrZXkgbG9hZGluZyB0aW1lZCBvdXQnKSwgbmV0d29ya0RldGFpbHMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25BYm9ydDogKHN0YXRzLCBjb250ZXh0LCBuZXR3b3JrRGV0YWlscykgPT4ge1xuICAgICAgICAgIHRoaXMucmVzZXRMb2FkZXIoY29udGV4dCk7XG4gICAgICAgICAgcmVqZWN0KHRoaXMuY3JlYXRlS2V5TG9hZEVycm9yKGZyYWcsIEVycm9yRGV0YWlscy5JTlRFUk5BTF9BQk9SVEVELCBuZXcgRXJyb3IoJ2tleSBsb2FkaW5nIGFib3J0ZWQnKSwgbmV0d29ya0RldGFpbHMpKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGtleUxvYWRlci5sb2FkKGxvYWRlckNvbnRleHQsIGxvYWRlckNvbmZpZywgbG9hZGVyQ2FsbGJhY2tzKTtcbiAgICB9KTtcbiAgfVxuICByZXNldExvYWRlcihjb250ZXh0KSB7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZyxcbiAgICAgIGtleUluZm8sXG4gICAgICB1cmw6IHVyaVxuICAgIH0gPSBjb250ZXh0O1xuICAgIGNvbnN0IGxvYWRlciA9IGtleUluZm8ubG9hZGVyO1xuICAgIGlmIChmcmFnLmtleUxvYWRlciA9PT0gbG9hZGVyKSB7XG4gICAgICBmcmFnLmtleUxvYWRlciA9IG51bGw7XG4gICAgICBrZXlJbmZvLmxvYWRlciA9IG51bGw7XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLmtleVVyaVRvS2V5SW5mb1t1cmldO1xuICAgIGlmIChsb2FkZXIpIHtcbiAgICAgIGxvYWRlci5kZXN0cm95KCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUJ1ZmZlcigpIHtcbiAgcmV0dXJuIHNlbGYuU291cmNlQnVmZmVyIHx8IHNlbGYuV2ViS2l0U291cmNlQnVmZmVyO1xufVxuZnVuY3Rpb24gaXNNU0VTdXBwb3J0ZWQoKSB7XG4gIGNvbnN0IG1lZGlhU291cmNlID0gZ2V0TWVkaWFTb3VyY2UoKTtcbiAgaWYgKCFtZWRpYVNvdXJjZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGlmIFNvdXJjZUJ1ZmZlciBpcyBleHBvc2VkIGVuc3VyZSBpdHMgQVBJIGlzIHZhbGlkXG4gIC8vIE9sZGVyIGJyb3dzZXJzIGRvIG5vdCBleHBvc2UgU291cmNlQnVmZmVyIGdsb2JhbGx5IHNvIGNoZWNraW5nIFNvdXJjZUJ1ZmZlci5wcm90b3R5cGUgaXMgaW1wb3NzaWJsZVxuICBjb25zdCBzb3VyY2VCdWZmZXIgPSBnZXRTb3VyY2VCdWZmZXIoKTtcbiAgcmV0dXJuICFzb3VyY2VCdWZmZXIgfHwgc291cmNlQnVmZmVyLnByb3RvdHlwZSAmJiB0eXBlb2Ygc291cmNlQnVmZmVyLnByb3RvdHlwZS5hcHBlbmRCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHNvdXJjZUJ1ZmZlci5wcm90b3R5cGUucmVtb3ZlID09PSAnZnVuY3Rpb24nO1xufVxuZnVuY3Rpb24gaXNTdXBwb3J0ZWQoKSB7XG4gIGlmICghaXNNU0VTdXBwb3J0ZWQoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBtZWRpYVNvdXJjZSA9IGdldE1lZGlhU291cmNlKCk7XG4gIHJldHVybiB0eXBlb2YgKG1lZGlhU291cmNlID09IG51bGwgPyB2b2lkIDAgOiBtZWRpYVNvdXJjZS5pc1R5cGVTdXBwb3J0ZWQpID09PSAnZnVuY3Rpb24nICYmIChbJ2F2YzEuNDJFMDFFLG1wNGEuNDAuMicsICdhdjAxLjAuMDFNLjA4JywgJ3ZwMDkuMDAuNTAuMDgnXS5zb21lKGNvZGVjc0ZvclZpZGVvQ29udGFpbmVyID0+IG1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZChtaW1lVHlwZUZvckNvZGVjKGNvZGVjc0ZvclZpZGVvQ29udGFpbmVyLCAndmlkZW8nKSkpIHx8IFsnbXA0YS40MC4yJywgJ2ZMYUMnXS5zb21lKGNvZGVjRm9yQXVkaW9Db250YWluZXIgPT4gbWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKG1pbWVUeXBlRm9yQ29kZWMoY29kZWNGb3JBdWRpb0NvbnRhaW5lciwgJ2F1ZGlvJykpKSk7XG59XG5mdW5jdGlvbiBjaGFuZ2VUeXBlU3VwcG9ydGVkKCkge1xuICB2YXIgX3NvdXJjZUJ1ZmZlciRwcm90b3R5O1xuICBjb25zdCBzb3VyY2VCdWZmZXIgPSBnZXRTb3VyY2VCdWZmZXIoKTtcbiAgcmV0dXJuIHR5cGVvZiAoc291cmNlQnVmZmVyID09IG51bGwgPyB2b2lkIDAgOiAoX3NvdXJjZUJ1ZmZlciRwcm90b3R5ID0gc291cmNlQnVmZmVyLnByb3RvdHlwZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9zb3VyY2VCdWZmZXIkcHJvdG90eS5jaGFuZ2VUeXBlKSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuY29uc3QgU1RBTExfTUlOSU1VTV9EVVJBVElPTl9NUyA9IDI1MDtcbmNvbnN0IE1BWF9TVEFSVF9HQVBfSlVNUCA9IDIuMDtcbmNvbnN0IFNLSVBfQlVGRkVSX0hPTEVfU1RFUF9TRUNPTkRTID0gMC4xO1xuY29uc3QgU0tJUF9CVUZGRVJfUkFOR0VfU1RBUlQgPSAwLjA1O1xuY2xhc3MgR2FwQ29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZywgbWVkaWEsIGZyYWdtZW50VHJhY2tlciwgaGxzKSB7XG4gICAgdGhpcy5jb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5obHMgPSB2b2lkIDA7XG4gICAgdGhpcy5udWRnZVJldHJ5ID0gMDtcbiAgICB0aGlzLnN0YWxsUmVwb3J0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnN0YWxsZWQgPSBudWxsO1xuICAgIHRoaXMubW92ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnNlZWtpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLm1lZGlhID0gbWVkaWE7XG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIgPSBmcmFnbWVudFRyYWNrZXI7XG4gICAgdGhpcy5obHMgPSBobHM7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLm1lZGlhID0gbnVsbDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5obHMgPSB0aGlzLmZyYWdtZW50VHJhY2tlciA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBwbGF5aGVhZCBpcyBzdHVjayB3aXRoaW4gYSBnYXAsIGFuZCBpZiBzbywgYXR0ZW1wdHMgdG8gZnJlZSBpdC5cbiAgICogQSBnYXAgaXMgYW4gdW5idWZmZXJlZCByYW5nZSBiZXR3ZWVuIHR3byBidWZmZXJlZCByYW5nZXMgKG9yIHRoZSBzdGFydCBhbmQgdGhlIGZpcnN0IGJ1ZmZlcmVkIHJhbmdlKS5cbiAgICpcbiAgICogQHBhcmFtIGxhc3RDdXJyZW50VGltZSAtIFByZXZpb3VzbHkgcmVhZCBwbGF5aGVhZCBwb3NpdGlvblxuICAgKi9cbiAgcG9sbChsYXN0Q3VycmVudFRpbWUsIGFjdGl2ZUZyYWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb25maWcsXG4gICAgICBtZWRpYSxcbiAgICAgIHN0YWxsZWRcbiAgICB9ID0gdGhpcztcbiAgICBpZiAobWVkaWEgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY3VycmVudFRpbWUsXG4gICAgICBzZWVraW5nXG4gICAgfSA9IG1lZGlhO1xuICAgIGNvbnN0IHNlZWtlZCA9IHRoaXMuc2Vla2luZyAmJiAhc2Vla2luZztcbiAgICBjb25zdCBiZWdpblNlZWsgPSAhdGhpcy5zZWVraW5nICYmIHNlZWtpbmc7XG4gICAgdGhpcy5zZWVraW5nID0gc2Vla2luZztcblxuICAgIC8vIFRoZSBwbGF5aGVhZCBpcyBtb3ZpbmcsIG5vLW9wXG4gICAgaWYgKGN1cnJlbnRUaW1lICE9PSBsYXN0Q3VycmVudFRpbWUpIHtcbiAgICAgIHRoaXMubW92ZWQgPSB0cnVlO1xuICAgICAgaWYgKCFzZWVraW5nKSB7XG4gICAgICAgIHRoaXMubnVkZ2VSZXRyeSA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoc3RhbGxlZCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBUaGUgcGxheWhlYWQgaXMgbm93IG1vdmluZywgYnV0IHdhcyBwcmV2aW91c2x5IHN0YWxsZWRcbiAgICAgICAgaWYgKHRoaXMuc3RhbGxSZXBvcnRlZCkge1xuICAgICAgICAgIGNvbnN0IF9zdGFsbGVkRHVyYXRpb24gPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpIC0gc3RhbGxlZDtcbiAgICAgICAgICBsb2dnZXIud2FybihgcGxheWJhY2sgbm90IHN0dWNrIGFueW1vcmUgQCR7Y3VycmVudFRpbWV9LCBhZnRlciAke01hdGgucm91bmQoX3N0YWxsZWREdXJhdGlvbil9bXNgKTtcbiAgICAgICAgICB0aGlzLnN0YWxsUmVwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YWxsZWQgPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENsZWFyIHN0YWxsZWQgc3RhdGUgd2hlbiBiZWdpbm5pbmcgb3IgZmluaXNoaW5nIHNlZWtpbmcgc28gdGhhdCB3ZSBkb24ndCByZXBvcnQgc3RhbGxzIGNvbWluZyBvdXQgb2YgYSBzZWVrXG4gICAgaWYgKGJlZ2luU2VlayB8fCBzZWVrZWQpIHtcbiAgICAgIHRoaXMuc3RhbGxlZCA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVGhlIHBsYXloZWFkIHNob3VsZCBub3QgYmUgbW92aW5nXG4gICAgaWYgKG1lZGlhLnBhdXNlZCAmJiAhc2Vla2luZyB8fCBtZWRpYS5lbmRlZCB8fCBtZWRpYS5wbGF5YmFja1JhdGUgPT09IDAgfHwgIUJ1ZmZlckhlbHBlci5nZXRCdWZmZXJlZChtZWRpYSkubGVuZ3RoKSB7XG4gICAgICB0aGlzLm51ZGdlUmV0cnkgPSAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBidWZmZXJJbmZvID0gQnVmZmVySGVscGVyLmJ1ZmZlckluZm8obWVkaWEsIGN1cnJlbnRUaW1lLCAwKTtcbiAgICBjb25zdCBuZXh0U3RhcnQgPSBidWZmZXJJbmZvLm5leHRTdGFydCB8fCAwO1xuICAgIGlmIChzZWVraW5nKSB7XG4gICAgICAvLyBXYWl0aW5nIGZvciBzZWVraW5nIGluIGEgYnVmZmVyZWQgcmFuZ2UgdG8gY29tcGxldGVcbiAgICAgIGNvbnN0IGhhc0Vub3VnaEJ1ZmZlciA9IGJ1ZmZlckluZm8ubGVuID4gTUFYX1NUQVJUX0dBUF9KVU1QO1xuICAgICAgLy8gTmV4dCBidWZmZXJlZCByYW5nZSBpcyB0b28gZmFyIGFoZWFkIHRvIGp1bXAgdG8gd2hpbGUgc3RpbGwgc2Vla2luZ1xuICAgICAgY29uc3Qgbm9CdWZmZXJHYXAgPSAhbmV4dFN0YXJ0IHx8IGFjdGl2ZUZyYWcgJiYgYWN0aXZlRnJhZy5zdGFydCA8PSBjdXJyZW50VGltZSB8fCBuZXh0U3RhcnQgLSBjdXJyZW50VGltZSA+IE1BWF9TVEFSVF9HQVBfSlVNUCAmJiAhdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0UGFydGlhbEZyYWdtZW50KGN1cnJlbnRUaW1lKTtcbiAgICAgIGlmIChoYXNFbm91Z2hCdWZmZXIgfHwgbm9CdWZmZXJHYXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gUmVzZXQgbW92ZWQgc3RhdGUgd2hlbiBzZWVraW5nIHRvIGEgcG9pbnQgaW4gb3IgYmVmb3JlIGEgZ2FwXG4gICAgICB0aGlzLm1vdmVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gU2tpcCBzdGFydCBnYXBzIGlmIHdlIGhhdmVuJ3QgcGxheWVkLCBidXQgdGhlIGxhc3QgcG9sbCBkZXRlY3RlZCB0aGUgc3RhcnQgb2YgYSBzdGFsbFxuICAgIC8vIFRoZSBhZGRpdGlvbiBwb2xsIGdpdmVzIHRoZSBicm93c2VyIGEgY2hhbmNlIHRvIGp1bXAgdGhlIGdhcCBmb3IgdXNcbiAgICBpZiAoIXRoaXMubW92ZWQgJiYgdGhpcy5zdGFsbGVkICE9PSBudWxsKSB7XG4gICAgICB2YXIgX2xldmVsJGRldGFpbHM7XG4gICAgICAvLyBUaGVyZSBpcyBubyBwbGF5YWJsZSBidWZmZXIgKHNlZWtlZCwgd2FpdGluZyBmb3IgYnVmZmVyKVxuICAgICAgY29uc3QgaXNCdWZmZXJlZCA9IGJ1ZmZlckluZm8ubGVuID4gMDtcbiAgICAgIGlmICghaXNCdWZmZXJlZCAmJiAhbmV4dFN0YXJ0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIEp1bXAgc3RhcnQgZ2FwcyB3aXRoaW4ganVtcCB0aHJlc2hvbGRcbiAgICAgIGNvbnN0IHN0YXJ0SnVtcCA9IE1hdGgubWF4KG5leHRTdGFydCwgYnVmZmVySW5mby5zdGFydCB8fCAwKSAtIGN1cnJlbnRUaW1lO1xuXG4gICAgICAvLyBXaGVuIGpvaW5pbmcgYSBsaXZlIHN0cmVhbSB3aXRoIGF1ZGlvIHRyYWNrcywgYWNjb3VudCBmb3IgbGl2ZSBwbGF5bGlzdCB3aW5kb3cgc2xpZGluZyBieSBhbGxvd2luZ1xuICAgICAgLy8gYSBsYXJnZXIganVtcCBvdmVyIHN0YXJ0IGdhcHMgY2F1c2VkIGJ5IHRoZSBhdWRpby1zdHJlYW0tY29udHJvbGxlciBidWZmZXJpbmcgYSBzdGFydCBmcmFnbWVudFxuICAgICAgLy8gdGhhdCBiZWdpbnMgb3ZlciAxIHRhcmdldCBkdXJhdGlvbiBhZnRlciB0aGUgdmlkZW8gc3RhcnQgcG9zaXRpb24uXG4gICAgICBjb25zdCBsZXZlbCA9IHRoaXMuaGxzLmxldmVscyA/IHRoaXMuaGxzLmxldmVsc1t0aGlzLmhscy5jdXJyZW50TGV2ZWxdIDogbnVsbDtcbiAgICAgIGNvbnN0IGlzTGl2ZSA9IGxldmVsID09IG51bGwgPyB2b2lkIDAgOiAoX2xldmVsJGRldGFpbHMgPSBsZXZlbC5kZXRhaWxzKSA9PSBudWxsID8gdm9pZCAwIDogX2xldmVsJGRldGFpbHMubGl2ZTtcbiAgICAgIGNvbnN0IG1heFN0YXJ0R2FwSnVtcCA9IGlzTGl2ZSA/IGxldmVsLmRldGFpbHMudGFyZ2V0ZHVyYXRpb24gKiAyIDogTUFYX1NUQVJUX0dBUF9KVU1QO1xuICAgICAgY29uc3QgcGFydGlhbE9yR2FwID0gdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0UGFydGlhbEZyYWdtZW50KGN1cnJlbnRUaW1lKTtcbiAgICAgIGlmIChzdGFydEp1bXAgPiAwICYmIChzdGFydEp1bXAgPD0gbWF4U3RhcnRHYXBKdW1wIHx8IHBhcnRpYWxPckdhcCkpIHtcbiAgICAgICAgaWYgKCFtZWRpYS5wYXVzZWQpIHtcbiAgICAgICAgICB0aGlzLl90cnlTa2lwQnVmZmVySG9sZShwYXJ0aWFsT3JHYXApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTdGFydCB0cmFja2luZyBzdGFsbCB0aW1lXG4gICAgY29uc3QgdG5vdyA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgaWYgKHN0YWxsZWQgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuc3RhbGxlZCA9IHRub3c7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0YWxsZWREdXJhdGlvbiA9IHRub3cgLSBzdGFsbGVkO1xuICAgIGlmICghc2Vla2luZyAmJiBzdGFsbGVkRHVyYXRpb24gPj0gU1RBTExfTUlOSU1VTV9EVVJBVElPTl9NUykge1xuICAgICAgLy8gUmVwb3J0IHN0YWxsaW5nIGFmdGVyIHRyeWluZyB0byBmaXhcbiAgICAgIHRoaXMuX3JlcG9ydFN0YWxsKGJ1ZmZlckluZm8pO1xuICAgICAgaWYgKCF0aGlzLm1lZGlhKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYnVmZmVyZWRXaXRoSG9sZXMgPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhtZWRpYSwgY3VycmVudFRpbWUsIGNvbmZpZy5tYXhCdWZmZXJIb2xlKTtcbiAgICB0aGlzLl90cnlGaXhCdWZmZXJTdGFsbChidWZmZXJlZFdpdGhIb2xlcywgc3RhbGxlZER1cmF0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlY3RzIGFuZCBhdHRlbXB0cyB0byBmaXgga25vd24gYnVmZmVyIHN0YWxsaW5nIGlzc3Vlcy5cbiAgICogQHBhcmFtIGJ1ZmZlckluZm8gLSBUaGUgcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCBidWZmZXIuXG4gICAqIEBwYXJhbSBzdGFsbGVkRHVyYXRpb25NcyAtIFRoZSBhbW91bnQgb2YgdGltZSBIbHMuanMgaGFzIGJlZW4gc3RhbGxpbmcgZm9yLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3RyeUZpeEJ1ZmZlclN0YWxsKGJ1ZmZlckluZm8sIHN0YWxsZWREdXJhdGlvbk1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29uZmlnLFxuICAgICAgZnJhZ21lbnRUcmFja2VyLFxuICAgICAgbWVkaWFcbiAgICB9ID0gdGhpcztcbiAgICBpZiAobWVkaWEgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICBjb25zdCBwYXJ0aWFsID0gZnJhZ21lbnRUcmFja2VyLmdldFBhcnRpYWxGcmFnbWVudChjdXJyZW50VGltZSk7XG4gICAgaWYgKHBhcnRpYWwpIHtcbiAgICAgIC8vIFRyeSB0byBza2lwIG92ZXIgdGhlIGJ1ZmZlciBob2xlIGNhdXNlZCBieSBhIHBhcnRpYWwgZnJhZ21lbnRcbiAgICAgIC8vIFRoaXMgbWV0aG9kIGlzbid0IGxpbWl0ZWQgYnkgdGhlIHNpemUgb2YgdGhlIGdhcCBiZXR3ZWVuIGJ1ZmZlcmVkIHJhbmdlc1xuICAgICAgY29uc3QgdGFyZ2V0VGltZSA9IHRoaXMuX3RyeVNraXBCdWZmZXJIb2xlKHBhcnRpYWwpO1xuICAgICAgLy8gd2UgcmV0dXJuIGhlcmUgaW4gdGhpcyBjYXNlLCBtZWFuaW5nXG4gICAgICAvLyB0aGUgYnJhbmNoIGJlbG93IG9ubHkgZXhlY3V0ZXMgd2hlbiB3ZSBoYXZlbid0IHNlZWtlZCB0byBhIG5ldyBwb3NpdGlvblxuICAgICAgaWYgKHRhcmdldFRpbWUgfHwgIXRoaXMubWVkaWEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHdlIGhhdmVuJ3QgaGFkIHRvIHNraXAgb3ZlciBhIGJ1ZmZlciBob2xlIG9mIGEgcGFydGlhbCBmcmFnbWVudFxuICAgIC8vIHdlIG1heSBqdXN0IGhhdmUgdG8gXCJudWRnZVwiIHRoZSBwbGF5bGlzdCBhcyB0aGUgYnJvd3NlciBkZWNvZGluZy9yZW5kZXJpbmcgZW5naW5lXG4gICAgLy8gbmVlZHMgdG8gY3Jvc3Mgc29tZSBzb3J0IG9mIHRocmVzaG9sZCBjb3ZlcmluZyBhbGwgc291cmNlLWJ1ZmZlcnMgY29udGVudFxuICAgIC8vIHRvIHN0YXJ0IHBsYXlpbmcgcHJvcGVybHkuXG4gICAgaWYgKChidWZmZXJJbmZvLmxlbiA+IGNvbmZpZy5tYXhCdWZmZXJIb2xlIHx8IGJ1ZmZlckluZm8ubmV4dFN0YXJ0ICYmIGJ1ZmZlckluZm8ubmV4dFN0YXJ0IC0gY3VycmVudFRpbWUgPCBjb25maWcubWF4QnVmZmVySG9sZSkgJiYgc3RhbGxlZER1cmF0aW9uTXMgPiBjb25maWcuaGlnaEJ1ZmZlcldhdGNoZG9nUGVyaW9kICogMTAwMCkge1xuICAgICAgbG9nZ2VyLndhcm4oJ1RyeWluZyB0byBudWRnZSBwbGF5aGVhZCBvdmVyIGJ1ZmZlci1ob2xlJyk7XG4gICAgICAvLyBUcnkgdG8gbnVkZ2UgY3VycmVudFRpbWUgb3ZlciBhIGJ1ZmZlciBob2xlIGlmIHdlJ3ZlIGJlZW4gc3RhbGxpbmcgZm9yIHRoZSBjb25maWd1cmVkIGFtb3VudCBvZiBzZWNvbmRzXG4gICAgICAvLyBXZSBvbmx5IHRyeSB0byBqdW1wIHRoZSBob2xlIGlmIGl0J3MgdW5kZXIgdGhlIGNvbmZpZ3VyZWQgc2l6ZVxuICAgICAgLy8gUmVzZXQgc3RhbGxlZCBzbyB0byByZWFybSB3YXRjaGRvZyB0aW1lclxuICAgICAgdGhpcy5zdGFsbGVkID0gbnVsbDtcbiAgICAgIHRoaXMuX3RyeU51ZGdlQnVmZmVyKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRyaWdnZXJzIGEgQlVGRkVSX1NUQUxMRURfRVJST1IgZXZlbnQsIGJ1dCBvbmx5IG9uY2UgcGVyIHN0YWxsIHBlcmlvZC5cbiAgICogQHBhcmFtIGJ1ZmZlckxlbiAtIFRoZSBwbGF5aGVhZCBkaXN0YW5jZSBmcm9tIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgYnVmZmVyIHNlZ21lbnQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVwb3J0U3RhbGwoYnVmZmVySW5mbykge1xuICAgIGNvbnN0IHtcbiAgICAgIGhscyxcbiAgICAgIG1lZGlhLFxuICAgICAgc3RhbGxSZXBvcnRlZFxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghc3RhbGxSZXBvcnRlZCAmJiBtZWRpYSkge1xuICAgICAgLy8gUmVwb3J0IHN0YWxsZWQgZXJyb3Igb25jZVxuICAgICAgdGhpcy5zdGFsbFJlcG9ydGVkID0gdHJ1ZTtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBQbGF5YmFjayBzdGFsbGluZyBhdCBAJHttZWRpYS5jdXJyZW50VGltZX0gZHVlIHRvIGxvdyBidWZmZXIgKCR7SlNPTi5zdHJpbmdpZnkoYnVmZmVySW5mbyl9KWApO1xuICAgICAgbG9nZ2VyLndhcm4oZXJyb3IubWVzc2FnZSk7XG4gICAgICBobHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9TVEFMTEVEX0VSUk9SLFxuICAgICAgICBmYXRhbDogZmFsc2UsXG4gICAgICAgIGVycm9yLFxuICAgICAgICBidWZmZXI6IGJ1ZmZlckluZm8ubGVuXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gZml4IGJ1ZmZlciBzdGFsbHMgYnkganVtcGluZyBvdmVyIGtub3duIGdhcHMgY2F1c2VkIGJ5IHBhcnRpYWwgZnJhZ21lbnRzXG4gICAqIEBwYXJhbSBwYXJ0aWFsIC0gVGhlIHBhcnRpYWwgZnJhZ21lbnQgZm91bmQgYXQgdGhlIGN1cnJlbnQgdGltZSAod2hlcmUgcGxheWJhY2sgaXMgc3RhbGxpbmcpLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3RyeVNraXBCdWZmZXJIb2xlKHBhcnRpYWwpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb25maWcsXG4gICAgICBobHMsXG4gICAgICBtZWRpYVxuICAgIH0gPSB0aGlzO1xuICAgIGlmIChtZWRpYSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgY3VycmVudFRpbWUgaXMgYmV0d2VlbiB1bmJ1ZmZlcmVkIHJlZ2lvbnMgb2YgcGFydGlhbCBmcmFnbWVudHNcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIGNvbnN0IGJ1ZmZlckluZm8gPSBCdWZmZXJIZWxwZXIuYnVmZmVySW5mbyhtZWRpYSwgY3VycmVudFRpbWUsIDApO1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lIDwgYnVmZmVySW5mby5zdGFydCA/IGJ1ZmZlckluZm8uc3RhcnQgOiBidWZmZXJJbmZvLm5leHRTdGFydDtcbiAgICBpZiAoc3RhcnRUaW1lKSB7XG4gICAgICBjb25zdCBidWZmZXJTdGFydmVkID0gYnVmZmVySW5mby5sZW4gPD0gY29uZmlnLm1heEJ1ZmZlckhvbGU7XG4gICAgICBjb25zdCB3YWl0aW5nID0gYnVmZmVySW5mby5sZW4gPiAwICYmIGJ1ZmZlckluZm8ubGVuIDwgMSAmJiBtZWRpYS5yZWFkeVN0YXRlIDwgMztcbiAgICAgIGNvbnN0IGdhcExlbmd0aCA9IHN0YXJ0VGltZSAtIGN1cnJlbnRUaW1lO1xuICAgICAgaWYgKGdhcExlbmd0aCA+IDAgJiYgKGJ1ZmZlclN0YXJ2ZWQgfHwgd2FpdGluZykpIHtcbiAgICAgICAgLy8gT25seSBhbGxvdyBsYXJnZSBnYXBzIHRvIGJlIHNraXBwZWQgaWYgaXQgaXMgYSBzdGFydCBnYXAsIG9yIGFsbCBmcmFnbWVudHMgaW4gc2tpcCByYW5nZSBhcmUgcGFydGlhbFxuICAgICAgICBpZiAoZ2FwTGVuZ3RoID4gY29uZmlnLm1heEJ1ZmZlckhvbGUpIHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBmcmFnbWVudFRyYWNrZXJcbiAgICAgICAgICB9ID0gdGhpcztcbiAgICAgICAgICBsZXQgc3RhcnRHYXAgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoY3VycmVudFRpbWUgPT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0RnJhZyA9IGZyYWdtZW50VHJhY2tlci5nZXRBcHBlbmRlZEZyYWcoMCwgUGxheWxpc3RMZXZlbFR5cGUuTUFJTik7XG4gICAgICAgICAgICBpZiAoc3RhcnRGcmFnICYmIHN0YXJ0VGltZSA8IHN0YXJ0RnJhZy5lbmQpIHtcbiAgICAgICAgICAgICAgc3RhcnRHYXAgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXN0YXJ0R2FwKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydFByb3Zpc2lvbmVkID0gcGFydGlhbCB8fCBmcmFnbWVudFRyYWNrZXIuZ2V0QXBwZW5kZWRGcmFnKGN1cnJlbnRUaW1lLCBQbGF5bGlzdExldmVsVHlwZS5NQUlOKTtcbiAgICAgICAgICAgIGlmIChzdGFydFByb3Zpc2lvbmVkKSB7XG4gICAgICAgICAgICAgIGxldCBtb3JlVG9Mb2FkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGxldCBwb3MgPSBzdGFydFByb3Zpc2lvbmVkLmVuZDtcbiAgICAgICAgICAgICAgd2hpbGUgKHBvcyA8IHN0YXJ0VGltZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3Zpc2lvbmVkID0gZnJhZ21lbnRUcmFja2VyLmdldFBhcnRpYWxGcmFnbWVudChwb3MpO1xuICAgICAgICAgICAgICAgIGlmIChwcm92aXNpb25lZCkge1xuICAgICAgICAgICAgICAgICAgcG9zICs9IHByb3Zpc2lvbmVkLmR1cmF0aW9uO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBtb3JlVG9Mb2FkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobW9yZVRvTG9hZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldFRpbWUgPSBNYXRoLm1heChzdGFydFRpbWUgKyBTS0lQX0JVRkZFUl9SQU5HRV9TVEFSVCwgY3VycmVudFRpbWUgKyBTS0lQX0JVRkZFUl9IT0xFX1NURVBfU0VDT05EUyk7XG4gICAgICAgIGxvZ2dlci53YXJuKGBza2lwcGluZyBob2xlLCBhZGp1c3RpbmcgY3VycmVudFRpbWUgZnJvbSAke2N1cnJlbnRUaW1lfSB0byAke3RhcmdldFRpbWV9YCk7XG4gICAgICAgIHRoaXMubW92ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnN0YWxsZWQgPSBudWxsO1xuICAgICAgICBtZWRpYS5jdXJyZW50VGltZSA9IHRhcmdldFRpbWU7XG4gICAgICAgIGlmIChwYXJ0aWFsICYmICFwYXJ0aWFsLmdhcCkge1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBmcmFnbWVudCBsb2FkZWQgd2l0aCBidWZmZXIgaG9sZXMsIHNlZWtpbmcgZnJvbSAke2N1cnJlbnRUaW1lfSB0byAke3RhcmdldFRpbWV9YCk7XG4gICAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgICAgICB0eXBlOiBFcnJvclR5cGVzLk1FRElBX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9TRUVLX09WRVJfSE9MRSxcbiAgICAgICAgICAgIGZhdGFsOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgcmVhc29uOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgZnJhZzogcGFydGlhbFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXRUaW1lO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRlbXB0cyB0byBmaXggYnVmZmVyIHN0YWxscyBieSBhZHZhbmNpbmcgdGhlIG1lZGlhRWxlbWVudCdzIGN1cnJlbnQgdGltZSBieSBhIHNtYWxsIGFtb3VudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF90cnlOdWRnZUJ1ZmZlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb25maWcsXG4gICAgICBobHMsXG4gICAgICBtZWRpYSxcbiAgICAgIG51ZGdlUmV0cnlcbiAgICB9ID0gdGhpcztcbiAgICBpZiAobWVkaWEgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgICB0aGlzLm51ZGdlUmV0cnkrKztcbiAgICBpZiAobnVkZ2VSZXRyeSA8IGNvbmZpZy5udWRnZU1heFJldHJ5KSB7XG4gICAgICBjb25zdCB0YXJnZXRUaW1lID0gY3VycmVudFRpbWUgKyAobnVkZ2VSZXRyeSArIDEpICogY29uZmlnLm51ZGdlT2Zmc2V0O1xuICAgICAgLy8gcGxheWJhY2sgc3RhbGxlZCBpbiBidWZmZXJlZCBhcmVhIC4uLiBsZXQncyBudWRnZSBjdXJyZW50VGltZSB0byB0cnkgdG8gb3ZlcmNvbWUgdGhpc1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYE51ZGdpbmcgJ2N1cnJlbnRUaW1lJyBmcm9tICR7Y3VycmVudFRpbWV9IHRvICR7dGFyZ2V0VGltZX1gKTtcbiAgICAgIGxvZ2dlci53YXJuKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgbWVkaWEuY3VycmVudFRpbWUgPSB0YXJnZXRUaW1lO1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IEVycm9yVHlwZXMuTUVESUFfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEVycm9yRGV0YWlscy5CVUZGRVJfTlVER0VfT05fU1RBTEwsXG4gICAgICAgIGVycm9yLFxuICAgICAgICBmYXRhbDogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgUGxheWhlYWQgc3RpbGwgbm90IG1vdmluZyB3aGlsZSBlbm91Z2ggZGF0YSBidWZmZXJlZCBAJHtjdXJyZW50VGltZX0gYWZ0ZXIgJHtjb25maWcubnVkZ2VNYXhSZXRyeX0gbnVkZ2VzYCk7XG4gICAgICBsb2dnZXIuZXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgICBobHMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgdHlwZTogRXJyb3JUeXBlcy5NRURJQV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogRXJyb3JEZXRhaWxzLkJVRkZFUl9TVEFMTEVEX0VSUk9SLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBUSUNLX0lOVEVSVkFMID0gMTAwOyAvLyBob3cgb2Z0ZW4gdG8gdGljayBpbiBtc1xuXG5jbGFzcyBTdHJlYW1Db250cm9sbGVyIGV4dGVuZHMgQmFzZVN0cmVhbUNvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihobHMsIGZyYWdtZW50VHJhY2tlciwga2V5TG9hZGVyKSB7XG4gICAgc3VwZXIoaGxzLCBmcmFnbWVudFRyYWNrZXIsIGtleUxvYWRlciwgJ1tzdHJlYW0tY29udHJvbGxlcl0nLCBQbGF5bGlzdExldmVsVHlwZS5NQUlOKTtcbiAgICB0aGlzLmF1ZGlvQ29kZWNTd2FwID0gZmFsc2U7XG4gICAgdGhpcy5nYXBDb250cm9sbGVyID0gbnVsbDtcbiAgICB0aGlzLmxldmVsID0gLTE7XG4gICAgdGhpcy5fZm9yY2VTdGFydExvYWQgPSBmYWxzZTtcbiAgICB0aGlzLmFsdEF1ZGlvID0gZmFsc2U7XG4gICAgdGhpcy5hdWRpb09ubHkgPSBmYWxzZTtcbiAgICB0aGlzLmZyYWdQbGF5aW5nID0gbnVsbDtcbiAgICB0aGlzLm9udnBsYXlpbmcgPSBudWxsO1xuICAgIHRoaXMub252c2Vla2VkID0gbnVsbDtcbiAgICB0aGlzLmZyYWdMYXN0S2JwcyA9IDA7XG4gICAgdGhpcy5jb3VsZEJhY2t0cmFjayA9IGZhbHNlO1xuICAgIHRoaXMuYmFja3RyYWNrRnJhZ21lbnQgPSBudWxsO1xuICAgIHRoaXMuYXVkaW9Db2RlY1N3aXRjaCA9IGZhbHNlO1xuICAgIHRoaXMudmlkZW9CdWZmZXIgPSBudWxsO1xuICAgIHRoaXMuX3JlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cbiAgX3JlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGhscy5vbihFdmVudHMuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxfTE9BRElORywgdGhpcy5vbkxldmVsTG9hZGluZywgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5MRVZFTF9MT0FERUQsIHRoaXMub25MZXZlbExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5GUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURUQsIHRoaXMub25GcmFnTG9hZEVtZXJnZW5jeUFib3J0ZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5BVURJT19UUkFDS19TV0lUQ0hJTkcsIHRoaXMub25BdWRpb1RyYWNrU3dpdGNoaW5nLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSEVELCB0aGlzLm9uQXVkaW9UcmFja1N3aXRjaGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkJVRkZFUl9DUkVBVEVELCB0aGlzLm9uQnVmZmVyQ3JlYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9uKEV2ZW50cy5CVUZGRVJfRkxVU0hFRCwgdGhpcy5vbkJ1ZmZlckZsdXNoZWQsIHRoaXMpO1xuICAgIGhscy5vbihFdmVudHMuTEVWRUxTX1VQREFURUQsIHRoaXMub25MZXZlbHNVcGRhdGVkLCB0aGlzKTtcbiAgICBobHMub24oRXZlbnRzLkZSQUdfQlVGRkVSRUQsIHRoaXMub25GcmFnQnVmZmVyZWQsIHRoaXMpO1xuICB9XG4gIF91bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsc1xuICAgIH0gPSB0aGlzO1xuICAgIGhscy5vZmYoRXZlbnRzLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5MRVZFTF9MT0FERUQsIHRoaXMub25MZXZlbExvYWRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19MT0FEX0VNRVJHRU5DWV9BQk9SVEVELCB0aGlzLm9uRnJhZ0xvYWRFbWVyZ2VuY3lBYm9ydGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5BVURJT19UUkFDS19TV0lUQ0hJTkcsIHRoaXMub25BdWRpb1RyYWNrU3dpdGNoaW5nLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5BVURJT19UUkFDS19TV0lUQ0hFRCwgdGhpcy5vbkF1ZGlvVHJhY2tTd2l0Y2hlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuQlVGRkVSX0NSRUFURUQsIHRoaXMub25CdWZmZXJDcmVhdGVkLCB0aGlzKTtcbiAgICBobHMub2ZmKEV2ZW50cy5CVUZGRVJfRkxVU0hFRCwgdGhpcy5vbkJ1ZmZlckZsdXNoZWQsIHRoaXMpO1xuICAgIGhscy5vZmYoRXZlbnRzLkxFVkVMU19VUERBVEVELCB0aGlzLm9uTGV2ZWxzVXBkYXRlZCwgdGhpcyk7XG4gICAgaGxzLm9mZihFdmVudHMuRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gIH1cbiAgb25IYW5kbGVyRGVzdHJveWluZygpIHtcbiAgICB0aGlzLl91bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgc3VwZXIub25IYW5kbGVyRGVzdHJveWluZygpO1xuICB9XG4gIHN0YXJ0TG9hZChzdGFydFBvc2l0aW9uKSB7XG4gICAgaWYgKHRoaXMubGV2ZWxzKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxhc3RDdXJyZW50VGltZSxcbiAgICAgICAgaGxzXG4gICAgICB9ID0gdGhpcztcbiAgICAgIHRoaXMuc3RvcExvYWQoKTtcbiAgICAgIHRoaXMuc2V0SW50ZXJ2YWwoVElDS19JTlRFUlZBTCk7XG4gICAgICB0aGlzLmxldmVsID0gLTE7XG4gICAgICBpZiAoIXRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkKSB7XG4gICAgICAgIC8vIGRldGVybWluZSBsb2FkIGxldmVsXG4gICAgICAgIGxldCBzdGFydExldmVsID0gaGxzLnN0YXJ0TGV2ZWw7XG4gICAgICAgIGlmIChzdGFydExldmVsID09PSAtMSkge1xuICAgICAgICAgIGlmIChobHMuY29uZmlnLnRlc3RCYW5kd2lkdGggJiYgdGhpcy5sZXZlbHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgLy8gLTEgOiBndWVzcyBzdGFydCBMZXZlbCBieSBkb2luZyBhIGJpdHJhdGUgdGVzdCBieSBsb2FkaW5nIGZpcnN0IGZyYWdtZW50IG9mIGxvd2VzdCBxdWFsaXR5IGxldmVsXG4gICAgICAgICAgICBzdGFydExldmVsID0gMDtcbiAgICAgICAgICAgIHRoaXMuYml0cmF0ZVRlc3QgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGFydExldmVsID0gaGxzLmZpcnN0QXV0b0xldmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgbmV3IGxldmVsIHRvIHBsYXlsaXN0IGxvYWRlciA6IHRoaXMgd2lsbCB0cmlnZ2VyIHN0YXJ0IGxldmVsIGxvYWRcbiAgICAgICAgLy8gaGxzLm5leHRMb2FkTGV2ZWwgcmVtYWlucyB1bnRpbCBpdCBpcyBzZXQgdG8gYSBuZXcgdmFsdWUgb3IgdW50aWwgYSBuZXcgZnJhZyBpcyBzdWNjZXNzZnVsbHkgbG9hZGVkXG4gICAgICAgIHRoaXMubGV2ZWwgPSBobHMubmV4dExvYWRMZXZlbCA9IHN0YXJ0TGV2ZWw7XG4gICAgICAgIHRoaXMubG9hZGVkbWV0YWRhdGEgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIHN0YXJ0UG9zaXRpb24gdW5kZWZpbmVkIGJ1dCBsYXN0Q3VycmVudFRpbWUgc2V0LCBzZXQgc3RhcnRQb3NpdGlvbiB0byBsYXN0IGN1cnJlbnRUaW1lXG4gICAgICBpZiAobGFzdEN1cnJlbnRUaW1lID4gMCAmJiBzdGFydFBvc2l0aW9uID09PSAtMSkge1xuICAgICAgICB0aGlzLmxvZyhgT3ZlcnJpZGUgc3RhcnRQb3NpdGlvbiB3aXRoIGxhc3RDdXJyZW50VGltZSBAJHtsYXN0Q3VycmVudFRpbWUudG9GaXhlZCgzKX1gKTtcbiAgICAgICAgc3RhcnRQb3NpdGlvbiA9IGxhc3RDdXJyZW50VGltZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSBzdGFydFBvc2l0aW9uO1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2ZvcmNlU3RhcnRMb2FkID0gdHJ1ZTtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5TVE9QUEVEO1xuICAgIH1cbiAgfVxuICBzdG9wTG9hZCgpIHtcbiAgICB0aGlzLl9mb3JjZVN0YXJ0TG9hZCA9IGZhbHNlO1xuICAgIHN1cGVyLnN0b3BMb2FkKCk7XG4gIH1cbiAgZG9UaWNrKCkge1xuICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgY2FzZSBTdGF0ZS5XQUlUSU5HX0xFVkVMOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgbGV2ZWxzLFxuICAgICAgICAgICAgbGV2ZWxcbiAgICAgICAgICB9ID0gdGhpcztcbiAgICAgICAgICBjb25zdCBjdXJyZW50TGV2ZWwgPSBsZXZlbHMgPT0gbnVsbCA/IHZvaWQgMCA6IGxldmVsc1tsZXZlbF07XG4gICAgICAgICAgY29uc3QgZGV0YWlscyA9IGN1cnJlbnRMZXZlbCA9PSBudWxsID8gdm9pZCAwIDogY3VycmVudExldmVsLmRldGFpbHM7XG4gICAgICAgICAgaWYgKGRldGFpbHMgJiYgKCFkZXRhaWxzLmxpdmUgfHwgdGhpcy5sZXZlbExhc3RMb2FkZWQgPT09IGN1cnJlbnRMZXZlbCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLndhaXRGb3JDZG5UdW5lSW4oZGV0YWlscykpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5obHMubmV4dExvYWRMZXZlbCAhPT0gdGhpcy5sZXZlbCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgU3RhdGUuRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX3RoaXMkbWVkaWE7XG4gICAgICAgICAgY29uc3Qgbm93ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICBjb25zdCByZXRyeURhdGUgPSB0aGlzLnJldHJ5RGF0ZTtcbiAgICAgICAgICAvLyBpZiBjdXJyZW50IHRpbWUgaXMgZ3QgdGhhbiByZXRyeURhdGUsIG9yIGlmIG1lZGlhIHNlZWtpbmcgbGV0J3Mgc3dpdGNoIHRvIElETEUgc3RhdGUgdG8gcmV0cnkgbG9hZGluZ1xuICAgICAgICAgIGlmICghcmV0cnlEYXRlIHx8IG5vdyA+PSByZXRyeURhdGUgfHwgKF90aGlzJG1lZGlhID0gdGhpcy5tZWRpYSkgIT0gbnVsbCAmJiBfdGhpcyRtZWRpYS5zZWVraW5nKSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGxldmVscyxcbiAgICAgICAgICAgICAgbGV2ZWxcbiAgICAgICAgICAgIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudExldmVsID0gbGV2ZWxzID09IG51bGwgPyB2b2lkIDAgOiBsZXZlbHNbbGV2ZWxdO1xuICAgICAgICAgICAgdGhpcy5yZXNldFN0YXJ0V2hlbk5vdExvYWRlZChjdXJyZW50TGV2ZWwgfHwgbnVsbCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5JRExFKSB7XG4gICAgICB0aGlzLmRvVGlja0lkbGUoKTtcbiAgICB9XG4gICAgdGhpcy5vblRpY2tFbmQoKTtcbiAgfVxuICBvblRpY2tFbmQoKSB7XG4gICAgc3VwZXIub25UaWNrRW5kKCk7XG4gICAgdGhpcy5jaGVja0J1ZmZlcigpO1xuICAgIHRoaXMuY2hlY2tGcmFnbWVudENoYW5nZWQoKTtcbiAgfVxuICBkb1RpY2tJZGxlKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhscyxcbiAgICAgIGxldmVsTGFzdExvYWRlZCxcbiAgICAgIGxldmVscyxcbiAgICAgIG1lZGlhXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgY29uZmlnLFxuICAgICAgbmV4dExvYWRMZXZlbDogbGV2ZWxcbiAgICB9ID0gaGxzO1xuXG4gICAgLy8gaWYgc3RhcnQgbGV2ZWwgbm90IHBhcnNlZCB5ZXQgT1JcbiAgICAvLyBpZiB2aWRlbyBub3QgYXR0YWNoZWQgQU5EIHN0YXJ0IGZyYWdtZW50IGFscmVhZHkgcmVxdWVzdGVkIE9SIHN0YXJ0IGZyYWcgcHJlZmV0Y2ggbm90IGVuYWJsZWRcbiAgICAvLyBleGl0IGxvb3AsIGFzIHdlIGVpdGhlciBuZWVkIG1vcmUgaW5mbyAobGV2ZWwgbm90IHBhcnNlZCkgb3Igd2UgbmVlZCBtZWRpYSB0byBiZSBhdHRhY2hlZCB0byBsb2FkIG5ldyBmcmFnbWVudFxuICAgIGlmIChsZXZlbExhc3RMb2FkZWQgPT09IG51bGwgfHwgIW1lZGlhICYmICh0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCB8fCAhY29uZmlnLnN0YXJ0RnJhZ1ByZWZldGNoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBcIm1haW5cIiBsZXZlbCBpcyBhdWRpby1vbmx5IGJ1dCB3ZSBhcmUgbG9hZGluZyBhbiBhbHRlcm5hdGUgdHJhY2sgaW4gdGhlIHNhbWUgZ3JvdXAsIGRvIG5vdCBsb2FkIGFueXRoaW5nXG4gICAgaWYgKHRoaXMuYWx0QXVkaW8gJiYgdGhpcy5hdWRpb09ubHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCEobGV2ZWxzICE9IG51bGwgJiYgbGV2ZWxzW2xldmVsXSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGV2ZWxJbmZvID0gbGV2ZWxzW2xldmVsXTtcblxuICAgIC8vIGlmIGJ1ZmZlciBsZW5ndGggaXMgbGVzcyB0aGFuIG1heEJ1ZkxlbiB0cnkgdG8gbG9hZCBhIG5ldyBmcmFnbWVudFxuXG4gICAgY29uc3QgYnVmZmVySW5mbyA9IHRoaXMuZ2V0TWFpbkZ3ZEJ1ZmZlckluZm8oKTtcbiAgICBpZiAoYnVmZmVySW5mbyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsYXN0RGV0YWlscyA9IHRoaXMuZ2V0TGV2ZWxEZXRhaWxzKCk7XG4gICAgaWYgKGxhc3REZXRhaWxzICYmIHRoaXMuX3N0cmVhbUVuZGVkKGJ1ZmZlckluZm8sIGxhc3REZXRhaWxzKSkge1xuICAgICAgY29uc3QgZGF0YSA9IHt9O1xuICAgICAgaWYgKHRoaXMuYWx0QXVkaW8pIHtcbiAgICAgICAgZGF0YS50eXBlID0gJ3ZpZGVvJztcbiAgICAgIH1cbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9FT1MsIGRhdGEpO1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkVOREVEO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHNldCBuZXh0IGxvYWQgbGV2ZWwgOiB0aGlzIHdpbGwgdHJpZ2dlciBhIHBsYXlsaXN0IGxvYWQgaWYgbmVlZGVkXG4gICAgaWYgKGhscy5sb2FkTGV2ZWwgIT09IGxldmVsICYmIGhscy5tYW51YWxMZXZlbCA9PT0gLTEpIHtcbiAgICAgIHRoaXMubG9nKGBBZGFwdGluZyB0byBsZXZlbCAke2xldmVsfSBmcm9tIGxldmVsICR7dGhpcy5sZXZlbH1gKTtcbiAgICB9XG4gICAgdGhpcy5sZXZlbCA9IGhscy5uZXh0TG9hZExldmVsID0gbGV2ZWw7XG4gICAgY29uc3QgbGV2ZWxEZXRhaWxzID0gbGV2ZWxJbmZvLmRldGFpbHM7XG4gICAgLy8gaWYgbGV2ZWwgaW5mbyBub3QgcmV0cmlldmVkIHlldCwgc3dpdGNoIHN0YXRlIGFuZCB3YWl0IGZvciBsZXZlbCByZXRyaWV2YWxcbiAgICAvLyBpZiBsaXZlIHBsYXlsaXN0LCBlbnN1cmUgdGhhdCBuZXcgcGxheWxpc3QgaGFzIGJlZW4gcmVmcmVzaGVkIHRvIGF2b2lkIGxvYWRpbmcvdHJ5IHRvIGxvYWRcbiAgICAvLyBhIHVzZWxlc3MgYW5kIG91dGRhdGVkIGZyYWdtZW50ICh0aGF0IG1pZ2h0IGV2ZW4gaW50cm9kdWNlIGxvYWQgZXJyb3IgaWYgaXQgaXMgYWxyZWFkeSBvdXQgb2YgdGhlIGxpdmUgcGxheWxpc3QpXG4gICAgaWYgKCFsZXZlbERldGFpbHMgfHwgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuV0FJVElOR19MRVZFTCB8fCBsZXZlbERldGFpbHMubGl2ZSAmJiB0aGlzLmxldmVsTGFzdExvYWRlZCAhPT0gbGV2ZWxJbmZvKSB7XG4gICAgICB0aGlzLmxldmVsID0gbGV2ZWw7XG4gICAgICB0aGlzLnN0YXRlID0gU3RhdGUuV0FJVElOR19MRVZFTDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYnVmZmVyTGVuID0gYnVmZmVySW5mby5sZW47XG5cbiAgICAvLyBjb21wdXRlIG1heCBCdWZmZXIgTGVuZ3RoIHRoYXQgd2UgY291bGQgZ2V0IGZyb20gdGhpcyBsb2FkIGxldmVsLCBiYXNlZCBvbiBsZXZlbCBiaXRyYXRlLiBkb24ndCBidWZmZXIgbW9yZSB0aGFuIDYwIE1CIGFuZCBtb3JlIHRoYW4gMzBzXG4gICAgY29uc3QgbWF4QnVmTGVuID0gdGhpcy5nZXRNYXhCdWZmZXJMZW5ndGgobGV2ZWxJbmZvLm1heEJpdHJhdGUpO1xuXG4gICAgLy8gU3RheSBpZGxlIGlmIHdlIGFyZSBzdGlsbCB3aXRoIGJ1ZmZlciBtYXJnaW5zXG4gICAgaWYgKGJ1ZmZlckxlbiA+PSBtYXhCdWZMZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuYmFja3RyYWNrRnJhZ21lbnQgJiYgdGhpcy5iYWNrdHJhY2tGcmFnbWVudC5zdGFydCA+IGJ1ZmZlckluZm8uZW5kKSB7XG4gICAgICB0aGlzLmJhY2t0cmFja0ZyYWdtZW50ID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0QnVmZmVyVGltZSA9IHRoaXMuYmFja3RyYWNrRnJhZ21lbnQgPyB0aGlzLmJhY2t0cmFja0ZyYWdtZW50LnN0YXJ0IDogYnVmZmVySW5mby5lbmQ7XG4gICAgbGV0IGZyYWcgPSB0aGlzLmdldE5leHRGcmFnbWVudCh0YXJnZXRCdWZmZXJUaW1lLCBsZXZlbERldGFpbHMpO1xuICAgIC8vIEF2b2lkIGJhY2t0cmFja2luZyBieSBsb2FkaW5nIGFuIGVhcmxpZXIgc2VnbWVudCBpbiBzdHJlYW1zIHdpdGggc2VnbWVudHMgdGhhdCBkbyBub3Qgc3RhcnQgd2l0aCBhIGtleSBmcmFtZSAoZmxhZ2dlZCBieSBgY291bGRCYWNrdHJhY2tgKVxuICAgIGlmICh0aGlzLmNvdWxkQmFja3RyYWNrICYmICF0aGlzLmZyYWdQcmV2aW91cyAmJiBmcmFnICYmIGZyYWcuc24gIT09ICdpbml0U2VnbWVudCcgJiYgdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZnJhZykgIT09IEZyYWdtZW50U3RhdGUuT0spIHtcbiAgICAgIHZhciBfdGhpcyRiYWNrdHJhY2tGcmFnbWU7XG4gICAgICBjb25zdCBiYWNrdHJhY2tTbiA9ICgoX3RoaXMkYmFja3RyYWNrRnJhZ21lID0gdGhpcy5iYWNrdHJhY2tGcmFnbWVudCkgIT0gbnVsbCA/IF90aGlzJGJhY2t0cmFja0ZyYWdtZSA6IGZyYWcpLnNuO1xuICAgICAgY29uc3QgZnJhZ0lkeCA9IGJhY2t0cmFja1NuIC0gbGV2ZWxEZXRhaWxzLnN0YXJ0U047XG4gICAgICBjb25zdCBiYWNrdHJhY2tGcmFnID0gbGV2ZWxEZXRhaWxzLmZyYWdtZW50c1tmcmFnSWR4IC0gMV07XG4gICAgICBpZiAoYmFja3RyYWNrRnJhZyAmJiBmcmFnLmNjID09PSBiYWNrdHJhY2tGcmFnLmNjKSB7XG4gICAgICAgIGZyYWcgPSBiYWNrdHJhY2tGcmFnO1xuICAgICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChiYWNrdHJhY2tGcmFnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuYmFja3RyYWNrRnJhZ21lbnQgJiYgYnVmZmVySW5mby5sZW4pIHtcbiAgICAgIHRoaXMuYmFja3RyYWNrRnJhZ21lbnQgPSBudWxsO1xuICAgIH1cbiAgICAvLyBBdm9pZCBsb29wIGxvYWRpbmcgYnkgdXNpbmcgbmV4dExvYWRQb3NpdGlvbiBzZXQgZm9yIGJhY2t0cmFja2luZyBhbmQgc2tpcHBpbmcgY29uc2VjdXRpdmUgR0FQIHRhZ3NcbiAgICBpZiAoZnJhZyAmJiB0aGlzLmlzTG9vcExvYWRpbmcoZnJhZywgdGFyZ2V0QnVmZmVyVGltZSkpIHtcbiAgICAgIGNvbnN0IGdhcFN0YXJ0ID0gZnJhZy5nYXA7XG4gICAgICBpZiAoIWdhcFN0YXJ0KSB7XG4gICAgICAgIC8vIENsZWFudXAgdGhlIGZyYWdtZW50IHRyYWNrZXIgYmVmb3JlIHRyeWluZyB0byBmaW5kIHRoZSBuZXh0IHVuYnVmZmVyZWQgZnJhZ21lbnRcbiAgICAgICAgY29uc3QgdHlwZSA9IHRoaXMuYXVkaW9Pbmx5ICYmICF0aGlzLmFsdEF1ZGlvID8gRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPIDogRWxlbWVudGFyeVN0cmVhbVR5cGVzLlZJREVPO1xuICAgICAgICBjb25zdCBtZWRpYUJ1ZmZlciA9ICh0eXBlID09PSBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuVklERU8gPyB0aGlzLnZpZGVvQnVmZmVyIDogdGhpcy5tZWRpYUJ1ZmZlcikgfHwgdGhpcy5tZWRpYTtcbiAgICAgICAgaWYgKG1lZGlhQnVmZmVyKSB7XG4gICAgICAgICAgdGhpcy5hZnRlckJ1ZmZlckZsdXNoZWQobWVkaWFCdWZmZXIsIHR5cGUsIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmcmFnID0gdGhpcy5nZXROZXh0RnJhZ21lbnRMb29wTG9hZGluZyhmcmFnLCBsZXZlbERldGFpbHMsIGJ1ZmZlckluZm8sIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4sIG1heEJ1Zkxlbik7XG4gICAgfVxuICAgIGlmICghZnJhZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZnJhZy5pbml0U2VnbWVudCAmJiAhZnJhZy5pbml0U2VnbWVudC5kYXRhICYmICF0aGlzLmJpdHJhdGVUZXN0KSB7XG4gICAgICBmcmFnID0gZnJhZy5pbml0U2VnbWVudDtcbiAgICB9XG4gICAgdGhpcy5sb2FkRnJhZ21lbnQoZnJhZywgbGV2ZWxJbmZvLCB0YXJnZXRCdWZmZXJUaW1lKTtcbiAgfVxuICBsb2FkRnJhZ21lbnQoZnJhZywgbGV2ZWwsIHRhcmdldEJ1ZmZlclRpbWUpIHtcbiAgICAvLyBDaGVjayBpZiBmcmFnbWVudCBpcyBub3QgbG9hZGVkXG4gICAgY29uc3QgZnJhZ1N0YXRlID0gdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZnJhZyk7XG4gICAgdGhpcy5mcmFnQ3VycmVudCA9IGZyYWc7XG4gICAgaWYgKGZyYWdTdGF0ZSA9PT0gRnJhZ21lbnRTdGF0ZS5OT1RfTE9BREVEIHx8IGZyYWdTdGF0ZSA9PT0gRnJhZ21lbnRTdGF0ZS5QQVJUSUFMKSB7XG4gICAgICBpZiAoZnJhZy5zbiA9PT0gJ2luaXRTZWdtZW50Jykge1xuICAgICAgICB0aGlzLl9sb2FkSW5pdFNlZ21lbnQoZnJhZywgbGV2ZWwpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmJpdHJhdGVUZXN0KSB7XG4gICAgICAgIHRoaXMubG9nKGBGcmFnbWVudCAke2ZyYWcuc259IG9mIGxldmVsICR7ZnJhZy5sZXZlbH0gaXMgYmVpbmcgZG93bmxvYWRlZCB0byB0ZXN0IGJpdHJhdGUgYW5kIHdpbGwgbm90IGJlIGJ1ZmZlcmVkYCk7XG4gICAgICAgIHRoaXMuX2xvYWRCaXRyYXRlVGVzdEZyYWcoZnJhZywgbGV2ZWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSB0cnVlO1xuICAgICAgICBzdXBlci5sb2FkRnJhZ21lbnQoZnJhZywgbGV2ZWwsIHRhcmdldEJ1ZmZlclRpbWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNsZWFyVHJhY2tlcklmTmVlZGVkKGZyYWcpO1xuICAgIH1cbiAgfVxuICBnZXRCdWZmZXJlZEZyYWcocG9zaXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0QnVmZmVyZWRGcmFnKHBvc2l0aW9uLCBQbGF5bGlzdExldmVsVHlwZS5NQUlOKTtcbiAgfVxuICBmb2xsb3dpbmdCdWZmZXJlZEZyYWcoZnJhZykge1xuICAgIGlmIChmcmFnKSB7XG4gICAgICAvLyB0cnkgdG8gZ2V0IHJhbmdlIG9mIG5leHQgZnJhZ21lbnQgKDUwMG1zIGFmdGVyIHRoaXMgcmFuZ2UpXG4gICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXJlZEZyYWcoZnJhZy5lbmQgKyAwLjUpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qXG4gICAgb24gaW1tZWRpYXRlIGxldmVsIHN3aXRjaCA6XG4gICAgIC0gcGF1c2UgcGxheWJhY2sgaWYgcGxheWluZ1xuICAgICAtIGNhbmNlbCBhbnkgcGVuZGluZyBsb2FkIHJlcXVlc3RcbiAgICAgLSBhbmQgdHJpZ2dlciBhIGJ1ZmZlciBmbHVzaFxuICAqL1xuICBpbW1lZGlhdGVMZXZlbFN3aXRjaCgpIHtcbiAgICB0aGlzLmFib3J0Q3VycmVudEZyYWcoKTtcbiAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcigwLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICB9XG5cbiAgLyoqXG4gICAqIHRyeSB0byBzd2l0Y2ggQVNBUCB3aXRob3V0IGJyZWFraW5nIHZpZGVvIHBsYXliYWNrOlxuICAgKiBpbiBvcmRlciB0byBlbnN1cmUgc21vb3RoIGJ1dCBxdWljayBsZXZlbCBzd2l0Y2hpbmcsXG4gICAqIHdlIG5lZWQgdG8gZmluZCB0aGUgbmV4dCBmbHVzaGFibGUgYnVmZmVyIHJhbmdlXG4gICAqIHdlIHNob3VsZCB0YWtlIGludG8gYWNjb3VudCBuZXcgc2VnbWVudCBmZXRjaCB0aW1lXG4gICAqL1xuICBuZXh0TGV2ZWxTd2l0Y2goKSB7XG4gICAgY29uc3Qge1xuICAgICAgbGV2ZWxzLFxuICAgICAgbWVkaWFcbiAgICB9ID0gdGhpcztcbiAgICAvLyBlbnN1cmUgdGhhdCBtZWRpYSBpcyBkZWZpbmVkIGFuZCB0aGF0IG1ldGFkYXRhIGFyZSBhdmFpbGFibGUgKHRvIHJldHJpZXZlIGN1cnJlbnRUaW1lKVxuICAgIGlmIChtZWRpYSAhPSBudWxsICYmIG1lZGlhLnJlYWR5U3RhdGUpIHtcbiAgICAgIGxldCBmZXRjaGRlbGF5O1xuICAgICAgY29uc3QgZnJhZ1BsYXlpbmdDdXJyZW50ID0gdGhpcy5nZXRBcHBlbmRlZEZyYWcobWVkaWEuY3VycmVudFRpbWUpO1xuICAgICAgaWYgKGZyYWdQbGF5aW5nQ3VycmVudCAmJiBmcmFnUGxheWluZ0N1cnJlbnQuc3RhcnQgPiAxKSB7XG4gICAgICAgIC8vIGZsdXNoIGJ1ZmZlciBwcmVjZWRpbmcgY3VycmVudCBmcmFnbWVudCAoZmx1c2ggdW50aWwgY3VycmVudCBmcmFnbWVudCBzdGFydCBvZmZzZXQpXG4gICAgICAgIC8vIG1pbnVzIDFzIHRvIGF2b2lkIHZpZGVvIGZyZWV6aW5nLCB0aGF0IGNvdWxkIGhhcHBlbiBpZiB3ZSBmbHVzaCBrZXlmcmFtZSBvZiBjdXJyZW50IHZpZGVvIC4uLlxuICAgICAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcigwLCBmcmFnUGxheWluZ0N1cnJlbnQuc3RhcnQgLSAxKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxldmVsRGV0YWlscyA9IHRoaXMuZ2V0TGV2ZWxEZXRhaWxzKCk7XG4gICAgICBpZiAobGV2ZWxEZXRhaWxzICE9IG51bGwgJiYgbGV2ZWxEZXRhaWxzLmxpdmUpIHtcbiAgICAgICAgY29uc3QgYnVmZmVySW5mbyA9IHRoaXMuZ2V0TWFpbkZ3ZEJ1ZmZlckluZm8oKTtcbiAgICAgICAgLy8gRG8gbm90IGZsdXNoIGluIGxpdmUgc3RyZWFtIHdpdGggbG93IGJ1ZmZlclxuICAgICAgICBpZiAoIWJ1ZmZlckluZm8gfHwgYnVmZmVySW5mby5sZW4gPCBsZXZlbERldGFpbHMudGFyZ2V0ZHVyYXRpb24gKiAyKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIW1lZGlhLnBhdXNlZCAmJiBsZXZlbHMpIHtcbiAgICAgICAgLy8gYWRkIGEgc2FmZXR5IGRlbGF5IG9mIDFzXG4gICAgICAgIGNvbnN0IG5leHRMZXZlbElkID0gdGhpcy5obHMubmV4dExvYWRMZXZlbDtcbiAgICAgICAgY29uc3QgbmV4dExldmVsID0gbGV2ZWxzW25leHRMZXZlbElkXTtcbiAgICAgICAgY29uc3QgZnJhZ0xhc3RLYnBzID0gdGhpcy5mcmFnTGFzdEticHM7XG4gICAgICAgIGlmIChmcmFnTGFzdEticHMgJiYgdGhpcy5mcmFnQ3VycmVudCkge1xuICAgICAgICAgIGZldGNoZGVsYXkgPSB0aGlzLmZyYWdDdXJyZW50LmR1cmF0aW9uICogbmV4dExldmVsLm1heEJpdHJhdGUgLyAoMTAwMCAqIGZyYWdMYXN0S2JwcykgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZldGNoZGVsYXkgPSAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmZXRjaGRlbGF5ID0gMDtcbiAgICAgIH1cbiAgICAgIC8vIHRoaXMubG9nKCdmZXRjaGRlbGF5OicrZmV0Y2hkZWxheSk7XG4gICAgICAvLyBmaW5kIGJ1ZmZlciByYW5nZSB0aGF0IHdpbGwgYmUgcmVhY2hlZCBvbmNlIG5ldyBmcmFnbWVudCB3aWxsIGJlIGZldGNoZWRcbiAgICAgIGNvbnN0IGJ1ZmZlcmVkRnJhZyA9IHRoaXMuZ2V0QnVmZmVyZWRGcmFnKG1lZGlhLmN1cnJlbnRUaW1lICsgZmV0Y2hkZWxheSk7XG4gICAgICBpZiAoYnVmZmVyZWRGcmFnKSB7XG4gICAgICAgIC8vIHdlIGNhbiBmbHVzaCBidWZmZXIgcmFuZ2UgZm9sbG93aW5nIHRoaXMgb25lIHdpdGhvdXQgc3RhbGxpbmcgcGxheWJhY2tcbiAgICAgICAgY29uc3QgbmV4dEJ1ZmZlcmVkRnJhZyA9IHRoaXMuZm9sbG93aW5nQnVmZmVyZWRGcmFnKGJ1ZmZlcmVkRnJhZyk7XG4gICAgICAgIGlmIChuZXh0QnVmZmVyZWRGcmFnKSB7XG4gICAgICAgICAgLy8gaWYgd2UgYXJlIGhlcmUsIHdlIGNhbiBhbHNvIGNhbmNlbCBhbnkgbG9hZGluZy9kZW11eGluZyBpbiBwcm9ncmVzcywgYXMgdGhleSBhcmUgdXNlbGVzc1xuICAgICAgICAgIHRoaXMuYWJvcnRDdXJyZW50RnJhZygpO1xuICAgICAgICAgIC8vIHN0YXJ0IGZsdXNoIHBvc2l0aW9uIGlzIGluIG5leHQgYnVmZmVyZWQgZnJhZy4gTGVhdmUgc29tZSBwYWRkaW5nIGZvciBub24taW5kZXBlbmRlbnQgc2VnbWVudHMgYW5kIHNtb290aGVyIHBsYXliYWNrLlxuICAgICAgICAgIGNvbnN0IG1heFN0YXJ0ID0gbmV4dEJ1ZmZlcmVkRnJhZy5tYXhTdGFydFBUUyA/IG5leHRCdWZmZXJlZEZyYWcubWF4U3RhcnRQVFMgOiBuZXh0QnVmZmVyZWRGcmFnLnN0YXJ0O1xuICAgICAgICAgIGNvbnN0IGZyYWdEdXJhdGlvbiA9IG5leHRCdWZmZXJlZEZyYWcuZHVyYXRpb247XG4gICAgICAgICAgY29uc3Qgc3RhcnRQdHMgPSBNYXRoLm1heChidWZmZXJlZEZyYWcuZW5kLCBtYXhTdGFydCArIE1hdGgubWluKE1hdGgubWF4KGZyYWdEdXJhdGlvbiAtIHRoaXMuY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGZyYWdEdXJhdGlvbiAqICh0aGlzLmNvdWxkQmFja3RyYWNrID8gMC41IDogMC4xMjUpKSwgZnJhZ0R1cmF0aW9uICogKHRoaXMuY291bGRCYWNrdHJhY2sgPyAwLjc1IDogMC4yNSkpKTtcbiAgICAgICAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcihzdGFydFB0cywgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBhYm9ydEN1cnJlbnRGcmFnKCkge1xuICAgIGNvbnN0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbDtcbiAgICB0aGlzLmJhY2t0cmFja0ZyYWdtZW50ID0gbnVsbDtcbiAgICBpZiAoZnJhZ0N1cnJlbnQpIHtcbiAgICAgIGZyYWdDdXJyZW50LmFib3J0UmVxdWVzdHMoKTtcbiAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWdDdXJyZW50KTtcbiAgICB9XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIFN0YXRlLktFWV9MT0FESU5HOlxuICAgICAgY2FzZSBTdGF0ZS5GUkFHX0xPQURJTkc6XG4gICAgICBjYXNlIFN0YXRlLkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZOlxuICAgICAgY2FzZSBTdGF0ZS5QQVJTSU5HOlxuICAgICAgY2FzZSBTdGF0ZS5QQVJTRUQ6XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5nZXRMb2FkUG9zaXRpb24oKTtcbiAgfVxuICBmbHVzaE1haW5CdWZmZXIoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCkge1xuICAgIHN1cGVyLmZsdXNoTWFpbkJ1ZmZlcihzdGFydE9mZnNldCwgZW5kT2Zmc2V0LCB0aGlzLmFsdEF1ZGlvID8gJ3ZpZGVvJyA6IG51bGwpO1xuICB9XG4gIG9uTWVkaWFBdHRhY2hlZChldmVudCwgZGF0YSkge1xuICAgIHN1cGVyLm9uTWVkaWFBdHRhY2hlZChldmVudCwgZGF0YSk7XG4gICAgY29uc3QgbWVkaWEgPSBkYXRhLm1lZGlhO1xuICAgIHRoaXMub252cGxheWluZyA9IHRoaXMub25NZWRpYVBsYXlpbmcuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9udnNlZWtlZCA9IHRoaXMub25NZWRpYVNlZWtlZC5iaW5kKHRoaXMpO1xuICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ3BsYXlpbmcnLCB0aGlzLm9udnBsYXlpbmcpO1xuICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ3NlZWtlZCcsIHRoaXMub252c2Vla2VkKTtcbiAgICB0aGlzLmdhcENvbnRyb2xsZXIgPSBuZXcgR2FwQ29udHJvbGxlcih0aGlzLmNvbmZpZywgbWVkaWEsIHRoaXMuZnJhZ21lbnRUcmFja2VyLCB0aGlzLmhscyk7XG4gIH1cbiAgb25NZWRpYURldGFjaGluZygpIHtcbiAgICBjb25zdCB7XG4gICAgICBtZWRpYVxuICAgIH0gPSB0aGlzO1xuICAgIGlmIChtZWRpYSAmJiB0aGlzLm9udnBsYXlpbmcgJiYgdGhpcy5vbnZzZWVrZWQpIHtcbiAgICAgIG1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BsYXlpbmcnLCB0aGlzLm9udnBsYXlpbmcpO1xuICAgICAgbWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Vla2VkJywgdGhpcy5vbnZzZWVrZWQpO1xuICAgICAgdGhpcy5vbnZwbGF5aW5nID0gdGhpcy5vbnZzZWVrZWQgPSBudWxsO1xuICAgICAgdGhpcy52aWRlb0J1ZmZlciA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuZnJhZ1BsYXlpbmcgPSBudWxsO1xuICAgIGlmICh0aGlzLmdhcENvbnRyb2xsZXIpIHtcbiAgICAgIHRoaXMuZ2FwQ29udHJvbGxlci5kZXN0cm95KCk7XG4gICAgICB0aGlzLmdhcENvbnRyb2xsZXIgPSBudWxsO1xuICAgIH1cbiAgICBzdXBlci5vbk1lZGlhRGV0YWNoaW5nKCk7XG4gIH1cbiAgb25NZWRpYVBsYXlpbmcoKSB7XG4gICAgLy8gdGljayB0byBzcGVlZCB1cCBGUkFHX0NIQU5HRUQgdHJpZ2dlcmluZ1xuICAgIHRoaXMudGljaygpO1xuICB9XG4gIG9uTWVkaWFTZWVrZWQoKSB7XG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbWVkaWEgPyBtZWRpYS5jdXJyZW50VGltZSA6IG51bGw7XG4gICAgaWYgKGlzRmluaXRlTnVtYmVyKGN1cnJlbnRUaW1lKSkge1xuICAgICAgdGhpcy5sb2coYE1lZGlhIHNlZWtlZCB0byAke2N1cnJlbnRUaW1lLnRvRml4ZWQoMyl9YCk7XG4gICAgfVxuXG4gICAgLy8gSWYgc2Vla2VkIHdhcyBpc3N1ZWQgYmVmb3JlIGJ1ZmZlciB3YXMgYXBwZW5kZWQgZG8gbm90IHRpY2sgaW1tZWRpYXRlbHlcbiAgICBjb25zdCBidWZmZXJJbmZvID0gdGhpcy5nZXRNYWluRndkQnVmZmVySW5mbygpO1xuICAgIGlmIChidWZmZXJJbmZvID09PSBudWxsIHx8IGJ1ZmZlckluZm8ubGVuID09PSAwKSB7XG4gICAgICB0aGlzLndhcm4oYE1haW4gZm9yd2FyZCBidWZmZXIgbGVuZ3RoIG9uIFwic2Vla2VkXCIgZXZlbnQgJHtidWZmZXJJbmZvID8gYnVmZmVySW5mby5sZW4gOiAnZW1wdHknfSlgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyB0aWNrIHRvIHNwZWVkIHVwIEZSQUdfQ0hBTkdFRCB0cmlnZ2VyaW5nXG4gICAgdGhpcy50aWNrKCk7XG4gIH1cbiAgb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgLy8gcmVzZXQgYnVmZmVyIG9uIG1hbmlmZXN0IGxvYWRpbmdcbiAgICB0aGlzLmxvZygnVHJpZ2dlciBCVUZGRVJfUkVTRVQnKTtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfUkVTRVQsIHVuZGVmaW5lZCk7XG4gICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlQWxsRnJhZ21lbnRzKCk7XG4gICAgdGhpcy5jb3VsZEJhY2t0cmFjayA9IGZhbHNlO1xuICAgIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lID0gdGhpcy5mcmFnTGFzdEticHMgPSAwO1xuICAgIHRoaXMubGV2ZWxzID0gdGhpcy5mcmFnUGxheWluZyA9IHRoaXMuYmFja3RyYWNrRnJhZ21lbnQgPSB0aGlzLmxldmVsTGFzdExvYWRlZCA9IG51bGw7XG4gICAgdGhpcy5hbHRBdWRpbyA9IHRoaXMuYXVkaW9Pbmx5ID0gdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgfVxuICBvbk1hbmlmZXN0UGFyc2VkKGV2ZW50LCBkYXRhKSB7XG4gICAgLy8gZGV0ZWN0IGlmIHdlIGhhdmUgZGlmZmVyZW50IGtpbmQgb2YgYXVkaW8gY29kZWNzIHVzZWQgYW1vbmdzdCBwbGF5bGlzdHNcbiAgICBsZXQgYWFjID0gZmFsc2U7XG4gICAgbGV0IGhlYWFjID0gZmFsc2U7XG4gICAgZGF0YS5sZXZlbHMuZm9yRWFjaChsZXZlbCA9PiB7XG4gICAgICBjb25zdCBjb2RlYyA9IGxldmVsLmF1ZGlvQ29kZWM7XG4gICAgICBpZiAoY29kZWMpIHtcbiAgICAgICAgYWFjID0gYWFjIHx8IGNvZGVjLmluZGV4T2YoJ21wNGEuNDAuMicpICE9PSAtMTtcbiAgICAgICAgaGVhYWMgPSBoZWFhYyB8fCBjb2RlYy5pbmRleE9mKCdtcDRhLjQwLjUnKSAhPT0gLTE7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5hdWRpb0NvZGVjU3dpdGNoID0gYWFjICYmIGhlYWFjICYmICFjaGFuZ2VUeXBlU3VwcG9ydGVkKCk7XG4gICAgaWYgKHRoaXMuYXVkaW9Db2RlY1N3aXRjaCkge1xuICAgICAgdGhpcy5sb2coJ0JvdGggQUFDL0hFLUFBQyBhdWRpbyBmb3VuZCBpbiBsZXZlbHM7IGRlY2xhcmluZyBsZXZlbCBjb2RlYyBhcyBIRS1BQUMnKTtcbiAgICB9XG4gICAgdGhpcy5sZXZlbHMgPSBkYXRhLmxldmVscztcbiAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9IGZhbHNlO1xuICB9XG4gIG9uTGV2ZWxMb2FkaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgbGV2ZWxzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFsZXZlbHMgfHwgdGhpcy5zdGF0ZSAhPT0gU3RhdGUuSURMRSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsZXZlbCA9IGxldmVsc1tkYXRhLmxldmVsXTtcbiAgICBpZiAoIWxldmVsLmRldGFpbHMgfHwgbGV2ZWwuZGV0YWlscy5saXZlICYmIHRoaXMubGV2ZWxMYXN0TG9hZGVkICE9PSBsZXZlbCB8fCB0aGlzLndhaXRGb3JDZG5UdW5lSW4obGV2ZWwuZGV0YWlscykpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5XQUlUSU5HX0xFVkVMO1xuICAgIH1cbiAgfVxuICBvbkxldmVsTG9hZGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgdmFyIF9jdXJMZXZlbCRkZXRhaWxzO1xuICAgIGNvbnN0IHtcbiAgICAgIGxldmVsc1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IG5ld0xldmVsSWQgPSBkYXRhLmxldmVsO1xuICAgIGNvbnN0IG5ld0RldGFpbHMgPSBkYXRhLmRldGFpbHM7XG4gICAgY29uc3QgZHVyYXRpb24gPSBuZXdEZXRhaWxzLnRvdGFsZHVyYXRpb247XG4gICAgaWYgKCFsZXZlbHMpIHtcbiAgICAgIHRoaXMud2FybihgTGV2ZWxzIHdlcmUgcmVzZXQgd2hpbGUgbG9hZGluZyBsZXZlbCAke25ld0xldmVsSWR9YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubG9nKGBMZXZlbCAke25ld0xldmVsSWR9IGxvYWRlZCBbJHtuZXdEZXRhaWxzLnN0YXJ0U059LCR7bmV3RGV0YWlscy5lbmRTTn1dJHtuZXdEZXRhaWxzLmxhc3RQYXJ0U24gPyBgW3BhcnQtJHtuZXdEZXRhaWxzLmxhc3RQYXJ0U259LSR7bmV3RGV0YWlscy5sYXN0UGFydEluZGV4fV1gIDogJyd9LCBjYyBbJHtuZXdEZXRhaWxzLnN0YXJ0Q0N9LCAke25ld0RldGFpbHMuZW5kQ0N9XSBkdXJhdGlvbjoke2R1cmF0aW9ufWApO1xuICAgIGNvbnN0IGN1ckxldmVsID0gbGV2ZWxzW25ld0xldmVsSWRdO1xuICAgIGNvbnN0IGZyYWdDdXJyZW50ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICBpZiAoZnJhZ0N1cnJlbnQgJiYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLkZSQUdfTE9BRElORyB8fCB0aGlzLnN0YXRlID09PSBTdGF0ZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWSkpIHtcbiAgICAgIGlmIChmcmFnQ3VycmVudC5sZXZlbCAhPT0gZGF0YS5sZXZlbCAmJiBmcmFnQ3VycmVudC5sb2FkZXIpIHtcbiAgICAgICAgdGhpcy5hYm9ydEN1cnJlbnRGcmFnKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBzbGlkaW5nID0gMDtcbiAgICBpZiAobmV3RGV0YWlscy5saXZlIHx8IChfY3VyTGV2ZWwkZGV0YWlscyA9IGN1ckxldmVsLmRldGFpbHMpICE9IG51bGwgJiYgX2N1ckxldmVsJGRldGFpbHMubGl2ZSkge1xuICAgICAgdmFyIF90aGlzJGxldmVsTGFzdExvYWRlZDtcbiAgICAgIHRoaXMuY2hlY2tMaXZlVXBkYXRlKG5ld0RldGFpbHMpO1xuICAgICAgaWYgKG5ld0RldGFpbHMuZGVsdGFVcGRhdGVGYWlsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2xpZGluZyA9IHRoaXMuYWxpZ25QbGF5bGlzdHMobmV3RGV0YWlscywgY3VyTGV2ZWwuZGV0YWlscywgKF90aGlzJGxldmVsTGFzdExvYWRlZCA9IHRoaXMubGV2ZWxMYXN0TG9hZGVkKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkbGV2ZWxMYXN0TG9hZGVkLmRldGFpbHMpO1xuICAgIH1cbiAgICAvLyBvdmVycmlkZSBsZXZlbCBpbmZvXG4gICAgY3VyTGV2ZWwuZGV0YWlscyA9IG5ld0RldGFpbHM7XG4gICAgdGhpcy5sZXZlbExhc3RMb2FkZWQgPSBjdXJMZXZlbDtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5MRVZFTF9VUERBVEVELCB7XG4gICAgICBkZXRhaWxzOiBuZXdEZXRhaWxzLFxuICAgICAgbGV2ZWw6IG5ld0xldmVsSWRcbiAgICB9KTtcblxuICAgIC8vIG9ubHkgc3dpdGNoIGJhY2sgdG8gSURMRSBzdGF0ZSBpZiB3ZSB3ZXJlIHdhaXRpbmcgZm9yIGxldmVsIHRvIHN0YXJ0IGRvd25sb2FkaW5nIGEgbmV3IGZyYWdtZW50XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFN0YXRlLldBSVRJTkdfTEVWRUwpIHtcbiAgICAgIGlmICh0aGlzLndhaXRGb3JDZG5UdW5lSW4obmV3RGV0YWlscykpIHtcbiAgICAgICAgLy8gV2FpdCBmb3IgTG93LUxhdGVuY3kgQ0ROIFR1bmUtaW5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgfVxuICAgIGlmICghdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQpIHtcbiAgICAgIHRoaXMuc2V0U3RhcnRQb3NpdGlvbihuZXdEZXRhaWxzLCBzbGlkaW5nKTtcbiAgICB9IGVsc2UgaWYgKG5ld0RldGFpbHMubGl2ZSkge1xuICAgICAgdGhpcy5zeW5jaHJvbml6ZVRvTGl2ZUVkZ2UobmV3RGV0YWlscyk7XG4gICAgfVxuXG4gICAgLy8gdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgIHRoaXMudGljaygpO1xuICB9XG4gIF9oYW5kbGVGcmFnbWVudExvYWRQcm9ncmVzcyhkYXRhKSB7XG4gICAgdmFyIF9mcmFnJGluaXRTZWdtZW50O1xuICAgIGNvbnN0IHtcbiAgICAgIGZyYWcsXG4gICAgICBwYXJ0LFxuICAgICAgcGF5bG9hZFxuICAgIH0gPSBkYXRhO1xuICAgIGNvbnN0IHtcbiAgICAgIGxldmVsc1xuICAgIH0gPSB0aGlzO1xuICAgIGlmICghbGV2ZWxzKSB7XG4gICAgICB0aGlzLndhcm4oYExldmVscyB3ZXJlIHJlc2V0IHdoaWxlIGZyYWdtZW50IGxvYWQgd2FzIGluIHByb2dyZXNzLiBGcmFnbWVudCAke2ZyYWcuc259IG9mIGxldmVsICR7ZnJhZy5sZXZlbH0gd2lsbCBub3QgYmUgYnVmZmVyZWRgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudExldmVsID0gbGV2ZWxzW2ZyYWcubGV2ZWxdO1xuICAgIGNvbnN0IGRldGFpbHMgPSBjdXJyZW50TGV2ZWwuZGV0YWlscztcbiAgICBpZiAoIWRldGFpbHMpIHtcbiAgICAgIHRoaXMud2FybihgRHJvcHBpbmcgZnJhZ21lbnQgJHtmcmFnLnNufSBvZiBsZXZlbCAke2ZyYWcubGV2ZWx9IGFmdGVyIGxldmVsIGRldGFpbHMgd2VyZSByZXNldGApO1xuICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHZpZGVvQ29kZWMgPSBjdXJyZW50TGV2ZWwudmlkZW9Db2RlYztcblxuICAgIC8vIHRpbWUgT2Zmc2V0IGlzIGFjY3VyYXRlIGlmIGxldmVsIFBUUyBpcyBrbm93biwgb3IgaWYgcGxheWxpc3QgaXMgbm90IHNsaWRpbmcgKG5vdCBsaXZlKVxuICAgIGNvbnN0IGFjY3VyYXRlVGltZU9mZnNldCA9IGRldGFpbHMuUFRTS25vd24gfHwgIWRldGFpbHMubGl2ZTtcbiAgICBjb25zdCBpbml0U2VnbWVudERhdGEgPSAoX2ZyYWckaW5pdFNlZ21lbnQgPSBmcmFnLmluaXRTZWdtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2ZyYWckaW5pdFNlZ21lbnQuZGF0YTtcbiAgICBjb25zdCBhdWRpb0NvZGVjID0gdGhpcy5fZ2V0QXVkaW9Db2RlYyhjdXJyZW50TGV2ZWwpO1xuXG4gICAgLy8gdHJhbnNtdXggdGhlIE1QRUctVFMgZGF0YSB0byBJU08tQk1GRiBzZWdtZW50c1xuICAgIC8vIHRoaXMubG9nKGBUcmFuc211eGluZyAke2ZyYWcuc259IG9mIFske2RldGFpbHMuc3RhcnRTTn0gLCR7ZGV0YWlscy5lbmRTTn1dLGxldmVsICR7ZnJhZy5sZXZlbH0sIGNjICR7ZnJhZy5jY31gKTtcbiAgICBjb25zdCB0cmFuc211eGVyID0gdGhpcy50cmFuc211eGVyID0gdGhpcy50cmFuc211eGVyIHx8IG5ldyBUcmFuc211eGVySW50ZXJmYWNlKHRoaXMuaGxzLCBQbGF5bGlzdExldmVsVHlwZS5NQUlOLCB0aGlzLl9oYW5kbGVUcmFuc211eENvbXBsZXRlLmJpbmQodGhpcyksIHRoaXMuX2hhbmRsZVRyYW5zbXV4ZXJGbHVzaC5iaW5kKHRoaXMpKTtcbiAgICBjb25zdCBwYXJ0SW5kZXggPSBwYXJ0ID8gcGFydC5pbmRleCA6IC0xO1xuICAgIGNvbnN0IHBhcnRpYWwgPSBwYXJ0SW5kZXggIT09IC0xO1xuICAgIGNvbnN0IGNodW5rTWV0YSA9IG5ldyBDaHVua01ldGFkYXRhKGZyYWcubGV2ZWwsIGZyYWcuc24sIGZyYWcuc3RhdHMuY2h1bmtDb3VudCwgcGF5bG9hZC5ieXRlTGVuZ3RoLCBwYXJ0SW5kZXgsIHBhcnRpYWwpO1xuICAgIGNvbnN0IGluaXRQVFMgPSB0aGlzLmluaXRQVFNbZnJhZy5jY107XG4gICAgdHJhbnNtdXhlci5wdXNoKHBheWxvYWQsIGluaXRTZWdtZW50RGF0YSwgYXVkaW9Db2RlYywgdmlkZW9Db2RlYywgZnJhZywgcGFydCwgZGV0YWlscy50b3RhbGR1cmF0aW9uLCBhY2N1cmF0ZVRpbWVPZmZzZXQsIGNodW5rTWV0YSwgaW5pdFBUUyk7XG4gIH1cbiAgb25BdWRpb1RyYWNrU3dpdGNoaW5nKGV2ZW50LCBkYXRhKSB7XG4gICAgLy8gaWYgYW55IFVSTCBmb3VuZCBvbiBuZXcgYXVkaW8gdHJhY2ssIGl0IGlzIGFuIGFsdGVybmF0ZSBhdWRpbyB0cmFja1xuICAgIGNvbnN0IGZyb21BbHRBdWRpbyA9IHRoaXMuYWx0QXVkaW87XG4gICAgY29uc3QgYWx0QXVkaW8gPSAhIWRhdGEudXJsO1xuICAgIC8vIGlmIHdlIHN3aXRjaCBvbiBtYWluIGF1ZGlvLCBlbnN1cmUgdGhhdCBtYWluIGZyYWdtZW50IHNjaGVkdWxpbmcgaXMgc3luY2VkIHdpdGggbWVkaWEuYnVmZmVyZWRcbiAgICAvLyBkb24ndCBkbyBhbnl0aGluZyBpZiB3ZSBzd2l0Y2ggdG8gYWx0IGF1ZGlvOiBhdWRpbyBzdHJlYW0gY29udHJvbGxlciBpcyBoYW5kbGluZyBpdC5cbiAgICAvLyB3ZSB3aWxsIGp1c3QgaGF2ZSB0byBjaGFuZ2UgYnVmZmVyIHNjaGVkdWxpbmcgb24gYXVkaW9UcmFja1N3aXRjaGVkXG4gICAgaWYgKCFhbHRBdWRpbykge1xuICAgICAgaWYgKHRoaXMubWVkaWFCdWZmZXIgIT09IHRoaXMubWVkaWEpIHtcbiAgICAgICAgdGhpcy5sb2coJ1N3aXRjaGluZyBvbiBtYWluIGF1ZGlvLCB1c2UgbWVkaWEuYnVmZmVyZWQgdG8gc2NoZWR1bGUgbWFpbiBmcmFnbWVudCBsb2FkaW5nJyk7XG4gICAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSB0aGlzLm1lZGlhO1xuICAgICAgICBjb25zdCBmcmFnQ3VycmVudCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gcmVmaWxsIGF1ZGlvIGJ1ZmZlciBmcm9tIG1haW46IGNhbmNlbCBhbnkgZnJhZyBsb2FkaW5nIHRvIHNwZWVkIHVwIGF1ZGlvIHN3aXRjaFxuICAgICAgICBpZiAoZnJhZ0N1cnJlbnQpIHtcbiAgICAgICAgICB0aGlzLmxvZygnU3dpdGNoaW5nIHRvIG1haW4gYXVkaW8gdHJhY2ssIGNhbmNlbCBtYWluIGZyYWdtZW50IGxvYWQnKTtcbiAgICAgICAgICBmcmFnQ3VycmVudC5hYm9ydFJlcXVlc3RzKCk7XG4gICAgICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZnJhZ0N1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRlc3Ryb3kgdHJhbnNtdXhlciB0byBmb3JjZSBpbml0IHNlZ21lbnQgZ2VuZXJhdGlvbiAoZm9sbG93aW5nIGF1ZGlvIHN3aXRjaClcbiAgICAgICAgdGhpcy5yZXNldFRyYW5zbXV4ZXIoKTtcbiAgICAgICAgLy8gc3dpdGNoIHRvIElETEUgc3RhdGUgdG8gbG9hZCBuZXcgZnJhZ21lbnRcbiAgICAgICAgdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmF1ZGlvT25seSkge1xuICAgICAgICAvLyBSZXNldCBhdWRpbyB0cmFuc211eGVyIHNvIHdoZW4gc3dpdGNoaW5nIGJhY2sgdG8gbWFpbiBhdWRpbyB3ZSdyZSBub3Qgc3RpbGwgYXBwZW5kaW5nIHdoZXJlIHdlIGxlZnQgb2ZmXG4gICAgICAgIHRoaXMucmVzZXRUcmFuc211eGVyKCk7XG4gICAgICB9XG4gICAgICBjb25zdCBobHMgPSB0aGlzLmhscztcbiAgICAgIC8vIElmIHN3aXRjaGluZyBmcm9tIGFsdCB0byBtYWluIGF1ZGlvLCBmbHVzaCBhbGwgYXVkaW8gYW5kIHRyaWdnZXIgdHJhY2sgc3dpdGNoZWRcbiAgICAgIGlmIChmcm9tQWx0QXVkaW8pIHtcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkJVRkZFUl9GTFVTSElORywge1xuICAgICAgICAgIHN0YXJ0T2Zmc2V0OiAwLFxuICAgICAgICAgIGVuZE9mZnNldDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgICAgICAgIHR5cGU6IG51bGxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUFsbEZyYWdtZW50cygpO1xuICAgICAgfVxuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkFVRElPX1RSQUNLX1NXSVRDSEVELCBkYXRhKTtcbiAgICB9XG4gIH1cbiAgb25BdWRpb1RyYWNrU3dpdGNoZWQoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCB0cmFja0lkID0gZGF0YS5pZDtcbiAgICBjb25zdCBhbHRBdWRpbyA9ICEhdGhpcy5obHMuYXVkaW9UcmFja3NbdHJhY2tJZF0udXJsO1xuICAgIGlmIChhbHRBdWRpbykge1xuICAgICAgY29uc3QgdmlkZW9CdWZmZXIgPSB0aGlzLnZpZGVvQnVmZmVyO1xuICAgICAgLy8gaWYgd2Ugc3dpdGNoZWQgb24gYWx0ZXJuYXRlIGF1ZGlvLCBlbnN1cmUgdGhhdCBtYWluIGZyYWdtZW50IHNjaGVkdWxpbmcgaXMgc3luY2VkIHdpdGggdmlkZW8gc291cmNlYnVmZmVyIGJ1ZmZlcmVkXG4gICAgICBpZiAodmlkZW9CdWZmZXIgJiYgdGhpcy5tZWRpYUJ1ZmZlciAhPT0gdmlkZW9CdWZmZXIpIHtcbiAgICAgICAgdGhpcy5sb2coJ1N3aXRjaGluZyBvbiBhbHRlcm5hdGUgYXVkaW8sIHVzZSB2aWRlby5idWZmZXJlZCB0byBzY2hlZHVsZSBtYWluIGZyYWdtZW50IGxvYWRpbmcnKTtcbiAgICAgICAgdGhpcy5tZWRpYUJ1ZmZlciA9IHZpZGVvQnVmZmVyO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmFsdEF1ZGlvID0gYWx0QXVkaW87XG4gICAgdGhpcy50aWNrKCk7XG4gIH1cbiAgb25CdWZmZXJDcmVhdGVkKGV2ZW50LCBkYXRhKSB7XG4gICAgY29uc3QgdHJhY2tzID0gZGF0YS50cmFja3M7XG4gICAgbGV0IG1lZGlhVHJhY2s7XG4gICAgbGV0IG5hbWU7XG4gICAgbGV0IGFsdGVybmF0ZSA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgdHlwZSBpbiB0cmFja3MpIHtcbiAgICAgIGNvbnN0IHRyYWNrID0gdHJhY2tzW3R5cGVdO1xuICAgICAgaWYgKHRyYWNrLmlkID09PSAnbWFpbicpIHtcbiAgICAgICAgbmFtZSA9IHR5cGU7XG4gICAgICAgIG1lZGlhVHJhY2sgPSB0cmFjaztcbiAgICAgICAgLy8ga2VlcCB2aWRlbyBzb3VyY2UgYnVmZmVyIHJlZmVyZW5jZVxuICAgICAgICBpZiAodHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgICAgIGNvbnN0IHZpZGVvVHJhY2sgPSB0cmFja3NbdHlwZV07XG4gICAgICAgICAgaWYgKHZpZGVvVHJhY2spIHtcbiAgICAgICAgICAgIHRoaXMudmlkZW9CdWZmZXIgPSB2aWRlb1RyYWNrLmJ1ZmZlcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsdGVybmF0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhbHRlcm5hdGUgJiYgbWVkaWFUcmFjaykge1xuICAgICAgdGhpcy5sb2coYEFsdGVybmF0ZSB0cmFjayBmb3VuZCwgdXNlICR7bmFtZX0uYnVmZmVyZWQgdG8gc2NoZWR1bGUgbWFpbiBmcmFnbWVudCBsb2FkaW5nYCk7XG4gICAgICB0aGlzLm1lZGlhQnVmZmVyID0gbWVkaWFUcmFjay5idWZmZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWVkaWFCdWZmZXIgPSB0aGlzLm1lZGlhO1xuICAgIH1cbiAgfVxuICBvbkZyYWdCdWZmZXJlZChldmVudCwgZGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGZyYWcsXG4gICAgICBwYXJ0XG4gICAgfSA9IGRhdGE7XG4gICAgaWYgKGZyYWcgJiYgZnJhZy50eXBlICE9PSBQbGF5bGlzdExldmVsVHlwZS5NQUlOKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSkge1xuICAgICAgLy8gSWYgYSBsZXZlbCBzd2l0Y2ggd2FzIHJlcXVlc3RlZCB3aGlsZSBhIGZyYWdtZW50IHdhcyBidWZmZXJpbmcsIGl0IHdpbGwgZW1pdCB0aGUgRlJBR19CVUZGRVJFRCBldmVudCB1cG9uIGNvbXBsZXRpb25cbiAgICAgIC8vIEF2b2lkIHNldHRpbmcgc3RhdGUgYmFjayB0byBJRExFLCBzaW5jZSB0aGF0IHdpbGwgaW50ZXJmZXJlIHdpdGggYSBsZXZlbCBzd2l0Y2hcbiAgICAgIHRoaXMud2FybihgRnJhZ21lbnQgJHtmcmFnLnNufSR7cGFydCA/ICcgcDogJyArIHBhcnQuaW5kZXggOiAnJ30gb2YgbGV2ZWwgJHtmcmFnLmxldmVsfSBmaW5pc2hlZCBidWZmZXJpbmcsIGJ1dCB3YXMgYWJvcnRlZC4gc3RhdGU6ICR7dGhpcy5zdGF0ZX1gKTtcbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5QQVJTRUQpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0YXRzID0gcGFydCA/IHBhcnQuc3RhdHMgOiBmcmFnLnN0YXRzO1xuICAgIHRoaXMuZnJhZ0xhc3RLYnBzID0gTWF0aC5yb3VuZCg4ICogc3RhdHMudG90YWwgLyAoc3RhdHMuYnVmZmVyaW5nLmVuZCAtIHN0YXRzLmxvYWRpbmcuZmlyc3QpKTtcbiAgICBpZiAoZnJhZy5zbiAhPT0gJ2luaXRTZWdtZW50Jykge1xuICAgICAgdGhpcy5mcmFnUHJldmlvdXMgPSBmcmFnO1xuICAgIH1cbiAgICB0aGlzLmZyYWdCdWZmZXJlZENvbXBsZXRlKGZyYWcsIHBhcnQpO1xuICB9XG4gIG9uRXJyb3IoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgX2RhdGEkY29udGV4dDtcbiAgICBpZiAoZGF0YS5mYXRhbCkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLkVSUk9SO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzd2l0Y2ggKGRhdGEuZGV0YWlscykge1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuRlJBR19HQVA6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX1BBUlNJTkdfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0RFQ1JZUFRfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5GUkFHX0xPQURfVElNRU9VVDpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLktFWV9MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuS0VZX0xPQURfVElNRU9VVDpcbiAgICAgICAgdGhpcy5vbkZyYWdtZW50T3JLZXlMb2FkRXJyb3IoUGxheWxpc3RMZXZlbFR5cGUuTUFJTiwgZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuTEVWRUxfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX0xPQURfVElNRU9VVDpcbiAgICAgIGNhc2UgRXJyb3JEZXRhaWxzLkxFVkVMX1BBUlNJTkdfRVJST1I6XG4gICAgICAgIC8vIGluIGNhc2Ugb2Ygbm9uIGZhdGFsIGVycm9yIHdoaWxlIGxvYWRpbmcgbGV2ZWwsIGlmIGxldmVsIGNvbnRyb2xsZXIgaXMgbm90IHJldHJ5aW5nIHRvIGxvYWQgbGV2ZWwsIHN3aXRjaCBiYWNrIHRvIElETEVcbiAgICAgICAgaWYgKCFkYXRhLmxldmVsUmV0cnkgJiYgdGhpcy5zdGF0ZSA9PT0gU3RhdGUuV0FJVElOR19MRVZFTCAmJiAoKF9kYXRhJGNvbnRleHQgPSBkYXRhLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YSRjb250ZXh0LnR5cGUpID09PSBQbGF5bGlzdENvbnRleHRUeXBlLkxFVkVMKSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLklETEU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVycm9yRGV0YWlscy5CVUZGRVJfQVBQRU5EX0VSUk9SOlxuICAgICAgY2FzZSBFcnJvckRldGFpbHMuQlVGRkVSX0ZVTExfRVJST1I6XG4gICAgICAgIGlmICghZGF0YS5wYXJlbnQgfHwgZGF0YS5wYXJlbnQgIT09ICdtYWluJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5kZXRhaWxzID09PSBFcnJvckRldGFpbHMuQlVGRkVSX0FQUEVORF9FUlJPUikge1xuICAgICAgICAgIHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVkdWNlTGVuZ3RoQW5kRmx1c2hCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgICB0aGlzLmZsdXNoTWFpbkJ1ZmZlcigwLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFcnJvckRldGFpbHMuSU5URVJOQUxfRVhDRVBUSU9OOlxuICAgICAgICB0aGlzLnJlY292ZXJXb3JrZXJFcnJvcihkYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hlY2tzIHRoZSBoZWFsdGggb2YgdGhlIGJ1ZmZlciBhbmQgYXR0ZW1wdHMgdG8gcmVzb2x2ZSBwbGF5YmFjayBzdGFsbHMuXG4gIGNoZWNrQnVmZmVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1lZGlhLFxuICAgICAgZ2FwQ29udHJvbGxlclxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghbWVkaWEgfHwgIWdhcENvbnRyb2xsZXIgfHwgIW1lZGlhLnJlYWR5U3RhdGUpIHtcbiAgICAgIC8vIEV4aXQgZWFybHkgaWYgd2UgZG9uJ3QgaGF2ZSBtZWRpYSBvciBpZiB0aGUgbWVkaWEgaGFzbid0IGJ1ZmZlcmVkIGFueXRoaW5nIHlldCAocmVhZHlTdGF0ZSAwKVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5sb2FkZWRtZXRhZGF0YSB8fCAhQnVmZmVySGVscGVyLmdldEJ1ZmZlcmVkKG1lZGlhKS5sZW5ndGgpIHtcbiAgICAgIC8vIFJlc29sdmUgZ2FwcyB1c2luZyB0aGUgbWFpbiBidWZmZXIsIHdob3NlIHJhbmdlcyBhcmUgdGhlIGludGVyc2VjdGlvbnMgb2YgdGhlIEEvViBzb3VyY2VidWZmZXJzXG4gICAgICBjb25zdCBhY3RpdmVGcmFnID0gdGhpcy5zdGF0ZSAhPT0gU3RhdGUuSURMRSA/IHRoaXMuZnJhZ0N1cnJlbnQgOiBudWxsO1xuICAgICAgZ2FwQ29udHJvbGxlci5wb2xsKHRoaXMubGFzdEN1cnJlbnRUaW1lLCBhY3RpdmVGcmFnKTtcbiAgICB9XG4gICAgdGhpcy5sYXN0Q3VycmVudFRpbWUgPSBtZWRpYS5jdXJyZW50VGltZTtcbiAgfVxuICBvbkZyYWdMb2FkRW1lcmdlbmN5QWJvcnRlZCgpIHtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgICAvLyBpZiBsb2FkZWRtZXRhZGF0YSBpcyBub3Qgc2V0LCBpdCBtZWFucyB0aGF0IHdlIGFyZSBlbWVyZ2VuY3kgc3dpdGNoIGRvd24gb24gZmlyc3QgZnJhZ1xuICAgIC8vIGluIHRoYXQgY2FzZSwgcmVzZXQgc3RhcnRGcmFnUmVxdWVzdGVkIGZsYWdcbiAgICBpZiAoIXRoaXMubG9hZGVkbWV0YWRhdGEpIHtcbiAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSB0aGlzLnN0YXJ0UG9zaXRpb247XG4gICAgfVxuICAgIHRoaXMudGlja0ltbWVkaWF0ZSgpO1xuICB9XG4gIG9uQnVmZmVyRmx1c2hlZChldmVudCwge1xuICAgIHR5cGVcbiAgfSkge1xuICAgIGlmICh0eXBlICE9PSBFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU8gfHwgdGhpcy5hdWRpb09ubHkgJiYgIXRoaXMuYWx0QXVkaW8pIHtcbiAgICAgIGNvbnN0IG1lZGlhQnVmZmVyID0gKHR5cGUgPT09IEVsZW1lbnRhcnlTdHJlYW1UeXBlcy5WSURFTyA/IHRoaXMudmlkZW9CdWZmZXIgOiB0aGlzLm1lZGlhQnVmZmVyKSB8fCB0aGlzLm1lZGlhO1xuICAgICAgdGhpcy5hZnRlckJ1ZmZlckZsdXNoZWQobWVkaWFCdWZmZXIsIHR5cGUsIFBsYXlsaXN0TGV2ZWxUeXBlLk1BSU4pO1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgfVxuICB9XG4gIG9uTGV2ZWxzVXBkYXRlZChldmVudCwgZGF0YSkge1xuICAgIGlmICh0aGlzLmxldmVsID4gLTEgJiYgdGhpcy5mcmFnQ3VycmVudCkge1xuICAgICAgdGhpcy5sZXZlbCA9IHRoaXMuZnJhZ0N1cnJlbnQubGV2ZWw7XG4gICAgfVxuICAgIHRoaXMubGV2ZWxzID0gZGF0YS5sZXZlbHM7XG4gIH1cbiAgc3dhcEF1ZGlvQ29kZWMoKSB7XG4gICAgdGhpcy5hdWRpb0NvZGVjU3dhcCA9ICF0aGlzLmF1ZGlvQ29kZWNTd2FwO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlZWtzIHRvIHRoZSBzZXQgc3RhcnRQb3NpdGlvbiBpZiBub3QgZXF1YWwgdG8gdGhlIG1lZGlhRWxlbWVudCdzIGN1cnJlbnQgdGltZS5cbiAgICovXG4gIHNlZWtUb1N0YXJ0UG9zKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1lZGlhXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFtZWRpYSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgIGxldCBzdGFydFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uO1xuICAgIC8vIG9ubHkgYWRqdXN0IGN1cnJlbnRUaW1lIGlmIGRpZmZlcmVudCBmcm9tIHN0YXJ0UG9zaXRpb24gb3IgaWYgc3RhcnRQb3NpdGlvbiBub3QgYnVmZmVyZWRcbiAgICAvLyBhdCB0aGF0IHN0YWdlLCB0aGVyZSBzaG91bGQgYmUgb25seSBvbmUgYnVmZmVyZWQgcmFuZ2UsIGFzIHdlIHJlYWNoIHRoYXQgY29kZSBhZnRlciBmaXJzdCBmcmFnbWVudCBoYXMgYmVlbiBidWZmZXJlZFxuICAgIGlmIChzdGFydFBvc2l0aW9uID49IDAgJiYgY3VycmVudFRpbWUgPCBzdGFydFBvc2l0aW9uKSB7XG4gICAgICBpZiAobWVkaWEuc2Vla2luZykge1xuICAgICAgICB0aGlzLmxvZyhgY291bGQgbm90IHNlZWsgdG8gJHtzdGFydFBvc2l0aW9ufSwgYWxyZWFkeSBzZWVraW5nIGF0ICR7Y3VycmVudFRpbWV9YCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJ1ZmZlcmVkID0gQnVmZmVySGVscGVyLmdldEJ1ZmZlcmVkKG1lZGlhKTtcbiAgICAgIGNvbnN0IGJ1ZmZlclN0YXJ0ID0gYnVmZmVyZWQubGVuZ3RoID8gYnVmZmVyZWQuc3RhcnQoMCkgOiAwO1xuICAgICAgY29uc3QgZGVsdGEgPSBidWZmZXJTdGFydCAtIHN0YXJ0UG9zaXRpb247XG4gICAgICBpZiAoZGVsdGEgPiAwICYmIChkZWx0YSA8IHRoaXMuY29uZmlnLm1heEJ1ZmZlckhvbGUgfHwgZGVsdGEgPCB0aGlzLmNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlKSkge1xuICAgICAgICB0aGlzLmxvZyhgYWRqdXN0aW5nIHN0YXJ0IHBvc2l0aW9uIGJ5ICR7ZGVsdGF9IHRvIG1hdGNoIGJ1ZmZlciBzdGFydGApO1xuICAgICAgICBzdGFydFBvc2l0aW9uICs9IGRlbHRhO1xuICAgICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBzdGFydFBvc2l0aW9uO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2coYHNlZWsgdG8gdGFyZ2V0IHN0YXJ0IHBvc2l0aW9uICR7c3RhcnRQb3NpdGlvbn0gZnJvbSBjdXJyZW50IHRpbWUgJHtjdXJyZW50VGltZX1gKTtcbiAgICAgIG1lZGlhLmN1cnJlbnRUaW1lID0gc3RhcnRQb3NpdGlvbjtcbiAgICB9XG4gIH1cbiAgX2dldEF1ZGlvQ29kZWMoY3VycmVudExldmVsKSB7XG4gICAgbGV0IGF1ZGlvQ29kZWMgPSB0aGlzLmNvbmZpZy5kZWZhdWx0QXVkaW9Db2RlYyB8fCBjdXJyZW50TGV2ZWwuYXVkaW9Db2RlYztcbiAgICBpZiAodGhpcy5hdWRpb0NvZGVjU3dhcCAmJiBhdWRpb0NvZGVjKSB7XG4gICAgICB0aGlzLmxvZygnU3dhcHBpbmcgYXVkaW8gY29kZWMnKTtcbiAgICAgIGlmIChhdWRpb0NvZGVjLmluZGV4T2YoJ21wNGEuNDAuNScpICE9PSAtMSkge1xuICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuMic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuNSc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhdWRpb0NvZGVjO1xuICB9XG4gIF9sb2FkQml0cmF0ZVRlc3RGcmFnKGZyYWcsIGxldmVsKSB7XG4gICAgZnJhZy5iaXRyYXRlVGVzdCA9IHRydWU7XG4gICAgdGhpcy5fZG9GcmFnTG9hZChmcmFnLCBsZXZlbCkudGhlbihkYXRhID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaGxzXG4gICAgICB9ID0gdGhpcztcbiAgICAgIGlmICghZGF0YSB8fCB0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChmcmFnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXZlbC5mcmFnbWVudEVycm9yID0gMDtcbiAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JRExFO1xuICAgICAgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuYml0cmF0ZVRlc3QgPSBmYWxzZTtcbiAgICAgIGNvbnN0IHN0YXRzID0gZnJhZy5zdGF0cztcbiAgICAgIC8vIEJpdHJhdGUgdGVzdHMgZnJhZ21lbnRzIGFyZSBuZWl0aGVyIHBhcnNlZCBub3IgYnVmZmVyZWRcbiAgICAgIHN0YXRzLnBhcnNpbmcuc3RhcnQgPSBzdGF0cy5wYXJzaW5nLmVuZCA9IHN0YXRzLmJ1ZmZlcmluZy5zdGFydCA9IHN0YXRzLmJ1ZmZlcmluZy5lbmQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfTE9BREVELCBkYXRhKTtcbiAgICAgIGZyYWcuYml0cmF0ZVRlc3QgPSBmYWxzZTtcbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlVHJhbnNtdXhDb21wbGV0ZSh0cmFuc211eFJlc3VsdCkge1xuICAgIHZhciBfaWQzJHNhbXBsZXM7XG4gICAgY29uc3QgaWQgPSAnbWFpbic7XG4gICAgY29uc3Qge1xuICAgICAgaGxzXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgcmVtdXhSZXN1bHQsXG4gICAgICBjaHVua01ldGFcbiAgICB9ID0gdHJhbnNtdXhSZXN1bHQ7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuZ2V0Q3VycmVudENvbnRleHQoY2h1bmtNZXRhKTtcbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgIHRoaXMucmVzZXRXaGVuTWlzc2luZ0NvbnRleHQoY2h1bmtNZXRhKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgZnJhZyxcbiAgICAgIHBhcnQsXG4gICAgICBsZXZlbFxuICAgIH0gPSBjb250ZXh0O1xuICAgIGNvbnN0IHtcbiAgICAgIHZpZGVvLFxuICAgICAgdGV4dCxcbiAgICAgIGlkMyxcbiAgICAgIGluaXRTZWdtZW50XG4gICAgfSA9IHJlbXV4UmVzdWx0O1xuICAgIGNvbnN0IHtcbiAgICAgIGRldGFpbHNcbiAgICB9ID0gbGV2ZWw7XG4gICAgLy8gVGhlIGF1ZGlvLXN0cmVhbS1jb250cm9sbGVyIGhhbmRsZXMgYXVkaW8gYnVmZmVyaW5nIGlmIEhscy5qcyBpcyBwbGF5aW5nIGFuIGFsdGVybmF0ZSBhdWRpbyB0cmFja1xuICAgIGNvbnN0IGF1ZGlvID0gdGhpcy5hbHRBdWRpbyA/IHVuZGVmaW5lZCA6IHJlbXV4UmVzdWx0LmF1ZGlvO1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIGN1cnJlbnQgZnJhZ21lbnQgaGFzIGJlZW4gYWJvcnRlZC4gV2UgY2hlY2sgdGhpcyBieSBmaXJzdCBzZWVpbmcgaWYgd2UncmUgc3RpbGwgcGxheWluZyB0aGUgY3VycmVudCBsZXZlbC5cbiAgICAvLyBJZiB3ZSBhcmUsIHN1YnNlcXVlbnRseSBjaGVjayBpZiB0aGUgY3VycmVudGx5IGxvYWRpbmcgZnJhZ21lbnQgKGZyYWdDdXJyZW50KSBoYXMgY2hhbmdlZC5cbiAgICBpZiAodGhpcy5mcmFnQ29udGV4dENoYW5nZWQoZnJhZykpIHtcbiAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGZyYWcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuUEFSU0lORztcbiAgICBpZiAoaW5pdFNlZ21lbnQpIHtcbiAgICAgIGlmIChpbml0U2VnbWVudCAhPSBudWxsICYmIGluaXRTZWdtZW50LnRyYWNrcykge1xuICAgICAgICBjb25zdCBtYXBGcmFnbWVudCA9IGZyYWcuaW5pdFNlZ21lbnQgfHwgZnJhZztcbiAgICAgICAgdGhpcy5fYnVmZmVySW5pdFNlZ21lbnQobGV2ZWwsIGluaXRTZWdtZW50LnRyYWNrcywgbWFwRnJhZ21lbnQsIGNodW5rTWV0YSk7XG4gICAgICAgIGhscy50cmlnZ2VyKEV2ZW50cy5GUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5ULCB7XG4gICAgICAgICAgZnJhZzogbWFwRnJhZ21lbnQsXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgdHJhY2tzOiBpbml0U2VnbWVudC50cmFja3NcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoaXMgd291bGQgYmUgbmljZSBpZiBOdW1iZXIuaXNGaW5pdGUgYWN0ZWQgYXMgYSB0eXBlZ3VhcmQsIGJ1dCBpdCBkb2Vzbid0LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMTAwMzhcbiAgICAgIGNvbnN0IGluaXRQVFMgPSBpbml0U2VnbWVudC5pbml0UFRTO1xuICAgICAgY29uc3QgdGltZXNjYWxlID0gaW5pdFNlZ21lbnQudGltZXNjYWxlO1xuICAgICAgaWYgKGlzRmluaXRlTnVtYmVyKGluaXRQVFMpKSB7XG4gICAgICAgIHRoaXMuaW5pdFBUU1tmcmFnLmNjXSA9IHtcbiAgICAgICAgICBiYXNlVGltZTogaW5pdFBUUyxcbiAgICAgICAgICB0aW1lc2NhbGVcbiAgICAgICAgfTtcbiAgICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLklOSVRfUFRTX0ZPVU5ELCB7XG4gICAgICAgICAgZnJhZyxcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBpbml0UFRTLFxuICAgICAgICAgIHRpbWVzY2FsZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBdm9pZCBidWZmZXJpbmcgaWYgYmFja3RyYWNraW5nIHRoaXMgZnJhZ21lbnRcbiAgICBpZiAodmlkZW8gJiYgZGV0YWlscyAmJiBmcmFnLnNuICE9PSAnaW5pdFNlZ21lbnQnKSB7XG4gICAgICBjb25zdCBwcmV2RnJhZyA9IGRldGFpbHMuZnJhZ21lbnRzW2ZyYWcuc24gLSAxIC0gZGV0YWlscy5zdGFydFNOXTtcbiAgICAgIGNvbnN0IGlzRmlyc3RGcmFnbWVudCA9IGZyYWcuc24gPT09IGRldGFpbHMuc3RhcnRTTjtcbiAgICAgIGNvbnN0IGlzRmlyc3RJbkRpc2NvbnRpbnVpdHkgPSAhcHJldkZyYWcgfHwgZnJhZy5jYyA+IHByZXZGcmFnLmNjO1xuICAgICAgaWYgKHJlbXV4UmVzdWx0LmluZGVwZW5kZW50ICE9PSBmYWxzZSkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgc3RhcnRQVFMsXG4gICAgICAgICAgZW5kUFRTLFxuICAgICAgICAgIHN0YXJ0RFRTLFxuICAgICAgICAgIGVuZERUU1xuICAgICAgICB9ID0gdmlkZW87XG4gICAgICAgIGlmIChwYXJ0KSB7XG4gICAgICAgICAgcGFydC5lbGVtZW50YXJ5U3RyZWFtc1t2aWRlby50eXBlXSA9IHtcbiAgICAgICAgICAgIHN0YXJ0UFRTLFxuICAgICAgICAgICAgZW5kUFRTLFxuICAgICAgICAgICAgc3RhcnREVFMsXG4gICAgICAgICAgICBlbmREVFNcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh2aWRlby5maXJzdEtleUZyYW1lICYmIHZpZGVvLmluZGVwZW5kZW50ICYmIGNodW5rTWV0YS5pZCA9PT0gMSAmJiAhaXNGaXJzdEluRGlzY29udGludWl0eSkge1xuICAgICAgICAgICAgdGhpcy5jb3VsZEJhY2t0cmFjayA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2aWRlby5kcm9wcGVkICYmIHZpZGVvLmluZGVwZW5kZW50KSB7XG4gICAgICAgICAgICAvLyBCYWNrdHJhY2sgaWYgZHJvcHBlZCBmcmFtZXMgY3JlYXRlIGEgZ2FwIGFmdGVyIGN1cnJlbnRUaW1lXG5cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlckluZm8gPSB0aGlzLmdldE1haW5Gd2RCdWZmZXJJbmZvKCk7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRCdWZmZXJUaW1lID0gKGJ1ZmZlckluZm8gPyBidWZmZXJJbmZvLmVuZCA6IHRoaXMuZ2V0TG9hZFBvc2l0aW9uKCkpICsgdGhpcy5jb25maWcubWF4QnVmZmVySG9sZTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHZpZGVvLmZpcnN0S2V5RnJhbWVQVFMgPyB2aWRlby5maXJzdEtleUZyYW1lUFRTIDogc3RhcnRQVFM7XG4gICAgICAgICAgICBpZiAoIWlzRmlyc3RGcmFnbWVudCAmJiB0YXJnZXRCdWZmZXJUaW1lIDwgc3RhcnRUaW1lIC0gdGhpcy5jb25maWcubWF4QnVmZmVySG9sZSAmJiAhaXNGaXJzdEluRGlzY29udGludWl0eSkge1xuICAgICAgICAgICAgICB0aGlzLmJhY2t0cmFjayhmcmFnKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0ZpcnN0SW5EaXNjb250aW51aXR5KSB7XG4gICAgICAgICAgICAgIC8vIE1hcmsgc2VnbWVudCB3aXRoIGEgZ2FwIHRvIGF2b2lkIGxvb3AgbG9hZGluZ1xuICAgICAgICAgICAgICBmcmFnLmdhcCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZXQgdmlkZW8gc3RyZWFtIHN0YXJ0IHRvIGZyYWdtZW50IHN0YXJ0IHNvIHRoYXQgdHJ1bmNhdGVkIHNhbXBsZXMgZG8gbm90IGRpc3RvcnQgdGhlIHRpbWVsaW5lLCBhbmQgbWFyayBpdCBwYXJ0aWFsXG4gICAgICAgICAgICBmcmFnLnNldEVsZW1lbnRhcnlTdHJlYW1JbmZvKHZpZGVvLnR5cGUsIGZyYWcuc3RhcnQsIGVuZFBUUywgZnJhZy5zdGFydCwgZW5kRFRTLCB0cnVlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzRmlyc3RGcmFnbWVudCAmJiBzdGFydFBUUyA+IE1BWF9TVEFSVF9HQVBfSlVNUCkge1xuICAgICAgICAgICAgLy8gTWFyayBzZWdtZW50IHdpdGggYSBnYXAgdG8gc2tpcCBsYXJnZSBzdGFydCBnYXBcbiAgICAgICAgICAgIGZyYWcuZ2FwID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnJhZy5zZXRFbGVtZW50YXJ5U3RyZWFtSW5mbyh2aWRlby50eXBlLCBzdGFydFBUUywgZW5kUFRTLCBzdGFydERUUywgZW5kRFRTKTtcbiAgICAgICAgaWYgKHRoaXMuYmFja3RyYWNrRnJhZ21lbnQpIHtcbiAgICAgICAgICB0aGlzLmJhY2t0cmFja0ZyYWdtZW50ID0gZnJhZztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ1ZmZlckZyYWdtZW50RGF0YSh2aWRlbywgZnJhZywgcGFydCwgY2h1bmtNZXRhLCBpc0ZpcnN0RnJhZ21lbnQgfHwgaXNGaXJzdEluRGlzY29udGludWl0eSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRmlyc3RGcmFnbWVudCB8fCBpc0ZpcnN0SW5EaXNjb250aW51aXR5KSB7XG4gICAgICAgIC8vIE1hcmsgc2VnbWVudCB3aXRoIGEgZ2FwIHRvIGF2b2lkIGxvb3AgbG9hZGluZ1xuICAgICAgICBmcmFnLmdhcCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJhY2t0cmFjayhmcmFnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYXVkaW8pIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3RhcnRQVFMsXG4gICAgICAgIGVuZFBUUyxcbiAgICAgICAgc3RhcnREVFMsXG4gICAgICAgIGVuZERUU1xuICAgICAgfSA9IGF1ZGlvO1xuICAgICAgaWYgKHBhcnQpIHtcbiAgICAgICAgcGFydC5lbGVtZW50YXJ5U3RyZWFtc1tFbGVtZW50YXJ5U3RyZWFtVHlwZXMuQVVESU9dID0ge1xuICAgICAgICAgIHN0YXJ0UFRTLFxuICAgICAgICAgIGVuZFBUUyxcbiAgICAgICAgICBzdGFydERUUyxcbiAgICAgICAgICBlbmREVFNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGZyYWcuc2V0RWxlbWVudGFyeVN0cmVhbUluZm8oRWxlbWVudGFyeVN0cmVhbVR5cGVzLkFVRElPLCBzdGFydFBUUywgZW5kUFRTLCBzdGFydERUUywgZW5kRFRTKTtcbiAgICAgIHRoaXMuYnVmZmVyRnJhZ21lbnREYXRhKGF1ZGlvLCBmcmFnLCBwYXJ0LCBjaHVua01ldGEpO1xuICAgIH1cbiAgICBpZiAoZGV0YWlscyAmJiBpZDMgIT0gbnVsbCAmJiAoX2lkMyRzYW1wbGVzID0gaWQzLnNhbXBsZXMpICE9IG51bGwgJiYgX2lkMyRzYW1wbGVzLmxlbmd0aCkge1xuICAgICAgY29uc3QgZW1pdHRlZElEMyA9IHtcbiAgICAgICAgaWQsXG4gICAgICAgIGZyYWcsXG4gICAgICAgIGRldGFpbHMsXG4gICAgICAgIHNhbXBsZXM6IGlkMy5zYW1wbGVzXG4gICAgICB9O1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfUEFSU0lOR19NRVRBREFUQSwgZW1pdHRlZElEMyk7XG4gICAgfVxuICAgIGlmIChkZXRhaWxzICYmIHRleHQpIHtcbiAgICAgIGNvbnN0IGVtaXR0ZWRUZXh0ID0ge1xuICAgICAgICBpZCxcbiAgICAgICAgZnJhZyxcbiAgICAgICAgZGV0YWlscyxcbiAgICAgICAgc2FtcGxlczogdGV4dC5zYW1wbGVzXG4gICAgICB9O1xuICAgICAgaGxzLnRyaWdnZXIoRXZlbnRzLkZSQUdfUEFSU0lOR19VU0VSREFUQSwgZW1pdHRlZFRleHQpO1xuICAgIH1cbiAgfVxuICBfYnVmZmVySW5pdFNlZ21lbnQoY3VycmVudExldmVsLCB0cmFja3MsIGZyYWcsIGNodW5rTWV0YSkge1xuICAgIGlmICh0aGlzLnN0YXRlICE9PSBTdGF0ZS5QQVJTSU5HKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYXVkaW9Pbmx5ID0gISF0cmFja3MuYXVkaW8gJiYgIXRyYWNrcy52aWRlbztcblxuICAgIC8vIGlmIGF1ZGlvIHRyYWNrIGlzIGV4cGVjdGVkIHRvIGNvbWUgZnJvbSBhdWRpbyBzdHJlYW0gY29udHJvbGxlciwgZGlzY2FyZCBhbnkgY29taW5nIGZyb20gbWFpblxuICAgIGlmICh0aGlzLmFsdEF1ZGlvICYmICF0aGlzLmF1ZGlvT25seSkge1xuICAgICAgZGVsZXRlIHRyYWNrcy5hdWRpbztcbiAgICB9XG4gICAgLy8gaW5jbHVkZSBsZXZlbENvZGVjIGluIGF1ZGlvIGFuZCB2aWRlbyB0cmFja3NcbiAgICBjb25zdCB7XG4gICAgICBhdWRpbyxcbiAgICAgIHZpZGVvLFxuICAgICAgYXVkaW92aWRlb1xuICAgIH0gPSB0cmFja3M7XG4gICAgaWYgKGF1ZGlvKSB7XG4gICAgICBsZXQgYXVkaW9Db2RlYyA9IGN1cnJlbnRMZXZlbC5hdWRpb0NvZGVjO1xuICAgICAgY29uc3QgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAodGhpcy5hdWRpb0NvZGVjU3dpdGNoKSB7XG4gICAgICAgIGlmIChhdWRpb0NvZGVjKSB7XG4gICAgICAgICAgaWYgKGF1ZGlvQ29kZWMuaW5kZXhPZignbXA0YS40MC41JykgIT09IC0xKSB7XG4gICAgICAgICAgICBhdWRpb0NvZGVjID0gJ21wNGEuNDAuMic7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC41JztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW4gdGhlIGNhc2UgdGhhdCBBQUMgYW5kIEhFLUFBQyBhdWRpbyBjb2RlY3MgYXJlIHNpZ25hbGxlZCBpbiBtYW5pZmVzdCxcbiAgICAgICAgLy8gZm9yY2UgSEUtQUFDLCBhcyBpdCBzZWVtcyB0aGF0IG1vc3QgYnJvd3NlcnMgcHJlZmVycyBpdC5cbiAgICAgICAgLy8gZG9uJ3QgZm9yY2UgSEUtQUFDIGlmIG1vbm8gc3RyZWFtLCBvciBpbiBGaXJlZm94XG4gICAgICAgIGlmIChhdWRpby5tZXRhZGF0YS5jaGFubmVsQ291bnQgIT09IDEgJiYgdWEuaW5kZXhPZignZmlyZWZveCcpID09PSAtMSkge1xuICAgICAgICAgIGF1ZGlvQ29kZWMgPSAnbXA0YS40MC41JztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gSEUtQUFDIGlzIGJyb2tlbiBvbiBBbmRyb2lkLCBhbHdheXMgc2lnbmFsIGF1ZGlvIGNvZGVjIGFzIEFBQyBldmVuIGlmIHZhcmlhbnQgbWFuaWZlc3Qgc3RhdGVzIG90aGVyd2lzZVxuICAgICAgaWYgKGF1ZGlvQ29kZWMgJiYgYXVkaW9Db2RlYy5pbmRleE9mKCdtcDRhLjQwLjUnKSAhPT0gLTEgJiYgdWEuaW5kZXhPZignYW5kcm9pZCcpICE9PSAtMSAmJiBhdWRpby5jb250YWluZXIgIT09ICdhdWRpby9tcGVnJykge1xuICAgICAgICAvLyBFeGNsdWRlIG1wZWcgYXVkaW9cbiAgICAgICAgYXVkaW9Db2RlYyA9ICdtcDRhLjQwLjInO1xuICAgICAgICB0aGlzLmxvZyhgQW5kcm9pZDogZm9yY2UgYXVkaW8gY29kZWMgdG8gJHthdWRpb0NvZGVjfWApO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRMZXZlbC5hdWRpb0NvZGVjICYmIGN1cnJlbnRMZXZlbC5hdWRpb0NvZGVjICE9PSBhdWRpb0NvZGVjKSB7XG4gICAgICAgIHRoaXMubG9nKGBTd2FwcGluZyBtYW5pZmVzdCBhdWRpbyBjb2RlYyBcIiR7Y3VycmVudExldmVsLmF1ZGlvQ29kZWN9XCIgZm9yIFwiJHthdWRpb0NvZGVjfVwiYCk7XG4gICAgICB9XG4gICAgICBhdWRpby5sZXZlbENvZGVjID0gYXVkaW9Db2RlYztcbiAgICAgIGF1ZGlvLmlkID0gJ21haW4nO1xuICAgICAgdGhpcy5sb2coYEluaXQgYXVkaW8gYnVmZmVyLCBjb250YWluZXI6JHthdWRpby5jb250YWluZXJ9LCBjb2RlY3Nbc2VsZWN0ZWQvbGV2ZWwvcGFyc2VkXT1bJHthdWRpb0NvZGVjIHx8ICcnfS8ke2N1cnJlbnRMZXZlbC5hdWRpb0NvZGVjIHx8ICcnfS8ke2F1ZGlvLmNvZGVjfV1gKTtcbiAgICB9XG4gICAgaWYgKHZpZGVvKSB7XG4gICAgICB2aWRlby5sZXZlbENvZGVjID0gY3VycmVudExldmVsLnZpZGVvQ29kZWM7XG4gICAgICB2aWRlby5pZCA9ICdtYWluJztcbiAgICAgIHRoaXMubG9nKGBJbml0IHZpZGVvIGJ1ZmZlciwgY29udGFpbmVyOiR7dmlkZW8uY29udGFpbmVyfSwgY29kZWNzW2xldmVsL3BhcnNlZF09WyR7Y3VycmVudExldmVsLnZpZGVvQ29kZWMgfHwgJyd9LyR7dmlkZW8uY29kZWN9XWApO1xuICAgIH1cbiAgICBpZiAoYXVkaW92aWRlbykge1xuICAgICAgdGhpcy5sb2coYEluaXQgYXVkaW92aWRlbyBidWZmZXIsIGNvbnRhaW5lcjoke2F1ZGlvdmlkZW8uY29udGFpbmVyfSwgY29kZWNzW2xldmVsL3BhcnNlZF09WyR7Y3VycmVudExldmVsLmNvZGVjc30vJHthdWRpb3ZpZGVvLmNvZGVjfV1gKTtcbiAgICB9XG4gICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuQlVGRkVSX0NPREVDUywgdHJhY2tzKTtcbiAgICAvLyBsb29wIHRocm91Z2ggdHJhY2tzIHRoYXQgYXJlIGdvaW5nIHRvIGJlIHByb3ZpZGVkIHRvIGJ1ZmZlckNvbnRyb2xsZXJcbiAgICBPYmplY3Qua2V5cyh0cmFja3MpLmZvckVhY2godHJhY2tOYW1lID0+IHtcbiAgICAgIGNvbnN0IHRyYWNrID0gdHJhY2tzW3RyYWNrTmFtZV07XG4gICAgICBjb25zdCBpbml0U2VnbWVudCA9IHRyYWNrLmluaXRTZWdtZW50O1xuICAgICAgaWYgKGluaXRTZWdtZW50ICE9IG51bGwgJiYgaW5pdFNlZ21lbnQuYnl0ZUxlbmd0aCkge1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5CVUZGRVJfQVBQRU5ESU5HLCB7XG4gICAgICAgICAgdHlwZTogdHJhY2tOYW1lLFxuICAgICAgICAgIGRhdGE6IGluaXRTZWdtZW50LFxuICAgICAgICAgIGZyYWcsXG4gICAgICAgICAgcGFydDogbnVsbCxcbiAgICAgICAgICBjaHVua01ldGEsXG4gICAgICAgICAgcGFyZW50OiBmcmFnLnR5cGVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gdHJpZ2dlciBoYW5kbGVyIHJpZ2h0IG5vd1xuICAgIHRoaXMudGlja0ltbWVkaWF0ZSgpO1xuICB9XG4gIGdldE1haW5Gd2RCdWZmZXJJbmZvKCkge1xuICAgIHJldHVybiB0aGlzLmdldEZ3ZEJ1ZmZlckluZm8odGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiB0aGlzLm1lZGlhLCBQbGF5bGlzdExldmVsVHlwZS5NQUlOKTtcbiAgfVxuICBiYWNrdHJhY2soZnJhZykge1xuICAgIHRoaXMuY291bGRCYWNrdHJhY2sgPSB0cnVlO1xuICAgIC8vIENhdXNlcyBmaW5kRnJhZ21lbnRzIHRvIGJhY2t0cmFjayB0aHJvdWdoIGZyYWdtZW50cyB0byBmaW5kIHRoZSBrZXlmcmFtZVxuICAgIHRoaXMuYmFja3RyYWNrRnJhZ21lbnQgPSBmcmFnO1xuICAgIHRoaXMucmVzZXRUcmFuc211eGVyKCk7XG4gICAgdGhpcy5mbHVzaEJ1ZmZlckdhcChmcmFnKTtcbiAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChmcmFnKTtcbiAgICB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGw7XG4gICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gZnJhZy5zdGFydDtcbiAgICB0aGlzLnN0YXRlID0gU3RhdGUuSURMRTtcbiAgfVxuICBjaGVja0ZyYWdtZW50Q2hhbmdlZCgpIHtcbiAgICBjb25zdCB2aWRlbyA9IHRoaXMubWVkaWE7XG4gICAgbGV0IGZyYWdQbGF5aW5nQ3VycmVudCA9IG51bGw7XG4gICAgaWYgKHZpZGVvICYmIHZpZGVvLnJlYWR5U3RhdGUgPiAxICYmIHZpZGVvLnNlZWtpbmcgPT09IGZhbHNlKSB7XG4gICAgICBjb25zdCBjdXJyZW50VGltZSA9IHZpZGVvLmN1cnJlbnRUaW1lO1xuICAgICAgLyogaWYgdmlkZW8gZWxlbWVudCBpcyBpbiBzZWVrZWQgc3RhdGUsIGN1cnJlbnRUaW1lIGNhbiBvbmx5IGluY3JlYXNlLlxuICAgICAgICAoYXNzdW1pbmcgdGhhdCBwbGF5YmFjayByYXRlIGlzIHBvc2l0aXZlIC4uLilcbiAgICAgICAgQXMgc29tZXRpbWVzIGN1cnJlbnRUaW1lIGp1bXBzIGJhY2sgdG8gemVybyBhZnRlciBhXG4gICAgICAgIG1lZGlhIGRlY29kZSBlcnJvciwgY2hlY2sgdGhpcywgdG8gYXZvaWQgc2Vla2luZyBiYWNrIHRvXG4gICAgICAgIHdyb25nIHBvc2l0aW9uIGFmdGVyIGEgbWVkaWEgZGVjb2RlIGVycm9yXG4gICAgICAqL1xuXG4gICAgICBpZiAoQnVmZmVySGVscGVyLmlzQnVmZmVyZWQodmlkZW8sIGN1cnJlbnRUaW1lKSkge1xuICAgICAgICBmcmFnUGxheWluZ0N1cnJlbnQgPSB0aGlzLmdldEFwcGVuZGVkRnJhZyhjdXJyZW50VGltZSk7XG4gICAgICB9IGVsc2UgaWYgKEJ1ZmZlckhlbHBlci5pc0J1ZmZlcmVkKHZpZGVvLCBjdXJyZW50VGltZSArIDAuMSkpIHtcbiAgICAgICAgLyogZW5zdXJlIHRoYXQgRlJBR19DSEFOR0VEIGV2ZW50IGlzIHRyaWdnZXJlZCBhdCBzdGFydHVwLFxuICAgICAgICAgIHdoZW4gZmlyc3QgdmlkZW8gZnJhbWUgaXMgZGlzcGxheWVkIGFuZCBwbGF5YmFjayBpcyBwYXVzZWQuXG4gICAgICAgICAgYWRkIGEgdG9sZXJhbmNlIG9mIDEwMG1zLCBpbiBjYXNlIGN1cnJlbnQgcG9zaXRpb24gaXMgbm90IGJ1ZmZlcmVkLFxuICAgICAgICAgIGNoZWNrIGlmIGN1cnJlbnQgcG9zKzEwMG1zIGlzIGJ1ZmZlcmVkIGFuZCB1c2UgdGhhdCBidWZmZXIgcmFuZ2VcbiAgICAgICAgICBmb3IgRlJBR19DSEFOR0VEIGV2ZW50IHJlcG9ydGluZyAqL1xuICAgICAgICBmcmFnUGxheWluZ0N1cnJlbnQgPSB0aGlzLmdldEFwcGVuZGVkRnJhZyhjdXJyZW50VGltZSArIDAuMSk7XG4gICAgICB9XG4gICAgICBpZiAoZnJhZ1BsYXlpbmdDdXJyZW50KSB7XG4gICAgICAgIHRoaXMuYmFja3RyYWNrRnJhZ21lbnQgPSBudWxsO1xuICAgICAgICBjb25zdCBmcmFnUGxheWluZyA9IHRoaXMuZnJhZ1BsYXlpbmc7XG4gICAgICAgIGNvbnN0IGZyYWdDdXJyZW50TGV2ZWwgPSBmcmFnUGxheWluZ0N1cnJlbnQubGV2ZWw7XG4gICAgICAgIGlmICghZnJhZ1BsYXlpbmcgfHwgZnJhZ1BsYXlpbmdDdXJyZW50LnNuICE9PSBmcmFnUGxheWluZy5zbiB8fCBmcmFnUGxheWluZy5sZXZlbCAhPT0gZnJhZ0N1cnJlbnRMZXZlbCkge1xuICAgICAgICAgIHRoaXMuZnJhZ1BsYXlpbmcgPSBmcmFnUGxheWluZ0N1cnJlbnQ7XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihFdmVudHMuRlJBR19DSEFOR0VELCB7XG4gICAgICAgICAgICBmcmFnOiBmcmFnUGxheWluZ0N1cnJlbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoIWZyYWdQbGF5aW5nIHx8IGZyYWdQbGF5aW5nLmxldmVsICE9PSBmcmFnQ3VycmVudExldmVsKSB7XG4gICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEV2ZW50cy5MRVZFTF9TV0lUQ0hFRCwge1xuICAgICAgICAgICAgICBsZXZlbDogZnJhZ0N1cnJlbnRMZXZlbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldCBuZXh0TGV2ZWwoKSB7XG4gICAgY29uc3QgZnJhZyA9IHRoaXMubmV4dEJ1ZmZlcmVkRnJhZztcbiAgICBpZiAoZnJhZykge1xuICAgICAgcmV0dXJuIGZyYWcubGV2ZWw7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuICBnZXQgY3VycmVudEZyYWcoKSB7XG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgcmV0dXJuIHRoaXMuZnJhZ1BsYXlpbmcgfHwgdGhpcy5nZXRBcHBlbmRlZEZyYWcobWVkaWEuY3VycmVudFRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBnZXQgY3VycmVudFByb2dyYW1EYXRlVGltZSgpIHtcbiAgICBjb25zdCBtZWRpYSA9IHRoaXMubWVkaWE7XG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICBjb25zdCBjdXJyZW50VGltZSA9IG1lZGlhLmN1cnJlbnRUaW1lO1xuICAgICAgY29uc3QgZnJhZyA9IHRoaXMuY3VycmVudEZyYWc7XG4gICAgICBpZiAoZnJhZyAmJiBpc0Zpbml0ZU51bWJlcihjdXJyZW50VGltZSkgJiYgaXNGaW5pdGVOdW1iZXIoZnJhZy5wcm9ncmFtRGF0ZVRpbWUpKSB7XG4gICAgICAgIGNvbnN0IGVwb2NNcyA9IGZyYWcucHJvZ3JhbURhdGVUaW1lICsgKGN1cnJlbnRUaW1lIC0gZnJhZy5zdGFydCkgKiAxMDAwO1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoZXBvY01zKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZ2V0IGN1cnJlbnRMZXZlbCgpIHtcbiAgICBjb25zdCBmcmFnID0gdGhpcy5jdXJyZW50RnJhZztcbiAgICBpZiAoZnJhZykge1xuICAgICAgcmV0dXJuIGZyYWcubGV2ZWw7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuICBnZXQgbmV4dEJ1ZmZlcmVkRnJhZygpIHtcbiAgICBjb25zdCBmcmFnID0gdGhpcy5jdXJyZW50RnJhZztcbiAgICBpZiAoZnJhZykge1xuICAgICAgcmV0dXJuIHRoaXMuZm9sbG93aW5nQnVmZmVyZWRGcmFnKGZyYWcpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBnZXQgZm9yY2VTdGFydExvYWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZvcmNlU3RhcnRMb2FkO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGBIbHNgIGNsYXNzIGlzIHRoZSBjb3JlIG9mIHRoZSBITFMuanMgbGlicmFyeSB1c2VkIHRvIGluc3RhbnRpYXRlIHBsYXllciBpbnN0YW5jZXMuXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIEhscyB7XG4gIC8qKlxuICAgKiBHZXQgdGhlIHZpZGVvLWRldi9obHMuanMgcGFja2FnZSB2ZXJzaW9uLlxuICAgKi9cbiAgc3RhdGljIGdldCB2ZXJzaW9uKCkge1xuICAgIHJldHVybiBcIjEuNS4yXCI7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIHJlcXVpcmVkIE1lZGlhU291cmNlIEV4dGVuc2lvbnMgYXJlIGF2YWlsYWJsZS5cbiAgICovXG4gIHN0YXRpYyBpc01TRVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gaXNNU0VTdXBwb3J0ZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBNZWRpYVNvdXJjZSBFeHRlbnNpb25zIGFyZSBhdmFpbGFibGUgYW5kIGlzVHlwZVN1cHBvcnRlZCBjaGVja3MgcGFzcyBmb3IgYW55IGJhc2VsaW5lIGNvZGVjcy5cbiAgICovXG4gIHN0YXRpYyBpc1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gaXNTdXBwb3J0ZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIE1lZGlhU291cmNlIGdsb2JhbCB1c2VkIGZvciBNU0UgcGxheWJhY2sgKE1hbmFnZWRNZWRpYVNvdXJjZSwgTWVkaWFTb3VyY2UsIG9yIFdlYktpdE1lZGlhU291cmNlKS5cbiAgICovXG4gIHN0YXRpYyBnZXRNZWRpYVNvdXJjZSgpIHtcbiAgICByZXR1cm4gZ2V0TWVkaWFTb3VyY2UoKTtcbiAgfVxuICBzdGF0aWMgZ2V0IEV2ZW50cygpIHtcbiAgICByZXR1cm4gRXZlbnRzO1xuICB9XG4gIHN0YXRpYyBnZXQgRXJyb3JUeXBlcygpIHtcbiAgICByZXR1cm4gRXJyb3JUeXBlcztcbiAgfVxuICBzdGF0aWMgZ2V0IEVycm9yRGV0YWlscygpIHtcbiAgICByZXR1cm4gRXJyb3JEZXRhaWxzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIGFwcGxpZWQgdG8gbmV3IGluc3RhbmNlcy5cbiAgICovXG4gIHN0YXRpYyBnZXQgRGVmYXVsdENvbmZpZygpIHtcbiAgICBpZiAoIUhscy5kZWZhdWx0Q29uZmlnKSB7XG4gICAgICByZXR1cm4gaGxzRGVmYXVsdENvbmZpZztcbiAgICB9XG4gICAgcmV0dXJuIEhscy5kZWZhdWx0Q29uZmlnO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2UgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBhcHBsaWVkIHRvIG5ldyBpbnN0YW5jZXMuXG4gICAqL1xuICBzdGF0aWMgc2V0IERlZmF1bHRDb25maWcoZGVmYXVsdENvbmZpZykge1xuICAgIEhscy5kZWZhdWx0Q29uZmlnID0gZGVmYXVsdENvbmZpZztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGFuIEhMUyBjbGllbnQgdGhhdCBjYW4gYXR0YWNoIHRvIGV4YWN0bHkgb25lIGBIVE1MTWVkaWFFbGVtZW50YC5cbiAgICogQHBhcmFtIHVzZXJDb25maWcgLSBDb25maWd1cmF0aW9uIG9wdGlvbnMgYXBwbGllZCBvdmVyIGBIbHMuRGVmYXVsdENvbmZpZ2BcbiAgICovXG4gIGNvbnN0cnVjdG9yKHVzZXJDb25maWcgPSB7fSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBydW50aW1lIGNvbmZpZ3VyYXRpb24gdXNlZCBieSB0aGUgcGxheWVyLiBBdCBpbnN0YW50aWF0aW9uIHRoaXMgaXMgY29tYmluYXRpb24gb2YgYGhscy51c2VyQ29uZmlnYCBtZXJnZWQgb3ZlciBgSGxzLkRlZmF1bHRDb25maWdgLlxuICAgICAqL1xuICAgIHRoaXMuY29uZmlnID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdCBwcm92aWRlZCBvbiBwbGF5ZXIgaW5zdGFudGlhdGlvbi5cbiAgICAgKi9cbiAgICB0aGlzLnVzZXJDb25maWcgPSB2b2lkIDA7XG4gICAgdGhpcy5jb3JlQ29tcG9uZW50cyA9IHZvaWQgMDtcbiAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVycyA9IHZvaWQgMDtcbiAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9lbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIHRoaXMuX2F1dG9MZXZlbENhcHBpbmcgPSAtMTtcbiAgICB0aGlzLl9tYXhIZGNwTGV2ZWwgPSBudWxsO1xuICAgIHRoaXMuYWJyQ29udHJvbGxlciA9IHZvaWQgMDtcbiAgICB0aGlzLmJ1ZmZlckNvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5jYXBMZXZlbENvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5sYXRlbmN5Q29udHJvbGxlciA9IHZvaWQgMDtcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlciA9IHZvaWQgMDtcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlciA9IHZvaWQgMDtcbiAgICB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gdm9pZCAwO1xuICAgIHRoaXMuZW1lQ29udHJvbGxlciA9IHZvaWQgMDtcbiAgICB0aGlzLmNtY2RDb250cm9sbGVyID0gdm9pZCAwO1xuICAgIHRoaXMuX21lZGlhID0gbnVsbDtcbiAgICB0aGlzLnVybCA9IG51bGw7XG4gICAgdGhpcy50cmlnZ2VyaW5nRXhjZXB0aW9uID0gdm9pZCAwO1xuICAgIGVuYWJsZUxvZ3ModXNlckNvbmZpZy5kZWJ1ZyB8fCBmYWxzZSwgJ0hscyBpbnN0YW5jZScpO1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnID0gbWVyZ2VDb25maWcoSGxzLkRlZmF1bHRDb25maWcsIHVzZXJDb25maWcpO1xuICAgIHRoaXMudXNlckNvbmZpZyA9IHVzZXJDb25maWc7XG4gICAgaWYgKGNvbmZpZy5wcm9ncmVzc2l2ZSkge1xuICAgICAgZW5hYmxlU3RyZWFtaW5nTW9kZShjb25maWcpO1xuICAgIH1cblxuICAgIC8vIGNvcmUgY29udHJvbGxlcnMgYW5kIG5ldHdvcmsgbG9hZGVyc1xuICAgIGNvbnN0IHtcbiAgICAgIGFickNvbnRyb2xsZXI6IENvbmZpZ0FickNvbnRyb2xsZXIsXG4gICAgICBidWZmZXJDb250cm9sbGVyOiBDb25maWdCdWZmZXJDb250cm9sbGVyLFxuICAgICAgY2FwTGV2ZWxDb250cm9sbGVyOiBDb25maWdDYXBMZXZlbENvbnRyb2xsZXIsXG4gICAgICBlcnJvckNvbnRyb2xsZXI6IENvbmZpZ0Vycm9yQ29udHJvbGxlcixcbiAgICAgIGZwc0NvbnRyb2xsZXI6IENvbmZpZ0Zwc0NvbnRyb2xsZXJcbiAgICB9ID0gY29uZmlnO1xuICAgIGNvbnN0IGVycm9yQ29udHJvbGxlciA9IG5ldyBDb25maWdFcnJvckNvbnRyb2xsZXIodGhpcyk7XG4gICAgY29uc3QgYWJyQ29udHJvbGxlciA9IHRoaXMuYWJyQ29udHJvbGxlciA9IG5ldyBDb25maWdBYnJDb250cm9sbGVyKHRoaXMpO1xuICAgIGNvbnN0IGJ1ZmZlckNvbnRyb2xsZXIgPSB0aGlzLmJ1ZmZlckNvbnRyb2xsZXIgPSBuZXcgQ29uZmlnQnVmZmVyQ29udHJvbGxlcih0aGlzKTtcbiAgICBjb25zdCBjYXBMZXZlbENvbnRyb2xsZXIgPSB0aGlzLmNhcExldmVsQ29udHJvbGxlciA9IG5ldyBDb25maWdDYXBMZXZlbENvbnRyb2xsZXIodGhpcyk7XG4gICAgY29uc3QgZnBzQ29udHJvbGxlciA9IG5ldyBDb25maWdGcHNDb250cm9sbGVyKHRoaXMpO1xuICAgIGNvbnN0IHBsYXlMaXN0TG9hZGVyID0gbmV3IFBsYXlsaXN0TG9hZGVyKHRoaXMpO1xuICAgIGNvbnN0IGlkM1RyYWNrQ29udHJvbGxlciA9IG5ldyBJRDNUcmFja0NvbnRyb2xsZXIodGhpcyk7XG4gICAgY29uc3QgQ29uZmlnQ29udGVudFN0ZWVyaW5nQ29udHJvbGxlciA9IGNvbmZpZy5jb250ZW50U3RlZXJpbmdDb250cm9sbGVyO1xuICAgIC8vIENvbmVudFN0ZWVyaW5nQ29udHJvbGxlciBpcyBkZWZpbmVkIGJlZm9yZSBMZXZlbENvbnRyb2xsZXIgdG8gcmVjZWl2ZSBNdWx0aXZhcmlhbnQgUGxheWxpc3QgZXZlbnRzIGZpcnN0XG4gICAgY29uc3QgY29udGVudFN0ZWVyaW5nID0gQ29uZmlnQ29udGVudFN0ZWVyaW5nQ29udHJvbGxlciA/IG5ldyBDb25maWdDb250ZW50U3RlZXJpbmdDb250cm9sbGVyKHRoaXMpIDogbnVsbDtcbiAgICBjb25zdCBsZXZlbENvbnRyb2xsZXIgPSB0aGlzLmxldmVsQ29udHJvbGxlciA9IG5ldyBMZXZlbENvbnRyb2xsZXIodGhpcywgY29udGVudFN0ZWVyaW5nKTtcbiAgICAvLyBGcmFnbWVudFRyYWNrZXIgbXVzdCBiZSBkZWZpbmVkIGJlZm9yZSBTdHJlYW1Db250cm9sbGVyIGJlY2F1c2UgdGhlIG9yZGVyIG9mIGV2ZW50IGhhbmRsaW5nIGlzIGltcG9ydGFudFxuICAgIGNvbnN0IGZyYWdtZW50VHJhY2tlciA9IG5ldyBGcmFnbWVudFRyYWNrZXIodGhpcyk7XG4gICAgY29uc3Qga2V5TG9hZGVyID0gbmV3IEtleUxvYWRlcih0aGlzLmNvbmZpZyk7XG4gICAgY29uc3Qgc3RyZWFtQ29udHJvbGxlciA9IHRoaXMuc3RyZWFtQ29udHJvbGxlciA9IG5ldyBTdHJlYW1Db250cm9sbGVyKHRoaXMsIGZyYWdtZW50VHJhY2tlciwga2V5TG9hZGVyKTtcblxuICAgIC8vIENhcCBsZXZlbCBjb250cm9sbGVyIHVzZXMgc3RyZWFtQ29udHJvbGxlciB0byBmbHVzaCB0aGUgYnVmZmVyXG4gICAgY2FwTGV2ZWxDb250cm9sbGVyLnNldFN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtQ29udHJvbGxlcik7XG4gICAgLy8gZnBzQ29udHJvbGxlciB1c2VzIHN0cmVhbUNvbnRyb2xsZXIgdG8gc3dpdGNoIHdoZW4gZnJhbWVzIGFyZSBiZWluZyBkcm9wcGVkXG4gICAgZnBzQ29udHJvbGxlci5zZXRTdHJlYW1Db250cm9sbGVyKHN0cmVhbUNvbnRyb2xsZXIpO1xuICAgIGNvbnN0IG5ldHdvcmtDb250cm9sbGVycyA9IFtwbGF5TGlzdExvYWRlciwgbGV2ZWxDb250cm9sbGVyLCBzdHJlYW1Db250cm9sbGVyXTtcbiAgICBpZiAoY29udGVudFN0ZWVyaW5nKSB7XG4gICAgICBuZXR3b3JrQ29udHJvbGxlcnMuc3BsaWNlKDEsIDAsIGNvbnRlbnRTdGVlcmluZyk7XG4gICAgfVxuICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXJzID0gbmV0d29ya0NvbnRyb2xsZXJzO1xuICAgIGNvbnN0IGNvcmVDb21wb25lbnRzID0gW2FickNvbnRyb2xsZXIsIGJ1ZmZlckNvbnRyb2xsZXIsIGNhcExldmVsQ29udHJvbGxlciwgZnBzQ29udHJvbGxlciwgaWQzVHJhY2tDb250cm9sbGVyLCBmcmFnbWVudFRyYWNrZXJdO1xuICAgIHRoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXIgPSB0aGlzLmNyZWF0ZUNvbnRyb2xsZXIoY29uZmlnLmF1ZGlvVHJhY2tDb250cm9sbGVyLCBuZXR3b3JrQ29udHJvbGxlcnMpO1xuICAgIGNvbnN0IEF1ZGlvU3RyZWFtQ29udHJvbGxlckNsYXNzID0gY29uZmlnLmF1ZGlvU3RyZWFtQ29udHJvbGxlcjtcbiAgICBpZiAoQXVkaW9TdHJlYW1Db250cm9sbGVyQ2xhc3MpIHtcbiAgICAgIG5ldHdvcmtDb250cm9sbGVycy5wdXNoKG5ldyBBdWRpb1N0cmVhbUNvbnRyb2xsZXJDbGFzcyh0aGlzLCBmcmFnbWVudFRyYWNrZXIsIGtleUxvYWRlcikpO1xuICAgIH1cbiAgICAvLyBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciBtdXN0IGJlIGRlZmluZWQgYmVmb3JlIHN1YnRpdGxlU3RyZWFtQ29udHJvbGxlciBiZWNhdXNlIHRoZSBvcmRlciBvZiBldmVudCBoYW5kbGluZyBpcyBpbXBvcnRhbnRcbiAgICB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyID0gdGhpcy5jcmVhdGVDb250cm9sbGVyKGNvbmZpZy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlciwgbmV0d29ya0NvbnRyb2xsZXJzKTtcbiAgICBjb25zdCBTdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXJDbGFzcyA9IGNvbmZpZy5zdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXI7XG4gICAgaWYgKFN1YnRpdGxlU3RyZWFtQ29udHJvbGxlckNsYXNzKSB7XG4gICAgICBuZXR3b3JrQ29udHJvbGxlcnMucHVzaChuZXcgU3VidGl0bGVTdHJlYW1Db250cm9sbGVyQ2xhc3ModGhpcywgZnJhZ21lbnRUcmFja2VyLCBrZXlMb2FkZXIpKTtcbiAgICB9XG4gICAgdGhpcy5jcmVhdGVDb250cm9sbGVyKGNvbmZpZy50aW1lbGluZUNvbnRyb2xsZXIsIGNvcmVDb21wb25lbnRzKTtcbiAgICBrZXlMb2FkZXIuZW1lQ29udHJvbGxlciA9IHRoaXMuZW1lQ29udHJvbGxlciA9IHRoaXMuY3JlYXRlQ29udHJvbGxlcihjb25maWcuZW1lQ29udHJvbGxlciwgY29yZUNvbXBvbmVudHMpO1xuICAgIHRoaXMuY21jZENvbnRyb2xsZXIgPSB0aGlzLmNyZWF0ZUNvbnRyb2xsZXIoY29uZmlnLmNtY2RDb250cm9sbGVyLCBjb3JlQ29tcG9uZW50cyk7XG4gICAgdGhpcy5sYXRlbmN5Q29udHJvbGxlciA9IHRoaXMuY3JlYXRlQ29udHJvbGxlcihMYXRlbmN5Q29udHJvbGxlciwgY29yZUNvbXBvbmVudHMpO1xuICAgIHRoaXMuY29yZUNvbXBvbmVudHMgPSBjb3JlQ29tcG9uZW50cztcblxuICAgIC8vIEVycm9yIGNvbnRyb2xsZXIgaGFuZGxlcyBlcnJvcnMgYmVmb3JlIGFuZCBhZnRlciBhbGwgb3RoZXIgY29udHJvbGxlcnNcbiAgICAvLyBUaGlzIGxpc3RlbmVyIHdpbGwgYmUgaW52b2tlZCBhZnRlciBhbGwgb3RoZXIgY29udHJvbGxlcnMgZXJyb3IgbGlzdGVuZXJzXG4gICAgbmV0d29ya0NvbnRyb2xsZXJzLnB1c2goZXJyb3JDb250cm9sbGVyKTtcbiAgICBjb25zdCBvbkVycm9yT3V0ID0gZXJyb3JDb250cm9sbGVyLm9uRXJyb3JPdXQ7XG4gICAgaWYgKHR5cGVvZiBvbkVycm9yT3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLm9uKEV2ZW50cy5FUlJPUiwgb25FcnJvck91dCwgZXJyb3JDb250cm9sbGVyKTtcbiAgICB9XG4gIH1cbiAgY3JlYXRlQ29udHJvbGxlcihDb250cm9sbGVyQ2xhc3MsIGNvbXBvbmVudHMpIHtcbiAgICBpZiAoQ29udHJvbGxlckNsYXNzKSB7XG4gICAgICBjb25zdCBjb250cm9sbGVySW5zdGFuY2UgPSBuZXcgQ29udHJvbGxlckNsYXNzKHRoaXMpO1xuICAgICAgaWYgKGNvbXBvbmVudHMpIHtcbiAgICAgICAgY29tcG9uZW50cy5wdXNoKGNvbnRyb2xsZXJJbnN0YW5jZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29udHJvbGxlckluc3RhbmNlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIERlbGVnYXRlIHRoZSBFdmVudEVtaXR0ZXIgdGhyb3VnaCB0aGUgcHVibGljIEFQSSBvZiBIbHMuanNcbiAgb24oZXZlbnQsIGxpc3RlbmVyLCBjb250ZXh0ID0gdGhpcykge1xuICAgIHRoaXMuX2VtaXR0ZXIub24oZXZlbnQsIGxpc3RlbmVyLCBjb250ZXh0KTtcbiAgfVxuICBvbmNlKGV2ZW50LCBsaXN0ZW5lciwgY29udGV4dCA9IHRoaXMpIHtcbiAgICB0aGlzLl9lbWl0dGVyLm9uY2UoZXZlbnQsIGxpc3RlbmVyLCBjb250ZXh0KTtcbiAgfVxuICByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgICB0aGlzLl9lbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycyhldmVudCk7XG4gIH1cbiAgb2ZmKGV2ZW50LCBsaXN0ZW5lciwgY29udGV4dCA9IHRoaXMsIG9uY2UpIHtcbiAgICB0aGlzLl9lbWl0dGVyLm9mZihldmVudCwgbGlzdGVuZXIsIGNvbnRleHQsIG9uY2UpO1xuICB9XG4gIGxpc3RlbmVycyhldmVudCkge1xuICAgIHJldHVybiB0aGlzLl9lbWl0dGVyLmxpc3RlbmVycyhldmVudCk7XG4gIH1cbiAgZW1pdChldmVudCwgbmFtZSwgZXZlbnRPYmplY3QpIHtcbiAgICByZXR1cm4gdGhpcy5fZW1pdHRlci5lbWl0KGV2ZW50LCBuYW1lLCBldmVudE9iamVjdCk7XG4gIH1cbiAgdHJpZ2dlcihldmVudCwgZXZlbnRPYmplY3QpIHtcbiAgICBpZiAodGhpcy5jb25maWcuZGVidWcpIHtcbiAgICAgIHJldHVybiB0aGlzLmVtaXQoZXZlbnQsIGV2ZW50LCBldmVudE9iamVjdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoZXZlbnQsIGV2ZW50LCBldmVudE9iamVjdCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dnZXIuZXJyb3IoJ0FuIGludGVybmFsIGVycm9yIGhhcHBlbmVkIHdoaWxlIGhhbmRsaW5nIGV2ZW50ICcgKyBldmVudCArICcuIEVycm9yIG1lc3NhZ2U6IFwiJyArIGVycm9yLm1lc3NhZ2UgKyAnXCIuIEhlcmUgaXMgYSBzdGFja3RyYWNlOicsIGVycm9yKTtcbiAgICAgICAgLy8gUHJldmVudCByZWN1cnNpb24gaW4gZXJyb3IgZXZlbnQgaGFuZGxlcnMgdGhhdCB0aHJvdyAjNTQ5N1xuICAgICAgICBpZiAoIXRoaXMudHJpZ2dlcmluZ0V4Y2VwdGlvbikge1xuICAgICAgICAgIHRoaXMudHJpZ2dlcmluZ0V4Y2VwdGlvbiA9IHRydWU7XG4gICAgICAgICAgY29uc3QgZmF0YWwgPSBldmVudCA9PT0gRXZlbnRzLkVSUk9SO1xuICAgICAgICAgIHRoaXMudHJpZ2dlcihFdmVudHMuRVJST1IsIHtcbiAgICAgICAgICAgIHR5cGU6IEVycm9yVHlwZXMuT1RIRVJfRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBFcnJvckRldGFpbHMuSU5URVJOQUxfRVhDRVBUSU9OLFxuICAgICAgICAgICAgZmF0YWwsXG4gICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyaW5nRXhjZXB0aW9uID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcbiAgICByZXR1cm4gdGhpcy5fZW1pdHRlci5saXN0ZW5lckNvdW50KGV2ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwb3NlIG9mIHRoZSBpbnN0YW5jZVxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICBsb2dnZXIubG9nKCdkZXN0cm95Jyk7XG4gICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5ERVNUUk9ZSU5HLCB1bmRlZmluZWQpO1xuICAgIHRoaXMuZGV0YWNoTWVkaWEoKTtcbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIHRoaXMuX2F1dG9MZXZlbENhcHBpbmcgPSAtMTtcbiAgICB0aGlzLnVybCA9IG51bGw7XG4gICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMuZm9yRWFjaChjb21wb25lbnQgPT4gY29tcG9uZW50LmRlc3Ryb3koKSk7XG4gICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMubGVuZ3RoID0gMDtcbiAgICB0aGlzLmNvcmVDb21wb25lbnRzLmZvckVhY2goY29tcG9uZW50ID0+IGNvbXBvbmVudC5kZXN0cm95KCkpO1xuICAgIHRoaXMuY29yZUNvbXBvbmVudHMubGVuZ3RoID0gMDtcbiAgICAvLyBSZW1vdmUgYW55IHJlZmVyZW5jZXMgdGhhdCBjb3VsZCBiZSBoZWxkIGluIGNvbmZpZyBvcHRpb25zIG9yIGNhbGxiYWNrc1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIGNvbmZpZy54aHJTZXR1cCA9IGNvbmZpZy5mZXRjaFNldHVwID0gdW5kZWZpbmVkO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLnVzZXJDb25maWcgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGFjaGVzIEhscy5qcyB0byBhIG1lZGlhIGVsZW1lbnRcbiAgICovXG4gIGF0dGFjaE1lZGlhKG1lZGlhKSB7XG4gICAgbG9nZ2VyLmxvZygnYXR0YWNoTWVkaWEnKTtcbiAgICB0aGlzLl9tZWRpYSA9IG1lZGlhO1xuICAgIHRoaXMudHJpZ2dlcihFdmVudHMuTUVESUFfQVRUQUNISU5HLCB7XG4gICAgICBtZWRpYTogbWVkaWFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRhY2ggSGxzLmpzIGZyb20gdGhlIG1lZGlhXG4gICAqL1xuICBkZXRhY2hNZWRpYSgpIHtcbiAgICBsb2dnZXIubG9nKCdkZXRhY2hNZWRpYScpO1xuICAgIHRoaXMudHJpZ2dlcihFdmVudHMuTUVESUFfREVUQUNISU5HLCB1bmRlZmluZWQpO1xuICAgIHRoaXMuX21lZGlhID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHNvdXJjZSBVUkwuIENhbiBiZSByZWxhdGl2ZSBvciBhYnNvbHV0ZS5cbiAgICovXG4gIGxvYWRTb3VyY2UodXJsKSB7XG4gICAgdGhpcy5zdG9wTG9hZCgpO1xuICAgIGNvbnN0IG1lZGlhID0gdGhpcy5tZWRpYTtcbiAgICBjb25zdCBsb2FkZWRTb3VyY2UgPSB0aGlzLnVybDtcbiAgICBjb25zdCBsb2FkaW5nU291cmNlID0gdGhpcy51cmwgPSB1cmxUb29sa2l0RXhwb3J0cy5idWlsZEFic29sdXRlVVJMKHNlbGYubG9jYXRpb24uaHJlZiwgdXJsLCB7XG4gICAgICBhbHdheXNOb3JtYWxpemU6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nID0gLTE7XG4gICAgdGhpcy5fbWF4SGRjcExldmVsID0gbnVsbDtcbiAgICBsb2dnZXIubG9nKGBsb2FkU291cmNlOiR7bG9hZGluZ1NvdXJjZX1gKTtcbiAgICBpZiAobWVkaWEgJiYgbG9hZGVkU291cmNlICYmIChsb2FkZWRTb3VyY2UgIT09IGxvYWRpbmdTb3VyY2UgfHwgdGhpcy5idWZmZXJDb250cm9sbGVyLmhhc1NvdXJjZVR5cGVzKCkpKSB7XG4gICAgICB0aGlzLmRldGFjaE1lZGlhKCk7XG4gICAgICB0aGlzLmF0dGFjaE1lZGlhKG1lZGlhKTtcbiAgICB9XG4gICAgLy8gd2hlbiBhdHRhY2hpbmcgdG8gYSBzb3VyY2UgVVJMLCB0cmlnZ2VyIGEgcGxheWxpc3QgbG9hZFxuICAgIHRoaXMudHJpZ2dlcihFdmVudHMuTUFOSUZFU1RfTE9BRElORywge1xuICAgICAgdXJsOiB1cmxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBsb2FkaW5nIGRhdGEgZnJvbSB0aGUgc3RyZWFtIHNvdXJjZS5cbiAgICogRGVwZW5kaW5nIG9uIGRlZmF1bHQgY29uZmlnLCBjbGllbnQgc3RhcnRzIGxvYWRpbmcgYXV0b21hdGljYWxseSB3aGVuIGEgc291cmNlIGlzIHNldC5cbiAgICpcbiAgICogQHBhcmFtIHN0YXJ0UG9zaXRpb24gLSBTZXQgdGhlIHN0YXJ0IHBvc2l0aW9uIHRvIHN0cmVhbSBmcm9tLlxuICAgKiBEZWZhdWx0cyB0byAtMSAoTm9uZTogc3RhcnRzIGZyb20gZWFybGllc3QgcG9pbnQpXG4gICAqL1xuICBzdGFydExvYWQoc3RhcnRQb3NpdGlvbiA9IC0xKSB7XG4gICAgbG9nZ2VyLmxvZyhgc3RhcnRMb2FkKCR7c3RhcnRQb3NpdGlvbn0pYCk7XG4gICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVycy5mb3JFYWNoKGNvbnRyb2xsZXIgPT4ge1xuICAgICAgY29udHJvbGxlci5zdGFydExvYWQoc3RhcnRQb3NpdGlvbik7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3RvcCBsb2FkaW5nIG9mIGFueSBzdHJlYW0gZGF0YS5cbiAgICovXG4gIHN0b3BMb2FkKCkge1xuICAgIGxvZ2dlci5sb2coJ3N0b3BMb2FkJyk7XG4gICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMuZm9yRWFjaChjb250cm9sbGVyID0+IHtcbiAgICAgIGNvbnRyb2xsZXIuc3RvcExvYWQoKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXN1bWVzIHN0cmVhbSBjb250cm9sbGVyIHNlZ21lbnQgbG9hZGluZyBpZiBwcmV2aW91c2x5IHN0YXJ0ZWQuXG4gICAqL1xuICByZXN1bWVCdWZmZXJpbmcoKSB7XG4gICAgaWYgKHRoaXMuc3RhcnRlZCkge1xuICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMuZm9yRWFjaChjb250cm9sbGVyID0+IHtcbiAgICAgICAgaWYgKCdmcmFnbWVudExvYWRlcicgaW4gY29udHJvbGxlcikge1xuICAgICAgICAgIGNvbnRyb2xsZXIuc3RhcnRMb2FkKC0xKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3BzIHN0cmVhbSBjb250cm9sbGVyIHNlZ21lbnQgbG9hZGluZyB3aXRob3V0IGNoYW5naW5nICdzdGFydGVkJyBzdGF0ZSBsaWtlIHN0b3BMb2FkKCkuXG4gICAqIFRoaXMgYWxsb3dzIGZvciBtZWRpYSBidWZmZXJpbmcgdG8gYmUgcGF1c2VkIHdpdGhvdXQgaW50ZXJ1cHRpbmcgcGxheWxpc3QgbG9hZGluZy5cbiAgICovXG4gIHBhdXNlQnVmZmVyaW5nKCkge1xuICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXJzLmZvckVhY2goY29udHJvbGxlciA9PiB7XG4gICAgICBpZiAoJ2ZyYWdtZW50TG9hZGVyJyBpbiBjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuc3RvcExvYWQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTd2FwIHRocm91Z2ggcG9zc2libGUgYXVkaW8gY29kZWNzIGluIHRoZSBzdHJlYW0gKGZvciBleGFtcGxlIHRvIHN3aXRjaCBmcm9tIHN0ZXJlbyB0byA1LjEpXG4gICAqL1xuICBzd2FwQXVkaW9Db2RlYygpIHtcbiAgICBsb2dnZXIubG9nKCdzd2FwQXVkaW9Db2RlYycpO1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5zd2FwQXVkaW9Db2RlYygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIG1lZGlhLWVsZW1lbnQgZmFpbHMsIHRoaXMgYWxsb3dzIHRvIGRldGFjaCBhbmQgdGhlbiByZS1hdHRhY2ggaXRcbiAgICogYXMgb25lIGNhbGwgKGNvbnZlbmllbmNlIG1ldGhvZCkuXG4gICAqXG4gICAqIEF1dG9tYXRpYyByZWNvdmVyeSBvZiBtZWRpYS1lcnJvcnMgYnkgdGhpcyBwcm9jZXNzIGlzIGNvbmZpZ3VyYWJsZS5cbiAgICovXG4gIHJlY292ZXJNZWRpYUVycm9yKCkge1xuICAgIGxvZ2dlci5sb2coJ3JlY292ZXJNZWRpYUVycm9yJyk7XG4gICAgY29uc3QgbWVkaWEgPSB0aGlzLl9tZWRpYTtcbiAgICB0aGlzLmRldGFjaE1lZGlhKCk7XG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICB0aGlzLmF0dGFjaE1lZGlhKG1lZGlhKTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlTGV2ZWwobGV2ZWxJbmRleCkge1xuICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLnJlbW92ZUxldmVsKGxldmVsSW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIGFuIGFycmF5IG9mIGxldmVscyAodmFyaWFudHMpIHNvcnRlZCBieSBIRENQLUxFVkVMLCBSRVNPTFVUSU9OIChoZWlnaHQpLCBGUkFNRS1SQVRFLCBDT0RFQ1MsIFZJREVPLVJBTkdFLCBhbmQgQkFORFdJRFRIXG4gICAqL1xuICBnZXQgbGV2ZWxzKCkge1xuICAgIGNvbnN0IGxldmVscyA9IHRoaXMubGV2ZWxDb250cm9sbGVyLmxldmVscztcbiAgICByZXR1cm4gbGV2ZWxzID8gbGV2ZWxzIDogW107XG4gIH1cblxuICAvKipcbiAgICogSW5kZXggb2YgcXVhbGl0eSBsZXZlbCAodmFyaWFudCkgY3VycmVudGx5IHBsYXllZFxuICAgKi9cbiAgZ2V0IGN1cnJlbnRMZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLmN1cnJlbnRMZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgcXVhbGl0eSBsZXZlbCBpbmRleCBpbW1lZGlhdGVseS4gVGhpcyB3aWxsIGZsdXNoIHRoZSBjdXJyZW50IGJ1ZmZlciB0byByZXBsYWNlIHRoZSBxdWFsaXR5IGFzYXAuIFRoYXQgbWVhbnMgcGxheWJhY2sgd2lsbCBpbnRlcnJ1cHQgYXQgbGVhc3Qgc2hvcnRseSB0byByZS1idWZmZXIgYW5kIHJlLXN5bmMgZXZlbnR1YWxseS4gU2V0IHRvIC0xIGZvciBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uLlxuICAgKi9cbiAgc2V0IGN1cnJlbnRMZXZlbChuZXdMZXZlbCkge1xuICAgIGxvZ2dlci5sb2coYHNldCBjdXJyZW50TGV2ZWw6JHtuZXdMZXZlbH1gKTtcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5tYW51YWxMZXZlbCA9IG5ld0xldmVsO1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5pbW1lZGlhdGVMZXZlbFN3aXRjaCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluZGV4IG9mIG5leHQgcXVhbGl0eSBsZXZlbCBsb2FkZWQgYXMgc2NoZWR1bGVkIGJ5IHN0cmVhbSBjb250cm9sbGVyLlxuICAgKi9cbiAgZ2V0IG5leHRMZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgcXVhbGl0eSBsZXZlbCBpbmRleCBmb3IgbmV4dCBsb2FkZWQgZGF0YS5cbiAgICogVGhpcyB3aWxsIHN3aXRjaCB0aGUgdmlkZW8gcXVhbGl0eSBhc2FwLCB3aXRob3V0IGludGVycnVwdGluZyBwbGF5YmFjay5cbiAgICogTWF5IGFib3J0IGN1cnJlbnQgbG9hZGluZyBvZiBkYXRhLCBhbmQgZmx1c2ggcGFydHMgb2YgYnVmZmVyIChvdXRzaWRlIGN1cnJlbnRseSBwbGF5ZWQgZnJhZ21lbnQgcmVnaW9uKS5cbiAgICogQHBhcmFtIG5ld0xldmVsIC0gUGFzcyAtMSBmb3IgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvblxuICAgKi9cbiAgc2V0IG5leHRMZXZlbChuZXdMZXZlbCkge1xuICAgIGxvZ2dlci5sb2coYHNldCBuZXh0TGV2ZWw6JHtuZXdMZXZlbH1gKTtcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5tYW51YWxMZXZlbCA9IG5ld0xldmVsO1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWxTd2l0Y2goKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHF1YWxpdHkgbGV2ZWwgb2YgdGhlIGN1cnJlbnRseSBvciBsYXN0IChvZiBub25lIGlzIGxvYWRlZCBjdXJyZW50bHkpIHNlZ21lbnRcbiAgICovXG4gIGdldCBsb2FkTGV2ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLmxldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBxdWFsaXR5IGxldmVsIGluZGV4IGZvciBuZXh0IGxvYWRlZCBkYXRhIGluIGEgY29uc2VydmF0aXZlIHdheS5cbiAgICogVGhpcyB3aWxsIHN3aXRjaCB0aGUgcXVhbGl0eSB3aXRob3V0IGZsdXNoaW5nLCBidXQgaW50ZXJydXB0IGN1cnJlbnQgbG9hZGluZy5cbiAgICogVGh1cyB0aGUgbW9tZW50IHdoZW4gdGhlIHF1YWxpdHkgc3dpdGNoIHdpbGwgYXBwZWFyIGluIGVmZmVjdCB3aWxsIG9ubHkgYmUgYWZ0ZXIgdGhlIGFscmVhZHkgZXhpc3RpbmcgYnVmZmVyLlxuICAgKiBAcGFyYW0gbmV3TGV2ZWwgLSBQYXNzIC0xIGZvciBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uXG4gICAqL1xuICBzZXQgbG9hZExldmVsKG5ld0xldmVsKSB7XG4gICAgbG9nZ2VyLmxvZyhgc2V0IGxvYWRMZXZlbDoke25ld0xldmVsfWApO1xuICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLm1hbnVhbExldmVsID0gbmV3TGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogZ2V0IG5leHQgcXVhbGl0eSBsZXZlbCBsb2FkZWRcbiAgICovXG4gIGdldCBuZXh0TG9hZExldmVsKCkge1xuICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5uZXh0TG9hZExldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBxdWFsaXR5IGxldmVsIG9mIG5leHQgbG9hZGVkIHNlZ21lbnQgaW4gYSBmdWxseSBcIm5vbi1kZXN0cnVjdGl2ZVwiIHdheS5cbiAgICogU2FtZSBhcyBgbG9hZExldmVsYCBidXQgd2lsbCB3YWl0IGZvciBuZXh0IHN3aXRjaCAodW50aWwgY3VycmVudCBsb2FkaW5nIGlzIGRvbmUpLlxuICAgKi9cbiAgc2V0IG5leHRMb2FkTGV2ZWwobGV2ZWwpIHtcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5uZXh0TG9hZExldmVsID0gbGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIFwiZmlyc3QgbGV2ZWxcIjogbGlrZSBhIGRlZmF1bHQgbGV2ZWwsIGlmIG5vdCBzZXQsXG4gICAqIGZhbGxzIGJhY2sgdG8gaW5kZXggb2YgZmlyc3QgbGV2ZWwgcmVmZXJlbmNlZCBpbiBtYW5pZmVzdFxuICAgKi9cbiAgZ2V0IGZpcnN0TGV2ZWwoKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KHRoaXMubGV2ZWxDb250cm9sbGVyLmZpcnN0TGV2ZWwsIHRoaXMubWluQXV0b0xldmVsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIFwiZmlyc3QtbGV2ZWxcIiwgc2VlIGdldHRlci5cbiAgICovXG4gIHNldCBmaXJzdExldmVsKG5ld0xldmVsKSB7XG4gICAgbG9nZ2VyLmxvZyhgc2V0IGZpcnN0TGV2ZWw6JHtuZXdMZXZlbH1gKTtcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5maXJzdExldmVsID0gbmV3TGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBkZXNpcmVkIHN0YXJ0IGxldmVsIGZvciB0aGUgZmlyc3QgZnJhZ21lbnQgdGhhdCB3aWxsIGJlIGxvYWRlZC5cbiAgICogVGhlIGRlZmF1bHQgdmFsdWUgb2YgLTEgaW5kaWNhdGVzIGF1dG9tYXRpYyBzdGFydCBsZXZlbCBzZWxlY3Rpb24uXG4gICAqIFNldHRpbmcgaGxzLm5leHRBdXRvTGV2ZWwgd2l0aG91dCBzZXR0aW5nIGEgc3RhcnRMZXZlbCB3aWxsIHJlc3VsdCBpblxuICAgKiB0aGUgbmV4dEF1dG9MZXZlbCB2YWx1ZSBiZWluZyB1c2VkIGZvciBvbmUgZnJhZ21lbnQgbG9hZC5cbiAgICovXG4gIGdldCBzdGFydExldmVsKCkge1xuICAgIGNvbnN0IHN0YXJ0TGV2ZWwgPSB0aGlzLmxldmVsQ29udHJvbGxlci5zdGFydExldmVsO1xuICAgIGlmIChzdGFydExldmVsID09PSAtMSAmJiB0aGlzLmFickNvbnRyb2xsZXIuZm9yY2VkQXV0b0xldmVsID4gLTEpIHtcbiAgICAgIHJldHVybiB0aGlzLmFickNvbnRyb2xsZXIuZm9yY2VkQXV0b0xldmVsO1xuICAgIH1cbiAgICByZXR1cm4gc3RhcnRMZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBzZXQgIHN0YXJ0IGxldmVsIChsZXZlbCBvZiBmaXJzdCBmcmFnbWVudCB0aGF0IHdpbGwgYmUgcGxheWVkIGJhY2spXG4gICAqIGlmIG5vdCBvdmVycmlkZWQgYnkgdXNlciwgZmlyc3QgbGV2ZWwgYXBwZWFyaW5nIGluIG1hbmlmZXN0IHdpbGwgYmUgdXNlZCBhcyBzdGFydCBsZXZlbFxuICAgKiBpZiAtMSA6IGF1dG9tYXRpYyBzdGFydCBsZXZlbCBzZWxlY3Rpb24sIHBsYXliYWNrIHdpbGwgc3RhcnQgZnJvbSBsZXZlbCBtYXRjaGluZyBkb3dubG9hZCBiYW5kd2lkdGhcbiAgICogKGRldGVybWluZWQgZnJvbSBkb3dubG9hZCBvZiBmaXJzdCBzZWdtZW50KVxuICAgKi9cbiAgc2V0IHN0YXJ0TGV2ZWwobmV3TGV2ZWwpIHtcbiAgICBsb2dnZXIubG9nKGBzZXQgc3RhcnRMZXZlbDoke25ld0xldmVsfWApO1xuICAgIC8vIGlmIG5vdCBpbiBhdXRvbWF0aWMgc3RhcnQgbGV2ZWwgZGV0ZWN0aW9uLCBlbnN1cmUgc3RhcnRMZXZlbCBpcyBncmVhdGVyIHRoYW4gbWluQXV0b0xldmVsXG4gICAgaWYgKG5ld0xldmVsICE9PSAtMSkge1xuICAgICAgbmV3TGV2ZWwgPSBNYXRoLm1heChuZXdMZXZlbCwgdGhpcy5taW5BdXRvTGV2ZWwpO1xuICAgIH1cbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5zdGFydExldmVsID0gbmV3TGV2ZWw7XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciBsZXZlbCBjYXBwaW5nIGlzIGVuYWJsZWQuXG4gICAqIERlZmF1bHQgdmFsdWUgaXMgc2V0IHZpYSBgY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplYC5cbiAgICovXG4gIGdldCBjYXBMZXZlbFRvUGxheWVyU2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemU7XG4gIH1cblxuICAvKipcbiAgICogRW5hYmxlcyBvciBkaXNhYmxlcyBsZXZlbCBjYXBwaW5nLiBJZiBkaXNhYmxlZCBhZnRlciBwcmV2aW91c2x5IGVuYWJsZWQsIGBuZXh0TGV2ZWxTd2l0Y2hgIHdpbGwgYmUgaW1tZWRpYXRlbHkgY2FsbGVkLlxuICAgKi9cbiAgc2V0IGNhcExldmVsVG9QbGF5ZXJTaXplKHNob3VsZFN0YXJ0Q2FwcGluZykge1xuICAgIGNvbnN0IG5ld0NhcExldmVsVG9QbGF5ZXJTaXplID0gISFzaG91bGRTdGFydENhcHBpbmc7XG4gICAgaWYgKG5ld0NhcExldmVsVG9QbGF5ZXJTaXplICE9PSB0aGlzLmNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZSkge1xuICAgICAgaWYgKG5ld0NhcExldmVsVG9QbGF5ZXJTaXplKSB7XG4gICAgICAgIHRoaXMuY2FwTGV2ZWxDb250cm9sbGVyLnN0YXJ0Q2FwcGluZygpOyAvLyBJZiBjYXBwaW5nIG9jY3VycywgbmV4dExldmVsU3dpdGNoIHdpbGwgaGFwcGVuIGJhc2VkIG9uIHNpemUuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNhcExldmVsQ29udHJvbGxlci5zdG9wQ2FwcGluZygpO1xuICAgICAgICB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSAtMTtcbiAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbFN3aXRjaCgpOyAvLyBOb3cgd2UncmUgdW5jYXBwZWQsIGdldCB0aGUgbmV4dCBsZXZlbCBhc2FwLlxuICAgICAgfVxuICAgICAgdGhpcy5jb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemUgPSBuZXdDYXBMZXZlbFRvUGxheWVyU2l6ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FwcGluZy9tYXggbGV2ZWwgdmFsdWUgdGhhdCBzaG91bGQgYmUgdXNlZCBieSBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uIGFsZ29yaXRobSAoYEFCUkNvbnRyb2xsZXJgKVxuICAgKi9cbiAgZ2V0IGF1dG9MZXZlbENhcHBpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F1dG9MZXZlbENhcHBpbmc7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBiYW5kd2lkdGggZXN0aW1hdGUgaW4gYml0cyBwZXIgc2Vjb25kLCB3aGVuIGF2YWlsYWJsZS4gT3RoZXJ3aXNlLCBgTmFOYCBpcyByZXR1cm5lZC5cbiAgICovXG4gIGdldCBiYW5kd2lkdGhFc3RpbWF0ZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBid0VzdGltYXRvclxuICAgIH0gPSB0aGlzLmFickNvbnRyb2xsZXI7XG4gICAgaWYgKCFid0VzdGltYXRvcikge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgcmV0dXJuIGJ3RXN0aW1hdG9yLmdldEVzdGltYXRlKCk7XG4gIH1cbiAgc2V0IGJhbmR3aWR0aEVzdGltYXRlKGFickV3bWFEZWZhdWx0RXN0aW1hdGUpIHtcbiAgICB0aGlzLmFickNvbnRyb2xsZXIucmVzZXRFc3RpbWF0b3IoYWJyRXdtYURlZmF1bHRFc3RpbWF0ZSk7XG4gIH1cblxuICAvKipcbiAgICogZ2V0IHRpbWUgdG8gZmlyc3QgYnl0ZSBlc3RpbWF0ZVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHR0ZmJFc3RpbWF0ZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBid0VzdGltYXRvclxuICAgIH0gPSB0aGlzLmFickNvbnRyb2xsZXI7XG4gICAgaWYgKCFid0VzdGltYXRvcikge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgcmV0dXJuIGJ3RXN0aW1hdG9yLmdldEVzdGltYXRlVFRGQigpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhcHBpbmcvbWF4IGxldmVsIHZhbHVlIHRoYXQgc2hvdWxkIGJlIHVzZWQgYnkgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbiBhbGdvcml0aG0gKGBBQlJDb250cm9sbGVyYClcbiAgICovXG4gIHNldCBhdXRvTGV2ZWxDYXBwaW5nKG5ld0xldmVsKSB7XG4gICAgaWYgKHRoaXMuX2F1dG9MZXZlbENhcHBpbmcgIT09IG5ld0xldmVsKSB7XG4gICAgICBsb2dnZXIubG9nKGBzZXQgYXV0b0xldmVsQ2FwcGluZzoke25ld0xldmVsfWApO1xuICAgICAgdGhpcy5fYXV0b0xldmVsQ2FwcGluZyA9IG5ld0xldmVsO1xuICAgICAgdGhpcy5sZXZlbENvbnRyb2xsZXIuY2hlY2tNYXhBdXRvVXBkYXRlZCgpO1xuICAgIH1cbiAgfVxuICBnZXQgbWF4SGRjcExldmVsKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXhIZGNwTGV2ZWw7XG4gIH1cbiAgc2V0IG1heEhkY3BMZXZlbCh2YWx1ZSkge1xuICAgIGlmIChpc0hkY3BMZXZlbCh2YWx1ZSkgJiYgdGhpcy5fbWF4SGRjcExldmVsICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5fbWF4SGRjcExldmVsID0gdmFsdWU7XG4gICAgICB0aGlzLmxldmVsQ29udHJvbGxlci5jaGVja01heEF1dG9VcGRhdGVkKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRydWUgd2hlbiBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uIGVuYWJsZWRcbiAgICovXG4gIGdldCBhdXRvTGV2ZWxFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5tYW51YWxMZXZlbCA9PT0gLTE7XG4gIH1cblxuICAvKipcbiAgICogTGV2ZWwgc2V0IG1hbnVhbGx5IChpZiBhbnkpXG4gICAqL1xuICBnZXQgbWFudWFsTGV2ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLm1hbnVhbExldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIG1pbiBsZXZlbCBzZWxlY3RhYmxlIGluIGF1dG8gbW9kZSBhY2NvcmRpbmcgdG8gY29uZmlnLm1pbkF1dG9CaXRyYXRlXG4gICAqL1xuICBnZXQgbWluQXV0b0xldmVsKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGxldmVscyxcbiAgICAgIGNvbmZpZzoge1xuICAgICAgICBtaW5BdXRvQml0cmF0ZVxuICAgICAgfVxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghbGV2ZWxzKSByZXR1cm4gMDtcbiAgICBjb25zdCBsZW4gPSBsZXZlbHMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChsZXZlbHNbaV0ubWF4Qml0cmF0ZSA+PSBtaW5BdXRvQml0cmF0ZSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvKipcbiAgICogbWF4IGxldmVsIHNlbGVjdGFibGUgaW4gYXV0byBtb2RlIGFjY29yZGluZyB0byBhdXRvTGV2ZWxDYXBwaW5nXG4gICAqL1xuICBnZXQgbWF4QXV0b0xldmVsKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGxldmVscyxcbiAgICAgIGF1dG9MZXZlbENhcHBpbmcsXG4gICAgICBtYXhIZGNwTGV2ZWxcbiAgICB9ID0gdGhpcztcbiAgICBsZXQgbWF4QXV0b0xldmVsO1xuICAgIGlmIChhdXRvTGV2ZWxDYXBwaW5nID09PSAtMSAmJiBsZXZlbHMgIT0gbnVsbCAmJiBsZXZlbHMubGVuZ3RoKSB7XG4gICAgICBtYXhBdXRvTGV2ZWwgPSBsZXZlbHMubGVuZ3RoIC0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWF4QXV0b0xldmVsID0gYXV0b0xldmVsQ2FwcGluZztcbiAgICB9XG4gICAgaWYgKG1heEhkY3BMZXZlbCkge1xuICAgICAgZm9yIChsZXQgaSA9IG1heEF1dG9MZXZlbDsgaS0tOykge1xuICAgICAgICBjb25zdCBoZGNwTGV2ZWwgPSBsZXZlbHNbaV0uYXR0cnNbJ0hEQ1AtTEVWRUwnXTtcbiAgICAgICAgaWYgKGhkY3BMZXZlbCAmJiBoZGNwTGV2ZWwgPD0gbWF4SGRjcExldmVsKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1heEF1dG9MZXZlbDtcbiAgfVxuICBnZXQgZmlyc3RBdXRvTGV2ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWJyQ29udHJvbGxlci5maXJzdEF1dG9MZXZlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBuZXh0IGF1dG9tYXRpY2FsbHkgc2VsZWN0ZWQgcXVhbGl0eSBsZXZlbFxuICAgKi9cbiAgZ2V0IG5leHRBdXRvTGV2ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWJyQ29udHJvbGxlci5uZXh0QXV0b0xldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIHRoaXMgc2V0dGVyIGlzIHVzZWQgdG8gZm9yY2UgbmV4dCBhdXRvIGxldmVsLlxuICAgKiB0aGlzIGlzIHVzZWZ1bCB0byBmb3JjZSBhIHN3aXRjaCBkb3duIGluIGF1dG8gbW9kZTpcbiAgICogaW4gY2FzZSBvZiBsb2FkIGVycm9yIG9uIGxldmVsIE4sIGhscy5qcyBjYW4gc2V0IG5leHRBdXRvTGV2ZWwgdG8gTi0xIGZvciBleGFtcGxlKVxuICAgKiBmb3JjZWQgdmFsdWUgaXMgdmFsaWQgZm9yIG9uZSBmcmFnbWVudC4gdXBvbiBzdWNjZXNzZnVsIGZyYWcgbG9hZGluZyBhdCBmb3JjZWQgbGV2ZWwsXG4gICAqIHRoaXMgdmFsdWUgd2lsbCBiZSByZXNldHRlZCB0byAtMSBieSBBQlIgY29udHJvbGxlci5cbiAgICovXG4gIHNldCBuZXh0QXV0b0xldmVsKG5leHRMZXZlbCkge1xuICAgIHRoaXMuYWJyQ29udHJvbGxlci5uZXh0QXV0b0xldmVsID0gbmV4dExldmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCB0aGUgZGF0ZXRpbWUgdmFsdWUgcmVsYXRpdmUgdG8gbWVkaWEuY3VycmVudFRpbWUgZm9yIHRoZSBhY3RpdmUgbGV2ZWwgUHJvZ3JhbSBEYXRlIFRpbWUgaWYgcHJlc2VudFxuICAgKi9cbiAgZ2V0IHBsYXlpbmdEYXRlKCkge1xuICAgIHJldHVybiB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuY3VycmVudFByb2dyYW1EYXRlVGltZTtcbiAgfVxuICBnZXQgbWFpbkZvcndhcmRCdWZmZXJJbmZvKCkge1xuICAgIHJldHVybiB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuZ2V0TWFpbkZ3ZEJ1ZmZlckluZm8oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIGFuZCBzZWxlY3QgdGhlIGJlc3QgbWF0Y2hpbmcgYXVkaW8gdHJhY2ssIG1ha2luZyBhIGxldmVsIHN3aXRjaCB3aGVuIGEgR3JvdXAgY2hhbmdlIGlzIG5lY2Vzc2FyeS5cbiAgICogVXBkYXRlcyBgaGxzLmNvbmZpZy5hdWRpb1ByZWZlcmVuY2VgLiBSZXR1cm5zIHRoZSBzZWxlY3RlZCB0cmFjaywgb3IgbnVsbCB3aGVuIG5vIG1hdGNoaW5nIHRyYWNrIGlzIGZvdW5kLlxuICAgKi9cbiAgc2V0QXVkaW9PcHRpb24oYXVkaW9PcHRpb24pIHtcbiAgICB2YXIgX3RoaXMkYXVkaW9UcmFja0NvbnRyO1xuICAgIHJldHVybiAoX3RoaXMkYXVkaW9UcmFja0NvbnRyID0gdGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGF1ZGlvVHJhY2tDb250ci5zZXRBdWRpb09wdGlvbihhdWRpb09wdGlvbik7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmQgYW5kIHNlbGVjdCB0aGUgYmVzdCBtYXRjaGluZyBzdWJ0aXRsZSB0cmFjaywgbWFraW5nIGEgbGV2ZWwgc3dpdGNoIHdoZW4gYSBHcm91cCBjaGFuZ2UgaXMgbmVjZXNzYXJ5LlxuICAgKiBVcGRhdGVzIGBobHMuY29uZmlnLnN1YnRpdGxlUHJlZmVyZW5jZWAuIFJldHVybnMgdGhlIHNlbGVjdGVkIHRyYWNrLCBvciBudWxsIHdoZW4gbm8gbWF0Y2hpbmcgdHJhY2sgaXMgZm91bmQuXG4gICAqL1xuICBzZXRTdWJ0aXRsZU9wdGlvbihzdWJ0aXRsZU9wdGlvbikge1xuICAgIHZhciBfdGhpcyRzdWJ0aXRsZVRyYWNrQ287XG4gICAgKF90aGlzJHN1YnRpdGxlVHJhY2tDbyA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXIpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRzdWJ0aXRsZVRyYWNrQ28uc2V0U3VidGl0bGVPcHRpb24oc3VidGl0bGVPcHRpb24pO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY29tcGxldGUgbGlzdCBvZiBhdWRpbyB0cmFja3MgYWNyb3NzIGFsbCBtZWRpYSBncm91cHNcbiAgICovXG4gIGdldCBhbGxBdWRpb1RyYWNrcygpIHtcbiAgICBjb25zdCBhdWRpb1RyYWNrQ29udHJvbGxlciA9IHRoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXI7XG4gICAgcmV0dXJuIGF1ZGlvVHJhY2tDb250cm9sbGVyID8gYXVkaW9UcmFja0NvbnRyb2xsZXIuYWxsQXVkaW9UcmFja3MgOiBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxpc3Qgb2Ygc2VsZWN0YWJsZSBhdWRpbyB0cmFja3NcbiAgICovXG4gIGdldCBhdWRpb1RyYWNrcygpIHtcbiAgICBjb25zdCBhdWRpb1RyYWNrQ29udHJvbGxlciA9IHRoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXI7XG4gICAgcmV0dXJuIGF1ZGlvVHJhY2tDb250cm9sbGVyID8gYXVkaW9UcmFja0NvbnRyb2xsZXIuYXVkaW9UcmFja3MgOiBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBpbmRleCBvZiB0aGUgc2VsZWN0ZWQgYXVkaW8gdHJhY2sgKGluZGV4IGluIGF1ZGlvIHRyYWNrIGxpc3RzKVxuICAgKi9cbiAgZ2V0IGF1ZGlvVHJhY2soKSB7XG4gICAgY29uc3QgYXVkaW9UcmFja0NvbnRyb2xsZXIgPSB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyO1xuICAgIHJldHVybiBhdWRpb1RyYWNrQ29udHJvbGxlciA/IGF1ZGlvVHJhY2tDb250cm9sbGVyLmF1ZGlvVHJhY2sgOiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBzZWxlY3RzIGFuIGF1ZGlvIHRyYWNrLCBiYXNlZCBvbiBpdHMgaW5kZXggaW4gYXVkaW8gdHJhY2sgbGlzdHNcbiAgICovXG4gIHNldCBhdWRpb1RyYWNrKGF1ZGlvVHJhY2tJZCkge1xuICAgIGNvbnN0IGF1ZGlvVHJhY2tDb250cm9sbGVyID0gdGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlcjtcbiAgICBpZiAoYXVkaW9UcmFja0NvbnRyb2xsZXIpIHtcbiAgICAgIGF1ZGlvVHJhY2tDb250cm9sbGVyLmF1ZGlvVHJhY2sgPSBhdWRpb1RyYWNrSWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGdldCB0aGUgY29tcGxldGUgbGlzdCBvZiBzdWJ0aXRsZSB0cmFja3MgYWNyb3NzIGFsbCBtZWRpYSBncm91cHNcbiAgICovXG4gIGdldCBhbGxTdWJ0aXRsZVRyYWNrcygpIHtcbiAgICBjb25zdCBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gICAgcmV0dXJuIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID8gc3VidGl0bGVUcmFja0NvbnRyb2xsZXIuYWxsU3VidGl0bGVUcmFja3MgOiBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgYWx0ZXJuYXRlIHN1YnRpdGxlIHRyYWNrcyBsaXN0IGZyb20gcGxheWxpc3RcbiAgICovXG4gIGdldCBzdWJ0aXRsZVRyYWNrcygpIHtcbiAgICBjb25zdCBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gICAgcmV0dXJuIHN1YnRpdGxlVHJhY2tDb250cm9sbGVyID8gc3VidGl0bGVUcmFja0NvbnRyb2xsZXIuc3VidGl0bGVUcmFja3MgOiBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBpbmRleCBvZiB0aGUgc2VsZWN0ZWQgc3VidGl0bGUgdHJhY2sgKGluZGV4IGluIHN1YnRpdGxlIHRyYWNrIGxpc3RzKVxuICAgKi9cbiAgZ2V0IHN1YnRpdGxlVHJhY2soKSB7XG4gICAgY29uc3Qgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgIHJldHVybiBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA/IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnN1YnRpdGxlVHJhY2sgOiAtMTtcbiAgfVxuICBnZXQgbWVkaWEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21lZGlhO1xuICB9XG5cbiAgLyoqXG4gICAqIHNlbGVjdCBhbiBzdWJ0aXRsZSB0cmFjaywgYmFzZWQgb24gaXRzIGluZGV4IGluIHN1YnRpdGxlIHRyYWNrIGxpc3RzXG4gICAqL1xuICBzZXQgc3VidGl0bGVUcmFjayhzdWJ0aXRsZVRyYWNrSWQpIHtcbiAgICBjb25zdCBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gICAgaWYgKHN1YnRpdGxlVHJhY2tDb250cm9sbGVyKSB7XG4gICAgICBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlci5zdWJ0aXRsZVRyYWNrID0gc3VidGl0bGVUcmFja0lkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHN1YnRpdGxlIGRpc3BsYXkgaXMgZW5hYmxlZCBvciBub3RcbiAgICovXG4gIGdldCBzdWJ0aXRsZURpc3BsYXkoKSB7XG4gICAgY29uc3Qgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgIHJldHVybiBzdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA/IHN1YnRpdGxlVHJhY2tDb250cm9sbGVyLnN1YnRpdGxlRGlzcGxheSA6IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuYWJsZS9kaXNhYmxlIHN1YnRpdGxlIGRpc3BsYXkgcmVuZGVyaW5nXG4gICAqL1xuICBzZXQgc3VidGl0bGVEaXNwbGF5KHZhbHVlKSB7XG4gICAgY29uc3Qgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgIGlmIChzdWJ0aXRsZVRyYWNrQ29udHJvbGxlcikge1xuICAgICAgc3VidGl0bGVUcmFja0NvbnRyb2xsZXIuc3VidGl0bGVEaXNwbGF5ID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGdldCBtb2RlIGZvciBMb3ctTGF0ZW5jeSBITFMgbG9hZGluZ1xuICAgKi9cbiAgZ2V0IGxvd0xhdGVuY3lNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5sb3dMYXRlbmN5TW9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmFibGUvZGlzYWJsZSBMb3ctTGF0ZW5jeSBITFMgcGFydCBwbGF5bGlzdCBhbmQgc2VnbWVudCBsb2FkaW5nLCBhbmQgc3RhcnQgbGl2ZSBzdHJlYW1zIGF0IHBsYXlsaXN0IFBBUlQtSE9MRC1CQUNLIHJhdGhlciB0aGFuIEhPTEQtQkFDSy5cbiAgICovXG4gIHNldCBsb3dMYXRlbmN5TW9kZShtb2RlKSB7XG4gICAgdGhpcy5jb25maWcubG93TGF0ZW5jeU1vZGUgPSBtb2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIFBvc2l0aW9uIChpbiBzZWNvbmRzKSBvZiBsaXZlIHN5bmMgcG9pbnQgKGllIGVkZ2Ugb2YgbGl2ZSBwb3NpdGlvbiBtaW51cyBzYWZldHkgZGVsYXkgZGVmaW5lZCBieSBgYGBobHMuY29uZmlnLmxpdmVTeW5jRHVyYXRpb25gYGApXG4gICAqIEByZXR1cm5zIG51bGwgcHJpb3IgdG8gbG9hZGluZyBsaXZlIFBsYXlsaXN0XG4gICAqL1xuICBnZXQgbGl2ZVN5bmNQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5sYXRlbmN5Q29udHJvbGxlci5saXZlU3luY1Bvc2l0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEVzdGltYXRlZCBwb3NpdGlvbiAoaW4gc2Vjb25kcykgb2YgbGl2ZSBlZGdlIChpZSBlZGdlIG9mIGxpdmUgcGxheWxpc3QgcGx1cyB0aW1lIHN5bmMgcGxheWxpc3QgYWR2YW5jZWQpXG4gICAqIEByZXR1cm5zIDAgYmVmb3JlIGZpcnN0IHBsYXlsaXN0IGlzIGxvYWRlZFxuICAgKi9cbiAgZ2V0IGxhdGVuY3koKSB7XG4gICAgcmV0dXJuIHRoaXMubGF0ZW5jeUNvbnRyb2xsZXIubGF0ZW5jeTtcbiAgfVxuXG4gIC8qKlxuICAgKiBtYXhpbXVtIGRpc3RhbmNlIGZyb20gdGhlIGVkZ2UgYmVmb3JlIHRoZSBwbGF5ZXIgc2Vla3MgZm9yd2FyZCB0byBgYGBobHMubGl2ZVN5bmNQb3NpdGlvbmBgYFxuICAgKiBjb25maWd1cmVkIHVzaW5nIGBgYGxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudGBgYCAobXVsdGlwbGUgb2YgdGFyZ2V0IGR1cmF0aW9uKSBvciBgYGBsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uYGBgXG4gICAqIEByZXR1cm5zIDAgYmVmb3JlIGZpcnN0IHBsYXlsaXN0IGlzIGxvYWRlZFxuICAgKi9cbiAgZ2V0IG1heExhdGVuY3koKSB7XG4gICAgcmV0dXJuIHRoaXMubGF0ZW5jeUNvbnRyb2xsZXIubWF4TGF0ZW5jeTtcbiAgfVxuXG4gIC8qKlxuICAgKiB0YXJnZXQgZGlzdGFuY2UgZnJvbSB0aGUgZWRnZSBhcyBjYWxjdWxhdGVkIGJ5IHRoZSBsYXRlbmN5IGNvbnRyb2xsZXJcbiAgICovXG4gIGdldCB0YXJnZXRMYXRlbmN5KCkge1xuICAgIHJldHVybiB0aGlzLmxhdGVuY3lDb250cm9sbGVyLnRhcmdldExhdGVuY3k7XG4gIH1cblxuICAvKipcbiAgICogdGhlIHJhdGUgYXQgd2hpY2ggdGhlIGVkZ2Ugb2YgdGhlIGN1cnJlbnQgbGl2ZSBwbGF5bGlzdCBpcyBhZHZhbmNpbmcgb3IgMSBpZiB0aGVyZSBpcyBub25lXG4gICAqL1xuICBnZXQgZHJpZnQoKSB7XG4gICAgcmV0dXJuIHRoaXMubGF0ZW5jeUNvbnRyb2xsZXIuZHJpZnQ7XG4gIH1cblxuICAvKipcbiAgICogc2V0IHRvIHRydWUgd2hlbiBzdGFydExvYWQgaXMgY2FsbGVkIGJlZm9yZSBNQU5JRkVTVF9QQVJTRUQgZXZlbnRcbiAgICovXG4gIGdldCBmb3JjZVN0YXJ0TG9hZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLmZvcmNlU3RhcnRMb2FkO1xuICB9XG59XG5IbHMuZGVmYXVsdENvbmZpZyA9IHZvaWQgMDtcblxuZXhwb3J0IHsgQWJyQ29udHJvbGxlciwgQXR0ckxpc3QsIEF1ZGlvU3RyZWFtQ29udHJvbGxlciwgQXVkaW9UcmFja0NvbnRyb2xsZXIsIEJhc2VQbGF5bGlzdENvbnRyb2xsZXIsIEJhc2VTZWdtZW50LCBCYXNlU3RyZWFtQ29udHJvbGxlciwgQnVmZmVyQ29udHJvbGxlciwgQ01DRENvbnRyb2xsZXIsIENhcExldmVsQ29udHJvbGxlciwgQ2h1bmtNZXRhZGF0YSwgQ29udGVudFN0ZWVyaW5nQ29udHJvbGxlciwgRGF0ZVJhbmdlLCBFTUVDb250cm9sbGVyLCBFcnJvckFjdGlvbkZsYWdzLCBFcnJvckNvbnRyb2xsZXIsIEVycm9yRGV0YWlscywgRXJyb3JUeXBlcywgRXZlbnRzLCBGUFNDb250cm9sbGVyLCBGcmFnbWVudCwgSGxzLCBIbHNTa2lwLCBIbHNVcmxQYXJhbWV0ZXJzLCBLZXlTeXN0ZW1Gb3JtYXRzLCBLZXlTeXN0ZW1zLCBMZXZlbCwgTGV2ZWxEZXRhaWxzLCBMZXZlbEtleSwgTG9hZFN0YXRzLCBNZXRhZGF0YVNjaGVtYSwgTmV0d29ya0Vycm9yQWN0aW9uLCBQYXJ0LCBQbGF5bGlzdExldmVsVHlwZSwgU3VidGl0bGVTdHJlYW1Db250cm9sbGVyLCBTdWJ0aXRsZVRyYWNrQ29udHJvbGxlciwgVGltZWxpbmVDb250cm9sbGVyLCBIbHMgYXMgZGVmYXVsdCwgZ2V0TWVkaWFTb3VyY2UsIGlzTVNFU3VwcG9ydGVkLCBpc1N1cHBvcnRlZCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGxzLm1qcy5tYXBcbiJdLCJuYW1lcyI6WyJnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyIsIngiLCJfX2VzTW9kdWxlIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwidXJsVG9vbGtpdCIsImV4cG9ydHMiLCJtb2R1bGUiLCJyb290IiwiVVJMX1JFR0VYIiwiRklSU1RfU0VHTUVOVF9SRUdFWCIsIlNMQVNIX0RPVF9SRUdFWCIsIlNMQVNIX0RPVF9ET1RfUkVHRVgiLCJVUkxUb29sa2l0IiwiYnVpbGRBYnNvbHV0ZVVSTCIsImJhc2VVUkwiLCJyZWxhdGl2ZVVSTCIsIm9wdHMiLCJ0cmltIiwiYWx3YXlzTm9ybWFsaXplIiwiYmFzZVBhcnRzRm9yTm9ybWFsaXNlIiwicGFyc2VVUkwiLCJFcnJvciIsInBhdGgiLCJub3JtYWxpemVQYXRoIiwiYnVpbGRVUkxGcm9tUGFydHMiLCJyZWxhdGl2ZVBhcnRzIiwic2NoZW1lIiwiYmFzZVBhcnRzIiwibmV0TG9jIiwicGF0aFBhcnRzIiwiZXhlYyIsImJ1aWx0UGFydHMiLCJwYXJhbXMiLCJxdWVyeSIsImZyYWdtZW50IiwiYmFzZVVSTFBhdGgiLCJuZXdQYXRoIiwic3Vic3RyaW5nIiwibGFzdEluZGV4T2YiLCJ1cmwiLCJwYXJ0cyIsInNwbGl0IiwicmV2ZXJzZSIsImpvaW4iLCJyZXBsYWNlIiwibGVuZ3RoIiwidXJsVG9vbGtpdEV4cG9ydHMiLCJvd25LZXlzIiwiZSIsInIiLCJ0Iiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsIm8iLCJmaWx0ZXIiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwicHVzaCIsImFwcGx5IiwiX29iamVjdFNwcmVhZDIiLCJhcmd1bWVudHMiLCJmb3JFYWNoIiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJkZWZpbmVQcm9wZXJ0eSIsIl90b1ByaW1pdGl2ZSIsIlN5bWJvbCIsInRvUHJpbWl0aXZlIiwiaSIsIlR5cGVFcnJvciIsIlN0cmluZyIsIk51bWJlciIsIl90b1Byb3BlcnR5S2V5Iiwib2JqIiwia2V5IiwidmFsdWUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl9leHRlbmRzIiwiYXNzaWduIiwiYmluZCIsInRhcmdldCIsInNvdXJjZSIsImlzRmluaXRlTnVtYmVyIiwiaXNGaW5pdGUiLCJpc1NhZmVJbnRlZ2VyIiwiTWF0aCIsImFicyIsIk1BWF9TQUZFX0lOVEVHRVIiLCJFdmVudHMiLCJFcnJvclR5cGVzIiwiRXJyb3JEZXRhaWxzIiwibm9vcCIsImZha2VMb2dnZXIiLCJ0cmFjZSIsImRlYnVnIiwibG9nIiwid2FybiIsImluZm8iLCJlcnJvciIsImV4cG9ydGVkTG9nZ2VyIiwiY29uc29sZVByaW50Rm4iLCJ0eXBlIiwiZnVuYyIsInNlbGYiLCJjb25zb2xlIiwiZXhwb3J0TG9nZ2VyRnVuY3Rpb25zIiwiZGVidWdDb25maWciLCJmdW5jdGlvbnMiLCJlbmFibGVMb2dzIiwiaWQiLCJsb2dnZXIiLCJERUNJTUFMX1JFU09MVVRJT05fUkVHRVgiLCJBVFRSX0xJU1RfUkVHRVgiLCJBdHRyTGlzdCIsImNvbnN0cnVjdG9yIiwiYXR0cnMiLCJwYXJzZUF0dHJMaXN0IiwiY2xpZW50QXR0cnMiLCJhdHRyIiwiZGVjaW1hbEludGVnZXIiLCJhdHRyTmFtZSIsImludFZhbHVlIiwicGFyc2VJbnQiLCJJbmZpbml0eSIsImhleGFkZWNpbWFsSW50ZWdlciIsInN0cmluZ1ZhbHVlIiwic2xpY2UiLCJVaW50OEFycmF5IiwiaGV4YWRlY2ltYWxJbnRlZ2VyQXNOdW1iZXIiLCJkZWNpbWFsRmxvYXRpbmdQb2ludCIsInBhcnNlRmxvYXQiLCJvcHRpb25hbEZsb2F0IiwiZGVmYXVsdFZhbHVlIiwiZW51bWVyYXRlZFN0cmluZyIsImJvb2wiLCJkZWNpbWFsUmVzb2x1dGlvbiIsInJlcyIsInVuZGVmaW5lZCIsIndpZHRoIiwiaGVpZ2h0IiwiaW5wdXQiLCJtYXRjaCIsInF1b3RlIiwibGFzdEluZGV4IiwiaW5kZXhPZiIsIm5hbWUiLCJpc0RhdGVSYW5nZUN1ZUF0dHJpYnV0ZSIsImlzU0NURTM1QXR0cmlidXRlIiwiRGF0ZVJhbmdlIiwiZGF0ZVJhbmdlQXR0ciIsImRhdGVSYW5nZVdpdGhTYW1lSWQiLCJfc3RhcnREYXRlIiwiX2VuZERhdGUiLCJfYmFkVmFsdWVGb3JTYW1lSWQiLCJwcmV2aW91c0F0dHIiLCJJRCIsIkRhdGUiLCJlbmREYXRlIiwiZ2V0VGltZSIsImNsYXNzIiwiQ0xBU1MiLCJzdGFydERhdGUiLCJkdXJhdGlvbiIsInBsYW5uZWREdXJhdGlvbiIsImVuZE9uTmV4dCIsImlzVmFsaWQiLCJMb2FkU3RhdHMiLCJhYm9ydGVkIiwibG9hZGVkIiwicmV0cnkiLCJ0b3RhbCIsImNodW5rQ291bnQiLCJid0VzdGltYXRlIiwibG9hZGluZyIsInN0YXJ0IiwiZmlyc3QiLCJlbmQiLCJwYXJzaW5nIiwiYnVmZmVyaW5nIiwiRWxlbWVudGFyeVN0cmVhbVR5cGVzIiwiQVVESU8iLCJWSURFTyIsIkFVRElPVklERU8iLCJCYXNlU2VnbWVudCIsImJhc2V1cmwiLCJfYnl0ZVJhbmdlIiwiX3VybCIsInJlbHVybCIsImVsZW1lbnRhcnlTdHJlYW1zIiwic2V0Qnl0ZVJhbmdlIiwicHJldmlvdXMiLCJieXRlUmFuZ2VFbmRPZmZzZXQiLCJieXRlUmFuZ2UiLCJieXRlUmFuZ2VTdGFydE9mZnNldCIsIkZyYWdtZW50IiwiX2RlY3J5cHRkYXRhIiwicmF3UHJvZ3JhbURhdGVUaW1lIiwicHJvZ3JhbURhdGVUaW1lIiwidGFnTGlzdCIsInNuIiwibGV2ZWxrZXlzIiwibG9hZGVyIiwia2V5TG9hZGVyIiwibGV2ZWwiLCJjYyIsInN0YXJ0UFRTIiwiZW5kUFRTIiwic3RhcnREVFMiLCJlbmREVFMiLCJkZWx0YVBUUyIsIm1heFN0YXJ0UFRTIiwibWluRW5kUFRTIiwic3RhdHMiLCJkYXRhIiwiYml0cmF0ZVRlc3QiLCJ0aXRsZSIsImluaXRTZWdtZW50IiwiZW5kTGlzdCIsImdhcCIsInVybElkIiwiZGVjcnlwdGRhdGEiLCJOT05FIiwiaWRlbnRpdHkiLCJnZXREZWNyeXB0RGF0YSIsImtleUZvcm1hdHMiLCJlbmRQcm9ncmFtRGF0ZVRpbWUiLCJlbmNyeXB0ZWQiLCJfdGhpcyRfZGVjcnlwdGRhdGEiLCJsZW4iLCJzZXRLZXlGb3JtYXQiLCJrZXlGb3JtYXQiLCJhYm9ydFJlcXVlc3RzIiwiX3RoaXMkbG9hZGVyIiwiX3RoaXMka2V5TG9hZGVyIiwiYWJvcnQiLCJzZXRFbGVtZW50YXJ5U3RyZWFtSW5mbyIsInBhcnRpYWwiLCJtaW4iLCJtYXgiLCJjbGVhckVsZW1lbnRhcnlTdHJlYW1JbmZvIiwiUGFydCIsInBhcnRBdHRycyIsImZyYWciLCJpbmRleCIsImZyYWdPZmZzZXQiLCJpbmRlcGVuZGVudCIsImF1ZGlvIiwidmlkZW8iLCJhdWRpb3ZpZGVvIiwiREVGQVVMVF9UQVJHRVRfRFVSQVRJT04iLCJMZXZlbERldGFpbHMiLCJiYXNlVXJsIiwiUFRTS25vd24iLCJhbGlnbmVkU2xpZGluZyIsImF2ZXJhZ2V0YXJnZXRkdXJhdGlvbiIsImVuZENDIiwiZW5kU04iLCJmcmFnbWVudHMiLCJmcmFnbWVudEhpbnQiLCJwYXJ0TGlzdCIsImRhdGVSYW5nZXMiLCJsaXZlIiwiYWdlSGVhZGVyIiwiYWR2YW5jZWREYXRlVGltZSIsInVwZGF0ZWQiLCJhZHZhbmNlZCIsImF2YWlsYWJpbGl0eURlbGF5IiwibWlzc2VzIiwic3RhcnRDQyIsInN0YXJ0U04iLCJzdGFydFRpbWVPZmZzZXQiLCJ0YXJnZXRkdXJhdGlvbiIsInRvdGFsZHVyYXRpb24iLCJtM3U4IiwidmVyc2lvbiIsImNhbkJsb2NrUmVsb2FkIiwiY2FuU2tpcFVudGlsIiwiY2FuU2tpcERhdGVSYW5nZXMiLCJza2lwcGVkU2VnbWVudHMiLCJyZWNlbnRseVJlbW92ZWREYXRlcmFuZ2VzIiwicGFydEhvbGRCYWNrIiwiaG9sZEJhY2siLCJwYXJ0VGFyZ2V0IiwicHJlbG9hZEhpbnQiLCJyZW5kaXRpb25SZXBvcnRzIiwidHVuZUluR29hbCIsImRlbHRhVXBkYXRlRmFpbGVkIiwiZHJpZnRTdGFydFRpbWUiLCJkcmlmdEVuZFRpbWUiLCJkcmlmdFN0YXJ0IiwiZHJpZnRFbmQiLCJlbmNyeXB0ZWRGcmFnbWVudHMiLCJwbGF5bGlzdFBhcnNpbmdFcnJvciIsInZhcmlhYmxlTGlzdCIsImhhc1ZhcmlhYmxlUmVmcyIsInJlbG9hZGVkIiwicGFydFNuRGlmZiIsImxhc3RQYXJ0U24iLCJwYXJ0SW5kZXhEaWZmIiwibGFzdFBhcnRJbmRleCIsImZsb29yIiwiaGFzUHJvZ3JhbURhdGVUaW1lIiwibGV2ZWxUYXJnZXREdXJhdGlvbiIsImRyaWZ0IiwicnVuVGltZSIsInJ1bkR1cmF0aW9uIiwiZWRnZSIsInBhcnRFbmQiLCJmcmFnbWVudEVuZCIsIl90aGlzJHBhcnRMaXN0IiwiX3RoaXMkZnJhZ21lbnRzIiwiYWdlIiwibm93IiwiX3RoaXMkcGFydExpc3QyIiwiX3RoaXMkcGFydExpc3QzIiwiYmFzZTY0RGVjb2RlIiwiYmFzZTY0ZW5jb2RlZFN0ciIsImZyb20iLCJhdG9iIiwiYyIsImNoYXJDb2RlQXQiLCJnZXRLZXlJZEJ5dGVzIiwic3RyIiwia2V5SWRieXRlcyIsInN0clRvVXRmOGFycmF5Iiwic3ViYXJyYXkiLCJwYWRkZWRrZXlJZGJ5dGVzIiwic2V0IiwiY2hhbmdlRW5kaWFubmVzcyIsImtleUlkIiwic3dhcCIsImFycmF5IiwidG8iLCJjdXIiLCJjb252ZXJ0RGF0YVVyaVRvQXJyYXlCeXRlcyIsInVyaSIsImNvbG9uc3BsaXQiLCJrZXlkYXRhIiwic2VtaWNvbG9uc3BsaXQiLCJjb21tYXNwbGl0IiwiaXNiYXNlNjQiLCJzcGxpY2UiLCJ1bmVzY2FwZSIsImVuY29kZVVSSUNvbXBvbmVudCIsIm9wdGlvbmFsU2VsZiIsIktleVN5c3RlbXMiLCJDTEVBUktFWSIsIkZBSVJQTEFZIiwiUExBWVJFQURZIiwiV0lERVZJTkUiLCJLZXlTeXN0ZW1Gb3JtYXRzIiwia2V5U3lzdGVtRm9ybWF0VG9LZXlTeXN0ZW1Eb21haW4iLCJmb3JtYXQiLCJLZXlTeXN0ZW1JZHMiLCJrZXlTeXN0ZW1JZFRvS2V5U3lzdGVtRG9tYWluIiwic3lzdGVtSWQiLCJrZXlTeXN0ZW1Eb21haW5Ub0tleVN5c3RlbUZvcm1hdCIsImtleVN5c3RlbSIsImdldEtleVN5c3RlbXNGb3JDb25maWciLCJjb25maWciLCJkcm1TeXN0ZW1zIiwid2lkZXZpbmVMaWNlbnNlVXJsIiwia2V5U3lzdGVtc1RvQXR0ZW1wdCIsInJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyIsIl9vcHRpb25hbFNlbGYkbmF2aWdhdCIsIm5hdmlnYXRvciIsImdldFN1cHBvcnRlZE1lZGlhS2V5U3lzdGVtQ29uZmlndXJhdGlvbnMiLCJhdWRpb0NvZGVjcyIsInZpZGVvQ29kZWNzIiwiZHJtU3lzdGVtT3B0aW9ucyIsImluaXREYXRhVHlwZXMiLCJjcmVhdGVNZWRpYUtleVN5c3RlbUNvbmZpZ3VyYXRpb25zIiwiYmFzZUNvbmZpZyIsInBlcnNpc3RlbnRTdGF0ZSIsImRpc3RpbmN0aXZlSWRlbnRpZmllciIsInNlc3Npb25UeXBlcyIsInNlc3Npb25UeXBlIiwiYXVkaW9DYXBhYmlsaXRpZXMiLCJtYXAiLCJjb2RlYyIsImNvbnRlbnRUeXBlIiwicm9idXN0bmVzcyIsImF1ZGlvUm9idXN0bmVzcyIsImVuY3J5cHRpb25TY2hlbWUiLCJhdWRpb0VuY3J5cHRpb25TY2hlbWUiLCJ2aWRlb0NhcGFiaWxpdGllcyIsInZpZGVvUm9idXN0bmVzcyIsInZpZGVvRW5jcnlwdGlvblNjaGVtZSIsInNsaWNlVWludDgiLCJBcnJheSIsImlzSGVhZGVyJDIiLCJvZmZzZXQiLCJpc0Zvb3RlciIsImdldElEM0RhdGEiLCJmcm9udCIsInNpemUiLCJyZWFkU2l6ZSIsImNhblBhcnNlJDIiLCJnZXRUaW1lU3RhbXAiLCJmcmFtZXMiLCJnZXRJRDNGcmFtZXMiLCJmcmFtZSIsImlzVGltZVN0YW1wRnJhbWUiLCJyZWFkVGltZVN0YW1wIiwiZ2V0RnJhbWVEYXRhIiwiZnJvbUNoYXJDb2RlIiwiaWQzRGF0YSIsImZyYW1lRGF0YSIsImRlY29kZUZyYW1lIiwiZGVjb2RlUHJpdkZyYW1lIiwiZGVjb2RlVVJMRnJhbWUiLCJkZWNvZGVUZXh0RnJhbWUiLCJvd25lciIsInV0ZjhBcnJheVRvU3RyIiwicHJpdmF0ZURhdGEiLCJidWZmZXIiLCJkZXNjcmlwdGlvbiIsInRleHQiLCJ0aW1lU3RhbXBGcmFtZSIsImJ5dGVMZW5ndGgiLCJwdHMzM0JpdCIsInRpbWVzdGFtcCIsInJvdW5kIiwiZXhpdE9uTnVsbCIsImRlY29kZXIiLCJnZXRUZXh0RGVjb2RlciIsImRlY29kZWQiLCJkZWNvZGUiLCJpZHgiLCJjaGFyMiIsImNoYXIzIiwib3V0IiwidXNlckFnZW50IiwiaW5jbHVkZXMiLCJUZXh0RGVjb2RlciIsIkhleCIsImhleER1bXAiLCJoIiwidG9TdHJpbmciLCJVSU5UMzJfTUFYJDEiLCJwb3ciLCJSZW11eGVyVHJhY2tJZENvbmZpZyIsImlkMyIsImJpbjJzdHIiLCJyZWFkVWludDE2IiwidmFsIiwicmVhZFVpbnQzMiIsInJlYWRTaW50MzIiLCJ3cml0ZVVpbnQzMiIsImhhc01vb2ZEYXRhIiwiZmluZEJveCIsInJlc3VsdHMiLCJlbmRib3giLCJzdWJyZXN1bHRzIiwicGFyc2VTZWdtZW50SW5kZXgiLCJzaWR4IiwicmVmZXJlbmNlcyIsInRpbWVzY2FsZSIsImVhcmxpZXN0UHJlc2VudGF0aW9uVGltZSIsImZpcnN0T2Zmc2V0Iiwic3RhcnRCeXRlIiwicmVmZXJlbmNlc0NvdW50IiwicmVmZXJlbmNlSW5kZXgiLCJyZWZlcmVuY2VJbmZvIiwicmVmZXJlbmNlU2l6ZSIsInJlZmVyZW5jZVR5cGUiLCJzdWJzZWdtZW50RHVyYXRpb24iLCJwYXJzZUluaXRTZWdtZW50IiwicmVzdWx0IiwidHJha3MiLCJ0cmFrIiwidGtoZCIsInRyYWNrSWQiLCJtZGhkIiwiaGRsciIsImhkbHJUeXBlIiwic291biIsInZpZGUiLCJzdHNkIiwic3RzZERhdGEiLCJwYXJzZVN0c2QiLCJ0cmV4IiwidHJhY2siLCJkZWZhdWx0IiwiZmxhZ3MiLCJzYW1wbGVFbnRyaWVzIiwic2FtcGxlRW50cmllc0VuZCIsImZvdXJDQyIsImVuY0JveCIsImVuY0JveENoaWxkcmVuIiwic2luZnMiLCJzaW5mIiwic2NobSIsImZybWEiLCJhdmNDQm94IiwidG9IZXgiLCJjb2RlY0JveCIsImVzZHNCb3giLCJza2lwQkVSSW50ZWdlciIsIm9iamVjdFR5cGUiLCJmaXJzdEJ5dGUiLCJhdWRpb09iamVjdFR5cGUiLCJodmNDQm94IiwicHJvZmlsZUJ5dGUiLCJwcm9maWxlU3BhY2UiLCJnZW5lcmFsUHJvZmlsZUlkYyIsInByb2ZpbGVDb21wYXQiLCJ0aWVyRmxhZyIsImxldmVsSURDIiwiY29uc3RyYWludEluZGljYXRvciIsInRvVXBwZXJDYXNlIiwiY29uc3RyYWludFN0cmluZyIsImJ5dGUiLCJlbmNvZGVkQnl0ZSIsImR2Y0NCb3giLCJwcm9maWxlIiwiYWRkTGVhZGluZ1plcm8iLCJ2cGNDQm94IiwiYml0RGVwdGgiLCJhdjFDQm94IiwiaGlnaEJpdERlcHRoIiwidHdlbHZlQml0IiwibW9ub2Nocm9tZSIsImNocm9tYVN1YnNhbXBsaW5nWCIsImNocm9tYVN1YnNhbXBsaW5nWSIsImNocm9tYVNhbXBsZVBvc2l0aW9uIiwiY29sb3JQcmltYXJpZXMiLCJ0cmFuc2ZlckNoYXJhY3RlcmlzdGljcyIsIm1hdHJpeENvZWZmaWNpZW50cyIsInZpZGVvRnVsbFJhbmdlRmxhZyIsImJ5dGVzIiwibGltaXQiLCJudW0iLCJwYXRjaEVuY3lwdGlvbkRhdGEiLCJpc0NvbW1vbkVuY3J5cHRpb24iLCJlbmNCb3hlcyIsImlzQXVkaW8iLCJlbmMiLCJzaW5mQm94ZXMiLCJ0ZW5jIiwicGFyc2VTaW5mIiwidGVuY0tleUlkIiwic29tZSIsImIiLCJnZXRTdGFydERUUyIsImluaXREYXRhIiwiZm1wNCIsInJlZHVjZSIsInRyYWYiLCJ0ZmR0IiwidGZoZCIsImJhc2VUaW1lIiwic2NhbGUiLCJzdGFydFRpbWUiLCJnZXREdXJhdGlvbiIsInJhd0R1cmF0aW9uIiwidmlkZW9EdXJhdGlvbiIsImF1ZGlvRHVyYXRpb24iLCJ0cmFmcyIsInRyYWNrRGVmYXVsdCIsInRmaGRGbGFncyIsInNhbXBsZUR1cmF0aW9uIiwidHJ1bnMiLCJqIiwiY29tcHV0ZVJhd0R1cmF0aW9uRnJvbVNhbXBsZXMiLCJzYW1wbGVDb3VudCIsInNpZHhEdXJhdGlvbiIsInNpZHhzIiwiZHVyIiwicmVmIiwidHJ1biIsIm9mZnNldFN0YXJ0RFRTIiwidGltZU9mZnNldCIsImJhc2VNZWRpYURlY29kZVRpbWUiLCJ1cHBlciIsImxvd2VyIiwic2VnbWVudFZhbGlkUmFuZ2UiLCJzZWdtZW50ZWRSYW5nZSIsInZhbGlkIiwicmVtYWluZGVyIiwibW9vZnMiLCJsYXN0IiwiYnl0ZU9mZnNldCIsImFwcGVuZFVpbnQ4QXJyYXkiLCJkYXRhMSIsImRhdGEyIiwidGVtcCIsInBhcnNlU2FtcGxlcyIsInNlaVNhbXBsZXMiLCJ2aWRlb0RhdGEiLCJzYW1wbGVzIiwiaXNIRVZDRmxhdm9yIiwibW9vZiIsIm1vb2ZPZmZzZXQiLCJiYXNlRGF0YU9mZnNldFByZXNlbnQiLCJzYW1wbGVEZXNjcmlwdGlvbkluZGV4UHJlc2VudCIsImRlZmF1bHRTYW1wbGVEdXJhdGlvblByZXNlbnQiLCJkZWZhdWx0U2FtcGxlRHVyYXRpb24iLCJkZWZhdWx0U2FtcGxlU2l6ZVByZXNlbnQiLCJkZWZhdWx0U2FtcGxlU2l6ZSIsImRlZmF1bHRTYW1wbGVGbGFnc1ByZXNlbnQiLCJ0ZmhkT2Zmc2V0IiwiaXNIRVZDIiwiZGF0YU9mZnNldFByZXNlbnQiLCJkYXRhT2Zmc2V0IiwiZmlyc3RTYW1wbGVGbGFnc1ByZXNlbnQiLCJzYW1wbGVEdXJhdGlvblByZXNlbnQiLCJzYW1wbGVTaXplUHJlc2VudCIsInNhbXBsZVNpemUiLCJzYW1wbGVGbGFnc1ByZXNlbnQiLCJzYW1wbGVDb21wb3NpdGlvbk9mZnNldHNQcmVzZW50IiwiY29tcG9zaXRpb25PZmZzZXQiLCJ0cnVuT2Zmc2V0Iiwic2FtcGxlT2Zmc2V0IiwiaXgiLCJuYWx1VG90YWxTaXplIiwibmFsdVNpemUiLCJpc1NFSU1lc3NhZ2UiLCJwYXJzZVNFSU1lc3NhZ2VGcm9tTkFMdSIsImRlbGltaXQiLCJiYXNlQ29kZWMiLCJuYWx1SGVhZGVyIiwibmFsdVR5cGUiLCJ1bmVzY2FwZWREYXRhIiwiaGVhZGVyU2l6ZSIsInB0cyIsImRpc2NhcmRFUEIiLCJzZWlQdHIiLCJwYXlsb2FkVHlwZSIsInBheWxvYWRTaXplIiwibGVmdE92ZXIiLCJwYXlQdHIiLCJjb3VudHJ5Q29kZSIsInByb3ZpZGVyQ29kZSIsInVzZXJTdHJ1Y3R1cmUiLCJ1c2VyRGF0YVR5cGUiLCJ0b3RhbENDcyIsImVuYWJsZWQiLCJ0b3RhbEJ5dGVzIiwiYnl0ZUFycmF5IiwidXVpZFN0ckFycmF5IiwiX2IiLCJ1c2VyRGF0YUJ5dGVzIiwidXVpZCIsInVzZXJEYXRhIiwiRVBCUG9zaXRpb25zIiwibmV3TGVuZ3RoIiwibmV3RGF0YSIsInNvdXJjZUluZGV4Iiwic2hpZnQiLCJwYXJzZUVtc2ciLCJzY2hlbWVJZFVyaSIsInRpbWVTY2FsZSIsInByZXNlbnRhdGlvblRpbWVEZWx0YSIsInByZXNlbnRhdGlvblRpbWUiLCJldmVudER1cmF0aW9uIiwibGVmdFByZXNlbnRhdGlvblRpbWUiLCJyaWdodFByZXNlbnRhdGlvblRpbWUiLCJwYXlsb2FkIiwibXA0Qm94IiwibXA0cHNzaCIsImtleWlkcyIsIlJhbmdlRXJyb3IiLCJraWRzIiwiayIsImtpZENvdW50IiwiRGF0YVZpZXciLCJzZXRVaW50MzIiLCJkYXRhU2l6ZSIsInBhcnNlUHNzaCIsIkFycmF5QnVmZmVyIiwidmlldyIsImJveFNpemUiLCJnZXRVaW50MzIiLCJkYXRhU2l6ZU9yS2lkQ291bnQiLCJrZXlVcmlUb0tleUlkTWFwIiwiTGV2ZWxLZXkiLCJjbGVhcktleVVyaVRvS2V5SWRNYXAiLCJtZXRob2QiLCJmb3JtYXR2ZXJzaW9ucyIsIml2Iiwia2V5Rm9ybWF0VmVyc2lvbnMiLCJwc3NoIiwiaXNTdXBwb3J0ZWQiLCJjcmVhdGVJbml0aWFsaXphdGlvblZlY3RvciIsImtleUJ5dGVzIiwiUGxheVJlYWR5S2V5U3lzdGVtVVVJRCIsImtleUJ5dGVzVXRmMTYiLCJVaW50MTZBcnJheSIsImtleUJ5dGVTdHIiLCJ4bWxLZXlCeXRlcyIsInBhcnNlciIsIkRPTVBhcnNlciIsInhtbERvYyIsInBhcnNlRnJvbVN0cmluZyIsImtleURhdGEiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImNoaWxkTm9kZXMiLCJub2RlVmFsdWUiLCJnZXRBdHRyaWJ1dGUiLCJrZXlJZEFycmF5IiwicGFkZGVkIiwiZHYiLCJzZWdtZW50TnVtYmVyIiwidWludDhWaWV3IiwiVkFSSUFCTEVfUkVQTEFDRU1FTlRfUkVHRVgiLCJoYXNWYXJpYWJsZVJlZmVyZW5jZXMiLCJ0ZXN0Iiwic3Vic3RpdHV0ZVZhcmlhYmxlc0luQXR0cmlidXRlcyIsInBhcnNlZCIsImF0dHJpYnV0ZU5hbWVzIiwic3Vic3RpdHV0ZVZhcmlhYmxlcyIsInZhcmlhYmxlUmVmZXJlbmNlIiwidmFyaWFibGVOYW1lIiwidmFyaWFibGVWYWx1ZSIsImFkZFZhcmlhYmxlRGVmaW5pdGlvbiIsInBhcmVudFVybCIsIk5BTUUiLCJWQUxVRSIsIlFVRVJZUEFSQU0iLCJzZWFyY2hQYXJhbXMiLCJVUkwiLCJoYXMiLCJnZXQiLCJtZXNzYWdlIiwiaW1wb3J0VmFyaWFibGVEZWZpbml0aW9uIiwic291cmNlVmFyaWFibGVMaXN0IiwiSU1QT1JUIiwiZ2V0TWVkaWFTb3VyY2UiLCJwcmVmZXJNYW5hZ2VkTWVkaWFTb3VyY2UiLCJtbXMiLCJNZWRpYVNvdXJjZSIsIk1hbmFnZWRNZWRpYVNvdXJjZSIsIldlYktpdE1lZGlhU291cmNlIiwic2FtcGxlRW50cnlDb2Rlc0lTTyIsImEzZHMiLCJhbGFjIiwiYWxhdyIsImRyYTEiLCJkdHNjIiwiZHRzZSIsImR0c2giLCJlbmNhIiwiZkxhQyIsImZsYWMiLCJGTEFDIiwiZzcxOSIsImc3MjYiLCJtNGFlIiwibWhhMSIsIm1oYTIiLCJtaG0xIiwibWhtMiIsIm1scGEiLCJtcDRhIiwiT3B1cyIsIm9wdXMiLCJzYW1yIiwic2F3YiIsInNhd3AiLCJzZXZjIiwic3FjcCIsInNzbXYiLCJ0d29zIiwidWxhdyIsImF2YzEiLCJhdmMyIiwiYXZjMyIsImF2YzQiLCJhdmNwIiwiYXYwMSIsImRyYWMiLCJkdmExIiwiZHZhdiIsImR2aDEiLCJkdmhlIiwiZW5jdiIsImhldjEiLCJodmMxIiwibWpwMiIsIm1wNHYiLCJtdmMxIiwibXZjMiIsIm12YzMiLCJtdmM0IiwicmVzdiIsInJ2NjAiLCJzMjYzIiwic3ZjMSIsInN2YzIiLCJ2cDA4IiwidnAwOSIsInN0cHAiLCJ3dnR0IiwiaXNDb2RlY1R5cGUiLCJ0eXBlQ29kZXMiLCJhcmVDb2RlY3NNZWRpYVNvdXJjZVN1cHBvcnRlZCIsImNvZGVjcyIsImlzQ29kZWNNZWRpYVNvdXJjZVN1cHBvcnRlZCIsIl9NZWRpYVNvdXJjZSRpc1R5cGVTdSIsImlzVHlwZVN1cHBvcnRlZCIsIm1pbWVUeXBlRm9yQ29kZWMiLCJ2aWRlb0NvZGVjUHJlZmVyZW5jZVZhbHVlIiwidmlkZW9Db2RlYyIsImNvZGVjc1NldFNlbGVjdGlvblByZWZlcmVuY2VWYWx1ZSIsImNvZGVjU2V0IiwicHJlZmVyZW5jZVZhbHVlIiwiQ09ERUNfQ09NUEFUSUJMRV9OQU1FUyIsImdldENvZGVjQ29tcGF0aWJsZU5hbWVMb3dlciIsImxvd2VyQ2FzZUNvZGVjIiwiY29kZWNzVG9DaGVjayIsIkFVRElPX0NPREVDX1JFR0VYUCIsImdldENvZGVjQ29tcGF0aWJsZU5hbWUiLCJtIiwidG9Mb3dlckNhc2UiLCJwaWNrTW9zdENvbXBsZXRlQ29kZWNOYW1lIiwicGFyc2VkQ29kZWMiLCJsZXZlbENvZGVjIiwiY29udmVydEFWQzFUb0FWQ09USSIsImF2Y2RhdGEiLCJNQVNURVJfUExBWUxJU1RfUkVHRVgiLCJNQVNURVJfUExBWUxJU1RfTUVESUFfUkVHRVgiLCJJU19NRURJQV9QTEFZTElTVCIsIkxFVkVMX1BMQVlMSVNUX1JFR0VYX0ZBU1QiLCJSZWdFeHAiLCJMRVZFTF9QTEFZTElTVF9SRUdFWF9TTE9XIiwiTTNVOFBhcnNlciIsImZpbmRHcm91cCIsImdyb3VwcyIsIm1lZGlhR3JvdXBJZCIsImdyb3VwIiwicmVzb2x2ZSIsImlzTWVkaWFQbGF5bGlzdCIsInBhcnNlTWFzdGVyUGxheWxpc3QiLCJzdHJpbmciLCJjb250ZW50U3RlZXJpbmciLCJsZXZlbHMiLCJzZXNzaW9uRGF0YSIsInNlc3Npb25LZXlzIiwibGV2ZWxzV2l0aEtub3duQ29kZWNzIiwiX2xldmVsJHVua25vd25Db2RlY3MiLCJiaXRyYXRlIiwicmVzb2x1dGlvbiIsInNldENvZGVjcyIsIkNPREVDUyIsInVua25vd25Db2RlY3MiLCJ0YWciLCJhdHRyaWJ1dGVzIiwic2Vzc2lvbkF0dHJzIiwiZGF0YUlkIiwic2Vzc2lvbktleSIsInBhcnNlS2V5IiwidmFyaWFibGVBdHRyaWJ1dGVzIiwiY29udGVudFN0ZWVyaW5nQXR0cmlidXRlcyIsInBhdGh3YXlJZCIsInBhcnNlU3RhcnRUaW1lT2Zmc2V0Iiwic3RyaXBVbmtub3duQ29kZWNMZXZlbHMiLCJwYXJzZU1hc3RlclBsYXlsaXN0TWVkaWEiLCJncm91cHNCeVR5cGUiLCJhdWRpb0NvZGVjIiwiU1VCVElUTEVTIiwidGV4dENvZGVjIiwiVFlQRSIsIm1lZGlhcyIsImxhbmciLCJMQU5HVUFHRSIsImFzc29jTGFuZyIsImNoYW5uZWxzIiwiQ0hBTk5FTFMiLCJjaGFyYWN0ZXJpc3RpY3MiLCJDSEFSQUNURVJJU1RJQ1MiLCJpbnN0cmVhbUlkIiwibWVkaWEiLCJncm91cElkIiwiYXV0b3NlbGVjdCIsImZvcmNlZCIsIlVSSSIsImdyb3VwQ29kZWMiLCJhc3NpZ25Db2RlYyIsInBhcnNlTGV2ZWxQbGF5bGlzdCIsImxldmVsVXJsSWQiLCJtdWx0aXZhcmlhbnRWYXJpYWJsZUxpc3QiLCJjdXJyZW50SW5pdFNlZ21lbnQiLCJjdXJyZW50U04iLCJjdXJyZW50UGFydCIsImRpc2NvbnRpbnVpdHlDb3VudGVyIiwicHJldkZyYWciLCJmaXJzdFBkdEluZGV4IiwiY3JlYXRlTmV4dEZyYWciLCJuZXh0Qnl0ZVJhbmdlIiwic2V0RnJhZ0xldmVsS2V5cyIsImFzc2lnblByb2dyYW1EYXRlVGltZSIsInZhbHVlMSIsInZhbHVlMiIsInNraXBBdHRycyIsIl9pIiwidW5zaGlmdCIsImRhdGVSYW5nZSIsImxldmVsS2V5IiwibWFwQXR0cnMiLCJpbml0Iiwic2V0SW5pdFNlZ21lbnQiLCJzZXJ2ZXJDb250cm9sQXR0cnMiLCJwYXJ0SW5mQXR0cnMiLCJwcmV2aW91c0ZyYWdtZW50UGFydCIsInBhcnQiLCJwcmVsb2FkSGludEF0dHJzIiwicmVuZGl0aW9uUmVwb3J0QXR0cnMiLCJwb3AiLCJmcmFnbWVudExlbmd0aCIsImZpcnN0RnJhZ21lbnQiLCJsYXN0RnJhZ21lbnQiLCJsYXN0U24iLCJiYWNrZmlsbFByb2dyYW1EYXRlVGltZXMiLCJrZXlUYWdBdHRyaWJ1dGVzIiwiX2tleUF0dHJzJE1FVEhPRCIsIl9rZXlBdHRycyRLRVlGT1JNQVQiLCJrZXlBdHRycyIsImRlY3J5cHRtZXRob2QiLCJNRVRIT0QiLCJkZWNyeXB0dXJpIiwiZGVjcnlwdGl2IiwiZGVjcnlwdGtleWZvcm1hdHZlcnNpb25zIiwiS0VZRk9STUFUVkVSU0lPTlMiLCJkZWNyeXB0a2V5Zm9ybWF0IiwiS0VZRk9STUFUIiwiSVYiLCJyZXNvbHZlZFVyaSIsInN0YXJ0QXR0cmlidXRlcyIsInN0YXJ0QXR0cnMiLCJjb2RlY3NBdHRyaWJ1dGVWYWx1ZSIsImZpbHRlcmVkIiwiZ3JvdXBJdGVtIiwiY29kZWNQcm9wZXJ0eSIsImNvZGVjVmFsdWUiLCJmcmFnUHJldiIsInBhcnNlIiwiQllURVJBTkdFIiwiUGxheWxpc3RDb250ZXh0VHlwZSIsIk1BTklGRVNUIiwiTEVWRUwiLCJBVURJT19UUkFDSyIsIlNVQlRJVExFX1RSQUNLIiwiUGxheWxpc3RMZXZlbFR5cGUiLCJNQUlOIiwiU1VCVElUTEUiLCJtYXBDb250ZXh0VG9MZXZlbFR5cGUiLCJjb250ZXh0IiwiZ2V0UmVzcG9uc2VVcmwiLCJyZXNwb25zZSIsIlBsYXlsaXN0TG9hZGVyIiwiaGxzIiwibG9hZGVycyIsImNyZWF0ZSIsInJlZ2lzdGVyTGlzdGVuZXJzIiwic3RhcnRMb2FkIiwic3RhcnRQb3NpdGlvbiIsInN0b3BMb2FkIiwiZGVzdHJveUludGVybmFsTG9hZGVycyIsIm9uIiwiTUFOSUZFU1RfTE9BRElORyIsIm9uTWFuaWZlc3RMb2FkaW5nIiwiTEVWRUxfTE9BRElORyIsIm9uTGV2ZWxMb2FkaW5nIiwiQVVESU9fVFJBQ0tfTE9BRElORyIsIm9uQXVkaW9UcmFja0xvYWRpbmciLCJTVUJUSVRMRV9UUkFDS19MT0FESU5HIiwib25TdWJ0aXRsZVRyYWNrTG9hZGluZyIsInVucmVnaXN0ZXJMaXN0ZW5lcnMiLCJvZmYiLCJjcmVhdGVJbnRlcm5hbExvYWRlciIsIlBMb2FkZXIiLCJwTG9hZGVyIiwiTG9hZGVyIiwiSW50ZXJuYWxMb2FkZXIiLCJnZXRJbnRlcm5hbExvYWRlciIsInJlc2V0SW50ZXJuYWxMb2FkZXIiLCJjb250ZXh0VHlwZSIsImRlc3Ryb3kiLCJldmVudCIsImxvYWQiLCJyZXNwb25zZVR5cGUiLCJkZWxpdmVyeURpcmVjdGl2ZXMiLCJfY29udGV4dCRkZWxpdmVyeURpcmUiLCJsb2FkZXJDb250ZXh0IiwibG9hZFBvbGljeSIsIm1hbmlmZXN0TG9hZFBvbGljeSIsInBsYXlsaXN0TG9hZFBvbGljeSIsInRpbWVvdXRSZXRyeSIsImVycm9yUmV0cnkiLCJsZXZlbERldGFpbHMiLCJkZXRhaWxzIiwiYXVkaW9UcmFja3MiLCJzdWJ0aXRsZVRyYWNrcyIsInRhcmdldER1cmF0aW9uIiwibWF4TG93TGF0ZW5jeVBsYXlsaXN0UmVmcmVzaCIsIm1heFRpbWVUb0ZpcnN0Qnl0ZU1zIiwibWF4TG9hZFRpbWVNcyIsImxlZ2FjeVJldHJ5Q29tcGF0aWJpbGl0eSIsImxvYWRlckNvbmZpZyIsInRpbWVvdXQiLCJtYXhSZXRyeSIsIm1heE51bVJldHJ5IiwicmV0cnlEZWxheSIsInJldHJ5RGVsYXlNcyIsIm1heFJldHJ5RGVsYXkiLCJtYXhSZXRyeURlbGF5TXMiLCJsb2FkZXJDYWxsYmFja3MiLCJvblN1Y2Nlc3MiLCJuZXR3b3JrRGV0YWlscyIsImhhbmRsZU1hbmlmZXN0UGFyc2luZ0Vycm9yIiwicGVyZm9ybWFuY2UiLCJoYW5kbGVUcmFja09yTGV2ZWxQbGF5bGlzdCIsImhhbmRsZU1hc3RlclBsYXlsaXN0Iiwib25FcnJvciIsImhhbmRsZU5ldHdvcmtFcnJvciIsIm9uVGltZW91dCIsInBhcnNlZFJlc3VsdCIsInN1YnRpdGxlcyIsImNhcHRpb25zIiwiZW1iZWRkZWRBdWRpb0ZvdW5kIiwiYXVkaW9UcmFjayIsInRyaWdnZXIiLCJNQU5JRkVTVF9MT0FERUQiLCJsZXZlbElkIiwibGV2ZWxUeXBlIiwic2luZ2xlTGV2ZWwiLCJoYW5kbGVQbGF5bGlzdExvYWRlZCIsIkVSUk9SIiwiTkVUV09SS19FUlJPUiIsIk1BTklGRVNUX1BBUlNJTkdfRVJST1IiLCJmYXRhbCIsImVyciIsInJlYXNvbiIsImNvZGUiLCJVTktOT1dOIiwiTUFOSUZFU1RfTE9BRF9USU1FT1VUIiwiTUFOSUZFU1RfTE9BRF9FUlJPUiIsIkxFVkVMX0xPQURfVElNRU9VVCIsIkxFVkVMX0xPQURfRVJST1IiLCJBVURJT19UUkFDS19MT0FEX1RJTUVPVVQiLCJBVURJT19UUkFDS19MT0FEX0VSUk9SIiwiU1VCVElUTEVfVFJBQ0tfTE9BRF9USU1FT1VUIiwiU1VCVElUTEVfTE9BRF9FUlJPUiIsImVycm9yRGF0YSIsInBhcmVudCIsImxldmVsSW5kZXgiLCJfZXJyb3IiLCJMRVZFTF9FTVBUWV9FUlJPUiIsIkxFVkVMX1BBUlNJTkdfRVJST1IiLCJnZXRDYWNoZUFnZSIsImlzTmFOIiwiTEVWRUxfTE9BREVEIiwiQVVESU9fVFJBQ0tfTE9BREVEIiwiU1VCVElUTEVfVFJBQ0tfTE9BREVEIiwic2VuZEFkZFRyYWNrRXZlbnQiLCJ2aWRlb0VsIiwiRXZlbnQiLCJkb2N1bWVudCIsImNyZWF0ZUV2ZW50IiwiaW5pdEV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsImFkZEN1ZVRvVHJhY2siLCJjdWUiLCJtb2RlIiwiY3VlcyIsImdldEN1ZUJ5SWQiLCJhZGRDdWUiLCJ0ZXh0VHJhY2tDdWUiLCJUZXh0VHJhY2tDdWUiLCJlbmRUaW1lIiwiZXJyMiIsImNsZWFyQ3VycmVudEN1ZXMiLCJyZW1vdmVDdWUiLCJyZW1vdmVDdWVzSW5SYW5nZSIsInByZWRpY2F0ZSIsImdldEN1ZXNJblJhbmdlIiwiZ2V0Rmlyc3RDdWVJbmRleEFmdGVyVGltZSIsInRpbWUiLCJsZWZ0IiwicmlnaHQiLCJtaWQiLCJjdWVzRm91bmQiLCJmaXJzdEN1ZUluUmFuZ2UiLCJmaWx0ZXJTdWJ0aXRsZVRyYWNrcyIsInRleHRUcmFja0xpc3QiLCJ0cmFja3MiLCJraW5kIiwibGFiZWwiLCJNZXRhZGF0YVNjaGVtYSIsImF1ZGlvSWQzIiwiZW1zZyIsIk1JTl9DVUVfRFVSQVRJT04iLCJnZXRDdWVDbGFzcyIsIlZUVEN1ZSIsImNyZWF0ZUN1ZVdpdGhEYXRhRmllbGRzIiwiQ3VlIiwiSlNPTiIsInN0cmluZ2lmeSIsIk1BWF9DVUVfRU5EVElNRSIsIlBPU0lUSVZFX0lORklOSVRZIiwiTUFYX1ZBTFVFIiwiZGF0ZVJhbmdlRGF0ZVRvVGltZWxpbmVTZWNvbmRzIiwiZGF0ZSIsImhleFRvQXJyYXlCdWZmZXIiLCJJRDNUcmFja0NvbnRyb2xsZXIiLCJpZDNUcmFjayIsImRhdGVSYW5nZUN1ZXNBcHBlbmRlZCIsIl9yZWdpc3Rlckxpc3RlbmVycyIsIl91bnJlZ2lzdGVyTGlzdGVuZXJzIiwiTUVESUFfQVRUQUNIRUQiLCJvbk1lZGlhQXR0YWNoZWQiLCJNRURJQV9ERVRBQ0hJTkciLCJvbk1lZGlhRGV0YWNoaW5nIiwiRlJBR19QQVJTSU5HX01FVEFEQVRBIiwib25GcmFnUGFyc2luZ01ldGFkYXRhIiwiQlVGRkVSX0ZMVVNISU5HIiwib25CdWZmZXJGbHVzaGluZyIsIkxFVkVMX1VQREFURUQiLCJvbkxldmVsVXBkYXRlZCIsImNyZWF0ZVRyYWNrIiwiZ2V0SUQzVHJhY2siLCJ0ZXh0VHJhY2tzIiwidGV4dFRyYWNrIiwiYWRkVGV4dFRyYWNrIiwiZW5hYmxlRW1zZ01ldGFkYXRhQ3VlcyIsImVuYWJsZUlEM01ldGFkYXRhQ3VlcyIsInRpbWVEaWZmIiwidXBkYXRlSWQzQ3VlRW5kcyIsIl90aGlzJGlkM1RyYWNrIiwic3RhcnRPZmZzZXQiLCJlbmRPZmZzZXQiLCJlbmFibGVEYXRlUmFuZ2VNZXRhZGF0YUN1ZXMiLCJpZHMiLCJpZHNUb1JlbW92ZSIsImRhdGVUaW1lT2Zmc2V0IiwiYXBwZW5kZWREYXRlUmFuZ2VDdWVzIiwiZHVyYXRpb25Lbm93biIsIm5leHREYXRlUmFuZ2VXaXRoU2FtZUNsYXNzIiwiY2FuZGlkYXRlRGF0ZVJhbmdlIiwib3RoZXJEYXRlUmFuZ2UiLCJfY3VlIiwiTGF0ZW5jeUNvbnRyb2xsZXIiLCJjdXJyZW50VGltZSIsInN0YWxsQ291bnQiLCJfbGF0ZW5jeSIsInRpbWV1cGRhdGVIYW5kbGVyIiwidGltZXVwZGF0ZSIsImxhdGVuY3kiLCJtYXhMYXRlbmN5IiwibGl2ZU1heExhdGVuY3lEdXJhdGlvbiIsImxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCIsInRhcmdldExhdGVuY3kiLCJsaXZlU3luY0R1cmF0aW9uIiwibGl2ZVN5bmNEdXJhdGlvbkNvdW50IiwibG93TGF0ZW5jeU1vZGUiLCJ1c2VyQ29uZmlnIiwibWF4TGl2ZVN5bmNPblN0YWxsSW5jcmVhc2UiLCJsaXZlU3luY09uU3RhbGxJbmNyZWFzZSIsImxpdmVTeW5jUG9zaXRpb24iLCJsaXZlRWRnZSIsImVzdGltYXRlTGl2ZUVkZ2UiLCJzeW5jUG9zaXRpb24iLCJlZGdlU3RhbGxlZCIsIm1heExldmVsVXBkYXRlQWdlIiwiZm9yd2FyZEJ1ZmZlckxlbmd0aCIsImJ1ZmZlcmVkUmFuZ2VzIiwiYnVmZmVyZWQiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIl90aGlzJGxldmVsRGV0YWlscyIsIkJVRkZFUl9TVEFMTEVEX0VSUk9SIiwiY29tcHV0ZUxhdGVuY3kiLCJtYXhMaXZlU3luY1BsYXliYWNrUmF0ZSIsImRpc3RhbmNlRnJvbVRhcmdldCIsImxpdmVNaW5MYXRlbmN5RHVyYXRpb24iLCJpbkxpdmVSYW5nZSIsInJhdGUiLCJleHAiLCJwbGF5YmFja1JhdGUiLCJIZGNwTGV2ZWxzIiwiaXNIZGNwTGV2ZWwiLCJWaWRlb1JhbmdlVmFsdWVzIiwiaXNWaWRlb1JhbmdlIiwiSGxzU2tpcCIsIk5vIiwiWWVzIiwidjIiLCJnZXRTa2lwVmFsdWUiLCJtc24iLCJzbkNoYW5nZUdvYWwiLCJIbHNVcmxQYXJhbWV0ZXJzIiwic2tpcCIsImFkZERpcmVjdGl2ZXMiLCJocmVmIiwiTGV2ZWwiLCJfYXR0cnMiLCJmcmFtZVJhdGUiLCJmcmFnbWVudEVycm9yIiwibG9hZEVycm9yIiwicmVhbEJpdHJhdGUiLCJzdXBwb3J0ZWRQcm9taXNlIiwic3VwcG9ydGVkUmVzdWx0IiwiX2F2Z0JpdHJhdGUiLCJfYXVkaW9Hcm91cHMiLCJfc3VidGl0bGVHcm91cHMiLCJfdXJsSWQiLCJzIiwiYWRkR3JvdXBJZCIsIm1heEJpdHJhdGUiLCJhdmVyYWdlQml0cmF0ZSIsInZpZGVvUmFuZ2UiLCJzY29yZSIsImhhc0F1ZGlvR3JvdXAiLCJoYXNHcm91cCIsImhhc1N1YnRpdGxlR3JvdXAiLCJhdWRpb0dyb3VwcyIsInN1YnRpdGxlR3JvdXBzIiwiYXVkaW9Hcm91cElkcyIsImF1ZGlvR3JvdXBJZCIsInRleHRHcm91cElkcyIsInRleHRHcm91cElkIiwiX3RoaXMkYXVkaW9Hcm91cHMiLCJfdGhpcyRzdWJ0aXRsZUdyb3VwcyIsImFkZEZhbGxiYWNrIiwidXBkYXRlRnJvbVRvUFRTIiwiZnJhZ0Zyb20iLCJmcmFnVG8iLCJmcmFnVG9QVFMiLCJjb250aWd1b3VzIiwidXBkYXRlRnJhZ1BUU0RUUyIsInBhcnNlZE1lZGlhRHVyYXRpb24iLCJmcmFnU3RhcnRQdHMiLCJmcmFnRW5kUHRzIiwiZnJhZ0lkeCIsIm1lcmdlRGV0YWlscyIsIm9sZERldGFpbHMiLCJuZXdEZXRhaWxzIiwib2xkRnJhZ21lbnRzIiwib2xkSW5pdCIsImNjT2Zmc2V0IiwiUFRTRnJhZyIsIm1hcEZyYWdtZW50SW50ZXJzZWN0aW9uIiwib2xkRnJhZyIsIm5ld0ZyYWciLCJmcmFnbWVudHNUb0NoZWNrIiwiY29uY2F0IiwiX2N1cnJlbnRJbml0U2VnbWVudCIsIm1lcmdlRGF0ZVJhbmdlcyIsIm5ld0ZyYWdtZW50cyIsIm1hcFBhcnRJbnRlcnNlY3Rpb24iLCJvbGRQYXJ0IiwibmV3UGFydCIsImFkanVzdFNsaWRpbmciLCJvbGREYXRlUmFuZ2VzIiwiZGVsdGFEYXRlUmFuZ2VzIiwib2xkUGFydHMiLCJuZXdQYXJ0cyIsImludGVyc2VjdGlvbkZuIiwiZGVsdGEiLCJuZXdGcmFncyIsIm9sZEZyYWdzIiwiYWRkU2xpZGluZyIsImNvbXB1dGVSZWxvYWRJbnRlcnZhbCIsImRpc3RhbmNlVG9MaXZlRWRnZU1zIiwicmVsb2FkSW50ZXJ2YWwiLCJsaXZlRWRnZU1heFRhcmdldER1cmF0aW9ucyIsImxhc3RTZWdtZW50RHVyYXRpb24iLCJnZXRGcmFnbWVudFdpdGhTTiIsImZyYWdDdXJyZW50IiwiZ2V0UGFydFdpdGgiLCJwYXJ0SW5kZXgiLCJfbGV2ZWwkZGV0YWlscyIsImZpbmRQYXJ0IiwicmVhc3NpZ25GcmFnbWVudExldmVsSW5kZXhlcyIsImlzVGltZW91dEVycm9yIiwiRlJBR19MT0FEX1RJTUVPVVQiLCJLRVlfTE9BRF9USU1FT1VUIiwiZ2V0UmV0cnlDb25maWciLCJpc1RpbWVvdXQiLCJnZXRSZXRyeURlbGF5IiwicmV0cnlDb25maWciLCJyZXRyeUNvdW50IiwiYmFja29mZkZhY3RvciIsImJhY2tvZmYiLCJnZXRMb2FkZXJDb25maWdXaXRob3V0UmV0aWVzIiwibG9kZXJDb25maWciLCJzaG91bGRSZXRyeSIsImxvYWRlclJlc3BvbnNlIiwiaHR0cFN0YXR1cyIsInJldHJ5Rm9ySHR0cFN0YXR1cyIsIm9uTGluZSIsIkJpbmFyeVNlYXJjaCIsInNlYXJjaCIsImxpc3QiLCJjb21wYXJpc29uRm4iLCJtaW5JbmRleCIsIm1heEluZGV4IiwiY3VycmVudEluZGV4IiwiY3VycmVudEVsZW1lbnQiLCJjb21wYXJpc29uUmVzdWx0IiwiZmluZEZyYWdtZW50QnlQRFQiLCJQRFRWYWx1ZSIsIm1heEZyYWdMb29rVXBUb2xlcmFuY2UiLCJpc0FycmF5Iiwic3RhcnRQRFQiLCJlbmRQRFQiLCJzZWciLCJwZHRXaXRoaW5Ub2xlcmFuY2VUZXN0IiwiZmluZEZyYWdtZW50QnlQVFMiLCJmcmFnUHJldmlvdXMiLCJidWZmZXJFbmQiLCJmcmFnTmV4dCIsImJ1ZmZlckVkZ2VFcnJvciIsImZyYWdtZW50V2l0aGluVG9sZXJhbmNlVGVzdCIsImZvdW5kRnJhZ21lbnQiLCJjYW5kaWRhdGUiLCJjYW5kaWRhdGVMb29rdXBUb2xlcmFuY2UiLCJwZHRCdWZmZXJFbmQiLCJmaW5kRnJhZ1dpdGhDQyIsIk5ldHdvcmtFcnJvckFjdGlvbiIsIkRvTm90aGluZyIsIlNlbmRFbmRDYWxsYmFjayIsIlNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3giLCJSZW1vdmVBbHRlcm5hdGVQZXJtYW5lbnRseSIsIkluc2VydERpc2NvbnRpbnVpdHkiLCJSZXRyeVJlcXVlc3QiLCJFcnJvckFjdGlvbkZsYWdzIiwiTm9uZSIsIk1vdmVBbGxBbHRlcm5hdGVzTWF0Y2hpbmdIb3N0IiwiTW92ZUFsbEFsdGVybmF0ZXNNYXRjaGluZ0hEQ1AiLCJTd2l0Y2hUb1NEUiIsIkVycm9yQ29udHJvbGxlciIsInBsYXlsaXN0RXJyb3IiLCJwZW5hbGl6ZWRSZW5kaXRpb25zIiwib25FcnJvck91dCIsImdldFZhcmlhbnRMZXZlbEluZGV4IiwibG9hZExldmVsIiwiX2RhdGEkZnJhZyIsIl9kYXRhJGxldmVsIiwiRlJBR19MT0FEX0VSUk9SIiwiS0VZX0xPQURfRVJST1IiLCJlcnJvckFjdGlvbiIsImdldEZyYWdSZXRyeU9yU3dpdGNoQWN0aW9uIiwiRlJBR19QQVJTSU5HX0VSUk9SIiwiYWN0aW9uIiwiRlJBR19HQVAiLCJGUkFHX0RFQ1JZUFRfRVJST1IiLCJfZGF0YSRjb250ZXh0IiwiX2RhdGEkY29udGV4dCRsZXZlbERlIiwiZ2V0UGxheWxpc3RSZXRyeU9yU3dpdGNoQWN0aW9uIiwibGV2ZWxSZXRyeSIsImdldExldmVsU3dpdGNoQWN0aW9uIiwiS0VZX1NZU1RFTV9TVEFUVVNfT1VUUFVUX1JFU1RSSUNURUQiLCJyZXN0cmljdGVkSGRjcExldmVsIiwiaGRjcExldmVsIiwia2V5U3lzdGVtRXJyb3IiLCJCVUZGRVJfQUREX0NPREVDX0VSUk9SIiwiUkVNVVhfQUxMT0NfRVJST1IiLCJCVUZGRVJfQVBQRU5EX0VSUk9SIiwiSU5URVJOQUxfRVhDRVBUSU9OIiwiQlVGRkVSX0FQUEVORElOR19FUlJPUiIsIkJVRkZFUl9GVUxMX0VSUk9SIiwiTEVWRUxfU1dJVENIX0VSUk9SIiwiQlVGRkVSX1NFRUtfT1ZFUl9IT0xFIiwiQlVGRkVSX05VREdFX09OX1NUQUxMIiwiS0VZX1NZU1RFTV9FUlJPUiIsInZhcmlhbnRMZXZlbEluZGV4IiwiZnJhZ0xvYWRQb2xpY3kiLCJrZXlMb2FkUG9saWN5Iiwic3RhcnRzV2l0aCIsImZyYWdtZW50RXJyb3JzIiwiYWNjIiwiX2RhdGEkZnJhZzIiLCJfZGF0YSRjb250ZXh0MiIsImVycm9yRGV0YWlscyIsIm5leHRMZXZlbCIsIm1pbkF1dG9MZXZlbCIsIm1heEF1dG9MZXZlbCIsImF1dG9MZXZlbEVuYWJsZWQiLCJmcmFnRXJyb3JUeXBlIiwiaXNBdWRpb0NvZGVjRXJyb3IiLCJzb3VyY2VCdWZmZXJOYW1lIiwiZmluZEF1ZGlvQ29kZWNBbHRlcm5hdGUiLCJpc1ZpZGVvQ29kZWNFcnJvciIsImZpbmRWaWRlb0NvZGVjQWx0ZXJuYXRlIiwicGxheWxpc3RFcnJvclR5cGUiLCJwbGF5bGlzdEVycm9yR3JvdXBJZCIsIl9sZXZlbCRhdWRpb0dyb3VwcyIsIl9sZXZlbCRzdWJ0aXRsZUdyb3VwcyIsImxldmVsQ2FuZGlkYXRlIiwiZnJhZ0NhbmRpZGF0ZSIsIm5leHRBdXRvTGV2ZWwiLCJfZGF0YSRlcnJvckFjdGlvbiIsInNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3giLCJyZXNvbHZlZCIsInJlY292ZXJNZWRpYUVycm9yIiwic3dpdGNoTGV2ZWwiLCJtYXhIZGNwTGV2ZWwiLCJuZXh0TG9hZExldmVsIiwiQmFzZVBsYXlsaXN0Q29udHJvbGxlciIsImxvZ1ByZWZpeCIsInRpbWVyIiwicmVxdWVzdFNjaGVkdWxlZCIsImNhbkxvYWQiLCJjbGVhclRpbWVyIiwiY2xlYXJUaW1lb3V0IiwibG9hZFBsYXlsaXN0Iiwic3dpdGNoUGFyYW1zIiwicGxheWxpc3RVcmkiLCJmb3VuZEluZGV4IiwiY3VycmVudEdvYWwiLCJobHNVcmxQYXJhbWV0ZXJzIiwic2hvdWxkTG9hZFBsYXlsaXN0IiwicGxheWxpc3QiLCJzaG91bGRSZWxvYWRQbGF5bGlzdCIsInBsYXlsaXN0TG9hZGVkIiwicHJldmlvdXNEZXRhaWxzIiwiZWxhcHNlZCIsImVuZFNuIiwiaGFzUGFydHMiLCJsYXN0UGFydCIsIm5leHRTblN0YXJ0SW5kZXgiLCJsYXN0QWR2YW5jZWQiLCJjZG5BZ2UiLCJzZWdtZW50cyIsInRvRml4ZWQiLCJnZXREZWxpdmVyeURpcmVjdGl2ZXMiLCJidWZmZXJJbmZvIiwibWFpbkZvcndhcmRCdWZmZXJJbmZvIiwicG9zaXRpb24iLCJlc3RpbWF0ZWRUaW1lVW50aWxVcGRhdGUiLCJzZXRUaW1lb3V0IiwicHJldmlvdXNEZWxpdmVyeURpcmVjdGl2ZXMiLCJjaGVja1JldHJ5IiwiZXJyb3JFdmVudCIsIl9lcnJvckV2ZW50JGNvbnRleHQiLCJkZWxheSIsIkVXTUEiLCJoYWxmTGlmZSIsImVzdGltYXRlIiwid2VpZ2h0IiwiYWxwaGFfIiwiZXN0aW1hdGVfIiwidG90YWxXZWlnaHRfIiwic2FtcGxlIiwiYWRqQWxwaGEiLCJnZXRUb3RhbFdlaWdodCIsImdldEVzdGltYXRlIiwiemVyb0ZhY3RvciIsIkV3bWFCYW5kV2lkdGhFc3RpbWF0b3IiLCJzbG93IiwiZmFzdCIsImRlZmF1bHRFc3RpbWF0ZSIsImRlZmF1bHRUVEZCIiwiZGVmYXVsdEVzdGltYXRlXyIsIm1pbldlaWdodF8iLCJtaW5EZWxheU1zXyIsInNsb3dfIiwiZmFzdF8iLCJkZWZhdWx0VFRGQl8iLCJ0dGZiXyIsInVwZGF0ZSIsImR1cmF0aW9uTXMiLCJudW1CeXRlcyIsIm51bUJpdHMiLCJkdXJhdGlvblMiLCJiYW5kd2lkdGhJbkJwcyIsInNhbXBsZVRURkIiLCJ0dGZiIiwic2Vjb25kcyIsInNxcnQiLCJjYW5Fc3RpbWF0ZSIsImdldEVzdGltYXRlVFRGQiIsIlNVUFBPUlRFRF9JTkZPX0RFRkFVTFQiLCJzdXBwb3J0ZWQiLCJjb25maWd1cmF0aW9ucyIsImRlY29kaW5nSW5mb1Jlc3VsdHMiLCJwb3dlckVmZmljaWVudCIsInNtb290aCIsIlNVUFBPUlRFRF9JTkZPX0NBQ0hFIiwicmVxdWlyZXNNZWRpYUNhcGFiaWxpdGllc0RlY29kaW5nSW5mbyIsImF1ZGlvVHJhY2tzQnlHcm91cCIsImN1cnJlbnRWaWRlb1JhbmdlIiwiY3VycmVudEZyYW1lUmF0ZSIsImN1cnJlbnRCdyIsImF1ZGlvUHJlZmVyZW5jZSIsImF1ZGlvQ29kZWNQcmVmZXJlbmNlIiwiY2hhbm5lbHNQcmVmZXJlbmNlIiwibWF4Q2hhbm5lbHMiLCJhdWRpb0NoYW5uZWxzIiwiYXVkaW9UcmFja0dyb3VwIiwiZ2V0TWVkaWFEZWNvZGluZ0luZm9Qcm9taXNlIiwibWVkaWFDYXBhYmlsaXRpZXMiLCJQcm9taXNlIiwiYmFzZVZpZGVvQ29uZmlndXJhdGlvbiIsImNlaWwiLCJmcmFtZXJhdGUiLCJ0cmFuc2ZlckZ1bmN0aW9uIiwiX2F1ZGlvVHJhY2tzQnlHcm91cCRnIiwiY2hhbm5lbHNOdW1iZXIiLCJhbGwiLCJjb25maWd1cmF0aW9uIiwiZGVjb2RpbmdJbmZvS2V5IiwiZ2V0TWVkaWFEZWNvZGluZ0luZm9LZXkiLCJkZWNvZGluZ0luZm8iLCJ0aGVuIiwiY2F0Y2giLCJtZWRpYUNvbmZpZyIsInNwYXRpYWxSZW5kZXJpbmciLCJpc0hkclN1cHBvcnRlZCIsIm1hdGNoTWVkaWEiLCJtZWRpYVF1ZXJ5TGlzdCIsImJhZFF1ZXJ5IiwibWF0Y2hlcyIsImdldFZpZGVvU2VsZWN0aW9uT3B0aW9ucyIsInZpZGVvUHJlZmVyZW5jZSIsInByZWZlckhEUiIsImFsbG93ZWRWaWRlb1JhbmdlcyIsInJhbmdlIiwiZ2V0U3RhcnRDb2RlY1RpZXIiLCJjb2RlY1RpZXJzIiwiY29kZWNTZXRzIiwicHJlZmVyU3RlcmVvIiwiaGFzU3RlcmVvIiwiaGFzQ3VycmVudFZpZGVvUmFuZ2UiLCJtaW5IZWlnaHQiLCJtaW5GcmFtZXJhdGUiLCJtaW5CaXRyYXRlIiwic2VsZWN0ZWRTY29yZSIsInZpZGVvUmFuZ2VzIiwidGllciIsIm1hdGNoaW5nVmlkZW9SYW5nZXMiLCJtYXhIZWlnaHQiLCJtYXhGcmFtZXJhdGUiLCJzZWxlY3RlZCIsImNhbmRpZGF0ZVRpZXIiLCJsb2dTdGFydENvZGVjQ2FuZGlkYXRlSWdub3JlZCIsImhhc0RlZmF1bHRBdWRpbyIsIm1heFNjb3JlIiwiY29kZVNldCIsImdldEF1ZGlvVHJhY2tzQnlHcm91cCIsImFsbEF1ZGlvVHJhY2tzIiwidHJhY2tHcm91cCIsImhhc0RlZmF1bHQiLCJoYXNBdXRvU2VsZWN0IiwiY2hhbm5lbHNLZXkiLCJoYXNBdXRvU2VsZWN0QXVkaW8iLCJnZXRDb2RlY1RpZXJzIiwidGllcnMiLCJTRFIiLCJsZXNzZXJXaWR0aE9ySGVpZ2h0IiwiYXVkaW9Hcm91cCIsImZpbmRNYXRjaGluZ09wdGlvbiIsIm9wdGlvbiIsIm1hdGNoUHJlZGljYXRlIiwibWF0Y2hlc09wdGlvbiIsImlzRGVmYXVsdCIsImNoYXJhY3RlcmlzdGljc01hdGNoIiwiY2hhcmFjdGVyaXN0aWNzQSIsImNoYXJhY3RlcmlzdGljc0IiLCJhcnJBIiwiYXJyQiIsImVsIiwiYXVkaW9NYXRjaFByZWRpY2F0ZSIsImZpbmRDbG9zZXN0TGV2ZWxXaXRoQXVkaW9Hcm91cCIsInNlYXJjaEluZGV4IiwiY3VycmVudExldmVsIiwidmFyaWFudHMiLCJ2YXJpYW50TWFwIiwicmVuZGl0aW9ucyIsImN1cnJlbnRWaWRlb0NvZGVjIiwibWF0Y2hpbmdWaWRlbyIsInNlYXJjaERvd25BbmRVcExpc3QiLCJhcnIiLCJBYnJDb250cm9sbGVyIiwiX2hscyIsImxhc3RMZXZlbExvYWRTZWMiLCJsYXN0TG9hZGVkRnJhZ0xldmVsIiwiZmlyc3RTZWxlY3Rpb24iLCJfbmV4dEF1dG9MZXZlbCIsIm5leHRBdXRvTGV2ZWxLZXkiLCJwYXJ0Q3VycmVudCIsImJpdHJhdGVUZXN0RGVsYXkiLCJid0VzdGltYXRvciIsIl9hYmFuZG9uUnVsZXNDaGVjayIsInRpbWVMb2FkaW5nIiwicGF1c2VkIiwicmVhZHlTdGF0ZSIsInR0ZmJFc3RpbWF0ZSIsImJ1ZmZlclN0YXJ2YXRpb25EZWxheSIsImxvYWRlZEZpcnN0Qnl0ZSIsImdldEJ3RXN0aW1hdGUiLCJleHBlY3RlZExlbiIsInRpbWVTdHJlYW1pbmciLCJsb2FkUmF0ZSIsImZyYWdMb2FkZWREZWxheSIsImJ3ZSIsImZyYWdMZXZlbE5leHRMb2FkZWREZWxheSIsImxldmVsTmV4dEJpdHJhdGUiLCJnZXRUaW1lVG9Mb2FkRnJhZyIsIm5leHRMb2FkTGV2ZWxCaXRyYXRlIiwiYWJyQmFuZFdpZHRoVXBGYWN0b3IiLCJyZXNldEVzdGltYXRvciIsIkZSQUdfTE9BRF9FTUVSR0VOQ1lfQUJPUlRFRCIsImluaXRFc3RpbWF0b3IiLCJhYnJFd21hRGVmYXVsdEVzdGltYXRlIiwiYWJyRXdtYVNsb3dWb0QiLCJhYnJFd21hRmFzdFZvRCIsIkZSQUdfTE9BRElORyIsIm9uRnJhZ0xvYWRpbmciLCJGUkFHX0xPQURFRCIsIm9uRnJhZ0xvYWRlZCIsIkZSQUdfQlVGRkVSRUQiLCJvbkZyYWdCdWZmZXJlZCIsIkxFVkVMX1NXSVRDSElORyIsIm9uTGV2ZWxTd2l0Y2hpbmciLCJvbkxldmVsTG9hZGVkIiwiTEVWRUxTX1VQREFURUQiLCJvbkxldmVsc1VwZGF0ZWQiLCJNQVhfQVVUT19MRVZFTF9VUERBVEVEIiwib25NYXhBdXRvTGV2ZWxVcGRhdGVkIiwiaWdub3JlRnJhZ21lbnQiLCJfZGF0YSRwYXJ0Iiwic2V0SW50ZXJ2YWwiLCJ0aW1lVG9GaXJzdEJ5dGVTZWMiLCJiYW5kd2lkdGgiLCJmcmFnU2l6ZUJpdHMiLCJpc1N3aXRjaCIsImZyYWdMb2FkU2VjIiwicGxheWxpc3RMb2FkU2VjIiwidGltZUxvYWRpbmdNcyIsImFickV3bWFTbG93TGl2ZSIsImFickV3bWFGYXN0TGl2ZSIsImFick1heFdpdGhSZWFsQml0cmF0ZSIsImxvYWRlZEJ5dGVzIiwibG9hZGVkRHVyYXRpb24iLCJmcmFnQnVmZmVyZWREYXRhIiwicHJvY2Vzc2luZ01zIiwiY2xlYXJJbnRlcnZhbCIsImZpcnN0QXV0b0xldmVsIiwibWF4U3RhcnREZWxheSIsIm1heFN0YXJ2YXRpb25EZWxheSIsImFickF1dG9MZXZlbCIsImZpbmRCZXN0TGV2ZWwiLCJmaXJzdExldmVsIiwiY2xhbXBlZCIsImZvcmNlZEF1dG9MZXZlbCIsInVzZUVzdGltYXRlIiwibG9hZGVkRmlyc3RGcmFnIiwiZ2V0QXV0b0xldmVsS2V5IiwibmV4dEFCUkF1dG9MZXZlbCIsImdldE5leHRBQlJBdXRvTGV2ZWwiLCJfdGhpcyRobHMkbWFpbkZvcndhcmQiLCJjdXJyZW50RnJhZ0R1cmF0aW9uIiwiYXZnYnciLCJid0ZhY3RvciIsImFickJhbmRXaWR0aEZhY3RvciIsImJ3VXBGYWN0b3IiLCJfYmVzdExldmVsIiwibWF4TG9hZGluZ0RlbGF5IiwiYmVzdExldmVsIiwibWluTGV2ZWwiLCJhdXRvTGV2ZWwiLCJtYXhGZXRjaER1cmF0aW9uIiwic2VsZWN0aW9uQmFzZUxldmVsIiwiY3VycmVudENvZGVjU2V0Iiwic3RhcnRUaWVyIiwidHRmYkVzdGltYXRlU2VjIiwibGV2ZWxzU2tpcHBlZCIsIl9sZXZlbEluZm8kc3VwcG9ydGVkUiIsIl9sZXZlbEluZm8kc3VwcG9ydGVkUjIiLCJsZXZlbEluZm8iLCJ1cFN3aXRjaCIsInVzZU1lZGlhQ2FwYWJpbGl0aWVzIiwicmVtb3ZlTGV2ZWwiLCJhdmdEdXJhdGlvbiIsImFkanVzdGVkYnciLCJmZXRjaER1cmF0aW9uIiwiY2FuU3dpdGNoV2l0aGluVG9sZXJhbmNlIiwiVGFza0xvb3AiLCJfYm91bmRUaWNrIiwiX3RpY2tUaW1lciIsIl90aWNrSW50ZXJ2YWwiLCJfdGlja0NhbGxDb3VudCIsInRpY2siLCJvbkhhbmRsZXJEZXN0cm95aW5nIiwib25IYW5kbGVyRGVzdHJveWVkIiwiY2xlYXJOZXh0VGljayIsImhhc0ludGVydmFsIiwiaGFzTmV4dFRpY2siLCJtaWxsaXMiLCJkb1RpY2siLCJ0aWNrSW1tZWRpYXRlIiwiRnJhZ21lbnRTdGF0ZSIsIk5PVF9MT0FERUQiLCJBUFBFTkRJTkciLCJQQVJUSUFMIiwiT0siLCJGcmFnbWVudFRyYWNrZXIiLCJhY3RpdmVQYXJ0TGlzdHMiLCJlbmRMaXN0RnJhZ21lbnRzIiwidGltZVJhbmdlcyIsImJ1ZmZlclBhZGRpbmciLCJoYXNHYXBzIiwiQlVGRkVSX0FQUEVOREVEIiwib25CdWZmZXJBcHBlbmRlZCIsImdldEFwcGVuZGVkRnJhZyIsImFjdGl2ZVBhcnRzIiwiYWN0aXZlUGFydCIsImFwcGVuZGVkUFRTIiwiZ2V0QnVmZmVyZWRGcmFnIiwiZnJhZ21lbnRFbnRpdHkiLCJib2R5IiwiZGV0ZWN0RXZpY3RlZEZyYWdtZW50cyIsImVsZW1lbnRhcnlTdHJlYW0iLCJ0aW1lUmFuZ2UiLCJwbGF5bGlzdFR5cGUiLCJhcHBlbmRlZFBhcnQiLCJhcHBlbmRlZFBhcnRTbiIsInJlbW92ZUZyYWdtZW50IiwiZXNEYXRhIiwiaXNOb3RCdWZmZXJlZCIsImlzVGltZUJ1ZmZlcmVkIiwiZGV0ZWN0UGFydGlhbEZyYWdtZW50cyIsImZyYWdLZXkiLCJnZXRGcmFnbWVudEtleSIsImlzRnJhZ0hpbnQiLCJzdHJlYW1JbmZvIiwiZ2V0QnVmZmVyZWRUaW1lcyIsImlzUGFydGlhbCIsInJlbW92ZVBhcnRzIiwic25Ub0tlZXAiLCJmcmFnQnVmZmVyZWQiLCJmb3JjZSIsImdldFBhcnRpYWxGcmFnbWVudCIsImJlc3RGcmFnbWVudCIsInRpbWVQYWRkaW5nIiwiYmVzdE92ZXJsYXAiLCJpc0VuZExpc3RBcHBlbmRlZCIsImxhc3RGcmFnbWVudEVudGl0eSIsImdldFN0YXRlIiwiaGFzRnJhZ21lbnQiLCJfdGhpcyRhY3RpdmVQYXJ0TGlzdHMiLCJyZW1vdmVGcmFnbWVudHNJblJhbmdlIiwid2l0aEdhcE9ubHkiLCJ1bmJ1ZmZlcmVkT25seSIsInNuVG9SZW1vdmUiLCJyZW1vdmVBbGxGcmFnbWVudHMiLCJfZnJhZ21lbnRFbnRpdHkkcmFuZ2UiLCJfZnJhZ21lbnRFbnRpdHkkcmFuZ2UyIiwiX2ZyYWdtZW50RW50aXR5JHJhbmdlMyIsIm5vb3BCdWZmZXJlZCIsIkJ1ZmZlckhlbHBlciIsImlzQnVmZmVyZWQiLCJnZXRCdWZmZXJlZCIsInBvcyIsIm1heEhvbGVEdXJhdGlvbiIsInZidWZmZXJlZCIsImJ1ZmZlcmVkSW5mbyIsIm5leHRTdGFydCIsInNvcnQiLCJhIiwiZGlmZiIsImJ1ZmZlcmVkMiIsImJ1ZjJsZW4iLCJidWYyZW5kIiwiYnVmZmVyTGVuIiwiYnVmZmVyU3RhcnROZXh0IiwiYnVmZmVyU3RhcnQiLCJDaHVua01ldGFkYXRhIiwidHJhbnNtdXhpbmciLCJnZXROZXdQZXJmb3JtYW5jZVRpbWluZyIsImV4ZWN1dGVTdGFydCIsImV4ZWN1dGVFbmQiLCJmaW5kRmlyc3RGcmFnV2l0aENDIiwiX2ZyYWdtZW50cyRpIiwic2hvdWxkQWxpZ25PbkRpc2NvbnRpbnVpdGllcyIsImxhc3RGcmFnIiwic3dpdGNoRGV0YWlscyIsImZpbmREaXNjb250aW51b3VzUmVmZXJlbmNlRnJhZyIsInByZXZEZXRhaWxzIiwiY3VyRGV0YWlscyIsInByZXZGcmFncyIsImN1ckZyYWdzIiwicHJldlN0YXJ0RnJhZyIsImFkanVzdEZyYWdtZW50U3RhcnQiLCJzbGlkaW5nIiwiYWRqdXN0U2xpZGluZ1N0YXJ0IiwiYWxpZ25TdHJlYW0iLCJhbGlnbkRpc2NvbnRpbnVpdGllcyIsImFsaWduTWVkaWFQbGF5bGlzdEJ5UERUIiwicmVmZXJlbmNlRnJhZyIsInJlZkRldGFpbHMiLCJyZWZGcmFnbWVudHMiLCJyZWZGcmFnIiwidGFyZ2V0Q0MiLCJyZWZQRFQiLCJ0YXJnZXRQRFQiLCJNSU5fQ0hVTktfU0laRSIsIkZyYWdtZW50TG9hZGVyIiwicGFydExvYWRUaW1lb3V0Iiwib25Qcm9ncmVzcyIsInJlamVjdCIsIkxvYWRFcnJvciIsIkZyYWdtZW50SUxvYWRlciIsImZMb2FkZXIiLCJEZWZhdWx0SUxvYWRlciIsInRhZ3MiLCJjcmVhdGVHYXBMb2FkRXJyb3IiLCJjcmVhdGVMb2FkZXJDb250ZXh0IiwiaGlnaFdhdGVyTWFyayIsInJlc2V0TG9hZGVyIiwicmVzZXRJViIsIm9uQWJvcnQiLCJJTlRFUk5BTF9BQk9SVEVEIiwibG9hZFBhcnQiLCJ1cGRhdGVTdGF0c0Zyb21QYXJ0IiwicGFydExvYWRlZERhdGEiLCJmcmFnU3RhdHMiLCJwYXJ0U3RhdHMiLCJwYXJ0VG90YWwiLCJlc3RUb3RhbFBhcnRzIiwiZXN0TG9hZGVkUGFydHMiLCJlc3RSZW1haW5pbmdQYXJ0cyIsImVzdFJlbWFpbmluZ0J5dGVzIiwiZnJhZ0xvYWRpbmciLCJwYXJ0TG9hZGluZyIsInNlZ21lbnQiLCJoZWFkZXJzIiwicmFuZ2VTdGFydCIsInJhbmdlRW5kIiwiX2ZyYWckZGVjcnlwdGRhdGEiLCJieXRlUmFuZ2VTdGFydCIsImJ5dGVSYW5nZUVuZCIsImZyYWdtZW50TGVuIiwiTUVESUFfRVJST1IiLCJBRVNDcnlwdG8iLCJzdWJ0bGUiLCJhZXNJViIsImRlY3J5cHQiLCJGYXN0QUVTS2V5IiwiZXhwYW5kS2V5IiwiaW1wb3J0S2V5IiwicmVtb3ZlUGFkZGluZyIsIm91dHB1dEJ5dGVzIiwicGFkZGluZ0J5dGVzIiwiZ2V0VWludDgiLCJBRVNEZWNyeXB0b3IiLCJyY29uIiwic3ViTWl4IiwiVWludDMyQXJyYXkiLCJpbnZTdWJNaXgiLCJzQm94IiwiaW52U0JveCIsImtzUm93cyIsImtleVNpemUiLCJrZXlTY2hlZHVsZSIsImludktleVNjaGVkdWxlIiwiaW5pdFRhYmxlIiwidWludDhBcnJheVRvVWludDMyQXJyYXlfIiwiYXJyYXlCdWZmZXIiLCJuZXdBcnJheSIsInN1Yk1peDAiLCJzdWJNaXgxIiwic3ViTWl4MiIsInN1Yk1peDMiLCJpbnZTdWJNaXgwIiwiaW52U3ViTWl4MSIsImludlN1Yk1peDIiLCJpbnZTdWJNaXgzIiwiZCIsInhpIiwic3giLCJ4MiIsIng0IiwieDgiLCJrZXlCdWZmZXIiLCJzYW1lS2V5Iiwia3NSb3ciLCJpbnZLc1JvdyIsInNib3giLCJwcmV2IiwibmV0d29ya1RvSG9zdE9yZGVyU3dhcCIsIndvcmQiLCJpbnB1dEFycmF5QnVmZmVyIiwiblJvdW5kcyIsImludlNCT1giLCJpbml0VmVjdG9yIiwiaW5pdFZlY3RvcjAiLCJpbml0VmVjdG9yMSIsImluaXRWZWN0b3IyIiwiaW5pdFZlY3RvcjMiLCJpbnB1dEludDMyIiwiSW50MzJBcnJheSIsIm91dHB1dEludDMyIiwidDAiLCJ0MSIsInQyIiwidDMiLCJzMCIsInMxIiwiczIiLCJzMyIsImlucHV0V29yZHMwIiwiaW5wdXRXb3JkczEiLCJpbnB1dFdvcmRzMiIsImlucHV0V29yZHMzIiwic3dhcFdvcmQiLCJDSFVOS19TSVpFIiwiRGVjcnlwdGVyIiwicmVtb3ZlUEtDUzdQYWRkaW5nIiwibG9nRW5hYmxlZCIsInNvZnR3YXJlRGVjcnlwdGVyIiwiZmFzdEFlc0tleSIsInJlbWFpbmRlckRhdGEiLCJjdXJyZW50SVYiLCJjdXJyZW50UmVzdWx0IiwidXNlU29mdHdhcmUiLCJlbmFibGVTb2Z0d2FyZUFFUyIsImJyb3dzZXJDcnlwdG8iLCJjcnlwdG8iLCJ3ZWJraXRTdWJ0bGUiLCJpc1N5bmMiLCJmbHVzaCIsInJlc2V0Iiwic29mdHdhcmVEZWNyeXB0IiwiZGVjcnlwdFJlc3VsdCIsIndlYkNyeXB0b0RlY3J5cHQiLCJsb2dPbmNlIiwiY3VycmVudENodW5rIiwiZ2V0VmFsaWRDaHVuayIsImFlc0tleSIsIm9uV2ViQ3J5cHRvRXJyb3IiLCJzcGxpdFBvaW50IiwibXNnIiwiVGltZVJhbmdlcyIsIlN0YXRlIiwiU1RPUFBFRCIsIklETEUiLCJLRVlfTE9BRElORyIsIkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZIiwiV0FJVElOR19UUkFDSyIsIlBBUlNJTkciLCJQQVJTRUQiLCJFTkRFRCIsIldBSVRJTkdfSU5JVF9QVFMiLCJXQUlUSU5HX0xFVkVMIiwiQmFzZVN0cmVhbUNvbnRyb2xsZXIiLCJmcmFnbWVudFRyYWNrZXIiLCJ0cmFuc211eGVyIiwiX3N0YXRlIiwibWVkaWFCdWZmZXIiLCJsYXN0Q3VycmVudFRpbWUiLCJuZXh0TG9hZFBvc2l0aW9uIiwibG9hZGVkbWV0YWRhdGEiLCJyZXRyeURhdGUiLCJmcmFnbWVudExvYWRlciIsImxldmVsTGFzdExvYWRlZCIsInN0YXJ0RnJhZ1JlcXVlc3RlZCIsImRlY3J5cHRlciIsImluaXRQVFMiLCJvbnZzZWVraW5nIiwib252ZW5kZWQiLCJvbk1hbmlmZXN0TG9hZGVkIiwib25UaWNrRW5kIiwicmVzZXRUcmFuc211eGVyIiwic3RhdGUiLCJfc3RyZWFtRW5kZWQiLCJsYXN0UGFydEJ1ZmZlcmVkIiwiZ2V0TGV2ZWxEZXRhaWxzIiwiX3RoaXMkbGV2ZWxMYXN0TG9hZGVkIiwib25NZWRpYVNlZWtpbmciLCJvbk1lZGlhRW5kZWQiLCJhdXRvU3RhcnRMb2FkIiwiZW5kZWQiLCJkZXRhY2giLCJtYXhCdWZmZXJIb2xlIiwicmVzZXRMb2FkaW5nU3RhdGUiLCJ0b2xlcmFuY2UiLCJmcmFnU3RhcnRPZmZzZXQiLCJmcmFnRW5kT2Zmc2V0IiwicGFzdEZyYWdtZW50IiwibG9hZEZyYWdtZW50IiwidGFyZ2V0QnVmZmVyVGltZSIsIl9sb2FkRnJhZ0ZvclBsYXliYWNrIiwicHJvZ3Jlc3NDYWxsYmFjayIsImZyYWdDb250ZXh0Q2hhbmdlZCIsIl9oYW5kbGVGcmFnbWVudExvYWRQcm9ncmVzcyIsIl9kb0ZyYWdMb2FkIiwiX2hhbmRsZUZyYWdtZW50TG9hZENvbXBsZXRlIiwicmVzZXRGcmFnbWVudExvYWRpbmciLCJjbGVhclRyYWNrZXJJZk5lZWRlZCIsIl90aGlzJG1lZGlhQnVmZmVyIiwiZnJhZ1N0YXRlIiwiZ2V0RndkQnVmZmVySW5mbyIsIm1pbkZvcndhcmRCdWZmZXJMZW5ndGgiLCJtYXhCdWZmZXJMZW5ndGgiLCJyZWR1Y2VNYXhCdWZmZXJMZW5ndGgiLCJjaGVja0xpdmVVcGRhdGUiLCJmbHVzaE1haW5CdWZmZXIiLCJmbHVzaFNjb3BlIiwiX2xvYWRJbml0U2VnbWVudCIsImRlY3J5cHREYXRhIiwiZGVjcnlwdGVkRGF0YSIsIkZSQUdfREVDUllQVEVEIiwidHN0YXJ0IiwidGRlY3J5cHQiLCJjb21wbGV0ZUluaXRTZWdtZW50TG9hZCIsImZyYWdCdWZmZXJlZENvbXBsZXRlIiwiX2ZyYWckc3RhcnRQVFMiLCJfZnJhZyRlbmRQVFMiLCJfdGhpcyRmcmFnQ3VycmVudCIsIl90aGlzJGZyYWdQcmV2aW91cyIsIk5hTiIsIl90aGlzJGxldmVscyIsInNlZWtUb1N0YXJ0UG9zIiwiZnJhZ0xvYWRlZEVuZERhdGEiLCJwYXJ0c0xvYWRlZCIsImNvbXBsZXRlIiwiZnJhZ0xvYWRlZCIsImNodW5rTWV0YSIsImtleUxvYWRpbmdQcm9taXNlIiwia2V5TG9hZGVkRGF0YSIsIktFWV9MT0FERUQiLCJsb2FkQ2xlYXIiLCJnZXROZXh0UGFydCIsIl9yZXN1bHQiLCJkb0ZyYWdQYXJ0c0xvYWQiLCJoYW5kbGVGcmFnTG9hZEVycm9yIiwibG9hZGVkRW5kT2ZQYXJ0cyIsImRhdGFPblByb2dyZXNzIiwicHJvZ3Jlc3NpdmUiLCJmcmFnTG9hZGVkRGF0YSIsImZyb21QYXJ0IiwiaW5pdGlhbFBhcnRMaXN0IiwibG9hZGVkUGFydCIsIm5leHRQYXJ0IiwiaGFuZGxlRnJhZ0xvYWRBYm9ydGVkIiwiT1RIRVJfRVJST1IiLCJfaGFuZGxlVHJhbnNtdXhlckZsdXNoIiwiZ2V0Q3VycmVudENvbnRleHQiLCJ1cGRhdGVMZXZlbFRpbWluZyIsImJ1ZmZlckZyYWdtZW50RGF0YSIsIm5vQmFja3RyYWNraW5nIiwiX2J1ZmZlciIsIkJVRkZFUl9BUFBFTkRJTkciLCJkcm9wcGVkIiwiZmx1c2hCdWZmZXJHYXAiLCJmcmFnRHVyYXRpb24iLCJzZWdtZW50RnJhY3Rpb24iLCJidWZmZXJhYmxlIiwiZ2V0TG9hZFBvc2l0aW9uIiwiZ2V0RndkQnVmZmVySW5mb0F0UG9zIiwiYnVmZmVyZWRGcmFnQXRQb3MiLCJnZXRNYXhCdWZmZXJMZW5ndGgiLCJsZXZlbEJpdHJhdGUiLCJtYXhCdWZMZW4iLCJtYXhCdWZmZXJTaXplIiwibWF4TWF4QnVmZmVyTGVuZ3RoIiwidGhyZXNob2xkIiwibWluTGVuZ3RoIiwiZnJhZ09yUGFydCIsImdldE5leHRGcmFnbWVudCIsImZyYWdMZW4iLCJpbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZSIsImdldEluaXRpYWxMaXZlRnJhZ21lbnQiLCJnZXRGcmFnbWVudEF0UG9zaXRpb24iLCJtYXBUb0luaXRGcmFnV2hlblJlcXVpcmVkIiwiaXNMb29wTG9hZGluZyIsInRyYWNrZXJTdGF0ZSIsImdldE5leHRGcmFnbWVudExvb3BMb2FkaW5nIiwiZ2FwU3RhcnQiLCJuZXh0RnJhZ21lbnQiLCJuZXh0YnVmZmVySW5mbyIsImluZGVwZW5kZW50QXR0ck9taXR0ZWQiLCJ0YXJnZXRTTiIsImxpdmVTdGFydCIsImxvYWRpbmdQYXJ0cyIsImxvb2t1cFRvbGVyYW5jZSIsImN1clNOSWR4Iiwic2FtZUxldmVsIiwibmV4dEZyYWciLCJzeW5jaHJvbml6ZVRvTGl2ZUVkZ2UiLCJ3aXRoaW5TbGlkaW5nV2luZG93IiwiYWxpZ25QbGF5bGlzdHMiLCJzbGlkaW5nU3RhcnQiLCJmaXJzdExldmVsTG9hZCIsImFsaWduZWQiLCJhbGlnbmVkU2xpZGluZ1N0YXJ0Iiwid2FpdEZvckNkblR1bmVJbiIsImFkdmFuY2VQYXJ0TGltaXQiLCJzZXRTdGFydFBvc2l0aW9uIiwib2Zmc2V0SW5NdWx0aXZhcmlhbnRQbGF5bGlzdCIsIm9uRnJhZ21lbnRPcktleUxvYWRFcnJvciIsImZpbHRlclR5cGUiLCJfdGhpcyRmcmFnQ3VycmVudDIiLCJnYXBUYWdFbmNvdW50ZXJlZCIsInJlc2V0U3RhcnRXaGVuTm90TG9hZGVkIiwicmVzZXRGcmFnbWVudEVycm9ycyIsInJlZHVjZUxlbmd0aEFuZEZsdXNoQnVmZmVyIiwiZmx1c2hCdWZmZXIiLCJhZnRlckJ1ZmZlckZsdXNoZWQiLCJidWZmZXJUeXBlIiwiYnVmZmVyZWRUaW1lUmFuZ2VzIiwicmVzZXRXaGVuTWlzc2luZ0NvbnRleHQiLCJyZW1vdmVVbmJ1ZmZlcmVkRnJhZ3MiLCJfdGhpcyR0cmFuc211eGVyIiwicGFyc2VkRHVyYXRpb24iLCJMRVZFTF9QVFNfVVBEQVRFRCIsIkZSQUdfUEFSU0VEIiwicmVjb3ZlcldvcmtlckVycm9yIiwibmV4dFN0YXRlIiwicHJldmlvdXNTdGF0ZSIsIkNodW5rQ2FjaGUiLCJjaHVua3MiLCJkYXRhTGVuZ3RoIiwiY2h1bmsiLCJjb25jYXRVaW50OEFycmF5cyIsImhhc1VNRFdvcmtlciIsIl9fSExTX1dPUktFUl9CVU5ETEVfXyIsImluamVjdFdvcmtlciIsImJsb2IiLCJCbG9iIiwib2JqZWN0VVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwid29ya2VyIiwiV29ya2VyIiwibG9hZFdvcmtlciIsInNjcmlwdFVSTCIsImxvY2F0aW9uIiwiZHVtbXlUcmFjayIsImlucHV0VGltZVNjYWxlIiwicGlkIiwic2VxdWVuY2VOdW1iZXIiLCJCYXNlQXVkaW9EZW11eGVyIiwiX2F1ZGlvVHJhY2siLCJfaWQzVHJhY2siLCJmcmFtZUluZGV4IiwiY2FjaGVkRGF0YSIsImJhc2VQVFMiLCJsYXN0UFRTIiwicmVzZXRJbml0U2VnbWVudCIsInRyYWNrRHVyYXRpb24iLCJyZXNldFRpbWVTdGFtcCIsImRlYXVsdFRpbWVzdGFtcCIsInJlc2V0Q29udGlndWl0eSIsImNhblBhcnNlIiwiYXBwZW5kRnJhbWUiLCJkZW11eCIsImxhc3REYXRhSW5kZXgiLCJpbml0UFRTRm4iLCJkdHMiLCJwYXJ0aWFsRGF0YSIsInZpZGVvVHJhY2siLCJkZW11eFNhbXBsZUFlcyIsImluaXQ5MGtIeiIsImdldEF1ZGlvQ29uZmlnIiwib2JzZXJ2ZXIiLCJhZHRzT2JqZWN0VHlwZSIsImFkdHNFeHRlbnNpb25TYW1wbGluZ0luZGV4IiwiYWR0c0NoYW5uZWxDb25maWciLCJtYW5pZmVzdENvZGVjIiwiYWR0c1NhbXBsaW5nUmF0ZXMiLCJhZHRzU2FtcGxpbmdJbmRleCIsImVtaXQiLCJzYW1wbGVyYXRlIiwiY2hhbm5lbENvdW50IiwiaXNIZWFkZXJQYXR0ZXJuJDEiLCJnZXRIZWFkZXJMZW5ndGgiLCJnZXRGdWxsRnJhbWVMZW5ndGgiLCJjYW5HZXRGcmFtZUxlbmd0aCIsImlzSGVhZGVyJDEiLCJjYW5QYXJzZSQxIiwicHJvYmUkMSIsImhlYWRlckxlbmd0aCIsImZyYW1lTGVuZ3RoIiwibmV3T2Zmc2V0IiwiaW5pdFRyYWNrQ29uZmlnIiwiZ2V0RnJhbWVEdXJhdGlvbiIsInBhcnNlRnJhbWVIZWFkZXIiLCJhcHBlbmRGcmFtZSQyIiwiZnJhbWVEdXJhdGlvbiIsInN0YW1wIiwiaGVhZGVyIiwidW5pdCIsIl9sZW5ndGgiLCJtaXNzaW5nIiwiX3NhbXBsZSIsImNocm9tZVZlcnNpb24kMSIsIkJpdHJhdGVzTWFwIiwiU2FtcGxpbmdSYXRlTWFwIiwiU2FtcGxlc0NvZWZmaWNpZW50cyIsIkJ5dGVzSW5TbG90IiwiYXBwZW5kRnJhbWUkMSIsInBhcnNlSGVhZGVyIiwic2FtcGxlc1BlckZyYW1lIiwic2FtcGxlUmF0ZSIsIm1wZWdWZXJzaW9uIiwibXBlZ0xheWVyIiwiYml0UmF0ZUluZGV4Iiwic2FtcGxlUmF0ZUluZGV4IiwicGFkZGluZ0JpdCIsImNoYW5uZWxNb2RlIiwiY29sdW1uSW5CaXRyYXRlcyIsImJpdFJhdGUiLCJjb2x1bW5JblNhbXBsZVJhdGVzIiwic2FtcGxlQ29lZmZpY2llbnQiLCJieXRlc0luU2xvdCIsIm5lZWRDaHJvbWVGaXgiLCJpc0hlYWRlclBhdHRlcm4iLCJpc0hlYWRlciIsInByb2JlIiwiQUFDRGVtdXhlciIsImNvbnRhaW5lciIsInNlZ21lbnRDb2RlYyIsImVtc2dTY2hlbWVQYXR0ZXJuIiwiTVA0RGVtdXhlciIsInR4dFRyYWNrIiwiY2FwdGlvblRyYWNrIiwidmlkZW9TYW1wbGVzIiwic2VnbWVudGVkRGF0YSIsImV4dHJhY3RJRDNUcmFjayIsImVtc2dzIiwiZW1zZ0luZm8iLCJnZXRBdWRpb0JTSUQiLCJic2lkIiwibWFzayIsImJpdHMiLCJBQzNEZW11eGVyIiwic2FtcGxpbmdSYXRlQ29kZSIsInNhbXBsaW5nUmF0ZU1hcCIsImZyYW1lU2l6ZUNvZGUiLCJmcmFtZVNpemVNYXAiLCJza2lwQ291bnQiLCJsZmVvbiIsImNoYW5uZWxzTWFwIiwiYnNtb2QiLCJCYXNlVmlkZW9QYXJzZXIiLCJWaWRlb1NhbXBsZSIsImNyZWF0ZVZpZGVvU2FtcGxlIiwidW5pdHMiLCJnZXRMYXN0TmFsVW5pdCIsIl9WaWRlb1NhbXBsZSIsImxhc3RVbml0IiwicHVzaEFjY2Vzc1VuaXQiLCJuYlNhbXBsZXMiLCJsYXN0U2FtcGxlIiwiRXhwR29sb21iIiwiYnl0ZXNBdmFpbGFibGUiLCJiaXRzQXZhaWxhYmxlIiwibG9hZFdvcmQiLCJ3b3JraW5nQnl0ZXMiLCJhdmFpbGFibGVCeXRlcyIsInNraXBCaXRzIiwiY291bnQiLCJza2lwQnl0ZXMiLCJyZWFkQml0cyIsInZhbHUiLCJza2lwTFoiLCJsZWFkaW5nWmVyb0NvdW50Iiwic2tpcFVFRyIsInNraXBFRyIsInJlYWRVRUciLCJjbHoiLCJyZWFkRUciLCJyZWFkQm9vbGVhbiIsInJlYWRVQnl0ZSIsInJlYWRVU2hvcnQiLCJyZWFkVUludCIsInNraXBTY2FsaW5nTGlzdCIsImxhc3RTY2FsZSIsIm5leHRTY2FsZSIsImRlbHRhU2NhbGUiLCJyZWFkU1BTIiwiZnJhbWVDcm9wTGVmdE9mZnNldCIsImZyYW1lQ3JvcFJpZ2h0T2Zmc2V0IiwiZnJhbWVDcm9wVG9wT2Zmc2V0IiwiZnJhbWVDcm9wQm90dG9tT2Zmc2V0IiwibnVtUmVmRnJhbWVzSW5QaWNPcmRlckNudEN5Y2xlIiwic2NhbGluZ0xpc3RDb3VudCIsInByb2ZpbGVJZGMiLCJjaHJvbWFGb3JtYXRJZGMiLCJwaWNPcmRlckNudFR5cGUiLCJwaWNXaWR0aEluTWJzTWludXMxIiwicGljSGVpZ2h0SW5NYXBVbml0c01pbnVzMSIsImZyYW1lTWJzT25seUZsYWciLCJwaXhlbFJhdGlvIiwiYXNwZWN0UmF0aW9JZGMiLCJyZWFkU2xpY2VUeXBlIiwiQXZjVmlkZW9QYXJzZXIiLCJwYXJzZUFWQ1BFUyIsInBlcyIsInBhcnNlQVZDTkFMdSIsInNwc2ZvdW5kIiwiYXVkRm91bmQiLCJfVmlkZW9TYW1wbGUyIiwiaXNrZXkiLCJzbGljZVR5cGUiLCJfdHJhY2skcGl4ZWxSYXRpbyIsIl90cmFjayRwaXhlbFJhdGlvMiIsInNwcyIsImV4cEdvbG9tYkRlY29kZXIiLCJjb2RlY2FycmF5IiwiY29kZWNzdHJpbmciLCJwcHMiLCJuYWx1U3RhdGUiLCJsYXN0U3RhdGUiLCJvdmVyZmxvdyIsInVuaXRUeXBlIiwibGFzdFVuaXRTdGFydCIsImxhc3RVbml0VHlwZSIsIlNhbXBsZUFlc0RlY3J5cHRlciIsImRlY3J5cHRCdWZmZXIiLCJlbmNyeXB0ZWREYXRhIiwiZGVjcnlwdEFhY1NhbXBsZSIsInNhbXBsZUluZGV4IiwiY2FsbGJhY2siLCJjdXJVbml0IiwiZW5jcnlwdGVkQnVmZmVyIiwiZGVjcnlwdGVkQnVmZmVyIiwiZGVjcnlwdEFhY1NhbXBsZXMiLCJnZXRBdmNFbmNyeXB0ZWREYXRhIiwiZGVjb2RlZERhdGEiLCJlbmNyeXB0ZWREYXRhTGVuIiwiSW50OEFycmF5Iiwib3V0cHV0UG9zIiwiaW5wdXRQb3MiLCJnZXRBdmNEZWNyeXB0ZWRVbml0IiwidWludDhEZWNyeXB0ZWREYXRhIiwiZGVjcnlwdEF2Y1NhbXBsZSIsInVuaXRJbmRleCIsImRlY3J5cHRBdmNTYW1wbGVzIiwiY3VyVW5pdHMiLCJQQUNLRVRfTEVOR1RIIiwiVFNEZW11eGVyIiwidHlwZVN1cHBvcnRlZCIsInNhbXBsZUFlcyIsInBtdFBhcnNlZCIsIl9kdXJhdGlvbiIsIl9wbXRJZCIsIl92aWRlb1RyYWNrIiwiX3R4dFRyYWNrIiwiYWFjT3ZlckZsb3ciLCJ2aWRlb1BhcnNlciIsInN5bmNPZmZzZXQiLCJzY2Fud2luZG93IiwiZm91bmRQYXQiLCJwYWNrZXRTdGFydCIsInRzUGFja2V0cyIsInBhcnNlUElEIiwicGVzRGF0YSIsImlzU2FtcGxlQWVzIiwidmlkZW9QaWQiLCJhdWRpb1BpZCIsImlkM1BpZCIsImF1ZGlvRGF0YSIsInVua25vd25QSUQiLCJwbXRJZCIsInRzUGFja2V0RXJyb3JzIiwic3R0IiwiYXRmIiwicGFyc2VQRVMiLCJwYXJzZUFBQ1BFUyIsInBhcnNlTVBFR1BFUyIsInBhcnNlQUMzUEVTIiwicGFyc2VJRDNQRVMiLCJwYXJzZVBBVCIsInBhcnNlZFBJRHMiLCJwYXJzZVBNVCIsInNlZ21lbnRWaWRlb0NvZGVjIiwic2VnbWVudEF1ZGlvQ29kZWMiLCJkZW11eFJlc3VsdCIsImV4dHJhY3RSZW1haW5pbmdTYW1wbGVzIiwiZnJhbWVNaXNzaW5nQnl0ZXMiLCJzYW1wbGVMZW5ndGgiLCJmcmFtZU92ZXJmbG93Qnl0ZXMiLCJyZWNvdmVyYWJsZSIsImlkM1NhbXBsZSIsInNlY3Rpb25MZW5ndGgiLCJ0YWJsZUVuZCIsInByb2dyYW1JbmZvTGVuZ3RoIiwiZXNJbmZvTGVuZ3RoIiwibG9nRW5jcnlwdGVkU2FtcGxlc0ZvdW5kSW5VbmVuY3J5cHRlZFN0cmVhbSIsIm1wZWciLCJtcDMiLCJhYzMiLCJwYXJzZVBvcyIsInJlbWFpbmluZyIsImRlc2NyaXB0b3JJZCIsImRlc2NyaXB0b3JMZW4iLCJzdHJlYW0iLCJwZXNMZW4iLCJwZXNIZHJMZW4iLCJwZXNQdHMiLCJwZXNEdHMiLCJwZXNQcmVmaXgiLCJwZXNGbGFncyIsInBheWxvYWRTdGFydE9mZnNldCIsImRhdGFMZW4iLCJNUDNEZW11eGVyIiwiQUFDIiwiZ2V0U2lsZW50RnJhbWUiLCJVSU5UMzJfTUFYIiwiTVA0IiwidHlwZXMiLCJhdmNDIiwiYnRydCIsImRpbmYiLCJkcmVmIiwiZXNkcyIsImZ0eXAiLCJtZGF0IiwibWRpYSIsIm1maGQiLCJtaW5mIiwibW9vdiIsImRhYzMiLCJtdmV4IiwibXZoZCIsInBhc3AiLCJzZHRwIiwic3RibCIsInN0Y28iLCJzdHNjIiwic3RzeiIsInN0dHMiLCJ2bWhkIiwic21oZCIsInZpZGVvSGRsciIsImF1ZGlvSGRsciIsIkhETFJfVFlQRVMiLCJTVFRTIiwiU1RTQyIsIlNUQ08iLCJTVFNaIiwiVk1IRCIsIlNNSEQiLCJTVFNEIiwibWFqb3JCcmFuZCIsImF2YzFCcmFuZCIsIm1pbm9yVmVyc2lvbiIsIkZUWVAiLCJib3giLCJESU5GIiwidXBwZXJXb3JkRHVyYXRpb24iLCJsb3dlcldvcmREdXJhdGlvbiIsImJveGVzIiwiZGVwZW5kc09uIiwiaXNEZXBlbmRlZE9uIiwiaGFzUmVkdW5kYW5jeSIsImF2Y2MiLCJoU3BhY2luZyIsInZTcGFjaW5nIiwiY29uZmlnbGVuIiwiYXVkaW9TdHNkIiwic2FtcGxlRGVwZW5kZW5jeVRhYmxlIiwidXBwZXJXb3JkQmFzZU1lZGlhRGVjb2RlVGltZSIsImxvd2VyV29yZEJhc2VNZWRpYURlY29kZVRpbWUiLCJhcnJheWxlbiIsImN0cyIsImlzTGVhZGluZyIsInBhZGRpbmdWYWx1ZSIsImlzTm9uU3luYyIsImRlZ3JhZFByaW8iLCJtb3ZpZSIsIk1QRUdfVFNfQ0xPQ0tfRlJFUV9IWiIsInRvVGltZXNjYWxlRnJvbUJhc2UiLCJkZXN0U2NhbGUiLCJzcmNCYXNlIiwidG9UaW1lc2NhbGVGcm9tU2NhbGUiLCJzcmNTY2FsZSIsInRvTXNGcm9tTXBlZ1RzQ2xvY2siLCJ0b01wZWdUc0Nsb2NrRnJvbVRpbWVzY2FsZSIsIk1BWF9TSUxFTlRfRlJBTUVfRFVSQVRJT04iLCJBQUNfU0FNUExFU19QRVJfRlJBTUUiLCJNUEVHX0FVRElPX1NBTVBMRV9QRVJfRlJBTUUiLCJBQzNfU0FNUExFU19QRVJfRlJBTUUiLCJjaHJvbWVWZXJzaW9uIiwic2FmYXJpV2Via2l0VmVyc2lvbiIsIk1QNFJlbXV4ZXIiLCJ2ZW5kb3IiLCJJU0dlbmVyYXRlZCIsIl9pbml0UFRTIiwiX2luaXREVFMiLCJuZXh0QXZjRHRzIiwibmV4dEF1ZGlvUHRzIiwidmlkZW9TYW1wbGVEdXJhdGlvbiIsImlzQXVkaW9Db250aWd1b3VzIiwiaXNWaWRlb0NvbnRpZ3VvdXMiLCJ2aWRlb1RyYWNrQ29uZmlnIiwiZGVmYXVsdFRpbWVTdGFtcCIsInJlc2V0TmV4dFRpbWVzdGFtcCIsImdldFZpZGVvU3RhcnRQdHMiLCJyb2xsb3ZlckRldGVjdGVkIiwibWluUFRTIiwibm9ybWFsaXplUHRzIiwicmVtdXgiLCJhY2N1cmF0ZVRpbWVPZmZzZXQiLCJhdWRpb1RpbWVPZmZzZXQiLCJ2aWRlb1RpbWVPZmZzZXQiLCJoYXNBdWRpbyIsImhhc1ZpZGVvIiwiZW5vdWdoQXVkaW9TYW1wbGVzIiwiZW5vdWdoVmlkZW9TYW1wbGVzIiwiY2FuUmVtdXhBdmMiLCJfdmlkZW9UcmFjayRwaXhlbFJhdGkiLCJfY29uZmlnJHBpeGVsUmF0aW8iLCJfdmlkZW9UcmFjayRwaXhlbFJhdGkyIiwiX2NvbmZpZyRwaXhlbFJhdGlvMiIsImdlbmVyYXRlSVMiLCJmaXJzdEtleUZyYW1lSW5kZXgiLCJmaXJzdEtleUZyYW1lUFRTIiwiZmluZEtleWZyYW1lSW5kZXgiLCJmb3JjZUtleUZyYW1lT25EaXNjb250aW51aXR5IiwidHNEZWx0YSIsImF1ZGlvdmlkZW9UaW1lc3RhbXBEZWx0YSIsInJlbXV4QXVkaW8iLCJhdWRpb1RyYWNrTGVuZ3RoIiwicmVtdXhWaWRlbyIsImZpcnN0S2V5RnJhbWUiLCJmbHVzaFRleHRUcmFja01ldGFkYXRhQ3VlU2FtcGxlcyIsImZsdXNoVGV4dFRyYWNrVXNlcmRhdGFDdWVTYW1wbGVzIiwiYXVkaW9TYW1wbGVzIiwiY29tcHV0ZVBUU0RUUyIsImluaXREVFMiLCJtZXRhZGF0YSIsImlucHV0U2FtcGxlcyIsIm91dHB1dFNhbXBsZXMiLCJtcDRTYW1wbGVEdXJhdGlvbiIsImZpcnN0RFRTIiwibGFzdERUUyIsIm1heFBUUyIsIk5FR0FUSVZFX0lORklOSVRZIiwic29ydFNhbXBsZXMiLCJpbml0VGltZSIsImRlbHRhZHRzIiwiZGVsdGFwdHMiLCJpbnB1dER1cmF0aW9uIiwiYXZlcmFnZVNhbXBsZUR1cmF0aW9uIiwiZm91bmRIb2xlIiwiZm91bmRPdmVybGFwIiwiZmlyc3RQVFMiLCJuYk5hbHUiLCJuYWx1TGVuIiwiZHRzU3RlcCIsIm5iVW5pdHMiLCJzYW1wbGVMZW4iLCJtZGF0U2l6ZSIsIk1VWF9FUlJPUiIsInN0cmV0Y2hlZExhc3RGcmFtZSIsIm1pbkR0c0RlbHRhIiwibWluUHRzRGVsdGEiLCJtYXhEdHNEZWx0YSIsIm1heFB0c0RlbHRhIiwiVmlkZW9TYW1wbGVVbml0cyIsIm1wNFNhbXBsZUxlbmd0aCIsInVuaXREYXRhIiwidW5pdERhdGFMZW4iLCJwdHNEZWx0YSIsImxhc3RGcmFtZUR1cmF0aW9uIiwic3RyZXRjaFNob3J0VmlkZW9UcmFjayIsImdhcFRvbGVyYW5jZSIsImRlbHRhVG9GcmFtZUVuZCIsImNvbXBvc2l0aW9uVGltZU9mZnNldCIsIk1wNFNhbXBsZSIsIm5leHREdHMiLCJuZXh0UHRzIiwibmIiLCJnZXRTYW1wbGVzUGVyRnJhbWUiLCJtcDR0aW1lU2NhbGUiLCJzY2FsZUZhY3RvciIsImlucHV0U2FtcGxlRHVyYXRpb24iLCJyYXdNUEVHIiwiYWxpZ25lZFdpdGhWaWRlbyIsInRpbWVPZmZzZXRNcGVnVFMiLCJtYXhBdWRpb0ZyYW1lc0RyaWZ0IiwibmV3U3RhbXAiLCJmaWxsRnJhbWUiLCJfbmJTYW1wbGVzIiwiYXVkaW9TYW1wbGUiLCJwcmV2U2FtcGxlIiwidW5pdExlbiIsInJlbXV4RW1wdHlBdWRpbyIsInNpbGVudEZyYW1lIiwicmVmZXJlbmNlIiwiaXNLZXlmcmFtZSIsIlBhc3NUaHJvdWdoUmVtdXhlciIsImVtaXRJbml0U2VnbWVudCIsImluaXRUcmFja3MiLCJsYXN0RW5kVGltZSIsImRlZmF1bHRJbml0UFRTIiwiZ2VuZXJhdGVJbml0U2VnbWVudCIsImdldFBhcnNlZFRyYWNrQ29kZWMiLCJfaW5pdERhdGEiLCJfaW5pdERhdGEyIiwiZGVjb2RlVGltZSIsImlzSW52YWxpZEluaXRQdHMiLCJtaW5EdXJhdGlvbiIsIm11eENvbmZpZyIsIlRyYW5zbXV4ZXIiLCJhc3luYyIsImRlbXV4ZXIiLCJyZW11eGVyIiwiZGVjcnlwdGlvblByb21pc2UiLCJ0cmFuc211eENvbmZpZyIsImN1cnJlbnRUcmFuc211eFN0YXRlIiwiY29uZmlndXJlIiwidWludERhdGEiLCJkaXNjb250aW51aXR5IiwidHJhY2tTd2l0Y2giLCJpbml0U2VnbWVudENoYW5nZSIsImRlZmF1bHRJbml0UHRzIiwiaW5pdFNlZ21lbnREYXRhIiwiZ2V0RW5jcnlwdGlvblR5cGUiLCJnZXREZWNyeXB0ZXIiLCJlbXB0eVJlc3VsdCIsInJlc2V0TXV4ZXJzIiwibmVlZHNQcm9iaW5nIiwiY29uZmlndXJlVHJhbnNtdXhlciIsInJlc2V0SW5pdGlhbFRpbWVzdGFtcCIsInRyYW5zbXV4IiwiY3VycmVudFN0YXRlIiwidHJhbnNtdXhSZXN1bHRzIiwiZGVtdXhSZXN1bHRPclByb21pc2UiLCJpc1Byb21pc2UiLCJmbHVzaFJlbXV4IiwicmVtdXhSZXN1bHQiLCJ0cmFuc211eFNhbXBsZUFlcyIsInRyYW5zbXV4VW5lbmNyeXB0ZWQiLCJtdXgiLCJfbXV4Q29uZmlnJGkkZGVtdXgiLCJSZW11eGVyIiwiRGVtdXhlciIsImVuY3J5cHRpb25UeXBlIiwicCIsIkZ1bmN0aW9uIiwiVHJhbnNtdXhDb25maWciLCJUcmFuc211eFN0YXRlIiwiZXZlbnRlbWl0dGVyMyIsInByZWZpeCIsIl9fcHJvdG9fXyIsIkVFIiwiZm4iLCJvbmNlIiwiYWRkTGlzdGVuZXIiLCJlbWl0dGVyIiwibGlzdGVuZXIiLCJldnQiLCJfZXZlbnRzIiwiX2V2ZW50c0NvdW50IiwiY2xlYXJFdmVudCIsIkV2ZW50RW1pdHRlciIsImV2ZW50TmFtZXMiLCJuYW1lcyIsImV2ZW50cyIsImxpc3RlbmVycyIsImhhbmRsZXJzIiwibCIsImVlIiwibGlzdGVuZXJDb3VudCIsImExIiwiYTIiLCJhMyIsImE0IiwiYTUiLCJhcmdzIiwicmVtb3ZlTGlzdGVuZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJwcmVmaXhlZCIsImV2ZW50ZW1pdHRlcjNFeHBvcnRzIiwiVHJhbnNtdXhlckludGVyZmFjZSIsIm9uVHJhbnNtdXhDb21wbGV0ZSIsIm9uRmx1c2giLCJ1c2VXb3JrZXIiLCJ3b3JrZXJDb250ZXh0Iiwib253bXNnIiwiZW5hYmxlV29ya2VyIiwiZm9yd2FyZE1lc3NhZ2UiLCJldiIsIm0ydHNUeXBlU3VwcG9ydGVkIiwiY2FuQ3JlYXRlV29ya2VyIiwid29ya2VyUGF0aCIsIm9uV29ya2VyTWVzc2FnZSIsIm9uZXJyb3IiLCJmaWxlbmFtZSIsImxpbmVubyIsInBvc3RNZXNzYWdlIiwiY21kIiwicmVzZXRXb3JrZXIiLCJyZXZva2VPYmplY3RVUkwiLCJ0ZXJtaW5hdGUiLCJfZnJhZyRpbml0U2VnbWVudCIsIl9sYXN0RnJhZyRpbml0U2VnbWVudCIsInNuRGlmZiIsInBhcnREaWZmIiwidHJhbnNtdXhSZXN1bHQiLCJoYW5kbGVUcmFuc211eENvbXBsZXRlIiwidHJhbnNtdXhlckVycm9yIiwiYXN5bmNGbHVzaCIsImhhbmRsZUZsdXNoUmVzdWx0IiwiX3RoaXMkd29ya2VyQ29udGV4dCIsImxvZ1R5cGUiLCJzdWJ0aXRsZU9wdGlvbnNJZGVudGljYWwiLCJ0cmFja0xpc3QxIiwidHJhY2tMaXN0MiIsIm1lZGlhQXR0cmlidXRlc0lkZW50aWNhbCIsImF0dHJzMSIsImF0dHJzMiIsImN1c3RvbUF0dHJpYnV0ZXMiLCJzdGFibGVSZW5kaXRpb25JZCIsInN1YnRpdGxlQXR0cmlidXRlIiwic3VidGl0bGVUcmFja01hdGNoZXNUZXh0VHJhY2siLCJzdWJ0aXRsZVRyYWNrIiwibGFuZ3VhZ2UiLCJUSUNLX0lOVEVSVkFMJDIiLCJBdWRpb1N0cmVhbUNvbnRyb2xsZXIiLCJ2aWRlb0J1ZmZlciIsInZpZGVvVHJhY2tDQyIsIndhaXRpbmdWaWRlb0NDIiwiYnVmZmVyZWRUcmFjayIsInN3aXRjaGluZ1RyYWNrIiwid2FpdGluZ0RhdGEiLCJtYWluRGV0YWlscyIsImZsdXNoaW5nIiwiYnVmZmVyRmx1c2hlZCIsImNhY2hlZFRyYWNrTG9hZGVkRGF0YSIsIkFVRElPX1RSQUNLU19VUERBVEVEIiwib25BdWRpb1RyYWNrc1VwZGF0ZWQiLCJBVURJT19UUkFDS19TV0lUQ0hJTkciLCJvbkF1ZGlvVHJhY2tTd2l0Y2hpbmciLCJvbkF1ZGlvVHJhY2tMb2FkZWQiLCJCVUZGRVJfUkVTRVQiLCJvbkJ1ZmZlclJlc2V0IiwiQlVGRkVSX0NSRUFURUQiLCJvbkJ1ZmZlckNyZWF0ZWQiLCJCVUZGRVJfRkxVU0hFRCIsIm9uQnVmZmVyRmx1c2hlZCIsIklOSVRfUFRTX0ZPVU5EIiwib25Jbml0UHRzRm91bmQiLCJkb1RpY2tJZGxlIiwiX2xldmVscyR0cmFja0lkIiwiX3RoaXMkbWVkaWEiLCJzZWVraW5nIiwiY2FjaGUiLCJjbGVhcldhaXRpbmdGcmFnbWVudCIsIndhaXRpbmdGcmFnbWVudEF0UG9zaXRpb24iLCJzdGFydEZyYWdQcmVmZXRjaCIsInRyYWNrRGV0YWlscyIsIkJVRkZFUl9FT1MiLCJtYWluQnVmZmVySW5mbyIsImF0R2FwIiwiYXRCdWZmZXJTeW5jTGltaXQiLCJtYWluRnJhZyIsIm1haW5CdWZmZXJMZW5ndGgiLCJtYXhDb25maWdCdWZmZXIiLCJtZWRpYVBsYXlsaXN0IiwiYWx0QXVkaW8iLCJmbHVzaEF1ZGlvSWZOZWVkZWQiLCJfdHJhY2skZGV0YWlscyIsImRlZmF1bHRBdWRpb0NvZGVjIiwiX2hhbmRsZVRyYW5zbXV4Q29tcGxldGUiLCJBVURJT19UUkFDS19TV0lUQ0hFRCIsIl9pZDMkc2FtcGxlcyIsImNvbXBsZXRlQXVkaW9Td2l0Y2giLCJtYXBGcmFnbWVudCIsIl9idWZmZXJJbml0U2VnbWVudCIsIkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQiLCJlbWl0dGVkSUQzIiwiZW1pdHRlZFRleHQiLCJGUkFHX1BBUlNJTkdfVVNFUkRBVEEiLCJ2YXJpYW50QXVkaW9Db2RlY3MiLCJCVUZGRVJfQ09ERUNTIiwiX3RyYWNrJGRldGFpbHMyIiwiYnVmZmVyZWRBdHRyaWJ1dGVzIiwic3dpdGNoQXR0cmlidXRlcyIsIkF1ZGlvVHJhY2tDb250cm9sbGVyIiwiZ3JvdXBJZHMiLCJ0cmFja3NJbkdyb3VwIiwiY3VycmVudFRyYWNrIiwic2VsZWN0RGVmYXVsdFRyYWNrIiwiTUFOSUZFU1RfUEFSU0VEIiwib25NYW5pZmVzdFBhcnNlZCIsInRyYWNrSW5BY3RpdmVHcm91cCIsImN1cnJlbnRHcm91cHMiLCJncm91cEluZGV4IiwiYWxsSW5kZXgiLCJmaW5kVHJhY2tJZCIsImF1ZGlvVHJhY2tzVXBkYXRlZCIsInNlbGVjdGVkVHJhY2tJZCIsInNldEF1ZGlvVHJhY2siLCJfdGhpcyRncm91cElkcyIsIm5ld0lkIiwic2V0QXVkaW9PcHRpb24iLCJhdWRpb09wdGlvbiIsInN3aXRjaEluZGV4Iiwid2l0aG91dENvZGVjQW5kQ2hhbm5lbHNNYXRjaCIsImxhc3RUcmFjayIsInRyYWNrTG9hZGVkIiwiVElDS19JTlRFUlZBTCQxIiwiU3VidGl0bGVTdHJlYW1Db250cm9sbGVyIiwiY3VycmVudFRyYWNrSWQiLCJ0cmFja3NCdWZmZXJlZCIsIlNVQlRJVExFX1RSQUNLU19VUERBVEVEIiwib25TdWJ0aXRsZVRyYWNrc1VwZGF0ZWQiLCJTVUJUSVRMRV9UUkFDS19TV0lUQ0giLCJvblN1YnRpdGxlVHJhY2tTd2l0Y2giLCJvblN1YnRpdGxlVHJhY2tMb2FkZWQiLCJTVUJUSVRMRV9GUkFHX1BST0NFU1NFRCIsIm9uU3VidGl0bGVGcmFnUHJvY2Vzc2VkIiwic3VjY2VzcyIsImZyYWdTdGFydCIsImZyYWdFbmQiLCJlbmRPZmZzZXRTdWJ0aXRsZXMiLCJtZWRpYUJ1ZmZlclRpbWVSYW5nZXMiLCJtYWluU2xpZGluZ1N0YXJ0RnJhZ21lbnQiLCJmb3VuZEZyYWciLCJCdWZmZXJhYmxlSW5zdGFuY2UiLCJ0aW1lcmFuZ2VzIiwiZ2V0UmFuZ2UiLCJET01FeGNlcHRpb24iLCJTdWJ0aXRsZVRyYWNrQ29udHJvbGxlciIsInF1ZXVlZERlZmF1bHRUcmFjayIsImFzeW5jUG9sbFRyYWNrQ2hhbmdlIiwicG9sbFRyYWNrQ2hhbmdlIiwidXNlVGV4dFRyYWNrUG9sbGluZyIsInN1YnRpdGxlUG9sbGluZ0ludGVydmFsIiwiX3N1YnRpdGxlRGlzcGxheSIsIm9uVGV4dFRyYWNrc0NoYW5nZWQiLCJyZW5kZXJUZXh0VHJhY2tzTmF0aXZlbHkiLCJmaW5kVHJhY2tGb3JUZXh0VHJhY2siLCJzZXRTdWJ0aXRsZVRyYWNrIiwic3VidGl0bGVEaXNwbGF5IiwidG9nZ2xlVHJhY2tNb2RlcyIsInN1YnRpdGxlUHJlZmVyZW5jZSIsInN1YnRpdGxlVHJhY2tzVXBkYXRlZCIsInNlbGVjdERlZmF1bHQiLCJhbGxTdWJ0aXRsZVRyYWNrcyIsInNldFN1YnRpdGxlT3B0aW9uIiwic3VidGl0bGVPcHRpb24iLCJuZXh0VHJhY2siLCJCdWZmZXJPcGVyYXRpb25RdWV1ZSIsInNvdXJjZUJ1ZmZlclJlZmVyZW5jZSIsImJ1ZmZlcnMiLCJxdWV1ZXMiLCJhcHBlbmQiLCJvcGVyYXRpb24iLCJwZW5kaW5nIiwicXVldWUiLCJleGVjdXRlTmV4dCIsImluc2VydEFib3J0IiwiYXBwZW5kQmxvY2tlciIsImV4ZWN1dGUiLCJwcm9taXNlIiwib25TdGFydCIsIm9uQ29tcGxldGUiLCJzYiIsInVwZGF0aW5nIiwic2hpZnRBbmRFeGVjdXRlTmV4dCIsImN1cnJlbnQiLCJWSURFT19DT0RFQ19QUk9GSUxFX1JFUExBQ0UiLCJCdWZmZXJDb250cm9sbGVyIiwiX29iamVjdFVybCIsIm9wZXJhdGlvblF1ZXVlIiwiYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCIsIl9idWZmZXJDb2RlY0V2ZW50c1RvdGFsIiwibWVkaWFTb3VyY2UiLCJsYXN0TXBlZ0F1ZGlvQ2h1bmsiLCJhcHBlbmRTb3VyY2UiLCJhcHBlbmRFcnJvcnMiLCJwZW5kaW5nVHJhY2tzIiwic291cmNlQnVmZmVyIiwiX29uRW5kU3RyZWFtaW5nIiwicGF1c2VCdWZmZXJpbmciLCJfb25TdGFydFN0cmVhbWluZyIsInJlc3VtZUJ1ZmZlcmluZyIsIl9vbk1lZGlhU291cmNlT3BlbiIsIl9vbk1lZGlhRW1wdGllZCIsInVwZGF0ZU1lZGlhRWxlbWVudER1cmF0aW9uIiwiY2hlY2tQZW5kaW5nVHJhY2tzIiwiX29uTWVkaWFTb3VyY2VDbG9zZSIsIl9vbk1lZGlhU291cmNlRW5kZWQiLCJtZWRpYVNyYyIsIl9pbml0U291cmNlQnVmZmVyIiwiaGFzU291cmNlVHlwZXMiLCJnZXRTb3VyY2VCdWZmZXJUeXBlcyIsIk1FRElBX0FUVEFDSElORyIsIm9uTWVkaWFBdHRhY2hpbmciLCJvbkJ1ZmZlckFwcGVuZGluZyIsIm9uQnVmZmVyQ29kZWNzIiwib25CdWZmZXJFb3MiLCJvbkZyYWdQYXJzZWQiLCJGUkFHX0NIQU5HRUQiLCJvbkZyYWdDaGFuZ2VkIiwiY29kZWNFdmVudHMiLCJfbXMkY29uc3RydWN0b3IiLCJtcyIsIm9iamVjdFVybCIsInJlbW92ZUF0dHJpYnV0ZSIsIk1NUyIsImRpc2FibGVSZW1vdGVQbGF5YmFjayIsInJlbW92ZVNvdXJjZUNoaWxkcmVuIiwiYWRkU291cmNlIiwic3JjIiwiZW5kT2ZTdHJlYW0iLCJNRURJQV9ERVRBQ0hFRCIsInJlc2V0QnVmZmVyIiwiX3RoaXMkbWVkaWFTb3VyY2UiLCJyZW1vdmVCdWZmZXJMaXN0ZW5lcnMiLCJzb3VyY2VCdWZmZXJzIiwicmVtb3ZlU291cmNlQnVmZmVyIiwic291cmNlQnVmZmVyQ291bnQiLCJ0cmFja05hbWVzIiwidHJhY2tOYW1lIiwiY2hhbmdlVHlwZSIsIl90cmFja0NvZGVjIiwiY3VycmVudENvZGVjRnVsbCIsImN1cnJlbnRDb2RlYyIsInRyYWNrQ29kZWMiLCJuZXh0Q29kZWMiLCJtaW1lVHlwZSIsImFwcGVuZENoYW5nZVR5cGUiLCJldmVudERhdGEiLCJjaHVua1N0YXRzIiwiYnVmZmVyQXBwZW5kaW5nU3RhcnQiLCJmcmFnQnVmZmVyaW5nIiwicGFydEJ1ZmZlcmluZyIsImNoZWNrVGltZXN0YW1wT2Zmc2V0IiwidGltZXN0YW1wT2Zmc2V0IiwiYXBwZW5kRXhlY3V0b3IiLCJRVU9UQV9FWENFRURFRF9FUlIiLCJhcHBlbmRFcnJvckNvdW50IiwiYXBwZW5kRXJyb3JNYXhSZXRyeSIsImZsdXNoT3BlcmF0aW9uIiwicmVtb3ZlRXhlY3V0b3IiLCJidWZmZXJzQXBwZW5kZWRUbyIsIm9uVW5ibG9ja2VkIiwiYmxvY2tCdWZmZXJzIiwidHJpbUJ1ZmZlcnMiLCJlbmRpbmciLCJzb3VyY2VCdWZmZXJUeXBlcyIsImJhY2tCdWZmZXJMZW5ndGgiLCJsaXZlQmFja0J1ZmZlckxlbmd0aCIsIm1heEJhY2tCdWZmZXJMZW5ndGgiLCJ0YXJnZXRCYWNrQnVmZmVyUG9zaXRpb24iLCJmbHVzaEJhY2tCdWZmZXIiLCJmcm9udEJ1ZmZlckZsdXNoVGhyZXNob2xkIiwiZnJvbnRCdWZmZXJMZW5ndGgiLCJtYXhGcm9udEJ1ZmZlckxlbmd0aCIsInRhcmdldEZyb250QnVmZmVyUG9zaXRpb24iLCJmbHVzaEZyb250QnVmZmVyIiwiQkFDS19CVUZGRVJfUkVBQ0hFRCIsIkxJVkVfQkFDS19CVUZGRVJfUkVBQ0hFRCIsIm51bUJ1ZmZlcmVkUmFuZ2VzIiwibGV2ZWxEdXJhdGlvbiIsIm1lZGlhRHVyYXRpb24iLCJtc0R1cmF0aW9uIiwibGl2ZUR1cmF0aW9uSW5maW5pdHkiLCJ1cGRhdGVTZWVrYWJsZVJhbmdlIiwic2V0TGl2ZVNlZWthYmxlUmFuZ2UiLCJwZW5kaW5nVHJhY2tzQ291bnQiLCJjcmVhdGVTb3VyY2VCdWZmZXJzIiwiQlVGRkVSX0lOQ09NUEFUSUJMRV9DT0RFQ1NfRVJST1IiLCJhZGRTb3VyY2VCdWZmZXIiLCJzYk5hbWUiLCJhZGRCdWZmZXJMaXN0ZW5lciIsIl9vblNCVXBkYXRlU3RhcnQiLCJfb25TQlVwZGF0ZUVuZCIsIl9vblNCVXBkYXRlRXJyb3IiLCJyZW1vdmVkUmFuZ2VzIiwiZmlyc3RDaGlsZCIsIl90aGlzJG1lZGlhU291cmNlMiIsIl90aGlzJG1lZGlhU291cmNlMyIsInJlbW92ZVN0YXJ0IiwicmVtb3ZlRW5kIiwicmVtb3ZlIiwiYXBwZW5kQnVmZmVyIiwiYmxvY2tpbmdPcGVyYXRpb25zIiwibm9kZSIsInNvdXJjZUNoaWxkcmVuIiwicXVlcnlTZWxlY3RvckFsbCIsInJlbW92ZUNoaWxkIiwiY3JlYXRlRWxlbWVudCIsImFwcGVuZENoaWxkIiwic3BlY2lhbENlYTYwOENoYXJzQ29kZXMiLCJnZXRDaGFyRm9yQnl0ZSIsImNoYXJDb2RlIiwiTlJfUk9XUyIsIk5SX0NPTFMiLCJyb3dzTG93Q2gxIiwicm93c0hpZ2hDaDEiLCJyb3dzTG93Q2gyIiwicm93c0hpZ2hDaDIiLCJiYWNrZ3JvdW5kQ29sb3JzIiwiQ2FwdGlvbnNMb2dnZXIiLCJ2ZXJib3NlTGV2ZWwiLCJzZXZlcml0eSIsIm51bUFycmF5VG9IZXhBcnJheSIsIm51bUFycmF5IiwiaGV4QXJyYXkiLCJQZW5TdGF0ZSIsImZvcmVncm91bmQiLCJ1bmRlcmxpbmUiLCJpdGFsaWNzIiwiYmFja2dyb3VuZCIsImZsYXNoIiwic2V0U3R5bGVzIiwic3R5bGVzIiwiYXR0cmlicyIsInN0eWxlIiwiZXF1YWxzIiwib3RoZXIiLCJjb3B5IiwibmV3UGVuU3RhdGUiLCJTdHlsZWRVbmljb2RlQ2hhciIsInVjaGFyIiwicGVuU3RhdGUiLCJzZXRDaGFyIiwic2V0UGVuU3RhdGUiLCJuZXdDaGFyIiwiaXNFbXB0eSIsIlJvdyIsImNoYXJzIiwiY3VyclBlblN0YXRlIiwiY3VlU3RhcnRUaW1lIiwiZW1wdHkiLCJzZXRDdXJzb3IiLCJhYnNQb3MiLCJtb3ZlQ3Vyc29yIiwicmVsUG9zIiwibmV3UG9zIiwiYmFja1NwYWNlIiwiaW5zZXJ0Q2hhciIsImNoYXIiLCJjbGVhckZyb21Qb3MiLCJzdGFydFBvcyIsImNsZWFyIiwiY2xlYXJUb0VuZE9mUm93IiwiZ2V0VGV4dFN0cmluZyIsInNldFBlblN0eWxlcyIsImN1cnJDaGFyIiwiQ2FwdGlvblNjcmVlbiIsInJvd3MiLCJjdXJyUm93IiwibnJSb2xsVXBSb3dzIiwibGFzdE91dHB1dFNjcmVlbiIsImVxdWFsIiwicm93Iiwic2V0UGVuIiwic2V0UEFDIiwicGFjRGF0YSIsIm5ld1JvdyIsInRvcFJvd0luZGV4IiwicHJldkxpbmVUaW1lIiwiaW5kZW50IiwicHJldlBvcyIsImNvbG9yIiwic2V0QmtnRGF0YSIsImJrZ0RhdGEiLCJzZXRSb2xsVXBSb3dzIiwibnJSb3dzIiwicm9sbFVwIiwiZ2V0RGlzcGxheVRleHQiLCJ0b3BSb3ciLCJhc09uZVJvdyIsImRpc3BsYXlUZXh0Iiwicm93TnIiLCJyb3dUZXh0IiwiZ2V0VGV4dEFuZEZvcm1hdCIsIkNlYTYwOENoYW5uZWwiLCJjaGFubmVsTnVtYmVyIiwib3V0cHV0RmlsdGVyIiwiY2hOciIsInZlcmJvc2UiLCJkaXNwbGF5ZWRNZW1vcnkiLCJub25EaXNwbGF5ZWRNZW1vcnkiLCJjdXJyUm9sbFVwUm93Iiwid3JpdGVTY3JlZW4iLCJnZXRIYW5kbGVyIiwic2V0SGFuZGxlciIsIm5ld0hhbmRsZXIiLCJzZXRNb2RlIiwibmV3TW9kZSIsImluc2VydENoYXJzIiwic2NyZWVuIiwib3V0cHV0RGF0YVVwZGF0ZSIsImNjUkNMIiwiY2NCUyIsImNjQU9GIiwiY2NBT04iLCJjY0RFUiIsImNjUlUiLCJjY0ZPTiIsImNjUkRDIiwiY2NUUiIsImNjUlREIiwiY2NFRE0iLCJjY0NSIiwiY2NFTk0iLCJjY0VPQyIsInRtcCIsImNjVE8iLCJuckNvbHMiLCJjY01JRFJPVyIsInNlY29uZEJ5dGUiLCJjb2xvckluZGV4IiwiY29sb3JzIiwiZGlzcGF0Y2giLCJuZXdDdWUiLCJkaXNwYXRjaEN1ZSIsImN1ZVNwbGl0QXRUaW1lIiwiQ2VhNjA4UGFyc2VyIiwiZmllbGQiLCJvdXQxIiwib3V0MiIsImN1cnJlbnRDaGFubmVsIiwiY21kSGlzdG9yeSIsImNyZWF0ZUNtZEhpc3RvcnkiLCJjaGFubmVsIiwiYWRkRGF0YSIsImJ5dGVMaXN0IiwiY21kRm91bmQiLCJjaGFyc0ZvdW5kIiwicGFyc2VDbWQiLCJwYXJzZU1pZHJvdyIsInBhcnNlUEFDIiwicGFyc2VCYWNrZ3JvdW5kQXR0cmlidXRlcyIsInBhcnNlQ2hhcnMiLCJjdXJyQ2hOciIsImNvbmQxIiwiY29uZDIiLCJoYXNDbWRSZXBlYXRlZCIsInNldExhc3RDbWQiLCJjYXNlMSIsImNhc2UyIiwiaW50ZXJwcmV0UEFDIiwicGFjSW5kZXgiLCJjaGFubmVsTnIiLCJjaGFyQ29kZXMiLCJjaGFyQ29kZTEiLCJvbmVDb2RlIiwiaGV4Q29kZXMiLCJPdXRwdXRGaWx0ZXIiLCJ0aW1lbGluZUNvbnRyb2xsZXIiLCJjdWVSYW5nZXMiLCJhZGRDdWVzIiwiY3JlYXRlQ2FwdGlvbnNUcmFjayIsIkFsbG93ZWREaXJlY3Rpb25zIiwiQWxsb3dlZEFsaWdubWVudHMiLCJpc0FsbG93ZWRWYWx1ZSIsImFsbG93ZWQiLCJsY1ZhbHVlIiwiZmluZERpcmVjdGlvblNldHRpbmciLCJmaW5kQWxpZ25TZXR0aW5nIiwiZXh0ZW5kIiwicmVzdCIsImNvYmoiLCJiYXNlT2JqIiwiaGFzQmVlblJlc2V0IiwiX2lkIiwiX3BhdXNlT25FeGl0IiwiX3N0YXJ0VGltZSIsIl9lbmRUaW1lIiwiX3RleHQiLCJfcmVnaW9uIiwiX3ZlcnRpY2FsIiwiX3NuYXBUb0xpbmVzIiwiX2xpbmUiLCJfbGluZUFsaWduIiwiX3Bvc2l0aW9uIiwiX3Bvc2l0aW9uQWxpZ24iLCJfc2l6ZSIsIl9hbGlnbiIsInNldHRpbmciLCJTeW50YXhFcnJvciIsImRpc3BsYXlTdGF0ZSIsImdldEN1ZUFzSFRNTCIsIldlYlZUVCIsImNvbnZlcnRDdWVUb0RPTVRyZWUiLCJTdHJpbmdEZWNvZGVyIiwib3B0aW9ucyIsImRlY29kZVVSSUNvbXBvbmVudCIsInBhcnNlVGltZVN0YW1wIiwiY29tcHV0ZVNlY29uZHMiLCJmIiwiU2V0dGluZ3MiLCJ2YWx1ZXMiLCJ2IiwiZGZsdCIsImRlZmF1bHRLZXkiLCJhbHQiLCJuIiwiaW50ZWdlciIsInBlcmNlbnQiLCJwYXJzZU9wdGlvbnMiLCJrZXlWYWx1ZURlbGltIiwiZ3JvdXBEZWxpbSIsImt2IiwiZGVmYXVsdHMiLCJjZW50ZXIiLCJhbGlnbiIsInBhcnNlQ3VlIiwicmVnaW9uTGlzdCIsIm9JbnB1dCIsImNvbnN1bWVUaW1lU3RhbXAiLCJ0cyIsImNvbnN1bWVDdWVTZXR0aW5ncyIsInNldHRpbmdzIiwidmFscyIsInJlZ2lvbiIsInZlcnRpY2FsIiwibGluZSIsImxpbmVBbGlnbiIsInNuYXBUb0xpbmVzIiwic2tpcFdoaXRlc3BhY2UiLCJmaXhMaW5lQnJlYWtzIiwiVlRUUGFyc2VyIiwib25jdWUiLCJvbnBhcnNpbmdlcnJvciIsIm9uZmx1c2giLCJfdGhpcyIsImNvbGxlY3ROZXh0TGluZSIsImFscmVhZHlDb2xsZWN0ZWRMaW5lIiwiaGFzU3Vic3RyaW5nIiwiTElORUJSRUFLUyIsImlucHV0U3RyaW5nIiwic2VhcmNoU3RyaW5nIiwiY3VlU3RyaW5nMm1pbGxpcyIsInRpbWVTdHJpbmciLCJzZWNzIiwibWlucyIsImhvdXJzIiwiaGFzaCIsIl9oYXNoIiwiZ2VuZXJhdGVDdWVJZCIsImNhbGN1bGF0ZU9mZnNldCIsInZ0dENDcyIsImN1cnJDQyIsInByZXZDQyIsIm5ldyIsInByZXNlbnRhdGlvbk9mZnNldCIsIl9wcmV2Q0MiLCJwYXJzZVdlYlZUVCIsInZ0dEJ5dGVBcnJheSIsImNhbGxCYWNrIiwiZXJyb3JDYWxsQmFjayIsInZ0dExpbmVzIiwiY3VlVGltZSIsInRpbWVzdGFtcE1hcE1QRUdUUyIsInRpbWVzdGFtcE1hcExPQ0FMIiwicGFyc2luZ0Vycm9yIiwiaW5IZWFkZXIiLCJjdWVPZmZzZXQiLCJ3ZWJWdHRNcGVnVHNNYXBPZmZzZXQiLCJJTVNDMV9DT0RFQyIsIkhNU0ZfUkVHRVgiLCJUSU1FX1VOSVRfUkVHRVgiLCJ0ZXh0QWxpZ25Ub0xpbmVBbGlnbiIsInBhcnNlSU1TQzEiLCJ0dG1sTGlzdCIsInN5bmNUaW1lIiwidHRtbCIsInBhcnNlVFRNTCIsInR0IiwiZGVmYXVsdFJhdGVJbmZvIiwic3ViRnJhbWVSYXRlIiwiZnJhbWVSYXRlTXVsdGlwbGllciIsInRpY2tSYXRlIiwicmF0ZUluZm8iLCJzdHlsZUVsZW1lbnRzIiwiY29sbGVjdGlvblRvRGljdGlvbmFyeSIsImdldEVsZW1lbnRDb2xsZWN0aW9uIiwicmVnaW9uRWxlbWVudHMiLCJjdWVFbGVtZW50cyIsImN1ZUVsZW1lbnQiLCJjdWVUZXh0IiwiZ2V0VGV4dENvbnRlbnQiLCJoYXNBdHRyaWJ1dGUiLCJwYXJzZVR0bWxUaW1lIiwidGltZXN0YW1wUGFyc2luZ0Vycm9yIiwiZ2V0VHRtbFN0eWxlcyIsInRleHRBbGlnbiIsImZyb21FbGVtZW50IiwicGFyZW50TmFtZSIsImNoaWxkTmFtZSIsImVsZW1lbnRzV2l0aElkIiwiZGljdCIsImVsZW1lbnQiLCJfbm9kZSRjaGlsZE5vZGVzIiwibm9kZU5hbWUiLCJ0ZXh0Q29udGVudCIsInR0c05zIiwicmVnaW9uU3R5bGUiLCJzdHlsZUF0dHJpYnV0ZXMiLCJyZWdpb25TdHlsZU5hbWUiLCJnZXRBdHRyaWJ1dGVOUyIsIm5zIiwiaGFzQXR0cmlidXRlTlMiLCJ0aW1lQXR0cmlidXRlVmFsdWUiLCJwYXJzZUhvdXJzTWludXRlc1NlY29uZHNGcmFtZXMiLCJwYXJzZVRpbWVVbml0cyIsIlRpbWVsaW5lQ29udHJvbGxlciIsIkN1ZXMiLCJ1bnBhcnNlZFZ0dEZyYWdzIiwiY2FwdGlvbnNUcmFja3MiLCJub25OYXRpdmVDYXB0aW9uc1RyYWNrcyIsImNlYTYwOFBhcnNlcjEiLCJjZWE2MDhQYXJzZXIyIiwibGFzdENjIiwibmV3VlRUQ0NzIiwiY2FwdGlvbnNQcm9wZXJ0aWVzIiwiY3VlSGFuZGxlciIsInRleHRUcmFjazEiLCJjYXB0aW9uc1RleHRUcmFjazFMYWJlbCIsImxhbmd1YWdlQ29kZSIsImNhcHRpb25zVGV4dFRyYWNrMUxhbmd1YWdlQ29kZSIsInRleHRUcmFjazIiLCJjYXB0aW9uc1RleHRUcmFjazJMYWJlbCIsImNhcHRpb25zVGV4dFRyYWNrMkxhbmd1YWdlQ29kZSIsInRleHRUcmFjazMiLCJjYXB0aW9uc1RleHRUcmFjazNMYWJlbCIsImNhcHRpb25zVGV4dFRyYWNrM0xhbmd1YWdlQ29kZSIsInRleHRUcmFjazQiLCJjYXB0aW9uc1RleHRUcmFjazRMYWJlbCIsImNhcHRpb25zVGV4dFRyYWNrNExhbmd1YWdlQ29kZSIsIm9uRnJhZ1BhcnNpbmdVc2VyZGF0YSIsIm9uRnJhZ0RlY3J5cHRlZCIsIlNVQlRJVExFX1RSQUNLU19DTEVBUkVEIiwib25TdWJ0aXRsZVRyYWNrc0NsZWFyZWQiLCJpbml0Q2VhNjA4UGFyc2VycyIsImVuYWJsZUNFQTcwOENhcHRpb25zIiwiY2hhbm5lbDEiLCJjaGFubmVsMiIsImNoYW5uZWwzIiwiY2hhbm5lbDQiLCJtZXJnZWQiLCJjdWVSYW5nZSIsIm92ZXJsYXAiLCJpbnRlcnNlY3Rpb24iLCJDVUVTX1BBUlNFRCIsImdldEV4aXN0aW5nVHJhY2siLCJjYW5SZXVzZVZ0dFRleHRUcmFjayIsImNyZWF0ZU5hdGl2ZVRyYWNrIiwiY3JlYXRlTm9uTmF0aXZlVHJhY2siLCJleGlzdGluZ1RyYWNrIiwiY3JlYXRlVGV4dFRyYWNrIiwidHJhY2tQcm9wZXJ0aWVzIiwiY2xvc2VkQ2FwdGlvbnMiLCJOT05fTkFUSVZFX1RFWFRfVFJBQ0tTX0ZPVU5EIiwiX2NsZWFuVHJhY2tzIiwiaGFzSU1TQzEiLCJlbmFibGVXZWJWVFQiLCJlbmFibGVJTVNDMSIsImxpc3RJc0lkZW50aWNhbCIsImluVXNlVHJhY2tzIiwiaW5Vc2VUcmFjayIsInRleHRUcmFja0tpbmQiLCJjYXB0aW9uc09yU3VidGl0bGVzRnJvbUNoYXJhY3RlcmlzdGljcyIsInVudXNlZFRleHRUcmFja3MiLCJ0cmFja3NMaXN0IiwiY2FwdGlvbnNUcmFjayIsImluc3RyZWFtSWRNYXRjaCIsImNsb3NlZENhcHRpb25zRm9yTGV2ZWwiLCJfZGF0YSRwYXJ0JGluZGV4IiwiZGVjcnlwdGVkIiwidHJhY2tQbGF5bGlzdE1lZGlhIiwiX3BhcnNlSU1TQzEiLCJfcGFyc2VWVFRzIiwiX2FwcGVuZEN1ZXMiLCJtYXhBdkNDIiwicGF5bG9hZFdlYlZUVCIsIm1pc3NpbmdJbml0UFRTIiwiX2ZhbGxiYWNrVG9JTVNDMSIsImZyYWdMZXZlbCIsImNjQnl0ZXMiLCJjY2RhdGFzIiwiZXh0cmFjdENlYTYwOERhdGEiLCJhY3R1YWxDQ0J5dGVzIiwidG1wQnl0ZSIsImNjYnl0ZTEiLCJjY2J5dGUyIiwiY2NWYWxpZCIsImNjVHlwZSIsIm1hbmlmZXN0VHJhY2siLCJ4MSIsInkxIiwieTIiLCJDYXBMZXZlbENvbnRyb2xsZXIiLCJhdXRvTGV2ZWxDYXBwaW5nIiwicmVzdHJpY3RlZExldmVscyIsImNsaWVudFJlY3QiLCJzdHJlYW1Db250cm9sbGVyIiwic2V0U3RyZWFtQ29udHJvbGxlciIsInVucmVnaXN0ZXJMaXN0ZW5lciIsInN0b3BDYXBwaW5nIiwiRlBTX0RST1BfTEVWRUxfQ0FQUElORyIsIm9uRnBzRHJvcExldmVsQ2FwcGluZyIsImRyb3BwZWRMZXZlbCIsImlzTGV2ZWxBbGxvd2VkIiwiSFRNTFZpZGVvRWxlbWVudCIsImRldGVjdFBsYXllclNpemUiLCJjYXBMZXZlbFRvUGxheWVyU2l6ZSIsInN0YXJ0Q2FwcGluZyIsIm1lZGlhSGVpZ2h0IiwibWVkaWFXaWR0aCIsIm1heExldmVsIiwiZ2V0TWF4TGV2ZWwiLCJuZXh0TGV2ZWxTd2l0Y2giLCJjYXBMZXZlbEluZGV4IiwidmFsaWRMZXZlbHMiLCJnZXRNYXhMZXZlbEJ5TWVkaWFTaXplIiwiZ2V0RGltZW5zaW9ucyIsImJvdW5kc1JlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJib3R0b20iLCJ0b3AiLCJjb250ZW50U2NhbGVGYWN0b3IiLCJpZ25vcmVEZXZpY2VQaXhlbFJhdGlvIiwiZGV2aWNlUGl4ZWxSYXRpbyIsInJlc3RyaWN0ZWRMZXZlbCIsImF0R3JlYXRlc3RCYW5kd2lkdGgiLCJjdXJMZXZlbCIsIm1heExldmVsSW5kZXgiLCJzcXVhcmVTaXplIiwiRlBTQ29udHJvbGxlciIsImlzVmlkZW9QbGF5YmFja1F1YWxpdHlBdmFpbGFibGUiLCJsYXN0VGltZSIsImxhc3REcm9wcGVkRnJhbWVzIiwibGFzdERlY29kZWRGcmFtZXMiLCJjYXBMZXZlbE9uRlBTRHJvcCIsImdldFZpZGVvUGxheWJhY2tRdWFsaXR5IiwiY2hlY2tGUFNJbnRlcnZhbCIsImZwc0Ryb3BwZWRNb25pdG9yaW5nUGVyaW9kIiwiY2hlY2tGUFMiLCJkZWNvZGVkRnJhbWVzIiwiZHJvcHBlZEZyYW1lcyIsImN1cnJlbnRQZXJpb2QiLCJjdXJyZW50RHJvcHBlZCIsImN1cnJlbnREZWNvZGVkIiwiZHJvcHBlZEZQUyIsIkZQU19EUk9QIiwidG90YWxEcm9wcGVkRnJhbWVzIiwiZnBzRHJvcHBlZE1vbml0b3JpbmdUaHJlc2hvbGQiLCJ2aWRlb1BsYXliYWNrUXVhbGl0eSIsInRvdGFsVmlkZW9GcmFtZXMiLCJkcm9wcGVkVmlkZW9GcmFtZXMiLCJ3ZWJraXREZWNvZGVkRnJhbWVDb3VudCIsIndlYmtpdERyb3BwZWRGcmFtZUNvdW50IiwiTE9HR0VSX1BSRUZJWCIsIkVNRUNvbnRyb2xsZXIiLCJrZXlGb3JtYXRQcm9taXNlIiwia2V5U3lzdGVtQWNjZXNzUHJvbWlzZXMiLCJfcmVxdWVzdExpY2Vuc2VGYWlsdXJlQ291bnQiLCJtZWRpYUtleVNlc3Npb25zIiwia2V5SWRUb0tleVNlc3Npb25Qcm9taXNlIiwic2V0TWVkaWFLZXlzUXVldWUiLCJDRE1DbGVhbnVwUHJvbWlzZSIsIm9uTWVkaWFFbmNyeXB0ZWQiLCJfb25NZWRpYUVuY3J5cHRlZCIsIm9uV2FpdGluZ0ZvcktleSIsIl9vbldhaXRpbmdGb3JLZXkiLCJvbk1lZGlhRGV0YWNoZWQiLCJyZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NGdW5jIiwibGljZW5zZVhoclNldHVwIiwibGljZW5zZVJlc3BvbnNlQ2FsbGJhY2siLCJnZXRMaWNlbnNlU2VydmVyVXJsIiwia2V5U3lzdGVtQ29uZmlndXJhdGlvbiIsImxpY2Vuc2VVcmwiLCJnZXRTZXJ2ZXJDZXJ0aWZpY2F0ZVVybCIsInNlcnZlckNlcnRpZmljYXRlVXJsIiwiYXR0ZW1wdEtleVN5c3RlbUFjY2VzcyIsInVuaXF1ZUNvZGVjIiwiYXR0ZW1wdCIsImtleVN5c3RlbXMiLCJnZXRNZWRpYUtleXNQcm9taXNlIiwibWVkaWFLZXlzIiwiRU1FS2V5RXJyb3IiLCJLRVlfU1lTVEVNX05PX0FDQ0VTUyIsInN1cHBvcnRlZENvbmZpZ3VyYXRpb25zIiwiZXJyTWVzc2FnZSIsInByb3RvY29sIiwibWVkaWFLZXlTeXN0ZW1Db25maWdzIiwia2V5U3lzdGVtQWNjZXNzIiwiX2tleVN5c3RlbUFjY2Vzc1Byb21pc2VzIiwibWVkaWFLZXlTeXN0ZW1BY2Nlc3MiLCJjZXJ0aWZpY2F0ZVJlcXVlc3QiLCJmZXRjaFNlcnZlckNlcnRpZmljYXRlIiwiY3JlYXRlTWVkaWFLZXlzIiwiY2VydGlmaWNhdGUiLCJzZXRNZWRpYUtleXNTZXJ2ZXJDZXJ0aWZpY2F0ZSIsImNyZWF0ZU1lZGlhS2V5U2Vzc2lvbkNvbnRleHQiLCJtZWRpYUtleXNTZXNzaW9uIiwiY3JlYXRlU2Vzc2lvbiIsIm1lZGlhS2V5U2Vzc2lvbkNvbnRleHQiLCJrZXlTdGF0dXMiLCJyZW5ld0tleVNlc3Npb24iLCJrZXlTZXNzaW9uQ29udGV4dCIsImdldEtleUlkU3RyaW5nIiwiZ2VuZXJhdGVSZXF1ZXN0V2l0aFByZWZlcnJlZEtleVNlc3Npb24iLCJyZW1vdmVTZXNzaW9uIiwidXBkYXRlS2V5U2Vzc2lvbiIsIl9tZWRpYUtleVNlc3Npb25Db250ZSIsImtleVNlc3Npb24iLCJzZXNzaW9uSWQiLCJzZWxlY3RLZXlTeXN0ZW1Gb3JtYXQiLCJnZXRLZXlGb3JtYXRQcm9taXNlIiwia2V5U3lzdGVtc0luQ29uZmlnIiwiZ2V0S2V5U3lzdGVtU2VsZWN0aW9uUHJvbWlzZSIsImtleVN5c3RlbUZvcm1hdCIsImxvYWRLZXkiLCJrZXlJbmZvIiwia2V5RGV0YWlscyIsImtleVNlc3Npb25Db250ZXh0UHJvbWlzZSIsImdldEtleVN5c3RlbUZvcktleVByb21pc2UiLCJ0aHJvd0lmRGVzdHJveWVkIiwiYXR0ZW1wdFNldE1lZGlhS2V5cyIsImhhbmRsZUVycm9yIiwiS0VZX1NZU1RFTV9OT19LRVlTIiwiS0VZX1NZU1RFTV9OT19DT05GSUdVUkVEX0xJQ0VOU0UiLCJpbml0RGF0YVR5cGUiLCJrZXlTeXN0ZW1Eb21haW4iLCJqc29uIiwicHNzaEluZm8iLCJrZXlJZEhleCIsImtleUNvbnRleHQiLCJvbGRLZXlJZEhleCIsIl9rZXlTeXN0ZW1Ub0tleVN5c3RlbSIsInNldE1lZGlhS2V5c1Byb21pc2UiLCJzZXRNZWRpYUtleXMiLCJfdGhpcyRjb25maWckZHJtU3lzdGUiLCJfdGhpcyRjb25maWckZHJtU3lzdGUyIiwiZ2VuZXJhdGVSZXF1ZXN0RmlsdGVyIiwiZ2VuZXJhdGVSZXF1ZXN0IiwibWFwcGVkSW5pdERhdGEiLCJfdGhpcyRobHMiLCJsaWNlbnNlU3RhdHVzIiwib25tZXNzYWdlIiwiX29ubWVzc2FnZSIsIm1lc3NhZ2VUeXBlIiwicmVuZXdMaWNlbnNlIiwib25rZXlzdGF0dXNlc2NoYW5nZSIsIl9vbmtleXN0YXR1c2VzY2hhbmdlIiwib25LZXlTdGF0dXNDaGFuZ2UiLCJrZXlVc2FibGVQcm9taXNlIiwiS0VZX1NZU1RFTV9TVEFUVVNfSU5URVJOQUxfRVJST1IiLCJfY29udGV4dCRtZWRpYUtleXNTZXMiLCJLRVlfU1lTVEVNX05PX1NFU1NJT04iLCJrZXlTdGF0dXNlcyIsInN0YXR1cyIsImNlcnRMb2FkZXIiLCJjZXJ0TG9hZFBvbGljeSIsImNvbnRleCIsIktFWV9TWVNURU1fU0VSVkVSX0NFUlRJRklDQVRFX1JFUVVFU1RfRkFJTEVEIiwiY2VydCIsInNldFNlcnZlckNlcnRpZmljYXRlIiwiS0VZX1NZU1RFTV9TRVJWRVJfQ0VSVElGSUNBVEVfVVBEQVRFX0ZBSUxFRCIsImtleU1lc3NhZ2UiLCJyZXF1ZXN0TGljZW5zZSIsIktFWV9TWVNURU1fU0VTU0lPTl9VUERBVEVfRkFJTEVEIiwidW5wYWNrUGxheVJlYWR5S2V5TWVzc2FnZSIsInhociIsImxpY2Vuc2VDaGFsbGVuZ2UiLCJ4bWxTdHJpbmciLCJzZXRSZXF1ZXN0SGVhZGVyIiwia2V5TWVzc2FnZVhtbCIsIl9oZWFkZXIkcXVlcnlTZWxlY3RvciIsIl9oZWFkZXIkcXVlcnlTZWxlY3RvcjIiLCJxdWVyeVNlbGVjdG9yIiwiY2hhbGxlbmdlRWxlbWVudCIsImNoYWxsZW5nZVRleHQiLCJzZXR1cExpY2Vuc2VYSFIiLCJrZXlzTGlzdEl0ZW0iLCJvcGVuIiwibGljZW5zZVhoclNldHVwUmVzdWx0IiwiZmluYWxMaWNlbnNlQ2hhbGxlbmdlIiwiWE1MSHR0cFJlcXVlc3QiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJLRVlfU1lTVEVNX0xJQ0VOU0VfUkVRVUVTVF9GQUlMRUQiLCJzdGF0dXNUZXh0IiwiYXR0ZW1wdHNMZWZ0IiwibGljZW5zZVhociIsIkRPTkUiLCJzZW5kIiwiZW1lRW5hYmxlZCIsIm1lZGlhS2V5c0xpc3QiLCJrZXlTZXNzaW9uQ291bnQiLCJmb3JtYXRzIiwiY2xvc2UiLCJDbU9iamVjdFR5cGUiLCJDbVN0cmVhbWluZ0Zvcm1hdCIsIkNtY2RIZWFkZXJGaWVsZCIsIkNtY2RIZWFkZXJNYXAiLCJPQkpFQ1QiLCJSRVFVRVNUIiwiU0VTU0lPTiIsIlNUQVRVUyIsIlNmSXRlbSIsIlNmVG9rZW4iLCJESUNUIiwiTWFwIiwiU2V0IiwidGhyb3dFcnJvciIsImNhdXNlIiwiQkFSRV9JVEVNIiwiQk9PTEVBTiIsIkJZVEVTIiwiREVDSU1BTCIsIklOVEVHRVIiLCJpc0ludmFsaWRJbnQiLCJTVFJJTkdfUkVHRVgiLCJUT0tFTiIsIktFWSIsInNlcmlhbGl6ZUVycm9yIiwic2VyaWFsaXplQm9vbGVhbiIsImJhc2U2NGVuY29kZSIsImJpbmFyeSIsImJ0b2EiLCJzZXJpYWxpemVCeXRlU2VxdWVuY2UiLCJpc1ZpZXciLCJzZXJpYWxpemVJbnRlZ2VyIiwic2VyaWFsaXplRGF0ZSIsInJvdW5kVG9FdmVuIiwicHJlY2lzaW9uIiwiZGVjaW1hbFNoaWZ0IiwiaXNFcXVpZGlzdGFudCIsIkVQU0lMT04iLCJmbG9vcmVkVmFsdWUiLCJzZXJpYWxpemVEZWNpbWFsIiwicm91bmRlZFZhbHVlIiwiU1RSSU5HIiwic2VyaWFsaXplU3RyaW5nIiwic3ltYm9sVG9TdHIiLCJzeW1ib2wiLCJzZXJpYWxpemVUb2tlbiIsInRva2VuIiwic2VyaWFsaXplQmFyZUl0ZW0iLCJpc0ludGVnZXIiLCJzZXJpYWxpemVLZXkiLCJzZXJpYWxpemVQYXJhbXMiLCJlbnRyaWVzIiwic2VyaWFsaXplSXRlbSIsInNlcmlhbGl6ZUlubmVyTGlzdCIsInNlcmlhbGl6ZURpY3QiLCJ3aGl0ZXNwYWNlIiwib3B0aW9uYWxXaGl0ZVNwYWNlIiwiaXRlbSIsIm91dHB1dCIsImVuY29kZVNmRGljdCIsImlzVG9rZW5GaWVsZCIsInVybFRvUmVsYXRpdmVQYXRoIiwiYmFzZSIsIm9yaWdpbiIsInRvUGF0aCIsInBhdGhuYW1lIiwiZnJvbVBhdGgiLCJyYW5kb21VVUlEIiwiZHQiLCJyYW5kb20iLCJ0b1JvdW5kZWQiLCJ0b1VybFNhZmUiLCJ0b0h1bmRyZWQiLCJDbWNkRm9ybWF0dGVycyIsImJyIiwiYmwiLCJkbCIsIm10cCIsIm5vciIsInJ0cCIsInRiIiwicHJvY2Vzc0NtY2QiLCJmb3JtYXR0ZXJzIiwiZm9ybWF0dGVyIiwiZW5jb2RlQ21jZCIsImNtY2QiLCJ0b0NtY2RIZWFkZXJzIiwiaGVhZGVyTWFwIiwiY3VzdG9tSGVhZGVyTWFwIiwic2hhcmRzIiwiZW50cnkiLCJfaGVhZGVyTWFwJGZpbmQiLCJfYWNjJGZpZWxkIiwiZmluZCIsImFwcGVuZENtY2RIZWFkZXJzIiwiQ01DRF9QQVJBTSIsInRvQ21jZFF1ZXJ5IiwiUkVHRVgiLCJhcHBlbmRDbWNkUXVlcnkiLCJzZXBhcmF0b3IiLCJDTUNEQ29udHJvbGxlciIsInNpZCIsImNpZCIsInVzZUhlYWRlcnMiLCJpbmNsdWRlS2V5cyIsImluaXRpYWxpemVkIiwic3RhcnZlZCIsImF1ZGlvQnVmZmVyIiwib25XYWl0aW5nIiwib25QbGF5aW5nIiwiYXBwbHlQbGF5bGlzdERhdGEiLCJvdCIsInN1IiwiYXBwbHlGcmFnbWVudERhdGEiLCJnZXRPYmplY3RUeXBlIiwiTVVYRUQiLCJnZXRUb3BCYW5kd2lkdGgiLCJnZXRCdWZmZXJMZW5ndGgiLCJjcmVhdGVQbGF5bGlzdExvYWRlciIsImNyZWF0ZUZyYWdtZW50TG9hZGVyIiwiY29udGVudElkIiwiX2RhdGEkdHJhY2tzJGF1ZGlvIiwiX2RhdGEkdHJhY2tzJHZpZGVvIiwiY3JlYXRlRGF0YSIsInNmIiwiSExTIiwicHIiLCJiYW5kd2lkdGhFc3RpbWF0ZSIsImlzVmlkZW8iLCJJTklUIiwiYnMiLCJUSU1FRF9URVhUIiwiQ3RvciIsIkNtY2RQbGF5bGlzdExvYWRlciIsImNhbGxiYWNrcyIsIkNtY2RGcmFnbWVudExvYWRlciIsIlBBVEhXQVlfUEVOQUxUWV9EVVJBVElPTl9NUyIsIkNvbnRlbnRTdGVlcmluZ0NvbnRyb2xsZXIiLCJwYXRod2F5UHJpb3JpdHkiLCJ0aW1lVG9Mb2FkIiwicmVsb2FkVGltZXIiLCJzdGFydGVkIiwicGVuYWxpemVkUGF0aHdheXMiLCJ0dGwiLCJzY2hlZHVsZVJlZnJlc2giLCJsb2FkU3RlZXJpbmdNYW5pZmVzdCIsImxldmVsVG9SZW1vdmUiLCJlcnJvclBhdGh3YXkiLCJnZXRQYXRod2F5Rm9yR3JvdXBJZCIsInBhdGh3YXlzIiwidXBkYXRlUGF0aHdheVByaW9yaXR5IiwiZmlsdGVyUGFyc2VkTGV2ZWxzIiwicGF0aHdheUxldmVscyIsImdldExldmVsc0ZvclBhdGh3YXkiLCJzZWxlY3RlZEluZGV4Iiwic2VsZWN0ZWRMZXZlbCIsImxldmVsQWZ0ZXJDaGFuZ2UiLCJkZWZhdWx0UGF0aHdheSIsImNsb25lUGF0aHdheXMiLCJwYXRod2F5Q2xvbmVzIiwiYXVkaW9Hcm91cENsb25lTWFwIiwic3VidGl0bGVHcm91cENsb25lTWFwIiwicGF0aHdheUNsb25lIiwiY2xvbmVJZCIsImJhc2VJZCIsInVyaVJlcGxhY2VtZW50IiwiY2xvbmVkVmFyaWFudHMiLCJiYXNlTGV2ZWwiLCJjbG9uZWRBdWRpb0dyb3VwSWQiLCJjbG9uZWRTdWJ0aXRsZUdyb3VwSWQiLCJwZXJmb3JtVXJpUmVwbGFjZW1lbnQiLCJjbG9uZWRMZXZlbCIsImNsb25lUmVuZGl0aW9uR3JvdXBzIiwidGhyb3VnaHB1dCIsInN0ZWVyaW5nTWFuaWZlc3RMb2FkUG9saWN5Iiwic3RlZXJpbmdEYXRhIiwiVkVSU0lPTiIsIlRUTCIsInJlbG9hZFVyaSIsImxvYWRlZFN0ZWVyaW5nRGF0YSIsInN0ZWVyaW5nTWFuaWZlc3QiLCJTVEVFUklOR19NQU5JRkVTVF9MT0FERUQiLCJnZXRSZXNwb25zZUhlYWRlciIsInJldHJ5QWZ0ZXIiLCJ0dGxNcyIsImdyb3VwQ2xvbmVNYXAiLCJjbG9uZWRUcmFja3MiLCJjbG9uZWRUcmFjayIsInN0YWJsZUlkIiwicGVyT3B0aW9uS2V5IiwiSE9TVCIsImhvc3QiLCJQQVJBTVMiLCJwZXJPcHRpb25VcmlzIiwicGVyVmFyaWFudFVyaSIsIkFHRV9IRUFERVJfTElORV9SRUdFWCIsIlhockxvYWRlciIsInhoclNldHVwIiwicmVxdWVzdFRpbWVvdXQiLCJyZXRyeVRpbWVvdXQiLCJhYm9ydEludGVybmFsIiwib25wcm9ncmVzcyIsIl90aGlzJGNhbGxiYWNrcyIsImxvYWRJbnRlcm5hbCIsIm9wZW5BbmRTZW5kWGhyIiwicmVhZHlzdGF0ZWNoYW5nZSIsImxvYWRwcm9ncmVzcyIsImxvYWR0aW1lb3V0IiwidXNlUmVzcG9uc2UiLCJyZXNwb25zZVRleHQiLCJyZXNwb25zZVVSTCIsIl90aGlzJGNvbmZpZyIsIl90aGlzJGNvbnRleHQiLCJsZW5ndGhDb21wdXRhYmxlIiwiZ2V0QWxsUmVzcG9uc2VIZWFkZXJzIiwiZmV0Y2hTdXBwb3J0ZWQiLCJmZXRjaCIsIkFib3J0Q29udHJvbGxlciIsIlJlYWRhYmxlU3RyZWFtIiwiUmVxdWVzdCIsIkZldGNoTG9hZGVyIiwiZmV0Y2hTZXR1cCIsInJlcXVlc3QiLCJjb250cm9sbGVyIiwiZ2V0UmVxdWVzdCIsImluaXRQYXJhbXMiLCJnZXRSZXF1ZXN0UGFyYW1ldGVycyIsInNpZ25hbCIsImlzQXJyYXlCdWZmZXIiLCJMRU5HVEgiLCJvayIsIkZldGNoRXJyb3IiLCJnZXRDb250ZW50TGVuZ3RoIiwibG9hZFByb2dyZXNzaXZlbHkiLCJyZXNwb25zZURhdGEiLCJjaHVua0NhY2hlIiwicmVhZGVyIiwiZ2V0UmVhZGVyIiwicHVtcCIsInJlYWQiLCJkb25lIiwiY3JlZGVudGlhbHMiLCJIZWFkZXJzIiwiZ2V0Qnl0ZVJhbmdlTGVuZ3RoIiwiYnl0ZVJhbmdlSGVhZGVyIiwiY29udGVudFJhbmdlIiwiYnl0ZVJhbmdlTGVuZ3RoIiwiY29udGVudExlbmd0aCIsIldISVRFU1BBQ0VfQ0hBUiIsImNhcHRpb25TY3JlZW4iLCJpbmRlbnRpbmciLCJfdHJhY2skY3VlcyIsImN1ZUEiLCJjdWVCIiwiZGVmYXVsdExvYWRQb2xpY3kiLCJobHNEZWZhdWx0Q29uZmlnIiwiaGlnaEJ1ZmZlcldhdGNoZG9nUGVyaW9kIiwibnVkZ2VPZmZzZXQiLCJudWRnZU1heFJldHJ5Iiwic3RhcnRMZXZlbCIsImFickNvbnRyb2xsZXIiLCJidWZmZXJDb250cm9sbGVyIiwiY2FwTGV2ZWxDb250cm9sbGVyIiwiZXJyb3JDb250cm9sbGVyIiwiZnBzQ29udHJvbGxlciIsImFickV3bWFEZWZhdWx0RXN0aW1hdGVNYXgiLCJtaW5BdXRvQml0cmF0ZSIsInRlc3RCYW5kd2lkdGgiLCJtYW5pZmVzdExvYWRpbmdUaW1lT3V0IiwibWFuaWZlc3RMb2FkaW5nTWF4UmV0cnkiLCJtYW5pZmVzdExvYWRpbmdSZXRyeURlbGF5IiwibWFuaWZlc3RMb2FkaW5nTWF4UmV0cnlUaW1lb3V0IiwibGV2ZWxMb2FkaW5nVGltZU91dCIsImxldmVsTG9hZGluZ01heFJldHJ5IiwibGV2ZWxMb2FkaW5nUmV0cnlEZWxheSIsImxldmVsTG9hZGluZ01heFJldHJ5VGltZW91dCIsImZyYWdMb2FkaW5nVGltZU91dCIsImZyYWdMb2FkaW5nTWF4UmV0cnkiLCJmcmFnTG9hZGluZ1JldHJ5RGVsYXkiLCJmcmFnTG9hZGluZ01heFJldHJ5VGltZW91dCIsInRpbWVsaW5lQ29uZmlnIiwic3VidGl0bGVTdHJlYW1Db250cm9sbGVyIiwic3VidGl0bGVUcmFja0NvbnRyb2xsZXIiLCJhdWRpb1N0cmVhbUNvbnRyb2xsZXIiLCJhdWRpb1RyYWNrQ29udHJvbGxlciIsImVtZUNvbnRyb2xsZXIiLCJjbWNkQ29udHJvbGxlciIsImNvbnRlbnRTdGVlcmluZ0NvbnRyb2xsZXIiLCJtZXJnZUNvbmZpZyIsImRlZmF1bHRDb25maWciLCJkZWZhdWx0c0NvcHkiLCJkZWVwQ3B5IiwiZGVwcmVjYXRlZFNldHRpbmdUeXBlcyIsImRlcHJlY2F0ZWRTZXR0aW5ncyIsInBvbGljeU5hbWUiLCJwb2xpY3lOb3RTZXQiLCJyZXBvcnQiLCJkZXByZWNhdGVkU2V0dGluZyIsImVuYWJsZVN0cmVhbWluZ01vZGUiLCJjdXJyZW50TG9hZGVyIiwiY2FuU3RyZWFtUHJvZ3Jlc3NpdmVseSIsImNocm9tZU9yRmlyZWZveCIsIkxldmVsQ29udHJvbGxlciIsIl9sZXZlbHMiLCJfZmlyc3RMZXZlbCIsIl9tYXhBdXRvTGV2ZWwiLCJfc3RhcnRMZXZlbCIsImN1cnJlbnRMZXZlbEluZGV4IiwibWFudWFsTGV2ZWxJbmRleCIsInN0ZWVyaW5nIiwib25QYXJzZWRDb21wbGV0ZSIsInJlc2V0TGV2ZWxzIiwicmVkdW5kYW50U2V0IiwiZ2VuZXJhdGVQYXRod2F5U2V0IiwicmVzb2x1dGlvbkZvdW5kIiwidmlkZW9Db2RlY0ZvdW5kIiwiYXVkaW9Db2RlY0ZvdW5kIiwibGV2ZWxQYXJzZWQiLCJfYXVkaW9Db2RlYyIsIl92aWRlb0NvZGVjIiwiRlJBTUVSQVRFIiwiSERDUCIsIlBBVEhXQVkiLCJSRVNPTFVUSU9OIiwiVklERU9fUkFOR0UiLCJjb250ZW50U3RlZXJpbmdQcmVmaXgiLCJwYXRod2F5Q291bnQiLCJmaWx0ZXJBbmRTb3J0TWVkaWFPcHRpb25zIiwiZmlsdGVyZWRMZXZlbHMiLCJNQU5JRkVTVF9JTkNPTVBBVElCTEVfQ09ERUNTX0VSUk9SIiwiYXNzaWduVHJhY2tJZHNCeUdyb3VwIiwidW5zb3J0ZWRMZXZlbHMiLCJ2YWx1ZUEiLCJ2YWx1ZUIiLCJmaXJzdExldmVsSW5QbGF5bGlzdCIsIl90aGlzJGhscyR1c2VyQ29uZmlnIiwiZmlyc3RMZXZlbEJpdHJhdGUiLCJzdGFydGluZ0J3RXN0aW1hdGUiLCJhdWRpb09ubHkiLCJlZGF0YSIsImZvcmNlU3RhcnRMb2FkIiwibmV3TGV2ZWwiLCJsYXN0TGV2ZWxJbmRleCIsImxhc3RMZXZlbCIsImxhc3RQYXRod2F5SWQiLCJsZXZlbFN3aXRjaGluZ0RhdGEiLCJtYW51YWxMZXZlbCIsImNvbmZpZ1N0YXJ0TGV2ZWwiLCJfZGF0YSRkZWxpdmVyeURpcmVjdGkyIiwiX2RhdGEkZGVsaXZlcnlEaXJlY3RpIiwiX3RoaXMkY3VycmVudExldmVsIiwiY2hlY2tNYXhBdXRvVXBkYXRlZCIsIktleUxvYWRlciIsImtleVVyaVRvS2V5SW5mbyIsIl9sb2FkZXIkY29udGV4dCIsImNyZWF0ZUtleUxvYWRFcnJvciIsImxvYWRpbmdGcmFnIiwiX2tleUluZm8iLCJfa2V5SW5mbzIiLCJrZXlMb2FkUHJvbWlzZSIsIl9rZXlJbmZvJG1lZGlhS2V5U2VzcyIsImxvYWRLZXlIVFRQIiwibG9hZEtleUVNRSIsImdldFNvdXJjZUJ1ZmZlciIsIlNvdXJjZUJ1ZmZlciIsIldlYktpdFNvdXJjZUJ1ZmZlciIsImlzTVNFU3VwcG9ydGVkIiwiY29kZWNzRm9yVmlkZW9Db250YWluZXIiLCJjb2RlY0ZvckF1ZGlvQ29udGFpbmVyIiwiY2hhbmdlVHlwZVN1cHBvcnRlZCIsIl9zb3VyY2VCdWZmZXIkcHJvdG90eSIsIlNUQUxMX01JTklNVU1fRFVSQVRJT05fTVMiLCJNQVhfU1RBUlRfR0FQX0pVTVAiLCJTS0lQX0JVRkZFUl9IT0xFX1NURVBfU0VDT05EUyIsIlNLSVBfQlVGRkVSX1JBTkdFX1NUQVJUIiwiR2FwQ29udHJvbGxlciIsIm51ZGdlUmV0cnkiLCJzdGFsbFJlcG9ydGVkIiwic3RhbGxlZCIsIm1vdmVkIiwicG9sbCIsImFjdGl2ZUZyYWciLCJzZWVrZWQiLCJiZWdpblNlZWsiLCJfc3RhbGxlZER1cmF0aW9uIiwiaGFzRW5vdWdoQnVmZmVyIiwibm9CdWZmZXJHYXAiLCJzdGFydEp1bXAiLCJpc0xpdmUiLCJtYXhTdGFydEdhcEp1bXAiLCJwYXJ0aWFsT3JHYXAiLCJfdHJ5U2tpcEJ1ZmZlckhvbGUiLCJ0bm93Iiwic3RhbGxlZER1cmF0aW9uIiwiX3JlcG9ydFN0YWxsIiwiYnVmZmVyZWRXaXRoSG9sZXMiLCJfdHJ5Rml4QnVmZmVyU3RhbGwiLCJzdGFsbGVkRHVyYXRpb25NcyIsInRhcmdldFRpbWUiLCJfdHJ5TnVkZ2VCdWZmZXIiLCJidWZmZXJTdGFydmVkIiwid2FpdGluZyIsImdhcExlbmd0aCIsInN0YXJ0R2FwIiwic3RhcnRGcmFnIiwic3RhcnRQcm92aXNpb25lZCIsIm1vcmVUb0xvYWQiLCJwcm92aXNpb25lZCIsIlRJQ0tfSU5URVJWQUwiLCJTdHJlYW1Db250cm9sbGVyIiwiYXVkaW9Db2RlY1N3YXAiLCJnYXBDb250cm9sbGVyIiwiX2ZvcmNlU3RhcnRMb2FkIiwiZnJhZ1BsYXlpbmciLCJvbnZwbGF5aW5nIiwib252c2Vla2VkIiwiZnJhZ0xhc3RLYnBzIiwiY291bGRCYWNrdHJhY2siLCJiYWNrdHJhY2tGcmFnbWVudCIsImF1ZGlvQ29kZWNTd2l0Y2giLCJvbkZyYWdMb2FkRW1lcmdlbmN5QWJvcnRlZCIsIm9uQXVkaW9UcmFja1N3aXRjaGVkIiwiY2hlY2tCdWZmZXIiLCJjaGVja0ZyYWdtZW50Q2hhbmdlZCIsImdldE1haW5Gd2RCdWZmZXJJbmZvIiwibGFzdERldGFpbHMiLCJfdGhpcyRiYWNrdHJhY2tGcmFnbWUiLCJiYWNrdHJhY2tTbiIsImJhY2t0cmFja0ZyYWciLCJfbG9hZEJpdHJhdGVUZXN0RnJhZyIsImZvbGxvd2luZ0J1ZmZlcmVkRnJhZyIsImltbWVkaWF0ZUxldmVsU3dpdGNoIiwiYWJvcnRDdXJyZW50RnJhZyIsImZldGNoZGVsYXkiLCJmcmFnUGxheWluZ0N1cnJlbnQiLCJuZXh0TGV2ZWxJZCIsImJ1ZmZlcmVkRnJhZyIsIm5leHRCdWZmZXJlZEZyYWciLCJtYXhTdGFydCIsInN0YXJ0UHRzIiwib25NZWRpYVBsYXlpbmciLCJvbk1lZGlhU2Vla2VkIiwiYWFjIiwiaGVhYWMiLCJfY3VyTGV2ZWwkZGV0YWlscyIsIm5ld0xldmVsSWQiLCJfZ2V0QXVkaW9Db2RlYyIsImZyb21BbHRBdWRpbyIsIm1lZGlhVHJhY2siLCJhbHRlcm5hdGUiLCJzd2FwQXVkaW9Db2RlYyIsImlzRmlyc3RGcmFnbWVudCIsImlzRmlyc3RJbkRpc2NvbnRpbnVpdHkiLCJiYWNrdHJhY2siLCJ1YSIsImZyYWdDdXJyZW50TGV2ZWwiLCJMRVZFTF9TV0lUQ0hFRCIsImN1cnJlbnRGcmFnIiwiY3VycmVudFByb2dyYW1EYXRlVGltZSIsImVwb2NNcyIsIkhscyIsIkRlZmF1bHRDb25maWciLCJjb3JlQ29tcG9uZW50cyIsIm5ldHdvcmtDb250cm9sbGVycyIsIl9lbWl0dGVyIiwiX2F1dG9MZXZlbENhcHBpbmciLCJfbWF4SGRjcExldmVsIiwibGF0ZW5jeUNvbnRyb2xsZXIiLCJsZXZlbENvbnRyb2xsZXIiLCJfbWVkaWEiLCJ0cmlnZ2VyaW5nRXhjZXB0aW9uIiwiQ29uZmlnQWJyQ29udHJvbGxlciIsIkNvbmZpZ0J1ZmZlckNvbnRyb2xsZXIiLCJDb25maWdDYXBMZXZlbENvbnRyb2xsZXIiLCJDb25maWdFcnJvckNvbnRyb2xsZXIiLCJDb25maWdGcHNDb250cm9sbGVyIiwicGxheUxpc3RMb2FkZXIiLCJpZDNUcmFja0NvbnRyb2xsZXIiLCJDb25maWdDb250ZW50U3RlZXJpbmdDb250cm9sbGVyIiwiY3JlYXRlQ29udHJvbGxlciIsIkF1ZGlvU3RyZWFtQ29udHJvbGxlckNsYXNzIiwiU3VidGl0bGVTdHJlYW1Db250cm9sbGVyQ2xhc3MiLCJDb250cm9sbGVyQ2xhc3MiLCJjb21wb25lbnRzIiwiY29udHJvbGxlckluc3RhbmNlIiwiZXZlbnRPYmplY3QiLCJERVNUUk9ZSU5HIiwiZGV0YWNoTWVkaWEiLCJjb21wb25lbnQiLCJhdHRhY2hNZWRpYSIsImxvYWRTb3VyY2UiLCJsb2FkZWRTb3VyY2UiLCJsb2FkaW5nU291cmNlIiwic2hvdWxkU3RhcnRDYXBwaW5nIiwibmV3Q2FwTGV2ZWxUb1BsYXllclNpemUiLCJwbGF5aW5nRGF0ZSIsIl90aGlzJGF1ZGlvVHJhY2tDb250ciIsIl90aGlzJHN1YnRpdGxlVHJhY2tDbyIsImF1ZGlvVHJhY2tJZCIsInN1YnRpdGxlVHJhY2tJZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/hls.js/dist/hls.mjs\n");

/***/ })

};
;